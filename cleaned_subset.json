[
  {
    "conclusion": "Professor John can propose new courses.",
    "conclusion_FOL": "ProposeCourses(John) ::: Professor John can propose new courses.",
    "premises": [
      "If a faculty member has completed training, they can teach undergraduate courses.",
      "If a faculty member can teach undergraduate courses and holds a PhD, they can supervise graduate students.",
      "If a faculty member can supervise graduate students and has at least 3 publications, they can serve on curriculum committees.",
      "If a faculty member can serve on curriculum committees and has a positive teaching evaluation, they can propose new courses.",
      "Professor John has completed pedagogical training.",
      "Professor John holds a PhD.",
      "Professor John has published at least 3 academic papers.",
      "Professor John has received a positive teaching evaluation."
    ],
    "premises_FOL": [
      "∀x (CompletedTraining(x) → TeachUndergrad(x)) ::: If a faculty member has completed training, they can teach undergraduate courses.",
      "∀x ((TeachUndergrad(x) ∧ HoldsPhD(x)) → SuperviseGrad(x)) ::: If a faculty member can teach undergraduate courses and holds a PhD, they can supervise graduate students.",
      "∀x ((SuperviseGrad(x) ∧ HasPublications(x)) → ServeCommittee(x)) ::: If a faculty member can supervise graduate students and has at least 3 publications, they can serve on curriculum committees.",
      "∀x ((ServeCommittee(x) ∧ PositiveEval(x)) → ProposeCourses(x)) ::: If a faculty member can serve on curriculum committees and has a positive teaching evaluation, they can propose new courses.",
      "CompletedTraining(John) ::: Professor John has completed pedagogical training.",
      "HoldsPhD(John) ::: Professor John holds a PhD.",
      "HasPublications(John) ::: Professor John has published at least 3 academic papers.",
      "PositiveEval(John) ::: Professor John has received a positive teaching evaluation."
    ],
    "predicates": [
      "CompletedTraining(x) ::: x has completed pedagogical training",
      "TeachUndergrad(x) ::: x can teach undergraduate courses",
      "HoldsPhD(x) ::: x holds a PhD",
      "SuperviseGrad(x) ::: x can supervise graduate students",
      "HasPublications(x) ::: x has at least three publications",
      "ServeCommittee(x) ::: x can serve on curriculum committees",
      "PositiveEval(x) ::: x has a positive teaching evaluation",
      "ProposeCourses(x) ::: x can propose new courses"
    ]
  },      
  {
    "conclusion": "A student with low attendance, assignment completion, and professor approval can pass the course if they complete the exam.",
    "conclusion_FOL": "∀s ∀m ((Attend(s,m)<50 ∧ CompleteAssign(s,m) ∧ ProfApproval(s,m) ∧ CompleteExam(s,m)) → Pass(s,m)) ::: A student with low attendance, assignment completion, and professor approval can pass if they complete the exam.",
    "premises": [
      "If a student attends at least 80% of classes, they are allowed to take the final exam.",
      "If a student is allowed to take the final exam and completes the exam, they can pass the course.",
      "If a student fails to pass the course, they must retake the course.",
      "If a course requires a major assignment, the student must complete the major assignment or take the final exam.",
      "If a student attends less than 50% of classes, they are not allowed to take the final exam.",
      "If a student completes 3 courses with a score above 8.5, they receive a scholarship.",
      "If a student takes the exam but scores below the passing threshold, they do not pass the course.",
      "If a student attends all classes but does not complete the exam, they cannot pass the course.",
      "If a student passes 3 required courses, they will graduate.",
      "If a student attends less than 50% of the classes but completes the assignment and gets professor approval, they are allowed to take the exam."
    ],
    "premises_FOL": [
      "∀s ∀m (Attend(s,m)≥80 → AllowedExam(s,m)) ::: ≥80% attendance → allowed to take exam",
      "∀s ∀m (AllowedExam(s,m) ∧ CompleteExam(s,m) → Pass(s,m)) ::: allowed + completes exam → pass",
      "∀s ∀m (¬Pass(s,m) → Retake(s,m)) ::: if not pass → must retake",
      "∀m (RequireAssign(m) → ∀s (CompleteAssign(s,m) ∨ TakeExam(s,m))) ::: assignment required → complete or take exam",
      "∀s ∀m (Attend(s,m)<50 → ¬AllowedExam(s,m)) ::: <50% attendance → not allowed",
      "∀s (∃m1 ∃m2 ∃m3 (m1≠m2 ∧ m2≠m3 ∧ m1≠m3 ∧ Grade(s,m1)>8.5 ∧ Grade(s,m2)>8.5 ∧ Grade(s,m3)>8.5) → Scholarship(s)) ::: high scores in 3 courses → scholarship",
      "∀s ∀m (TakeExam(s,m) ∧ Score(s,m)<PassScore → ¬Pass(s,m)) ::: low score after exam → not pass",
      "∀s ∀m (Attend(s,m)=100 ∧ ¬CompleteExam(s,m) → ¬Pass(s,m)) ::: full attendance but no exam → not pass",
      "∀s (∃m1 ∃m2 ∃m3 (m1≠m2 ∧ m2≠m3 ∧ m1≠m3 ∧ Pass(s,m1) ∧ Pass(s,m2) ∧ Pass(s,m3) ∧ Required(m1) ∧ Required(m2) ∧ Required(m3)) → Graduate(s)) ::: pass 3 required courses → graduate",
      "∀s ∀m (Attend(s,m)<50 ∧ CompleteAssign(s,m) ∧ ProfApproval(s,m) → AllowedExam(s,m)) ::: low attendance + assignment + approval → allowed"
    ],
    "predicates": [
      "Attend(s,m) ::: attendance rate of student s in course m",
      "AllowedExam(s,m) ::: student s is allowed to take the final exam in course m",
      "CompleteExam(s,m) ::: student s completes the final exam in course m",
      "Pass(s,m) ::: student s passes course m",
      "Retake(s,m) ::: student s must retake course m",
      "RequireAssign(m) ::: course m requires a major assignment",
      "CompleteAssign(s,m) ::: student s completes the assignment in course m",
      "TakeExam(s,m) ::: student s takes the final exam in course m",
      "Score(s,m) ::: score of student s in course m",
      "PassScore ::: the passing threshold score",
      "Grade(s,m) ::: grade of student s in course m",
      "Scholarship(s) ::: student s receives a scholarship",
      "ProfApproval(s,m) ::: professor approval for student s in course m",
      "Graduate(s) ::: student s graduates",
      "Required(m) ::: course m is a required course"
    ]
  },
  {
    "conclusion": "A student mastering superposition who writes an original research paper in quantum mechanics qualifies for a scholarship.",
    "conclusion_FOL": "∀s ((Study(s,QuantumMech)≥15 ∧ WritePaper(s) ∧ OriginalWork(s) ∧ Field(s,QuantumMech)) → QualifyScholarship(s)) ::: A student mastering superposition and writing original research in quantum mechanics qualifies for a scholarship.",
    "premises": [
      "Mastery of quantum superposition requires at least 15 hours of dedicated study.",
      "A solid understanding of superposition enables clear explanations of quantum measurement.",
      "Those who can explain quantum measurement contribute by either writing research papers or giving presentations.",
      "Failure to give a presentation leaves research papers as the only viable option for contribution.",
      "Limited exposure (less than 8 hours) to quantum mechanics leads to difficulties in grasping superposition.",
      "When a professor mandates presentations, students must comply or justify their refusal.",
      "Original analytical work in research papers leads to academic recognition.",
      "Academic recognition in quantum mechanics opens the possibility of an advanced physics scholarship.",
      "Quantum entanglement experiments must be critically analyzed as part of coursework.",
      "Neglecting both research papers and presentations results in failing the quantum mechanics course."
    ],
    "premises_FOL": [
      "∀s (Study(s,QuantumMech)≥15 → Understand(s,Superposition)) ::: ≥15h study → understand superposition",
      "∀s (Understand(s,Superposition) → Explain(s,Measurement)) ::: understand superposition → explain measurement",
      "∀s (Explain(s,Measurement) → (WritePaper(s) ∨ GiveTalk(s))) ::: explain → write or present",
      "∀s (¬GiveTalk(s) → WritePaper(s)) ::: if no talk → must write paper",
      "∀s (Study(s,QuantumMech)<8 → Struggle(s,Superposition)) ::: <8h study → struggle with superposition",
      "∀s (ProfRequires(s,Talk) → (GiveTalk(s) ∨ Justified(s))) ::: if professor requires → must present or justify",
      "∀s (WritePaper(s) ∧ OriginalWork(s) → Recognized(s)) ::: original paper → recognition",
      "∀s (Recognized(s) ∧ Field(s,QuantumMech) → QualifyScholarship(s)) ::: recognition in quantum → scholarship",
      "∀e (EntanglementExp(e) → ∀s (MustAnalyze(s,e))) ::: all students must analyze entanglement experiments",
      "∀s (¬WritePaper(s) ∧ ¬GiveTalk(s) → Fail(s,QuantumMech)) ::: no paper & no talk → fail course"
    ],
    "predicates": [
      "Study(s,c) ::: student s studies course c",
      "Understand(s,t) ::: student s understands topic t",
      "Explain(s,t) ::: student s can explain topic t",
      "WritePaper(s) ::: student s writes a research paper",
      "GiveTalk(s) ::: student s gives a presentation",
      "OriginalWork(s) ::: student s produces original analytical work",
      "Recognized(s) ::: student s receives academic recognition",
      "Field(s,c) ::: student s is recognized in course c",
      "QualifyScholarship(s) ::: student s qualifies for a scholarship",
      "ProfRequires(s,t) ::: professor requires student s to give talk t",
      "Justified(s) ::: student s has a justified refusal",
      "Struggle(s,t) ::: student s struggles with topic t",
      "EntanglementExp(e) ::: experiment e is about quantum entanglement",
      "MustAnalyze(s,e) ::: student s must analyze experiment e",
      "Fail(s,c) ::: student s fails course c"
    ]
  },
  {
    "conclusion": "Spaced repetition improves both memory and academic performance.",
    "conclusion_FOL": "∀s (UseSpacedRep(s) → BetterMemory(s) ∧ BetterPerformance(s)) ::: Spaced repetition improves both memory and academic performance.",
    "premises": [
      "Ebbinghaus' forgetting curve formula: R = e^(-t/S), where R is retention rate, t is elapsed time, and S is review interval.",
      "A learning algorithm based on spaced repetition can adjust review intervals based on individual proficiency.",
      "Adequate sleep enhances memory consolidation after each review session.",
      "Creating flashcards with concise questions improves retention compared to passive reading.",
      "Reviewing just before forgetting significantly boosts memory efficiency.",
      "Neuroscience studies show self-testing activates the hippocampus, enhancing information recall.",
      "Encountering knowledge in various contexts improves retention compared to monotonous repetition.",
      "Too short review intervals reduce retention due to lack of time for consolidation.",
      "Too long review intervals risk forgetting most of the material before review.",
      "AI can personalize study schedules, optimizing memory retention for each student based on their progress."
    ],
    "premises_FOL": [
      "∀s ∀t (Retention(s,t) = e^(-t/S)) ::: forgetting curve: retention depends on time and spacing",
      "∀s (UseSpacedRep(s) → BetterMemory(s)) ::: spaced repetition improves memory",
      "∀s ∀m (SleepWell(s) ∧ Review(s,m) → StrongerMemory(s,m)) ::: sleep helps memory consolidation after review",
      "∀s ∀f (UseFlashcards(s,f) → HigherRetention(s,f)) ::: flashcards > passive reading",
      "∀s ∀m (ReviewBeforeForget(s,m) → HighEfficiency(s,m)) ::: reviewing just before forgetting is efficient",
      "∀s ∀m (SelfTest(s,m) → (ActivateHippocampus(s) ∧ ImproveRecall(s,m))) ::: self-testing improves recall",
      "∀s ∀m (MultiContext(s,m) → LongTermRetention(s,m)) ::: encountering in multiple contexts helps",
      "∀s ∀m (TooShort(s,m) → Inefficient(s,m)) ::: too short spacing is bad",
      "∀s ∀m (TooLong(s,m) → ForgetMost(s,m)) ::: too long spacing leads to forgetting",
      "∀s ∀m (AIPersonalized(s,m) → MaxRetention(s,m)) ::: AI scheduling maximizes retention"
    ],
    "predicates": [
      "Retention(s,t) ::: retention of student s after time t",
      "UseSpacedRep(s) ::: student s uses spaced repetition",
      "BetterMemory(s) ::: student s improves memory retention",
      "BetterPerformance(s) ::: student s improves academic performance",
      "SleepWell(s) ::: student s sleeps well",
      "Review(s,m) ::: student s reviews material m",
      "StrongerMemory(s,m) ::: stronger memory after review",
      "UseFlashcards(s,f) ::: student s uses flashcard f",
      "HigherRetention(s,f) ::: better retention using flashcards",
      "ReviewBeforeForget(s,m) ::: student s reviews material m just before forgetting",
      "HighEfficiency(s,m) ::: memory efficiency is high",
      "SelfTest(s,m) ::: student s self-tests on material m",
      "ActivateHippocampus(s) ::: hippocampus is activated in s",
      "ImproveRecall(s,m) ::: student s improves recall on material m",
      "MultiContext(s,m) ::: student s learns m in different contexts",
      "LongTermRetention(s,m) ::: long-term retention of m",
      "TooShort(s,m) ::: review interval is too short",
      "Inefficient(s,m) ::: learning of m is inefficient",
      "TooLong(s,m) ::: review interval is too long",
      "ForgetMost(s,m) ::: most of m is forgotten",
      "AIPersonalized(s,m) ::: AI schedules review for s on m",
      "MaxRetention(s,m) ::: maximum memory retention for s on m"
    ]
  },
  {
    "conclusion": "A quadrilateral with opposite angles summing to 180° and a perpendicular bisecting diagonal must be a cyclic trapezium.",
    "conclusion_FOL": "∀Q (OppAngles180(Q) ∧ PerpBisectDiag(Q) → IsCyclicTrapezium(Q)) ::: If a quadrilateral has opposite angles summing to 180° and a perpendicular bisecting diagonal, it is a cyclic trapezium.",
    "premises": [
      "In any triangle, the sum of the interior angles is 180 degrees.",
      "The perpendicular bisector of a chord passes through the center of the circle.",
      "If two triangles are similar, their corresponding sides are proportional.",
      "The centroid of a triangle divides each median in a 2:1 ratio.",
      "A tangent to a circle is perpendicular to the radius at the point of tangency.",
      "If two circles are orthogonal, the product of the distances from their intersection points to the centers equals the product of their radii.",
      "A point equidistant from two given points lies on the perpendicular bisector of the segment joining them.",
      "If a triangle is right-angled, then the median to the hypotenuse is half the hypotenuse."
    ],
    "premises_FOL": [
      "∀T (IsTriangle(T) → (AngleA(T) + AngleB(T) + AngleC(T) = 180)) ::: triangle angle sum is 180°",
      "∀C ∀P (IsChord(C) ∧ IsPerpBisector(P,C) → PassesThrough(P,Center(C))) ::: perp bisector of chord passes through center",
      "∀T1 ∀T2 (Similar(T1,T2) → Proportional(Sides(T1),Sides(T2))) ::: similar triangles have proportional sides",
      "∀G ∀T (Centroid(G,T) → Ratio(Median(G,T),2:1)) ::: centroid divides median in 2:1",
      "∀T ∀O (Tangent(T,O) → Perpendicular(T,Radius(O))) ::: tangent is perp to radius",
      "∀C1 ∀C2 (Orthogonal(C1,C2) → DistProd(Intersections(C1,C2),Centers(C1,C2)) = RadiiProd(C1,C2)) ::: orthogonal circles relation",
      "∀P ∀A ∀B (Equidistant(P,A,B) → On(P,PerpBisector(A,B))) ::: equidistant point lies on perp bisector",
      "∀T (IsRightTriangle(T) → Median(Hypotenuse(T)) = 0.5 * Hypotenuse(T)) ::: right triangle median rule"
    ],
    "predicates": [
      "IsTriangle(T) ::: T is a triangle",
      "AngleA(T), AngleB(T), AngleC(T) ::: angles of triangle T",
      "IsChord(C) ::: C is a chord",
      "IsPerpBisector(P,C) ::: P is perpendicular bisector of chord C",
      "PassesThrough(P,Point) ::: P passes through given point",
      "Center(C) ::: center of circle of chord C",
      "Similar(T1,T2) ::: triangles T1 and T2 are similar",
      "Proportional(S1,S2) ::: sides S1 and S2 are proportional",
      "Centroid(G,T) ::: G is centroid of triangle T",
      "Ratio(M,G) ::: median M is divided in given ratio",
      "Tangent(T,O) ::: T is tangent to circle with center O",
      "Radius(O) ::: radius of circle centered at O",
      "Orthogonal(C1,C2) ::: circles C1 and C2 are orthogonal",
      "DistProd(X,Y) ::: product of distances between X and Y",
      "RadiiProd(C1,C2) ::: product of radii of C1 and C2",
      "Intersections(C1,C2) ::: intersection points of C1 and C2",
      "Centers(C1,C2) ::: centers of circles C1 and C2",
      "Equidistant(P,A,B) ::: P is equidistant from A and B",
      "On(P,L) ::: point P lies on line L",
      "PerpBisector(A,B) ::: perpendicular bisector of segment AB",
      "IsRightTriangle(T) ::: T is a right triangle",
      "Median(E) ::: median to edge E",
      "Hypotenuse(T) ::: hypotenuse of triangle T",
      "OppAngles180(Q) ::: quadrilateral Q has opposite angles summing to 180°",
      "PerpBisectDiag(Q) ::: Q has a diagonal bisected perpendicularly",
      "IsCyclicTrapezium(Q) ::: Q is a cyclic trapezium"
    ]
  },
  {
    "conclusion": "Luna successfully completes the Mars expedition and achieves a scientific breakthrough.",
    "conclusion_FOL": "Breakthrough(Luna) ::: Luna successfully completes the Mars expedition and achieves a scientific breakthrough.",
    "premises": [
      "If an astronaut undergoes advanced training and excels in simulations, they earn a flight clearance.",
      "If an astronaut earns a flight clearance and the launch vehicle passes a safety audit, they are approved for a Mars expedition.",
      "If an astronaut is approved for a Mars expedition and the orbital trajectory is precisely calculated, the mission departs on schedule.",
      "If the mission departs on schedule and Mars' radiation levels are within safe limits, a surface landing is authorized.",
      "If a surface landing is authorized and the astronaut deploys a functioning rover, geological samples are collected.",
      "If geological samples are collected and the analysis equipment is operational, a scientific breakthrough is possible.",
      "Either Luna undergoes advanced training or she withdraws from the program.",
      "Luna does not withdraw from the program.",
      "Luna excels in simulations.",
      "The launch vehicle for Luna passes a safety audit.",
      "The orbital trajectory for Luna's mission is precisely calculated.",
      "Mars' radiation levels are within safe limits.",
      "Luna deploys a functioning rover.",
      "The analysis equipment on Luna's mission is operational.",
      "If the mission control loses contact, the trajectory cannot be calculated.",
      "Mission control does not lose contact.",
      "If the rover malfunctions, geological samples cannot be collected.",
      "The rover does not malfunction.",
      "If radiation exceeds safe limits, a landing is not authorized.",
      "Radiation does not exceed safe limits.",
      "If Luna fails psychological evaluations, she cannot earn flight clearance.",
      "Luna does not fail psychological evaluations.",
      "If the audit detects a flaw, the launch vehicle is not approved.",
      "The audit does not detect a flaw.",
      "If the equipment calibration fails, a breakthrough is not possible.",
      "The equipment calibration does not fail.",
      "If the expedition is delayed, samples cannot be collected on time.",
      "The expedition is not delayed."
    ],
    "premises_FOL": [
      "∀a (Training(a) ∧ Simulations(a) → Clearance(a))",
      "∀a (Clearance(a) ∧ AuditPassed(Vehicle(a)) → Approved(a))",
      "∀a (Approved(a) ∧ Trajectory(a) → Departs(a))",
      "∀a (Departs(a) ∧ SafeRadiation(Mars) → Landing(a))",
      "∀a (Landing(a) ∧ RoverOK(a) → Samples(a))",
      "∀a (Samples(a) ∧ EquipmentOK(a) → Breakthrough(a))",
      "Training(Luna) ∨ Withdraw(Luna)",
      "¬Withdraw(Luna)",
      "Simulations(Luna)",
      "AuditPassed(Vehicle(Luna))",
      "Trajectory(Luna)",
      "SafeRadiation(Mars)",
      "RoverOK(Luna)",
      "EquipmentOK(Luna)",
      "LoseContact(Control) → ¬Trajectory(Luna)",
      "¬LoseContact(Control)",
      "Malfunction(Rover(Luna)) → ¬Samples(Luna)",
      "¬Malfunction(Rover(Luna))",
      "ExceedRadiation(Mars) → ¬Landing(Luna)",
      "¬ExceedRadiation(Mars)",
      "FailPsych(Luna) → ¬Clearance(Luna)",
      "¬FailPsych(Luna)",
      "FlawAudit(Vehicle(Luna)) → ¬AuditPassed(Vehicle(Luna))",
      "¬FlawAudit(Vehicle(Luna))",
      "FailCalibration(Equipment(Luna)) → ¬Breakthrough(Luna)",
      "¬FailCalibration(Equipment(Luna))",
      "Delayed(Expedition) → ¬Samples(Luna)",
      "¬Delayed(Expedition)"
    ],
    "predicates": [
      "Training(a) ::: astronaut a completes advanced training",
      "Simulations(a) ::: astronaut a excels in simulations",
      "Clearance(a) ::: astronaut a earns flight clearance",
      "AuditPassed(v) ::: launch vehicle v passes safety audit",
      "Vehicle(a) ::: launch vehicle assigned to astronaut a",
      "Approved(a) ::: astronaut a is approved for Mars expedition",
      "Trajectory(a) ::: orbital trajectory for astronaut a is precisely calculated",
      "Departs(a) ::: mission of astronaut a departs on schedule",
      "SafeRadiation(Mars) ::: radiation on Mars is within safe limits",
      "Landing(a) ::: astronaut a is authorized to land on Mars",
      "RoverOK(a) ::: astronaut a deploys a functioning rover",
      "Samples(a) ::: astronaut a collects geological samples",
      "EquipmentOK(a) ::: analysis equipment for astronaut a is operational",
      "Breakthrough(a) ::: astronaut a achieves scientific breakthrough",
      "Withdraw(a) ::: astronaut a withdraws from the program",
      "LoseContact(Control) ::: mission control loses contact",
      "Malfunction(Rover(a)) ::: rover of astronaut a malfunctions",
      "ExceedRadiation(Mars) ::: radiation levels on Mars exceed safety limit",
      "FailPsych(a) ::: astronaut a fails psychological evaluation",
      "FlawAudit(v) ::: safety audit detects flaw in vehicle v",
      "FailCalibration(e) ::: equipment e calibration fails",
      "Delayed(Expedition) ::: expedition is delayed"
    ]
  },
  {
    "conclusion": "Lan cannot participate in the flight practice session and must take a make-up session within 2 weeks to retain flight exam eligibility.",
    "conclusion_FOL": "¬FlightPractice(Lan) ∧ MakeUp(Lan) ≤ 2 ∨ LoseEligibility(Lan) ::: Lan cannot join flight practice and must take a make-up session within 2 weeks or lose exam eligibility.",
    "premises": [
      "If an aviation student completes the aircraft theory course, they are allowed to participate in the flight practice course.",
      "If the weather is bad on the practice day, the flight will be delayed by at least 2 hours.",
      "Students must complete a safety test before flight practice within 1 hour.",
      "If they fail the safety test, students cannot fly and must retake the theory course.",
      "If the flight is delayed by more than 3 hours, students are refunded 50% of the practice course fee.",
      "If students fly more than 1 hour late from the schedule, they must submit a supplementary report.",
      "The flight practice course requires at least 2 instructors: a flight instructor and a technician.",
      "If the flight instructor is absent, the course must find a replacement within 1 hour.",
      "If no replacement is found, the practice session is canceled and students must re-register.",
      "Students must submit their practice registration application 7 days in advance for scheduling.",
      "Lan completed the aircraft theory course on March 20, 2025.",
      "Bad weather was reported at 8:00 AM on the practice day, March 25, 2025.",
      "Lan passed the safety test at 7:30 AM on the same day.",
      "The flight instructor was absent at 8:15 AM on the practice day.",
      "No replacement flight instructor was found within 1 hour.",
      "Students must be notified of the practice session cancellation at least 30 minutes before the scheduled 9:00 AM flight.",
      "If the practice session is canceled, students must take a make-up session within 2 weeks or lose their flight exam eligibility."
    ],
    "premises_FOL": [
      "CompleteTheory(s) → FlightPractice(s) ::: If theory completed, allowed to do practice",
      "BadWeather(s) → Delay(s) ≥ 2 ::: Bad weather causes at least 2h delay",
      "FlightPractice(s) → SafetyTest(s) ≤ 1 ::: Safety test must be taken within 1h before practice",
      "¬SafetyTest(s) → ¬FlightPractice(s) ∧ RetakeTheory(s) ::: No test → no practice and retake theory",
      "Delay(s) > 3 → Refund(s) = 0.5 ::: >3h delay → refund 50%",
      "FlightLate(s) > 1 → SubmitReport(s) ::: >1h late → report needed",
      "FlightPractice(s) → Instructors(s) ≥ 2 ::: At least 2 instructors needed",
      "InstructorAbsent(s) → FindReplacement(s) ≤ 1 ::: Must find replacement in 1h",
      "InstructorAbsent(s) ∧ ¬FindReplacement(s) → CancelPractice(s) ∧ ReRegister(s) ::: No replacement → cancel",
      "FlightPractice(s) → SubmitApp(s) ≥ 7 ::: Apply 7 days in advance",
      "CompleteTheory(Lan, '20/3/2025') ::: Lan completed theory",
      "BadWeather(Lan, '8:00', '25/3/2025') ::: Bad weather reported at 8:00",
      "SafetyTest(Lan, '7:30', '25/3/2025') ::: Lan passed test at 7:30",
      "InstructorAbsent(Lan, '8:15', '25/3/2025') ::: Instructor absent at 8:15",
      "¬FindReplacement(Lan, 1) ::: No replacement within 1h",
      "CancelPractice(s) → NotifyCancel(s) ≥ 0.5 ::: Cancelation notice 30m before",
      "CancelPractice(s) → MakeUp(s) ≤ 2 ∨ LoseEligibility(s) ::: Must do make-up in 2 weeks or lose eligibility"
    ],
    "predicates": [
      "CompleteTheory(s) ::: student s completed theory course",
      "FlightPractice(s) ::: student s can attend flight practice",
      "SafetyTest(s) ::: student s passed safety test",
      "RetakeTheory(s) ::: student s must retake theory course",
      "Delay(s) ::: delay time of flight for student s in hours",
      "Refund(s) ::: refund rate for student s",
      "FlightLate(s) ::: how late the flight is in hours",
      "SubmitReport(s) ::: student s must submit a report",
      "Instructors(s) ::: number of instructors assigned",
      "InstructorAbsent(s) ::: instructor absent for student s",
      "FindReplacement(s) ::: whether replacement is found for instructor",
      "CancelPractice(s) ::: practice is canceled for student s",
      "ReRegister(s) ::: student s must re-register",
      "SubmitApp(s) ::: days in advance student s submitted application",
      "NotifyCancel(s) ::: time in advance student s was notified of cancelation",
      "MakeUp(s) ::: weeks within which student s must make up",
      "LoseEligibility(s) ::: student s loses exam eligibility"
    ]
  },
  {
    "conclusion": "All Python projects are optimized for performance.",
    "conclusion_FOL": "∀x (Project(x) → Optimized(x)) ::: All Python projects are optimized.",
    "premises": [
      "Every Python project is well-structured.",
      "If a Python project is well-structured, then it is optimized.",
      "If a Python project is well-tested, then it is optimized.",
      "If a Python project is well-tested, then it follows PEP 8 standards.",
      "All Python projects have clean and readable code.",
      "All Python projects are easy to maintain.",
      "If a Python project is easy to maintain, then it is well-tested."
    ],
    "premises_FOL": [
      "∀x (Project(x) → WellStructured(x)) ::: Every Python project is well-structured.",
      "∀x (Project(x) ∧ WellStructured(x) → Optimized(x)) ::: Well-structured projects are optimized.",
      "∀x (Project(x) ∧ WellTested(x) → Optimized(x)) ::: Well-tested projects are optimized.",
      "∀x (Project(x) ∧ WellTested(x) → FollowsPEP8(x)) ::: Well-tested projects follow PEP 8.",
      "∀x (Project(x) → CleanReadable(x)) ::: Projects have clean and readable code.",
      "∀x (Project(x) → EasyToMaintain(x)) ::: Projects are easy to maintain.",
      "∀x (Project(x) ∧ EasyToMaintain(x) → WellTested(x)) ::: Easy to maintain → well-tested."
    ],
    "predicates": [
      "Project(x) ::: x is a Python project",
      "WellStructured(x) ::: x is well-structured",
      "Optimized(x) ::: x is optimized",
      "WellTested(x) ::: x is well-tested",
      "FollowsPEP8(x) ::: x follows PEP 8",
      "CleanReadable(x) ::: x has clean and readable code",
      "EasyToMaintain(x) ::: x is easy to maintain"
    ]
  },
  {
    "conclusion": "Having a career mentor leads to better long-term career growth.",
    "conclusion_FOL": "∀x (HasMentor(x) → BetterCareerGrowth(x)) ::: Having a career mentor leads to better career growth.",
    "premises": [
      "If a student builds a strong resume, they increase their chances of securing a job.",
      "If a student attends career workshops, they improve their job application skills.",
      "If a student improves their job application skills, they perform better in job interviews.",
      "If a student performs better in job interviews, they have a higher chance of getting hired.",
      "If a student participates in internships, they gain relevant work experience.",
      "If a student gains relevant work experience, they enhance their employability.",
      "If a student has professional networking skills, they can connect with potential employers.",
      "If a student connects with potential employers, they receive job opportunities.",
      "If a student has a career mentor, they receive guidance on career decisions.",
      "If a student receives guidance on career decisions, they make informed career choices.",
      "If a student makes informed career choices, they have better long-term career growth.",
      "If a student has better long-term career growth, they achieve financial stability."
    ],
    "premises_FOL": [
      "∀x (BuildResume(x) → HigherJobChance(x))",
      "∀x (AttendWorkshop(x) → ImproveAppSkills(x))",
      "∀x (ImproveAppSkills(x) → BetterInterview(x))",
      "∀x (BetterInterview(x) → HigherHiringChance(x))",
      "∀x (Internship(x) → GainExperience(x))",
      "∀x (GainExperience(x) → EnhanceEmployability(x))",
      "∀x (HasNetworking(x) → ConnectEmployers(x))",
      "∀x (ConnectEmployers(x) → GetJobOffers(x))",
      "∀x (HasMentor(x) → GetGuidance(x))",
      "∀x (GetGuidance(x) → MakeInformedChoices(x))",
      "∀x (MakeInformedChoices(x) → BetterCareerGrowth(x))",
      "∀x (BetterCareerGrowth(x) → FinancialStability(x))"
    ],
    "predicates": [
      "BuildResume(x) ::: student x builds a strong resume",
      "HigherJobChance(x) ::: student x increases chance of getting job",
      "AttendWorkshop(x) ::: student x attends career workshop",
      "ImproveAppSkills(x) ::: student x improves application skills",
      "BetterInterview(x) ::: student x performs better in interviews",
      "HigherHiringChance(x) ::: student x has higher chance of being hired",
      "Internship(x) ::: student x participates in internship",
      "GainExperience(x) ::: student x gains work experience",
      "EnhanceEmployability(x) ::: student x improves employability",
      "HasNetworking(x) ::: student x has networking skills",
      "ConnectEmployers(x) ::: student x connects with employers",
      "GetJobOffers(x) ::: student x receives job offers",
      "HasMentor(x) ::: student x has a career mentor",
      "GetGuidance(x) ::: student x receives career guidance",
      "MakeInformedChoices(x) ::: student x makes informed career choices",
      "BetterCareerGrowth(x) ::: student x achieves long-term career growth",
      "FinancialStability(x) ::: student x achieves financial stability"
    ]
  },      
  {
    "conclusion": "A cost-effective Raspberry Pi system may fail to support all versatile use-cases if it is not thoroughly tested and well-documented.",
    "conclusion_FOL": "∀x ((CostEffective(x) ∧ ¬TestedAndDocumented(x)) → ¬SupportsAllUseCases(x)) ::: A cost-effective system not tested and documented may not support all use-cases.",
    "premises": [
      "If a Raspberry Pi system is simple to use, then it is cost-effective.",
      "There exists at least one Raspberry Pi system that is cost-effective.",
      "If a Raspberry Pi system is not simple to use, then it is not versatile.",
      "If a Raspberry Pi system is simple to use, then it is versatile.",
      "There exists at least one Raspberry Pi system that is versatile.",
      "Every Raspberry Pi system is thoroughly tested and well-documented.",
      "If being simple to use implies cost-effectiveness for a Raspberry Pi system, then every Raspberry Pi system is thoroughly tested and well-documented.",
      "If there exists at least one cost-effective Raspberry Pi system, then there exists at least one versatile Raspberry Pi system.",
      "If a Raspberry Pi system is connected to online resources, then it is thoroughly tested and well-documented.",
      "If a Raspberry Pi system is connected to online resources, then it is versatile.",
      "There exists at least one Raspberry Pi system that is connected to online resources and benefits from active community support.",
      "If a Raspberry Pi system is cost-effective but not thoroughly tested and well-documented, then it might not support all versatile use-cases."
    ],
    "premises_FOL": [
      "∀x (Simple(x) → CostEffective(x))",
      "∃x (CostEffective(x))",
      "∀x (¬Simple(x) → ¬Versatile(x))",
      "∀x (Simple(x) → Versatile(x))",
      "∃x (Versatile(x))",
      "∀x (TestedAndDocumented(x))",
      "(∀x (Simple(x) → CostEffective(x)) → ∀x (TestedAndDocumented(x)))",
      "(∃x CostEffective(x) → ∃x Versatile(x))",
      "∀x (ConnectedOnline(x) → TestedAndDocumented(x))",
      "∀x (ConnectedOnline(x) → Versatile(x))",
      "∃x (ConnectedOnline(x))",
      "∀x ((CostEffective(x) ∧ ¬TestedAndDocumented(x)) → ¬SupportsAllUseCases(x))"
    ],
    "predicates": [
      "Simple(x) ::: x is simple to use",
      "CostEffective(x) ::: x is cost-effective",
      "Versatile(x) ::: x is versatile",
      "TestedAndDocumented(x) ::: x is thoroughly tested and well-documented",
      "ConnectedOnline(x) ::: x is connected to online resources",
      "SupportsAllUseCases(x) ::: x supports all versatile use-cases"
    ]
  },
  {
    "conclusion": "Some people who are healthy and exercise regularly live long lives.",
    "conclusion_FOL": "∃x (Healthy(x) ∧ ExercisesRegularly(x) ∧ LongLife(x)) ::: There exists someone who is healthy, exercises regularly and lives a long life.",
    "premises": [
      "All people are either healthy or not healthy.",
      "People who eat healthy food are healthy.",
      "Healthy people exercise regularly.",
      "People who get enough sleep are healthy.",
      "People with good genes are healthy.",
      "If a person smokes, they are not healthy.",
      "If a person drinks alcohol excessively, they are not healthy.",
      "If a person is happy, they are healthy.",
      "People who have good friends are happy.",
      "People who get regular checkups are healthy.",
      "If a person eats unhealthy food, they are not healthy.",
      "If a person is stressed, they are not healthy.",
      "If a person avoids stress, they are healthy.",
      "People who follow doctor's advice are healthy.",
      "People who exercise regularly live long lives.",
      "Some people are healthy."
    ],
    "premises_FOL": [
      "∀x (Person(x) → (Healthy(x) ∨ ¬Healthy(x))) ::: All people are either healthy or not healthy.",
      "∀x (EatsHealthyFood(x) → Healthy(x)) ::: People who eat healthy food are healthy.",
      "∀x (Healthy(x) → ExercisesRegularly(x)) ::: Healthy people exercise regularly.",
      "∀x (GetsEnoughSleep(x) → Healthy(x)) ::: People who get enough sleep are healthy.",
      "∀x (HasGoodGenes(x) → Healthy(x)) ::: People with good genes are healthy.",
      "∀x (Smokes(x) → ¬Healthy(x)) ::: If a person smokes, they are not healthy.",
      "∀x (DrinksAlcExcess(x) → ¬Healthy(x)) ::: If a person drinks alcohol excessively, they are not healthy.",
      "∀x (IsHappy(x) → Healthy(x)) ::: If a person is happy, they are healthy.",
      "∀x (HasGoodFriends(x) → IsHappy(x)) ::: People who have good friends are happy.",
      "∀x (GetsRegularCheckups(x) → Healthy(x)) ::: People who get regular checkups are healthy.",
      "∀x (EatsUnhealthyFood(x) → ¬Healthy(x)) ::: If a person eats unhealthy food, they are not healthy.",
      "∀x (IsStressed(x) → ¬Healthy(x)) ::: If a person is stressed, they are not healthy.",
      "∀x (AvoidsStress(x) → Healthy(x)) ::: If a person avoids stress, they are healthy.",
      "∀x (FollowsDoctorsAdvice(x) → Healthy(x)) ::: People who follow doctor's advice are healthy.",
      "∀x (ExercisesRegularly(x) → LongLife(x)) ::: People who exercise regularly live long lives.", 
      "∀x (Healthy(x) → LongLife(x)) ::: People who are healthy live long lives.", 
      "∃x Healthy(x) ::: Some people are healthy."
    ],
    "predicates": [
        "Person(x) ::: x is a person.",
        "Healthy(x) ::: x is healthy.",
        "ExercisesRegularly(x) ::: x exercises regularly.",
        "LongLife(x) ::: x lives a long life.",
        "EatsHealthyFood(x) ::: x eats healthy food.",
        "GetsEnoughSleep(x) ::: x gets enough sleep.",
        "HasGoodGenes(x) ::: x has good genes.",
        "Smokes(x) ::: x smokes.",
        "DrinksAlcExcess(x) ::: x drinks alcohol excessively.",
        "IsHappy(x) ::: x is happy.",
        "HasGoodFriends(x) ::: x has good friends.",
        "GetsRegularCheckups(x) ::: x gets regular checkups.",
        "EatsUnhealthyFood(x) ::: x eats unhealthy food.",
        "IsStressed(x) ::: x is stressed.",
        "AvoidsStress(x) ::: x avoids stress.",
        "FollowsDoctorsAdvice(x) ::: x follows the doctor's advice."
    ]
  },
  {
      "conclusion": "Some scientists who publish papers and secure funding collaborate.",
      "conclusion_FOL": "∃x (Scientist(x) ∧ PublishesPapers(x) ∧ SecuresFunding(x) ∧ Collaborates(x)) ::: There exists a scientist who publishes papers, secures funding and collaborates.",
      "premises": [
        "All scientists publish papers.",
        "Scientists who conduct research need equipment.",
        "Scientists who publish papers attend conferences.",
        "Those who attend conferences present results.",
        "Scientists with mentors get help.",
        "Mentors help scientists secure funding.",
        "Scientists who present results receive grants.",
        "Scientists who receive grants share data.",
        "Scientists who share data with others collaborate.",
        "Scientists who secure funding use a lab.",
        "Scientists who use a lab need support.",
        "Scientists who secure funding work on a project.",
        "Some scientists conduct research.",
        "If a scientist publishes papers, they finds interesting topics.",
        "If a scientist works on a project, they collaborate."
      ],
      "premises_FOL": [
        "∀x (Scientist(x) → PublishesPapers(x)) ::: All scientists publish papers.",
        "∀x (ConductsResearch(x) → NeedsEquipment(x)) ::: Scientists who conduct research need equipment.",
        "∀x (PublishesPapers(x) → AttendsConferences(x)) ::: Scientists who publish papers attend conferences.",
        "∀x (AttendsConferences(x) → PresentsResults(x)) ::: Those who attend conferences present results.",
        "∀x (HasMentors(x, y) → MentorsHelp(y, x)) ::: Scientists with mentors get help.",
        "∀x ∀y (MentorsHelp(x, y) → SecuresFunding(y)) ::: Mentors help scientists secure funding.",
        "∀x (PresentsResults(x) → ReceivesGrants(x)) ::: Scientists who present results receive grants.",
        "∃y (SharesData(x, y)) ::: Scientist x who receive grants share data shares data with y.",
        "∀x (SharesData(x, y) → Collaborates(x)) ::: Scientists who share data with others collaborate.",
        "∀x (SecuresFunding(x) → UsesLab(x)) ::: Scientists who secure funding use a lab.",
        "∀x (UsesLab(x) → NeedsSupport(x)) ::: Scientists who use a lab need support.",
        "∃y (SecuresFunding(x) → WorksOnProject(x, y)) ::: Scientist s who secure funding work on a project y.",
        "∃x ConductsResearch(x) ::: Some scientists conduct research.",
        "∀x (PublishesPapers(x) → FindsInterestingTopics(x)) ::: If a scientist publishes papers, they finds interesting topics.",
        "∀x ∀y (WorksOnProject(x, y) → Collaborates(x)) ::: If a scientist works on a project, they collaborate."
      ],
      "predicates": [
        "Scientist(x) ::: x is a scientist.",
        "PublishesPapers(x) ::: x publishes papers.",
        "SecuresFunding(x) ::: x secures funding.",
        "Collaborates(x) ::: x collaborates.",
        "ConductsResearch(x) ::: x conducts research.",
        "NeedsEquipment(x) ::: x needs equipment.",
        "AttendsConferences(x) ::: x attends conferences.",
        "PresentsResults(x) ::: x presents results.",
        "HasMentors(x, y) ::: x has mentor y.",
        "MentorsHelp(x, y) ::: mentor x helps y.",
        "ReceivesGrants(x) ::: x receives grants.",
        "SharesData(x, y) ::: x shares data with y.",
        "UsesLab(x) ::: x uses lab.",
        "NeedsSupport(x) ::: x needs support.",
        "FindsInterestingTopics(x) ::: x finds interesting topics.",
        "WorksOnProject(x, y) ::: x works on project y."
      ]
  },
  {
    "conclusion": "Some people who are leaders, have a good vision, and inspire others achieve great things.", 
    "conclusion_FOL": "∃x (Leader(x) ∧ GoodVision(x) ∧ InspiresOthers(x) ∧ AchievesGreatThings(x)) ::: There exists someone who is a leader, has a good vision, inspires others and achieves great things.",
    "premises": [
      "All leaders have a good vision.",
      "People with a good vision inspire others.",
      "People who inspire others motivate their team.",
      "Leaders set goals.",
      "People who communicate effectively build relationships.",
      "People who make decisions understand people.",
      "Leaders are confident.",
      "People who take risks overcome challenges.",
      "People who learn from mistakes are leaders.",
      "People who follow rules help others.",
      "Those who have integrity are leaders.",
      "Leaders who motivate their team achieve great things.",
      "If a person sets goals and builds relationships, they are leaders.",
      "If a person has a good vision and communicates effectively, they are leaders.",
      "Some people are leaders.",
      "If a person is confident and takes risks, they inspire others.",
      "If a person overcomes challenges, they achieve great things.",
      "Leaders must have integrity."
    ],
    "premises_FOL": [
      "∀x (Leader(x) → GoodVision(x)) ::: All leaders have a good vision.",
      "∀x (GoodVision(x) → InspiresOthers(x)) ::: People with a good vision inspire others.",
      "∀x (InspiresOthers(x) → MotivatesTeam(x)) ::: People who inspire others motivate their team.",
      "∀x (Leader(x) → SetsGoals(x)) ::: Leaders set goals.",
      "∀x (CommunicatesEffectively(x) → BuildsRelationships(x)) ::: People who communicate effectively build relationships.",
      "∀x (MakesDecisions(x) → UnderstandsPeople(x)) ::: People who make decisions understand people.",
      "∀x (Leader(x) → IsConfident(x)) ::: Leaders are confident.",
      "∀x (TakesRisks(x) → OvercomesChallenges(x)) ::: People who take risks overcome challenges.",
      "∀x (LearnsFromMistakes(x) → Leader(x)) ::: People who learn from mistakes are leaders.",
      "∀x (FollowsRules(x) → HelpsOthers(x)) ::: People who follow rules help others.",
      "∀x (Leader(x) ∧ MotivatesTeam(x) → AchievesGreatThings(x)) ::: Leaders who motivate their team achieve great things.",
      "∀x (SetsGoals(x) ∧ BuildsRelationships(x) → Leader(x)) ::: If a person sets goals and builds relationships, they are leaders.",
      "∀x (GoodVision(x) ∧ CommunicatesEffectively(x) → Leader(x)) ::: If a person has a good vision and communicates effectively, they are leaders.",
      "∃x Leader(x) ::: Some people are leaders.",
      "∀x (IsConfident(x) ∧ TakesRisks(x) → InspiresOthers(x)) ::: If a person is confident and takes risks, they inspire others.",
      "∀x (OvercomesChallenges(x) → AchievesGreatThings(x)) ::: If a person overcomes challenges, they achieve great things.",
      "∀x (Leader(x) → HasIntegrity(x)) ::: Leaders must have integrity."
    ],
    "predicates": [
      "Person(x) ::: x is a person.",
      "Leader(x) ::: x is a leader.",
      "GoodVision(x) ::: x has a good vision.",
      "InspiresOthers(x) ::: x inspires others.",
      "AchievesGreatThings(x) ::: x achieves great things.",
      "MotivatesTeam(x) ::: x motivates a team.",
      "SetsGoals(x) ::: x sets goals.",
      "CommunicatesEffectively(x) ::: x communicates effectively.",
      "BuildsRelationships(x) ::: x builds relationships.",
      "MakesDecisions(x) ::: x makes decisions.",
      "UnderstandsPeople(x) ::: x understands people.",
      "IsConfident(x) ::: x is confident.",
      "TakesRisks(x) ::: x takes risks.",
      "OvercomesChallenges(x) ::: x overcomes challenges.",
      "LearnsFromMistakes(x) ::: x learns from mistakes.",
      "FollowsRules(x) ::: x follows rules.",
      "HelpsOthers(x) ::: x helps others.",
      "HasIntegrity(x) ::: x has integrity."
    ]
  },
  {
    "conclusion": "If an item is both fragile and expensive, then it needs special handling.",
    "conclusion_FOL": "∀x ((Fragile(x) ∧ Expensive(x)) → NeedsSpecialHandling(x)) ::: For all x, if x is fragile and expensive, then x needs special handling.",
    "premises": [
      "All items made of glass are fragile.",
      "Every fragile item is breakable.",
      "If something is expensive, it's valuable.",
      "All valuable items are insured.",
      "If something is made of glass, it needs special handling.",
      "Some items are expensive.",
      "Some fragile items are delivered to recipients.",
      "Anything that contains a fragile item is a package.",
      "A package contains an item",
      "If something is insured, then handle it with care.",
      "Every package is an item.",
      "Every breakable item needs special handling.",
      "Something is made of glass or costs a lot.",
      "If something costs a lot, then it is expensive.",
      "All items are either expensive or not expensive."
    ],
    "premises_FOL": [
      "∀x (MadeOfGlass(x) → Fragile(x)) ::: For all x, if x is made of glass, then x is fragile.",
      "∀x (Fragile(x) → Breakable(x)) ::: For all x, if x is fragile, then x is breakable.",
      "∀x (Expensive(x) → Valuable(x)) ::: For all x, if x is expensive, then x is valuable.",
      "∀x (Valuable(x) → Insured(x)) ::: For all x, if x is valuable, then x is insured.",
      "∀x (MadeOfGlass(x) → NeedsSpecialHandling(x)) ::: For all x, if x is made of glass, then x needs special handling.",
      "∃x Expensive(x) ::: There exists an x such that x is expensive.",
      "∀x (HandleWithCare(x) → NeedsSpecialHandling(x)) ::: Anything handled with care needs special handling.",
      "∃x ∃y (Fragile(x) ∧ Delivered(x, y) ∧ Recipient(y)) ::: There exists an x and y such that x is fragile and x is delivered to y and y is a recipient.",
      "∀x ∀y ((Fragile(y) ∧ Contains(x, y)) → Package(x)) ::: For all x and y, if y is fragile and x contains y, then x is a package.",
      "∀x (Package(x) → ∃y (Contains(x,y) ∧ Item(y))) ::: For all x, there exists a y such that x is a package and x contains y and y is an item.",
      "∀x (Insured(x) → HandleWithCare(x)) ::: For all x, if x is insured, then handle x with care.",
      "∀x (Package(x) → Item(x)) ::: For all x, if x is a package, then x is an item.",
      "∀x (Breakable(x) → NeedsSpecialHandling(x)) ::: For all x, if x is breakable, then x needs special handling.",
      "∃x (MadeOfGlass(x) ∨ CostMoreThan(x, 1000)) ::: There exists an x such that x is made of glass or x costs more than 1000.",
      "∀x (CostMoreThan(x,1000) → Expensive(x)) ::: For all x, if x costs more than 1000, then x is expensive.",
      "∀x (Expensive(x) ∨ ¬Expensive(x)) ::: For all x, x is expensive or x is not expensive."
    ],
    "predicates": [
      "Fragile(x) ::: x is fragile.",
      "Expensive(x) ::: x is expensive.",
      "NeedsSpecialHandling(x) ::: x needs special handling.",
      "Item(x) ::: x is an item.",
      "MadeOfGlass(x) ::: x is made of glass.",
      "CostMoreThan(x, y) ::: x costs more than y.",
      "Price(x, y) ::: x's price is y.",
      "Material(x, y) ::: x is made of material y.",
      "HandleWithCare(x) ::: Handle x with care.",
      "Breakable(x) ::: x is breakable.",
      "Insured(x) ::: x is insured.",
      "Valuable(x) ::: x is valuable.",
      "Delivered(x, y) ::: x is delivered to y.",
      "Recipient(y) ::: y is the recipient.",
      "Contains(x, y) ::: x contains y.",
      "Package(x) ::: x is a package."
    ]
  },
  {
    "conclusion": "Some students that study hard are not lazy and will succeed in their studies.",
    "conclusion_FOL": "∃x (Student(x) ∧ StudiesHard(x) ∧ ¬IsLazy(x) ∧ Succeeds(x)) ::: There exists a student that studies hard, is not lazy, and succeeds.",
    "premises": [
      "Every student studies hard.",
      "No lazy student attends classes.",
      "Some students pass exams.",
      "Anyone who studies hard reads books.",
      "If a student reads books, then they get good grades.",
      "Every student who gets good grades enjoys learning.",
      "If someone enjoys learning, they are diligent.",
      "Some diligent students are not lazy.",
      "Anyone who is not lazy does not skip classes.",
      "If a student attends classes, they do not fail exams.",
      "Anyone who is motivated studies hard.",
      "If a student is diligent, they are motivated.",
      "Someone who gets good grades gets an award.",
      "Some people get good grades and are not lazy.",
      "If someone passes exams then they succeeds.",
      "If someone succeeds they offer help.",
      "If someone gets award, they are smart."
    ],
    "premises_FOL": [
      "∀x (Student(x) → StudiesHard(x)) ::: Every student studies hard.",
      "∀x (IsLazy(x) → ¬AttendsClasses(x)) ::: No lazy student attends classes.",
      "∃x PassesExams(x) ::: Some students pass exams.",
      "∀x (StudiesHard(x) → ReadsBooks(x)) ::: Anyone who studies hard reads books.",
      "∀x (ReadsBooks(x) → GetsGoodGrades(x)) ::: If a student reads books, then they get good grades.",
      "∀x (GetsGoodGrades(x) → EnjoysLearning(x)) ::: Every student who gets good grades enjoys learning.",
      "∀x (EnjoysLearning(x) → IsDiligent(x)) ::: If someone enjoys learning, they are diligent.",
      "∃x (IsDiligent(x) ∧ ¬IsLazy(x)) ::: Some diligent students are not lazy.",
      "∀x (¬IsLazy(x) → ¬SkipsClasses(x)) ::: Anyone who is not lazy does not skip classes.",
      "∀x (AttendsClasses(x) → ¬FailsExams(x)) ::: If a student attends classes, they do not fail exams.",
      "∀x (IsMotivated(x) → StudiesHard(x)) ::: Anyone who is motivated studies hard.",
      "∀x (IsDiligent(x) → IsMotivated(x)) ::: If a student is diligent, they are motivated.",
      "∃x (GetsGoodGrades(x) ∧ GetsAward(x)) ::: Someone who gets good grades gets an award.",
      "∃x (GetsGoodGrades(x) ∧ ¬IsLazy(x)) ::: Some people get good grades and are not lazy.",
      "∀x (PassesExams(x) → Succeeds(x)) ::: If someone passes exams then they succeeds.",
      "∀x (Succeeds(x) → OffersHelp(x, x)) ::: If someone succeeds they offer help.",
      "∀x (GetsAward(x) → IsSmart(x)) ::: If someone gets award, they are smart.",
      "∀x (GetsGoodGrades(x) → PassesExams(x)) ::: If you get good grades, you pass exams."
    ],
    "predicates": [
      "Student(x) ::: x is a student",
      "StudiesHard(x) ::: x studies hard",
      "IsLazy(x) ::: x is lazy",
      "Succeeds(x) ::: x succeeds",
      "AttendsClasses(x) ::: x attends classes",
      "PassesExams(x) ::: x passes exams",
      "ReadsBooks(x) ::: x reads books",
      "GetsGoodGrades(x) ::: x gets good grades",
      "EnjoysLearning(x) ::: x enjoys learning",
      "IsDiligent(x) ::: x is diligent",
      "SkipsClasses(x) ::: x skips classes",
      "FailsExams(x) ::: x fails exams",
      "IsMotivated(x) ::: x is motivated",
      "NeedsHelp(x) ::: x needs help",
      "OffersHelp(x, y) ::: x offers help to y",
      "IsSmart(x) ::: x is smart",
      "GetsAward(x) ::: x gets an award"
    ]
  },
  {
    "conclusion": "If someone is a doctor and works in a hospital, then they help patients.",
    "conclusion_FOL": "∀x ((Doctor(x) ∧ WorksInHospital(x)) → HelpsPatients(x)) ::: If someone is a doctor and works in a hospital, then they help patients.",
    "premises": [
      "All surgeons are doctors.",
      "All specialists are doctors.",
      "Every doctor treats illnesses.",
      "Anyone who treats illnesses uses medical equipment.",
      "Anyone who uses medical equipment prescribes medication.",
      "Everyone who prescribes medication diagnoses.",
      "Anyone who diagnoses sees patients.",
      "All who see patients work in a clinic or a hospital.",
      "Someone who conducts research is a doctor.",
      "Every doctor knows medicine.",
      "Anyone who knows medicine is educated.",
      "Everyone educated has a degree.",
      "All with a degree has a license.",
      "Anyone with a license can be a doctor.",
      "Not everyone works in a clinic.",
      "There are doctors who work in hospitals."
    ],
    "premises_FOL": [
      "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
      "∀x (SeesPatients(x) → HelpsPatients(x)) ::: Anyone who sees patients helps them.",
      "∀x (Specialist(x) → Doctor(x)) ::: All specialists are doctors.",
      "∀x (Doctor(x) → TreatsIllness(x)) ::: Every doctor treats illnesses.",
      "∀x (TreatsIllness(x) → UsesMedicalEquipment(x)) ::: Anyone who treats illnesses uses medical equipment.",
      "∀x (UsesMedicalEquipment(x) → PrescribesMedication(x)) ::: Anyone who uses medical equipment prescribes medication.",
      "∀x (PrescribesMedication(x) → Diagnoses(x)) ::: Everyone who prescribes medication diagnoses.",
      "∀x (Diagnoses(x) → SeesPatients(x)) ::: Anyone who diagnoses sees patients.",
      "∀x (SeesPatients(x) → (WorksInClinic(x) ∨ WorksInHospital(x))) ::: All who see patients work in a clinic or a hospital.",
      "∃x (ConductsResearch(x) ∧ Doctor(x)) ::: Someone who conducts research is a doctor.",
      "∀x (Doctor(x) → KnowsMedicine(x)) ::: Every doctor knows medicine.",
      "∀x (KnowsMedicine(x) → IsEducated(x)) ::: Anyone who knows medicine is educated.",
      "∀x (IsEducated(x) → HasDegree(x)) ::: Everyone educated has a degree.",
      "∀x (HasDegree(x) → HasLicense(x)) ::: All with a degree has a license.",
      "∀x (HasLicense(x) → Doctor(x)) ::: Anyone with a license can be a doctor.",
      "¬∀x WorksInClinic(x) ::: Not everyone works in a clinic.",
      "∃x (Doctor(x) ∧ WorksInHospital(x)) ::: There are doctors who work in hospitals.",
      "∀x (SeesPatients(x) → HelpsPatients(x)) ::: Anyone who sees patients helps them.",
      "∀x (Doctor(x) ∧ WorksInHospital(x) → SeesPatients(x)) ::: Doctors who work in hospitals see patients."
    ],
    "predicates": [
      "Doctor(x) ::: x is a doctor",
      "WorksInHospital(x) ::: x works in a hospital",
      "HelpsPatients(x) ::: x helps patients",
      "Surgeon(x) ::: x is a surgeon",
      "Specialist(x) ::: x is a specialist",
      "TreatsIllness(x) ::: x treats illness",
      "UsesMedicalEquipment(x) ::: x uses medical equipment",
      "PrescribesMedication(x) ::: x prescribes medication",
      "Diagnoses(x) ::: x diagnoses",
      "SeesPatients(x) ::: x sees patients",
      "WorksInClinic(x) ::: x works in a clinic",
      "ConductsResearch(x) ::: x conducts research",
      "KnowsMedicine(x) ::: x knows medicine",
      "IsEducated(x) ::: x is educated",
      "HasDegree(x) ::: x has a degree",
      "HasLicense(x) ::: x has a license"
    ]
  },
  {
    "conclusion": "If a student studies computer science and does well, then they will get a job.",
    "conclusion_FOL": "∀x ((Student(x) ∧ StudiesComputerScience(x) ∧ DoesWell(x)) → GetsJob(x)) ::: If a student studies computer science and does well, then they will get a job.",
    "premises": [
      "All students are enrolled.",
      "Anyone who is enrolled takes exams.",
      "Anyone who studies computer science attends lectures.",
      "Anyone who attends lectures submits assignments.",
      "Anyone who submits assignments understands concepts.",
      "Anyone who understands concepts passes exams.",
      "Anyone who passes exams gets good grades.",
      "Anyone who gets good grades does well.",
      "Anyone who does well has skills.",
      "Anyone with skills applies for jobs.",
      "Anyone who applies for jobs gets an interview.",
      "Anyone who gets an interview gets an offer.",
      "Anyone who gets an offer gets a job.",
      "Everyone who studies computer science works hard.",
      "Anyone who works hard is dedicated.",
      "Anyone who is dedicated submits assignments.",
      "Someone studies computer science.",
      "There are students."
    ],
    "premises_FOL": [
      "∀x (Student(x) → IsEnrolled(x)) ::: All students are enrolled.",
      "∀x (IsEnrolled(x) → TakesExams(x)) ::: Anyone who is enrolled takes exams.",
      "∀x (StudiesComputerScience(x) → AttendsLectures(x)) ::: Anyone who studies computer science attends lectures.",
      "∀x (AttendsLectures(x) → SubmitsAssignments(x)) ::: Anyone who attends lectures submits assignments.",
      "∀x (SubmitsAssignments(x) → UnderstandsConcepts(x)) ::: Anyone who submits assignments understands concepts.",
      "∀x (UnderstandsConcepts(x) → PassesExams(x)) ::: Anyone who understands concepts passes exams.",
      "∀x (PassesExams(x) → GetsGoodGrades(x)) ::: Anyone who passes exams gets good grades.",
      "∀x (GetsGoodGrades(x) → DoesWell(x)) ::: Anyone who gets good grades does well.",
      "∀x (DoesWell(x) → HasSkills(x)) ::: Anyone who does well has skills.",
      "∀x (HasSkills(x) → AppliesForJobs(x)) ::: Anyone with skills applies for jobs.",
      "∀x (AppliesForJobs(x) → GetsInterview(x)) ::: Anyone who applies for jobs gets an interview.",
      "∀x (GetsInterview(x) → GetsOffer(x)) ::: Anyone who gets an interview gets an offer.",
      "∀x (GetsOffer(x) → GetsJob(x)) ::: Anyone who gets an offer gets a job.",
      "∀x (StudiesComputerScience(x) → WorksHard(x)) ::: Everyone who studies computer science works hard.",
      "∀x (WorksHard(x) → IsDedicated(x)) ::: Anyone who works hard is dedicated.",
      "∀x (IsDedicated(x) → SubmitsAssignments(x)) ::: Anyone who is dedicated submits assignments.",
      "∃x StudiesComputerScience(x) ::: Someone studies computer science.",
      "∃x Student(x) ::: There are students."
    ],
    "predicates": [
      "Student(x) ::: x is a student",
      "StudiesComputerScience(x) ::: x studies computer science",
      "DoesWell(x) ::: x does well",
      "GetsJob(x) ::: x gets a job",
      "IsEnrolled(x) ::: x is enrolled",
      "TakesExams(x) ::: x takes exams",
      "AttendsLectures(x) ::: x attends lectures",
      "SubmitsAssignments(x) ::: x submits assignments",
      "UnderstandsConcepts(x) ::: x understands concepts",
      "PassesExams(x) ::: x passes exams",
      "GetsGoodGrades(x) ::: x gets good grades",
      "HasSkills(x) ::: x has skills",
      "AppliesForJobs(x) ::: x applies for jobs",
      "GetsInterview(x) ::: x gets an interview",
      "GetsOffer(x) ::: x gets an offer",
      "WorksHard(x) ::: x works hard",
      "IsDedicated(x) ::: x is dedicated"
    ]
  },
  {
    "conclusion": "If someone is a scientist and studies biology or chemistry, they will use lab equipment and generate a report.",
    "conclusion_FOL": "∀x ((Scientist(x) ∧ (StudiesBiology(x) ∨ StudiesChemistry(x))) → (UsesLabEquipment(x) ∧ GeneratesReport(x))) ::: If someone is a scientist and studies biology or chemistry, they will use lab equipment and generate a report.",
    "premises": [
      "All scientists conduct experiments.",
      "Anyone who conducts experiments analyzes data.",
      "Anyone who analyzes data generates a report.",
      "Anyone who studies biology or chemistry works in a lab.",
      "Anyone who works in a lab uses lab equipment.",
      "Scientists publish papers.",
      "Anyone who publishes papers needs funding.",
      "Scientists collaborate with others.",
      "Anyone who collaborates presents findings.",
      "Anyone who presents findings attends conferences.",
      "Anyone who attends conferences is a scientist.",
      "All who specialize in biology or chemistry understands principles.",
      "Anyone who understands principles has knowledge.",
      "Anyone who has knowledge is educated.",
      "Anyone who is educated graduates.",
      "Anyone who graduates is a researcher.",
      "All researchers are scientists.",
      "Someone studies biology or chemistry.",
        "There is a scientist."
    ],
    "premises_FOL": [
      "∀x (Scientist(x) → ConductsExperiments(x)) ::: All scientists conduct experiments.",
      "∀x (ConductsExperiments(x) → AnalyzesData(x)) ::: Anyone who conducts experiments analyzes data.",
      "∀x (AnalyzesData(x) → GeneratesReport(x)) ::: Anyone who analyzes data generates a report.",
      "∀x ((StudiesBiology(x) ∨ StudiesChemistry(x)) → WorksInLab(x)) ::: Anyone who studies biology or chemistry works in a lab.",
      "∀x (WorksInLab(x) → UsesLabEquipment(x)) ::: Anyone who works in a lab uses lab equipment.",
      "∀x (Scientist(x) → PublishesPapers(x)) ::: Scientists publish papers.",
      "∀x (PublishesPapers(x) → NeedsFunding(x)) ::: Anyone who publishes papers needs funding.",
      "∀x ∃y Collaborates(x, y) ::: Scientists collaborate with others.",
      "∀x (Collaborates(x, y) → PresentsFindings(x)) ::: Anyone who collaborates presents findings.",
      "∀x (PresentsFindings(x) → AttendsConferences(x)) ::: Anyone who presents findings attends conferences.",
      "∀x (AttendsConferences(x) → Scientist(x)) ::: Anyone who attends conferences is a scientist.",
      "∀x ((SpecializesIn(x, \"Biology\") ∨ SpecializesIn(x, \"Chemistry\")) → UnderstandsPrinciples(x)) ::: All who specialize in biology or chemistry understands principles.",
      "∀x (UnderstandsPrinciples(x) → HasKnowledge(x)) ::: Anyone who understands principles has knowledge.",
      "∀x (HasKnowledge(x) → IsEducated(x)) ::: Anyone who has knowledge is educated.",
      "∀x (IsEducated(x) → Graduates(x)) ::: Anyone who is educated graduates.",
      "∀x (Graduates(x) → IsResearcher(x)) ::: Anyone who graduates is a researcher.",
      "∀x (IsResearcher(x) → Scientist(x)) ::: All researchers are scientists.",
      "∃x (StudiesBiology(x) ∨ StudiesChemistry(x)) ::: Someone studies biology or chemistry.",
      "∃x Scientist(x) ::: There is a scientist."
    ],
    "predicates": [
      "Scientist(x) ::: x is a scientist",
      "StudiesBiology(x) ::: x studies biology",
      "StudiesChemistry(x) ::: x studies chemistry",
      "UsesLabEquipment(x) ::: x uses lab equipment",
      "GeneratesReport(x) ::: x generates a report",
      "ConductsExperiments(x) ::: x conducts experiments",
      "AnalyzesData(x) ::: x analyzes data",
      "PublishesPapers(x) ::: x publishes papers",
      "WorksInLab(x) ::: x works in a lab",
      "NeedsFunding(x) ::: x needs funding",
      "Collaborates(x, y) ::: x collaborates with y",
      "PresentsFindings(x) ::: x presents findings",
      "AttendsConferences(x) ::: x attends conferences",
      "SpecializesIn(x, y) ::: x specializes in y",
      "UnderstandsPrinciples(x) ::: x understands principles",
      "HasKnowledge(x) ::: x has knowledge",
      "IsEducated(x) ::: x is educated",
      "Graduates(x) ::: x graduates",
      "IsResearcher(x) ::: x is a researcher"
    ]
  },
  {
    "premises-NL": [
      "A student can withdraw up to 3 courses per academic year if remaining credits ≥ 10 (Year 1, 2) or ≥ 8 (Year 3+); each withdrawal deducts 0.5 credits from total accumulated credits.",
      "Courses have 3, 4, or 5 credits; withdrawn courses contribute 0 credits to semester GPA.",
      "Students must register for 12–18 credits per semester; withdrawals reduce semester credits.",
      "No regulation limits total withdrawals, but max 3 per year.",
      "A student with < 8 accumulated credits cannot withdraw courses.",
      "A student (Year 2) has 45 credits, withdrew 2 courses in Year 1 (penalty 1 credit), including C1 (4 credits, withdrawn), C2 (3 credits, withdrawn).",
      "In Year 2, semester S1, the student registered for 15 credits, withdrew C3 (5 credits), C4 (3 credits), attempted C5 (4 credits, passed)."
    ],
    "premises-FOL": [
      "∀x,y,s (Withdrawals(x, y) ≤ 3 ∧ (Year(x) ≤ 2 → GE(RemainingCredits(x, y, s), 10)) ∧ (Year(x) > 2 → GE(RemainingCredits(x, y, s), 8))) → CanWithdraw(x, y, s) ∧ CreditPenalty(x, Multiply(-0.5, Withdrawals(x, y)))",
      "∀c (InSet(Credits(c), [3, 4, 5]) ∧ Withdrawn(c) → GPAContribution(c, 0))",
      "∀x,s (RegisteredCredits(x, s) ∈ Interval(12, 18) ∧ RemainingCredits(x, s) = Subtract(RegisteredCredits(x, s), WithdrawnCredits(x, s)))",
      "¬∃r (Regulation(r) ∧ LimitsTotalWithdrawals(r)) ∧ ∀x,y (Withdrawals(x, y) ≤ 3)",
      "∀x (LT(TotalCredits(x), 8) → ¬∃y,s (CanWithdraw(x, y, s)))",
      "Student(s1) ∧ Year(s1) = 2 ∧ TotalCredits(s1) = 45 ∧ Withdrawals(s1, year1) = 2 ∧ CreditPenalty(s1, -1) ∧ Course(s1, c1) ∧ Credits(c1) = 4 ∧ Withdrawn(c1) ∧ Course(s1, c2) ∧ Credits(c2) = 3 ∧ Withdrawn(c2)",
      "SemesterCourses(s1, year2, S1, [c3, c4, c5]) ∧ Course(s1, c3) ∧ Credits(c3) = 5 ∧ Withdrawn(c3) ∧ Course(s1, c4) ∧ Credits(c4) = 3 ∧ Withdrawn(c4) ∧ Course(s1, c5) ∧ Credits(c5) = 4 ∧ Passed(c5) ∧ RegisteredCredits(s1, S1) = 15"
    ],
    "predicates": [
      "Withdrawals(x, y) ::: Number of courses withdrawn by student x in academic year y",
      "Year(x) ::: Academic year of student x",
      "RemainingCredits(x, y, s) ::: Credits remaining for student x in semester s of year y",
      "GE(a, b) ::: a ≥ b",
      "GT(a, b) ::: a > b",
      "LE(a, b) ::: a ≤ b",
      "LT(a, b) ::: a < b",
      "CanWithdraw(x, y, s) ::: Student x is allowed to withdraw in semester s of year y",
      "CreditPenalty(x, v) ::: Student x receives credit penalty v",
      "Multiply(a, b) ::: Result of a multiplied by b",
      "InSet(a, [v1, v2,...]) ::: a ∈ {v1, v2,...}",
      "GPAContribution(c, v) ::: Course c contributes v to GPA",
      "RegisteredCredits(x, s) ::: Total credits student x registered in semester s",
      "WithdrawnCredits(x, s) ::: Total credits withdrawn by x in semester s",
      "Subtract(a, b) ::: Result of a - b",
      "Regulation(r) ::: r is a regulation",
      "LimitsTotalWithdrawals(r) ::: Regulation r limits total number of withdrawals",
      "TotalCredits(x) ::: Total accumulated credits of student x",
      "Student(x) ::: x is a student",
      "Course(x, c) ::: Student x enrolled in course c",
      "Credits(c) ::: Credit value of course c",
      "Withdrawn(c) ::: Course c was withdrawn",
      "Passed(c) ::: Course c was passed",
      "SemesterCourses(x, y, s, [c1,...]) ::: List of courses taken by student x in year y, semester s",
      "Interval(a, b) ::: Value is within inclusive interval [a, b]"
    ]
  }
]