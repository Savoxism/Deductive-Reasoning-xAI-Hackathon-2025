[
    {
        "premises-NL": [
            "All doctors either specialize in surgery or are experienced.",
            "Surgeons are experienced.",
            "Anyone who is a doctor and is not experienced has a mentor.",
            "If someone has a mentor, they are a doctor.",
            "John is a surgeon and a doctor.",
            "All surgeons are doctors.",
            "If someone specializes in surgery, they are a doctor.",
            "Some doctors are surgeons.",
            "Every doctor either is experienced or has a mentor.",
            "Every doctor is experienced."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → (SpecializesIn(x, surgery) ∨ Experienced(x))) ::: All doctors either specialize in surgery or are experienced.",
            "∀x (Surgeon(x) → Experienced(x)) ::: Surgeons are experienced.",
            "∀x (Doctor(x) ∧ ¬Experienced(x) → HasMentor(x)) ::: Anyone who is a doctor and is not experienced has a mentor.",
            "∀x (HasMentor(x) → Doctor(x)) ::: If someone has a mentor, they are a doctor.",
            "Surgeon(john) ∧ Doctor(john) ::: John is a surgeon and a doctor.",
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (SpecializesIn(x, surgery) → Doctor(x)) ::: If someone specializes in surgery, they are a doctor.",
            "∃x (Doctor(x) ∧ Surgeon(x)) ::: Some doctors are surgeons.",
            "∀x (Doctor(x) → (Experienced(x) ∨ HasMentor(x))) ::: Every doctor either is experienced or has a mentor.",
            "∀x (Doctor(x) → Experienced(x)) ::: Every doctor is experienced."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Experienced(x) ::: x is experienced",
            "HasMentor(x) ::: x has a mentor",
            "SpecializesIn(x, y) ::: x specializes in y",
            "Surgeon(x) ::: x is a surgeon",
            "Surgeons(x, y) ::: x is a surgeon and y is a surgeon"
        ]
    },
    {
        "premises-NL": [
            "All students attend class.",
            "Anyone who studies will pass the exam.",
            "If someone attends class and is a student, then they study.",
            "Every student is taking the exam.",
            "Mark is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClass(x)) ::: All students attend class.",
            "∀x (Studies(x) → PassExam(x)) ::: Anyone who studies will pass the exam.",
            "∀x (AttendsClass(x) ∧ Student(x) → Studies(x)) ::: If someone attends class and is a student, then they study.",
            "∀x (Student(x) → TakingExam(x)) ::: Every student is taking the exam.",
            "Student(mark) ::: Mark is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "PassExam(x) ::: x passes the exam",
            "AttendsClass(x) ::: x attends class"
        ]
    },
    {
        "premises-NL": [
            "All students are either in a study group or they don't study.",
            "Any student who studies and is in a study group is capable of learning.",
            "All students are capable of learning if they study."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (StudyGroupMember(x) ∨ ¬Studies(x))) ::: All students are either in a study group or they don't study.",
            "∀x ((Student(x) ∧ StudyGroupMember(x) ∧ Studies(x)) → Learns(x)) ::: Any student who studies and is in a study group is capable of learning.",
            "∀x (Student(x) ∧ Studies(x) → Learns(x)) ::: All students are capable of learning if they study."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudyGroupMember(x) ::: x is a member of a study group",
            "Studies(x) ::: x studies",
            "Learns(x) ::: x learns"
        ]
    },
    {
        "premises-NL": [
            "All plants need water.",
            "Any plant that gets sunlight grows.",
            "Anything that grows provides oxygen.",
            "If something is a plant, it's green or eats insects.",
            "If something is green, it's not carnivorous.",
            "If something is a plant and needs water, it gets sunlight.",
            "Plants either get sunlight or don't grow.",
            "All carnivorous plants eat insects."
        ],
        "premises-FOL": [
            "∀x (Plant(x) → NeedsWater(x)) ::: All plants need water.",
            "∀x (Plant(x) ∧ GetsSunlight(x) → Grows(x)) ::: Any plant that gets sunlight grows.",
            "∀x (Grows(x) → ProvidesOxygen(x)) ::: Anything that grows provides oxygen.",
            "∀x (Plant(x) → (IsGreen(x) ∨ EatsInsects(x))) ::: If something is a plant, it's green or eats insects.",
            "∀x (IsGreen(x) → ¬IsCarnivorous(x)) ::: If something is green, it's not carnivorous.",
            "∀x (Plant(x) ∧ NeedsWater(x) → GetsSunlight(x)) ::: If something is a plant and needs water, it gets sunlight.",
            "∀x (Plant(x) → (GetsSunlight(x) ∨ ¬Grows(x))) ::: Plants either get sunlight or don't grow.",
            "∀x (IsCarnivorous(x) → EatsInsects(x)) ::: All carnivorous plants eat insects."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "GetsSunlight(x) ::: x gets sunlight",
            "Grows(x) ::: x grows",
            "NeedsWater(x) ::: x needs water",
            "ProvidesOxygen(x) ::: x provides oxygen",
            "IsGreen(x) ::: x is green",
            "EatsInsects(x) ::: x eats insects",
            "IsCarnivorous(x) ::: x is carnivorous"
        ]
    },
    {
        "premises-NL": [
            "All doctors specialize in medicine.",
            "Some researchers specialize in medicine.",
            "If someone specializes in medicine, then they are either a doctor or a researcher.",
            "John is a doctor.",
            "Mary is a researcher.",
            "John and Mary are both involved in medicine."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → SpecializesIn(x, Medicine)) ::: All doctors specialize in medicine.",
            "∃x (Researcher(x) ∧ SpecializesIn(x, Medicine)) ::: Some researchers specialize in medicine.",
            "∀x ∀y (SpecializesIn(x, y) → (Doctor(x) ∨ Researcher(x))) ::: If someone specializes in medicine, then they are either a doctor or a researcher.",
            "Doctor(John) ::: John is a doctor.",
            "Researcher(Mary) ::: Mary is a researcher.",
            "SpecializesIn(John, Medicine) ∧ SpecializesIn(Mary, Medicine) ::: John and Mary are both involved in medicine."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Researcher(x) ::: x is a researcher",
            "SpecializesIn(x, y) ::: x specializes in y",
            "Medicine(x) ::: x is in medicine"
        ]
    },
    {
        "premises-NL": [
            "Every software engineer knows programming.",
            "Anyone who knows programming works with code.",
            "Anyone who works with code is a problem solver.",
            "Alice is a software engineer.",
            "Bob knows programming.",
            "Charlie works with code.",
            "David is a software engineer.",
            "Alice works with code.",
            "Bob is a problem solver.",
            "Charlie is a problem solver."
        ],
        "premises-FOL": [
            "∀x (SoftwareEngineer(x) → KnowsProgramming(x)) ::: Every software engineer knows programming.",
            "∀x (KnowsProgramming(x) → WorksWithCode(x)) ::: Anyone who knows programming works with code.",
            "∀x (WorksWithCode(x) → ProblemSolver(x)) ::: Anyone who works with code is a problem solver.",
            "SoftwareEngineer(alice) ::: Alice is a software engineer.",
            "KnowsProgramming(bob) ::: Bob knows programming.",
            "WorksWithCode(charlie) ::: Charlie works with code.",
            "SoftwareEngineer(david) ::: David is a software engineer.",
            "WorksWithCode(alice) ::: Alice works with code.",
            "ProblemSolver(bob) ::: Bob is a problem solver.",
            "ProblemSolver(charlie) ::: Charlie is a problem solver."
        ],
        "predicates": [
            "SoftwareEngineer(x) ::: x is a software engineer",
            "KnowsProgramming(x) ::: x knows programming",
            "ProblemSolver(x) ::: x is a problem solver",
            "WorksWithCode(x) ::: x works with code"
        ]
    },
    {
        "premises-NL": [
            "All doctors study medicine.",
            "All researchers publish papers.",
            "Anyone who studies medicine is highly educated.",
            "Anyone who publishes papers is highly educated.",
            "Doctors teach.",
            "Researchers teach.",
            "Alice is a doctor.",
            "Bob is a researcher.",
            "Charlie is a doctor.",
            "Alice studies medicine.",
            "Bob publishes papers."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → StudiesMedicine(x)) ::: All doctors study medicine.",
            "∀x (Researcher(x) → PublishesPapers(x)) ::: All researchers publish papers.",
            "∀x (StudiesMedicine(x) → HighlyEducated(x)) ::: Anyone who studies medicine is highly educated.",
            "∀x (PublishesPapers(x) → HighlyEducated(x)) ::: Anyone who publishes papers is highly educated.",
            "∀x (Doctor(x) → Teaches(x)) ::: Doctors teach.",
            "∀x (Researcher(x) → Teaches(x)) ::: Researchers teach.",
            "Doctor(alice) ::: Alice is a doctor.",
            "Researcher(bob) ::: Bob is a researcher.",
            "Doctor(charlie) ::: Charlie is a doctor.",
            "StudiesMedicine(alice) ::: Alice studies medicine.",
            "PublishesPapers(bob) ::: Bob publishes papers."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Researcher(x) ::: x is a researcher",
            "HighlyEducated(x) ::: x is highly educated",
            "StudiesMedicine(x) ::: x studies medicine",
            "PublishesPapers(x) ::: x publishes papers",
            "Teaches(x) ::: x teaches"
        ]
    },
    {
        "premises-NL": [
            "All apples are fruit.",
            "All bananas are fruit.",
            "If someone eats a fruit, they like it.",
            "Alice is a human and eats apples.",
            "Bob is a human and eats bananas.",
            "Charlie is a human and eats apples and bananas.",
            "David is a human and eats apples.",
            "Apples are not yellow.",
            "Bananas are yellow.",
            "All humans are persons.",
            "If someone is a person and eats fruit, they like fruit.",
            "If someone likes apples, they eats apples",
            "If someone likes bananas, they eats bananas"
        ],
        "premises-FOL": [
            "∀x (Apple(x) → Fruit(x)) ::: All apples are fruit.",
            "∀x (Banana(x) → Fruit(x)) ::: All bananas are fruit.",
            "∀x ∀y (Eats(x, y) → Likes(x, y)) ::: If someone eats a fruit, they like it.",
            "Human(alice) ∧ Eats(alice, apples) ::: Alice is a human and eats apples.",
            "Human(bob) ∧ Eats(bob, bananas) ::: Bob is a human and eats bananas.",
            "Human(charlie) ∧ Eats(charlie, apples) ∧ Eats(charlie, bananas) ::: Charlie is a human and eats apples and bananas.",
            "Human(david) ∧ Eats(david, apples) ::: David is a human and eats apples.",
            "∀x (Apple(x) → ¬Yellow(x)) ::: Apples are not yellow.",
            "∀x (Banana(x) → Yellow(x)) ::: Bananas are yellow.",
            "∀x (Human(x) → Person(x)) ::: All humans are persons.",
            "∀x ∀y (Person(x) ∧ Eats(x, y) ∧ Fruit(y) → Likes(x, y)) ::: If someone is a person and eats fruit, they like fruit.",
            "∀x (LikesApples(x) → Eats(x, apples)) ::: If someone likes apples, they eats apples",
            "∀x (LikesBananas(x) → Eats(x, bananas)) ::: If someone likes bananas, they eats bananas"
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Eats(x, y) ::: x eats y",
            "Human(x) ::: x is a human",
            "Apple(x) ::: x is an apple",
            "Banana(x) ::: x is a banana",
            "Fruit(x) ::: x is a fruit",
            "Green(x) ::: x is green",
            "Yellow(x) ::: x is yellow",
            "Person(x) ::: x is a person",
            "EatsFruit(x) ::: x eats fruit",
            "LikesApples(x) ::: x likes apples",
            "LikesBananas(x) ::: x likes bananas"
        ]
    },
    {
        "premises-NL": [
            "All doctors have a medical license.",
            "Every doctor treats patients.",
            "If someone is a doctor, then they are educated.",
            "Patients have diseases.",
            "If someone is a doctor, then they work at a hospital.",
            "Anyone with a medical license can give prescriptions.",
            "If a doctor treats a patient, then the doctor prescribes medication.",
            "If someone prescribes medication, then they follow guidelines.",
            "If someone follows guidelines, then they are healthy.",
            "If someone is educated, then they have medical license.",
            "If someone is a patient, then they are not healthy."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HasMedicalLicense(x)) ::: All doctors have a medical license.",
            "∀x ∃y TreatsPatient(x, y) ::: Every doctor treats patients.",
            "∀x (Doctor(x) → IsEducated(x)) ::: If someone is a doctor, then they are educated.",
            "∀x ∃y (IsPatient(x) → HasDisease(x, y)) ::: Patients have diseases.",
            "∀x ∃y (Doctor(x) → WorksAtHospital(x, y)) ::: If someone is a doctor, then they work at a hospital.",
            "∀x (HasMedicalLicense(x) → CanGivePrescription(x)) ::: Anyone with a medical license can give prescriptions.",
            "∀x ∀y (TreatsPatient(x, y) → PrescribesMedication(x, y)) ::: If a doctor treats a patient, then the doctor prescribes medication.",
            "∀x (PrescribesMedication(x, y) → FollowsGuidelines(x)) ::: If someone prescribes medication, then they follow guidelines.",
            "∀x (FollowsGuidelines(x) → IsHealthy(x)) ::: If someone follows guidelines, then they are healthy.",
            "∀x (IsEducated(x) → HasMedicalLicense(x)) ::: If someone is educated, then they have medical license.",
            "∀x (IsPatient(x) → ¬IsHealthy(x)) ::: If someone is a patient, then they are not healthy."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "CanGivePrescription(x) ::: x can give prescriptions",
            "HasMedicalLicense(x) ::: x has a medical license",
            "TreatsPatient(x, y) ::: x treats patient y",
            "IsPatient(x) ::: x is a patient",
            "HasDisease(x, y) ::: x has disease y",
            "PrescribesMedication(x, y) ::: x prescribes medication y",
            "WorksAtHospital(x, y) ::: x works at hospital y",
            "IsEducated(x) ::: x is educated",
            "IsHealthy(x) ::: x is healthy",
            "FollowsGuidelines(x) ::: x follows guidelines"
        ]
    },
    {
        "premises-NL": [
            "All students either attend the lecture or study.",
            "Some students are smart.",
            "Everyone who studies passes the exam.",
            "No smart student studies.",
            "All professors teach.",
            "If someone studies, then they pass the exam.",
            "If someone is a student, they either attend the lecture or study.",
            "Some students do not study.",
            "No student attends the lecture and passes the exam.",
            "All students are smart or attend lecture.",
            "Some students do not pass the exam.",
            "Some students study and pass the exam.",
            "All students either pass the exam or do not attend lecture.",
            "No professor is a student.",
            "Some professors teach the lecture."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (AttendsLecture(x) ∨ Studies(x))) ::: All students either attend the lecture or study.",
            "∃x (Student(x) ∧ Smart(x)) ::: Some students are smart.",
            "∀x (Studies(x) → PassExam(x)) ::: Everyone who studies passes the exam.",
            "¬∃x (Smart(x) ∧ Studies(x)) ::: No smart student studies.",
            "∀x (Professor(x) → Teaches(x)) ::: All professors teach.",
            "∀x (Studies(x) → PassExam(x)) ::: If someone studies, then they pass the exam.",
            "∀x (Student(x) → (AttendsLecture(x) ∨ Studies(x))) ::: If someone is a student, they either attend the lecture or study.",
            "∃x (Student(x) ∧ ¬Studies(x)) ::: Some students do not study.",
            "¬∃x (Student(x) ∧ AttendsLecture(x) ∧ PassExam(x)) ::: No student attends the lecture and passes the exam.",
            "∀x (Student(x) → (Smart(x) ∨ AttendsLecture(x))) ::: All students are smart or attend lecture.",
            "∃x (Student(x) ∧ ¬PassExam(x)) ::: Some students do not pass the exam.",
            "∃x (Student(x) ∧ Studies(x) ∧ PassExam(x)) ::: Some students study and pass the exam.",
            "∀x (Student(x) → (PassExam(x) ∨ ¬AttendsLecture(x))) ::: All students either pass the exam or do not attend lecture.",
            "¬∃x (Professor(x) ∧ Student(x)) ::: No professor is a student.",
            "∃x (Professor(x) ∧ Teaches(x)) ::: Some professors teach the lecture."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsLecture(x) ::: x attends the lecture",
            "PassExam(x) ::: x passes the exam",
            "Studies(x, y) ::: x studies y",
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches y",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All students who are smart will pass the exam.",
            "John is a student.",
            "John is smart.",
            "If John studies, then John is smart.",
            "John studies.",
            "All smart people pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ Smart(x) → PassExam(x)) ::: All students who are smart will pass the exam.",
            "Student(john) ::: John is a student.",
            "Smart(john) ::: John is smart.",
            "Study(john) → Smart(john) ::: If John studies, then John is smart.",
            "Study(john) ::: John studies.",
            "∀x (Smart(x) → PassExam(x)) ::: All smart people pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Study(x) ::: x studies.",
            "PassExam(x) ::: x passes the exam.",
            "Smart(x) ::: x is smart."
        ]
    },
    {
        "premises-NL": [
            "If Alice is a doctor, then Alice works at a hospital.",
            "If Alice works at a hospital, then Alice has a high salary.",
            "If Alice is a researcher, then Alice has a good project.",
            "Alice is either a doctor or a researcher.",
            "Alice is not a doctor.",
            "If Alice is a researcher, then Alice has funding.",
            "If Alice has funding, then Alice has a good project."
        ],
        "premises-FOL": [
            "Doctor(alice) → WorksAtHospital(alice) ::: If Alice is a doctor, then Alice works at a hospital.",
            "WorksAtHospital(alice) → HighSalary(alice) ::: If Alice works at a hospital, then Alice has a high salary.",
            "Researcher(alice) → GoodProject(alice) ::: If Alice is a researcher, then Alice has a good project.",
            "Doctor(alice) ∨ Researcher(alice) ::: Alice is either a doctor or a researcher.",
            "¬Doctor(alice) ::: Alice is not a doctor.",
            "Researcher(alice) → HasFunding(alice) ::: If Alice is a researcher, then Alice has funding.",
            "HasFunding(alice) → GoodProject(alice) ::: If Alice has funding, then Alice has a good project."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "HighSalary(x) ::: x has a high salary.",
            "Researcher(x) ::: x is a researcher.",
            "GoodProject(x) ::: x has a good project.",
            "WorksAtHospital(x) ::: x works at a hospital.",
            "HasFunding(x) ::: x has funding."
        ]
    },
    {
        "premises-NL": [
            "All roses are flowers.",
            "All roses have thorns.",
            "Some flowers are red.",
            "All red flowers are beautiful.",
            "Some roses are in the garden.",
            "Anything that is a rose is a flower.",
            "Roses are a type of flower.",
            "If something is a flower, then it is in the garden."
        ],
        "premises-FOL": [
            "∀x (Rose(x) → Flower(x)) ::: All roses are flowers.",
            "∀x (Rose(x) → HasThorns(x)) ::: All roses have thorns.",
            "∃x (Flower(x) ∧ Red(x)) ::: Some flowers are red.",
            "∀x (Red(x) ∧ Flower(x) → IsBeautiful(x)) ::: All red flowers are beautiful.",
            "∃x (Rose(x) ∧ GrowsInGarden(x)) ::: Some roses are in the garden.",
            "∀x (Rose(x) → IsAFlower(x)) ::: Anything that is a rose is a flower.",
            "∀x (Rose(x) → Flower(x)) ::: Roses are a type of flower.",
            "∀x (Flower(x) → GrowsInGarden(x)) ::: If something is a flower, then it is in the garden."
        ],
        "predicates": [
            "Flower(x) ::: x is a flower.",
            "Red(x) ::: x is red.",
            "Rose(x) ::: x is a rose.",
            "GrowsInGarden(x) ::: x grows in a garden.",
            "IsBeautiful(x) ::: x is beautiful.",
            "Yellow(x) ::: x is yellow.",
            "HasThorns(x) ::: x has thorns.",
            "IsAFlower(x) ::: x is a flower."
        ]
    },
    {
        "premises-NL": [
            "All students who love programming study computer science.",
            "All computer science students attend university.",
            "John is a student.",
            "John loves programming.",
            "Anyone who studies computer science likes math or hates calculus.",
            "John doesn't hate calculus.",
            "All students who love programming enjoy coding.",
            "If someone enjoys coding, then they do not like math.",
            "All computer science students are smart."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ LovesProgramming(x) → StudiesComputerScience(x)) ::: All students who love programming study computer science.",
            "∀x (StudiesComputerScience(x) → AttendsUniversity(x)) ::: All computer science students attend university.",
            "Student(john) ::: John is a student.",
            "LovesProgramming(john) ::: John loves programming.",
            "∀x (StudiesComputerScience(x) → LikesMath(x) ∨ HatesCalculus(x)) ::: Anyone who studies computer science likes math or hates calculus.",
            "¬HatesCalculus(john) ::: John doesn't hate calculus.",
            "∀x (Student(x) ∧ LovesProgramming(x) → EnjoysCoding(x)) ::: All students who love programming enjoy coding.",
            "∀x (EnjoysCoding(x) → ¬LikesMath(x)) ::: If someone enjoys coding, then they do not like math.",
            "∀x (StudiesComputerScience(x) → IsSmart(x)) ::: All computer science students are smart."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "LikesMath(x) ::: x likes math.",
            "LovesProgramming(x) ::: x loves programming.",
            "StudiesComputerScience(x) ::: x studies computer science.",
            "AttendsUniversity(x) ::: x attends university.",
            "IsSmart(x) ::: x is smart.",
            "PassesExam(x) ::: x passes the exam.",
            "HatesCalculus(x) ::: x hates calculus.",
            "EnjoysCoding(x) ::: x enjoys coding."
        ]
    },
    {
        "premises-NL": [
            "All biologists work at hospitals.",
            "Anyone who works at a hospital is a researcher.",
            "All researchers publish papers.",
            "Anyone who studies genetics uses a microscope.",
            "All researchers analyze data.",
            "If someone analyzes data and publishes a paper, then they contribute to the understanding of diseases.",
            "All biologists have a lab.",
            "If someone has a lab and uses a microscope, they study genetics.",
            "Biologists are good at experiments.",
            "Anyone who is good at experiments is a biologist."
        ],
        "premises-FOL": [
            "∀x (Biologist(x) → WorksAtHospital(x)) ::: All biologists work at hospitals.",
            "∀x (WorksAtHospital(x) → IsResearcher(x)) ::: Anyone who works at a hospital is a researcher.",
            "∀x (IsResearcher(x) → PublishesPaper(x)) ::: All researchers publish papers.",
            "∀x (StudiesGenetics(x) → UsesMicroscope(x)) ::: Anyone who studies genetics uses a microscope.",
            "∀x (IsResearcher(x) → AnalyzesData(x)) ::: All researchers analyze data.",
            "∀x (AnalyzesData(x) ∧ PublishesPaper(x) → ContributesToUnderstandingOfDiseases(x)) ::: If someone analyzes data and publishes a paper, then they contribute to the understanding of diseases.",
            "∀x (Biologist(x) → HasLab(x)) ::: All biologists have a lab.",
            "∀x (HasLab(x) ∧ UsesMicroscope(x) → StudiesGenetics(x)) ::: If someone has a lab and uses a microscope, they study genetics.",
            "∀x (Biologist(x) → GoodAtExperiments(x)) ::: Biologists are good at experiments.",
            "∀x (GoodAtExperiments(x) → Biologist(x)) ::: Anyone who is good at experiments is a biologist."
        ],
        "predicates": [
            "Biologist(x) ::: x is a biologist.",
            "StudiesGenetics(x) ::: x studies genetics.",
            "ContributesToUnderstandingOfDiseases(x) ::: x contributes to the understanding of diseases.",
            "WorksAtHospital(x) ::: x works at a hospital.",
            "PublishesPaper(x) ::: x publishes a paper.",
            "IsResearcher(x) ::: x is a researcher.",
            "UsesMicroscope(x) ::: x uses a microscope.",
            "AnalyzesData(x) ::: x analyzes data.",
            "HasLab(x) ::: x has a lab.",
            "GoodAtExperiments(x) ::: x is good at experiments."
        ]
    },
    {
        "premises-NL": [
            "Alice is a student.",
            "Alice takes a programming course.",
            "All programming courses have assignments.",
            "Alice solves all assignments.",
            "If a student solves all assignments and enjoys the challenge, then they are proficient in programming.",
            "Alice enjoys the challenge of programming.",
            "If a student likes programming and is proficient in programming, then they are a good programmer.",
            "Alice likes programming.",
            "If someone is a student and takes a programming course, they enjoy the challenge of programming."
        ],
        "premises-FOL": [
            "Student(alice) ::: Alice is a student.",
            "TakesCourse(alice, programming101) ::: Alice takes a programming course.",
            "∀x (ProgrammingCourse(x) → CourseHasAssignment(x)) ::: All programming courses have assignments.",
            "∀x (CourseHasAssignment(x) ∧ TakesCourse(alice, x) → SolvesAssignments(alice)) ::: Alice solves all assignments.",
            "∀x (SolvesAssignments(x) ∧ EnjoysChallenge(x) → ProficientIn(x, programming)) ::: If a student solves all assignments and enjoys the challenge, then they are proficient in programming.",
            "EnjoysChallenge(alice) ::: Alice enjoys the challenge of programming.",
            "∀x (LikesProgramming(x) ∧ ProficientIn(x, programming) → GoodProgrammer(x)) ::: If a student likes programming and is proficient in programming, then they are a good programmer.",
            "LikesProgramming(alice) ::: Alice likes programming.",
            "∀x (Student(x) ∧ TakesCourse(x,y) ∧ ProgrammingCourse(y) → EnjoysChallenge(x)) ::: If someone is a student and takes a programming course, they enjoy the challenge of programming."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "TakesCourse(x, y) ::: x takes course y",
            "LikesProgramming(x) ::: x likes programming",
            "ProgrammingCourse(x) ::: x is a programming course",
            "GoodProgrammer(x) ::: x is a good programmer",
            "ProficientIn(x, y) ::: x is proficient in y",
            "CourseHasAssignment(x) ::: x is a course with assignments",
            "SolvesAssignments(x) ::: x solves assignments",
            "EnjoysChallenge(x) ::: x enjoys a challenge"
        ]
    },
    {
        "premises-NL": [
            "Mary studies hard.",
            "If someone studies hard, they pass the exam.",
            "If someone passes the exam, they get a good grade.",
            "If someone gets a good grade, they will get a scholarship.",
            "If someone gets a scholarship, they can pursue a degree.",
            "Mary gets a good grade.",
            "Mary has a degree.",
            "If Mary has a degree, she will get a job offer.",
            "If Mary has a job offer and likes the job, she is happy.",
            "Mary gets a promotion"
        ],
        "premises-FOL": [
            "StudiesHard(mary) ::: Mary studies hard.",
            "∀x (StudiesHard(x) → PassExam(x)) ::: If someone studies hard, they pass the exam.",
            "∀x (PassExam(x) → GetsGoodGrade(x)) ::: If someone passes the exam, they get a good grade.",
            "∀x (GetsGoodGrade(x) → GetsScholarship(x)) ::: If someone gets a good grade, they will get a scholarship.",
            "∀x (GetsScholarship(x) → HasDegree(x)) ::: If someone gets a scholarship, they can pursue a degree.",
            "GetsGoodGrade(mary) ::: Mary gets a good grade.",
            "HasDegree(mary) ::: Mary has a degree.",
            "∀x (HasDegree(x) → HasJobOffer(x)) ::: If Mary has a degree, she will get a job offer.",
            "∀x (HasJobOffer(x) ∧ LikesJob(x) → Happy(x)) ::: If Mary has a job offer and likes the job, she is happy.",
            "GetsPromotion(mary) ::: Mary gets a promotion."
        ],
        "predicates": [
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "Happy(x) ::: x will be happy",
            "HasJobOffer(x) ::: x has a job offer",
            "GetsGoodGrade(x) ::: x gets a good grade",
            "IsSmart(x) ::: x is smart",
            "GetsScholarship(x) ::: x gets a scholarship",
            "HasDegree(x) ::: x has a degree",
            "LikesJob(x) ::: x likes job",
            "GetsPromotion(x) ::: x gets promotion"
        ]
    },
    {
        "premises-NL": [
            "The event is well-organized.",
            "If an event is well-organized, it has sufficient resources.",
            "If an event has sufficient resources and great speakers, it attracts an audience.",
            "If an event attracts an audience and has good promotion, it has support.",
            "The event has good promotion.",
            "If an event has support and good weather, it is successful.",
            "The event has great speakers.",
            "If the event is successful and fun and has food, then it is a success.",
            "The event is fun.",
            "The event has food",
            "The organizers of the event are experienced."
        ],
        "premises-FOL": [
            "OrganizedEvent(event1) ::: The event is well-organized.",
            "∀x (OrganizedEvent(x) → HasSufficientResources(x)) ::: If an event is well-organized, it has sufficient resources.",
            "∀x (HasSufficientResources(x) ∧ HasGreatSpeakers(x) → AttractsAudience(x)) ::: If an event has sufficient resources and great speakers, it attracts an audience.",
            "∀x (AttractsAudience(x) ∧ GoodPromotion(x) → EventHasSupport(x)) ::: If an event attracts an audience and has good promotion, it has support.",
            "GoodPromotion(event1) ::: The event has good promotion.",
            "∀x (EventHasSupport(x) ∧ HasGoodWeather(x) → SuccessfulEvent(x)) ::: If an event has support and good weather, it is successful.",
            "HasGreatSpeakers(event1) ::: The event has great speakers.",
            "∀x (SuccessfulEvent(x) ∧ EventIsFun(x) ∧ EventHasFood(x) → SuccessfulEvent(x)) ::: If the event is successful and fun and has food, then it is a success.",
            "EventIsFun(event1) ::: The event is fun.",
            "EventHasFood(event1) ::: The event has food.",
            "OrganizersAreExperienced(event1) ::: The organizers of the event are experienced."
        ],
        "predicates": [
            "OrganizedEvent(x) ::: x is an organized event",
            "HasSufficientResources(x) ::: x has sufficient resources",
            "HasGreatSpeakers(x) ::: x has great speakers",
            "AttractsAudience(x) ::: x attracts an audience",
            "GoodPromotion(x) ::: x has good promotion",
            "EventHasSupport(x) ::: x event has support",
            "SuccessfulEvent(x) ::: x is a successful event",
            "HasGoodWeather(x) ::: x has good weather",
            "EventIsFun(x) ::: x event is fun",
            "EventHasFood(x) ::: x event has food",
            "OrganizersAreExperienced(x) ::: Organizers are experienced"
        ]
    },
    {
        "premises-NL": [
            "All plants are organisms.",
            "All animals are organisms.",
            "Some plants perform photosynthesis.",
            "All plants produce oxygen.",
            "Organisms that produce oxygen are aquatic.",
            "All aquatic organisms need to have photosynthesis.",
            "If an organism lives in an aquatic environment, then it's aquatic.",
            "There exists an organism that is a herbivore.",
            "All animals are carnivores or herbivores.",
            "Animals do not perform photosynthesis.",
            "If a herbivore lives in an aquatic environment, they must produce oxygen."
        ],
        "premises-FOL": [
            "∀x (Plant(x) → Organism(x)) ::: For all x, if x is a plant, then x is an organism.",
            "∀x (Animal(x) → Organism(x)) ::: For all x, if x is an animal, then x is an organism.",
            "∃x (Plant(x) ∧ Photosynthesis(x)) ::: There exists a plant that performs photosynthesis.",
            "∀x (Plant(x) → ProducesOxygen(x)) ::: For all x, if x is a plant, then x produces oxygen.",
            "∀x (ProducesOxygen(x) → Aquatic(x)) ::: For all x, if x produces oxygen, then x is aquatic.",
            "∀x (Aquatic(x) → PhotosynthesisNeeded(x)) ::: For all x, if x is aquatic, then x needs photosynthesis.",
            "∀x ∀y (LivesIn(x, y) ∧ AquaticEnvironment(y) → Aquatic(x)) ::: For all x and y, if x lives in y and y is an aquatic environment, then x is aquatic.",
            "∃x (Herbivore(x)) ::: There exists a herbivore.",
            "∀x (Animal(x) → (Carnivore(x) ∨ Herbivore(x))) ::: For all x, if x is an animal, then x is a carnivore or a herbivore.",
            "∀x (Animal(x) → ¬Photosynthesis(x)) ::: For all x, if x is an animal, then x does not perform photosynthesis.",
            "∀x (Herbivore(x) ∧ LivesIn(x, aquaticEnvironment) → ProducesOxygen(x)) ::: For all x, if x is a herbivore and x lives in an aquatic environment, then x produces oxygen."
        ],
        "predicates": [
            "Organism(x) ::: x is an organism",
            "Plant(x) ::: x is a plant",
            "Animal(x) ::: x is an animal",
            "Photosynthesis(x) ::: x performs photosynthesis",
            "ProducesOxygen(x) ::: x produces oxygen",
            "Eats(x, y) ::: x eats y",
            "Herbivore(x) ::: x is a herbivore",
            "Carnivore(x) ::: x is a carnivore",
            "LivesIn(x, y) ::: x lives in y",
            "Aquatic(x) ::: x is aquatic",
            "PhotosynthesisNeeded(x) ::: x needs photosynthesis"
        ]
    },
    {
        "premises-NL": [
            "Everyone either likes cats or likes dogs, but not both.",
            "If someone likes cats, they like animals.",
            "If someone likes dogs, they like animals.",
            "Some people like cats.",
            "Some people do not like animals.",
            "Everyone likes either cats or dogs."
        ],
        "premises-FOL": [
            "∀x ((LikesCats(x) ∨ LikesDogs(x)) ∧ ¬(LikesCats(x) ∧ LikesDogs(x))) ::: Everyone either likes cats or likes dogs, but not both.",
            "∀x (LikesCats(x) → LikesAnimals(x)) ::: If someone likes cats, they like animals.",
            "∀x (LikesDogs(x) → LikesAnimals(x)) ::: If someone likes dogs, they like animals.",
            "∃x LikesCats(x) ::: Some people like cats.",
            "∃x ¬LikesAnimals(x) ::: Some people do not like animals.",
            "∀x (LikesCats(x) ∨ LikesDogs(x)) ::: Everyone likes either cats or dogs."
        ],
        "predicates": [
            "LikesCats(x) ::: x likes cats",
            "LikesDogs(x) ::: x likes dogs",
            "LikesAnimals(x) ::: x likes animals",
            "HatesAnimals(x) ::: x hates animals",
            "LikesCatsDogs(x) ::: x likes cats and dogs",
            "AllLikesCatsLikeAnimals(x) ::: All people who like cats, like animals",
            "AllLikesDogsLikeAnimals(x) ::: All people who like dogs, like animals"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard attempt the exam.",
            "Some students study hard and fail the exam.",
            "All students who fail the exam did not get a good grade.",
            "Some students are tutored.",
            "No students are both smart and study hard.",
            "Any students who receive aid, also get a poor grade.",
            "All those who get a good grade will pass the exam."
        ],
        "premises-FOL": [
            "∀x (StudyHard(x) → PassExam(x) ∨ FailsExam(x)) ::: All students who study hard attempt the exam.",
            "∃x (StudyHard(x) ∧ FailsExam(x)) ::: Some students study hard and fail the exam.",
            "∀x (FailsExam(x) → ¬GoodGrade(x)) ::: All students who fail the exam did not get a good grade.",
            "∃x IsTutored(x) ::: Some students are tutored.",
            "¬∃x (SmartStudent(x) ∧ StudyHard(x)) ::: No students are both smart and study hard.",
            "∀x (ReceivesAid(x) → PoorGrade(x)) ::: Any students who receive aid, also get a poor grade.",
            "∀x (GoodGrade(x) → PassExam(x)) ::: All those who get a good grade will pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudyHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "FailsExam(x) ::: x fails the exam",
            "ReceivesAid(x) ::: x receives aid",
            "SmartStudent(x) ::: x is a smart student",
            "IsTutored(x) ::: x is tutored",
            "GoodGrade(x) ::: x gets a good grade",
            "PoorGrade(x) ::: x gets a poor grade"
        ]
    },
    {
        "premises-NL": [
            "All whales are mammals.",
            "All mammals need air.",
            "Some whales live in the ocean.",
            "All things that need air are not aquatic.",
            "All aquatic creatures live in the ocean.",
            "Some mammals have fur.",
            "All creatures that live in the ocean can swim.",
            "Some things that eat fish are aquatic."
        ],
        "premises-FOL": [
            "∀x (IsWhale(x) → Mammal(x)) ::: All whales are mammals.",
            "∀x (Mammal(x) → NeedsAir(x)) ::: All mammals need air.",
            "∃x (IsWhale(x) ∧ LivesInOcean(x)) ::: Some whales live in the ocean.",
            "∀x (NeedsAir(x) → ¬Aquatic(x)) ::: All things that need air are not aquatic.",
            "∀x (Aquatic(x) → LivesInOcean(x)) ::: All aquatic creatures live in the ocean.",
            "∃x (Mammal(x) ∧ HasFur(x)) ::: Some mammals have fur.",
            "∀x (LivesInOcean(x) → CanSwim(x)) ::: All creatures that live in the ocean can swim.",
            "∃x (EatsFish(x) ∧ Aquatic(x)) ::: Some things that eat fish are aquatic."
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal",
            "LivesInOcean(x) ::: x lives in the ocean",
            "Aquatic(x) ::: x is aquatic",
            "EatsFish(x) ::: x eats fish",
            "IsWhale(x) ::: x is a whale",
            "NeedsAir(x) ::: x needs air",
            "CanSwim(x) ::: x can swim",
            "IsWarmBlooded(x) ::: x is warm-blooded",
            "HasFur(x) ::: x has fur",
            "AllWhalesAreMammals(x) ::: All whales are mammals",
            "AllMammalsNeedAir(x) ::: All mammals need air"
        ]
    },
    {
        "premises-NL": [
            "All students study hard or they like pizza.",
            "Alex is a student.",
            "If Alex likes pizza, then Alex won't pass the exam.",
            "If someone studies hard and has a friend, they will pass the exam.",
            "Alex has a friend.",
            "No student passes the exam if they like pizza.",
            "John likes pizza.",
            "John has a friend.",
            "Alex studies hard or John likes pizza.",
            "If Alex studies hard, then Alex will study hard or John likes pizza."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (StudyHard(x) ∨ LikePizza(x))) ::: All students study hard or they like pizza",
            "Student(alex) ::: Alex is a student",
            "LikePizza(alex) → ¬PassExam(alex) ::: If Alex likes pizza, then Alex won't pass the exam",
            "∀x ∀y ((StudyHard(x) ∧ HasFriend(x, y)) → PassExam(x)) ::: If someone studies hard and has a friend, they will pass the exam",
            "∃y HasFriend(alex, y) ::: Alex has a friend",
            "∀x (Student(x) ∧ LikePizza(x) → ¬PassExam(x)) ::: No student passes the exam if they like pizza",
            "LikePizza(john) ::: John likes pizza",
            "∃y HasFriend(john, y) ::: John has a friend",
            "StudyHard(alex) ∨ LikePizza(john) ::: Alex studies hard or John likes pizza",
            "StudyHard(alex) → (StudyHard(alex) ∨ LikePizza(john)) ::: If Alex studies hard, then Alex will study hard or John likes pizza"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudyHard(x) ::: x studies hard",
            "PassExam(x) ::: x will pass the exam",
            "LikePizza(x) ::: x likes pizza",
            "HasFriend(x,y) ::: x has a friend y"
        ]
    },
    {
        "premises-NL": [
            "All reptiles are cold-blooded.",
            "All mammals are warm-blooded.",
            "All fish are aquatic.",
            "No mammal is aquatic.",
            "All reptiles are land-dwelling or aquatic.",
            "Some reptiles have scales.",
            "All mammals have fur.",
            "No fish has fur.",
            "All amphibians are cold blooded and can live in water.",
            "All reptiles either eat meat or are a herbivore.",
            "All reptiles don't have feather and cannot fly.",
            "All reptiles can not be a fish",
            "Mammals are not amphibians.",
            "All animals are aquatic, land-dwelling, or can fly.",
            "No mammals are fish."
        ],
        "premises-FOL": [
            "∀x (Reptile(x) → ColdBlooded(x)) ::: All reptiles are cold-blooded.",
            "∀x (Mammal(x) → WarmBlooded(x)) ::: All mammals are warm-blooded.",
            "∀x (Fish(x) → Aquatic(x)) ::: All fish are aquatic.",
            "∀x (Mammal(x) → ¬Aquatic(x)) ::: No mammal is aquatic.",
            "∀x (Reptile(x) → (LandDwelling(x) ∨ Aquatic(x))) ::: All reptiles are land-dwelling or aquatic.",
            "∃x (Reptile(x) ∧ HasScales(x)) ::: Some reptiles have scales.",
            "∀x (Mammal(x) → HasFur(x)) ::: All mammals have fur.",
            "∀x (Fish(x) → ¬HasFur(x)) ::: No fish has fur.",
            "∀x (Amphibian(x) → (ColdBlooded(x) ∧ LivesInWater(x))) ::: All amphibians are cold blooded and can live in water.",
            "∀x (Reptile(x) → (EatsMeat(x) ∨ Herbivore(x))) ::: All reptiles either eat meat or are a herbivore.",
            "∀x (Reptile(x) → (¬HasFeathers(x) ∧ ¬CanFly(x))) ::: All reptiles don't have feather and cannot fly.",
            "∀x (Reptile(x) → ¬Fish(x)) ::: All reptiles can not be a fish",
            "∀x (Mammal(x) → ¬Amphibian(x)) ::: Mammals are not amphibians.",
            "∀x (Aquatic(x) ∨ LandDwelling(x) ∨ CanFly(x)) ::: All animals are aquatic, land-dwelling, or can fly.",
            "∀x (Mammal(x) → ¬Fish(x)) ::: No mammals are fish."
        ],
        "predicates": [
            "Reptile(x) ::: x is a reptile.",
            "Mammal(x) ::: x is a mammal.",
            "Fish(x) ::: x is a fish.",
            "WarmBlooded(x) ::: x is warm-blooded.",
            "ColdBlooded(x) ::: x is cold-blooded.",
            "Aquatic(x) ::: x is aquatic.",
            "LandDwelling(x) ::: x is land-dwelling.",
            "HasScales(x) ::: x has scales.",
            "HasFur(x) ::: x has fur.",
            "Amphibian(x) ::: x is an amphibian.",
            "EatsMeat(x) ::: x eats meat.",
            "Herbivore(x) ::: x is a herbivore.",
            "LivesInWater(x) ::: x lives in water.",
            "CanFly(x) ::: x can fly.",
            "HasFeathers(x) ::: x has feathers."
        ]
    },
    {
        "premises-NL": [
            "Every athlete trains hard.",
            "David is an athlete.",
            "Eve is an athlete.",
            "If someone is an athlete and a friend, then both people train hard.",
            "David and Eve are friends.",
            "All members of a sports team are athletes.",
            "David plays for the 'Eagles' team.",
            "The 'Eagles' team is a sports team."
        ],
        "premises-FOL": [
            "∀x (Athlete(x) → TrainHard(x)) ::: Every athlete trains hard.",
            "Athlete(david) ::: David is an athlete.",
            "Athlete(eve) ::: Eve is an athlete.",
            "∀x ∀y (Athlete(x) ∧ Friends(x, y) → TrainHard(x) ∧ TrainHard(y)) ::: If someone is an athlete and a friend, then both people train hard.",
            "Friends(david, eve) ::: David and Eve are friends.",
            "∀x ∀y (MemberOf(x, y) ∧ SportsTeam(y) → Athlete(x)) ::: All members of a sports team are athletes.",
            "PlaysFor(david, eagles) ::: David plays for the 'Eagles' team.",
            "SportsTeam(eagles) ::: The 'Eagles' team is a sports team."
        ],
        "predicates": [
            "Friends(x, y) ::: x and y are friends.",
            "Athlete(x) ::: x is an athlete.",
            "TrainHard(x) ::: x trains hard.",
            "Likes(x, y) ::: x likes y.",
            "SportsTeam(x) ::: x is a sports team.",
            "MemberOf(x, y) ::: x is a member of y.",
            "PlaysFor(x, y) ::: x plays for y."
        ]
    },
    {
        "premises-NL": [
            "All students study.",
            "Every student has exams to pass.",
            "Every student gets high grades in any exam they pass.",
            "Some students are diligent.",
            "Some students pass exams.",
            "If a student is diligent and passes an exam, they are successful.",
            "If a student gets high grades on exams, they pass the exams.",
            "Any student who studies and passes an exam is diligent.",
            "If a student is diligent and passes an exam, then they get high grades.",
            "If a student does not study, they are not diligent.",
            "If a student does not study they do not pass exams.",
            "If a student does not get high grades they do not pass the exam.",
            "Students are either diligent or they are not diligent.",
            "Students are either successful or not successful."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Study(x)) ::: All students study.",
            "∀x ∃y (Student(x) → PassExam(x, y)) ::: Every student has exams to pass.",
            "∀x ∀y ((Student(x) ∧ PassExam(x, y)) → HighGrade(x, y)) ::: Every student gets high grades in any exam they pass.",
            "∃x (Student(x) ∧ DiligantStudent(x)) ::: Some students are diligent.",
            "∃x ∃y (Student(x) ∧ PassExam(x, y)) ::: Some students pass exams.",
            "∀x ((DiligantStudent(x) ∧ PassExam(x, y)) → SuccessfulStudent(x)) ::: If a student is diligent and passes an exam, they are successful.",
            "∀x ∀y (HighGrade(x, y) → PassExam(x, y)) ::: If a student gets high grades on exams, they pass the exams.",
            "∀x ∀y ((Study(x) ∧ PassExam(x,y)) → DiligantStudent(x)) ::: Any student who studies and passes an exam is diligent.",
            "∀x ∀y ((DiligantStudent(x) ∧ PassExam(x, y)) → HighGrade(x, y)) ::: If a student is diligent and passes an exam, then they get high grades.",
            "∀x (¬Study(x) → ¬DiligantStudent(x)) ::: If a student does not study, they are not diligent.",
            "∀x (¬Study(x) → ¬PassExam(x, y)) ::: If a student does not study they do not pass exams.",
            "∀x (¬HighGrade(x, y) → ¬PassExam(x, y)) ::: If a student does not get high grades they do not pass the exam.",
            "∀x (Student(x) → (DiligantStudent(x) ∨ ¬DiligantStudent(x))) ::: Students are either diligent or they are not diligent.",
            "∀x (Student(x) → (SuccessfulStudent(x) ∨ ¬SuccessfulStudent(x))) ::: Students are either successful or not successful."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "DiligantStudent(x) ::: x is a diligent student",
            "SuccessfulStudent(x) ::: x is a successful student",
            "Study(x, y) ::: x studies y",
            "PassExam(x, y) ::: x passes exam y",
            "HighGrade(x, y) ::: x gets high grade in y"
        ]
    },
    {
        "premises-NL": [
            "All fruits are edible.",
            "All fruits are sweet.",
            "Some fruits are red.",
            "All fruits grow on trees.",
            "If something is a fruit, it contains vitamin C.",
            "If something contains vitamin C, it is good for health.",
            "If something is good for health, it is sweet.",
            "If something is not edible, it is not a fruit.",
            "If something is not sweet, it is not good for health.",
            "If something does not contain vitamin C, it is not a fruit.",
            "If something is not red, it is not a fruit.",
            "If something does not grow on a tree, it is not edible.",
            "If something is a fruit, it is either red or not red.",
            "If something is red and sweet then it is a fruit.",
            "If something is sweet, then it is a fruit."
        ],
        "premises-FOL": [
            "∀x (Fruit(x) → Edible(x)) ::: All fruits are edible.",
            "∀x (Fruit(x) → Sweet(x)) ::: All fruits are sweet.",
            "∃x (Fruit(x) ∧ Red(x)) ::: Some fruits are red.",
            "∀x (Fruit(x) → GrowsOnTree(x)) ::: All fruits grow on trees.",
            "∀x (Fruit(x) → ContainsVitaminC(x)) ::: If something is a fruit, it contains vitamin C.",
            "∀x (ContainsVitaminC(x) → GoodForHealth(x)) ::: If something contains vitamin C, it is good for health.",
            "∀x (GoodForHealth(x) → Sweet(x)) ::: If something is good for health, it is sweet.",
            "∀x (¬Edible(x) → ¬Fruit(x)) ::: If something is not edible, it is not a fruit.",
            "∀x (¬Sweet(x) → ¬GoodForHealth(x)) ::: If something is not sweet, it is not good for health.",
            "∀x (¬ContainsVitaminC(x) → ¬Fruit(x)) ::: If something does not contain vitamin C, it is not a fruit.",
            "∀x (¬Red(x) → ¬Fruit(x)) ::: If something is not red, it is not a fruit.",
            "∀x (¬GrowsOnTree(x) → ¬Edible(x)) ::: If something does not grow on a tree, it is not edible.",
            "∀x (Fruit(x) → (Red(x) ∨ ¬Red(x))) ::: If something is a fruit, it is either red or not red.",
            "∀x ((Red(x) ∧ Sweet(x)) → Fruit(x)) ::: If something is red and sweet then it is a fruit.",
            "∀x (Sweet(x) → Fruit(x)) ::: If something is sweet, then it is a fruit."
        ],
        "predicates": [
            "Fruit(x) ::: x is a fruit",
            "Sweet(x) ::: x is sweet",
            "Red(x) ::: x is red",
            "Edible(x) ::: x is edible",
            "GrowsOnTree(x) ::: x grows on a tree",
            "ContainsVitaminC(x) ::: x contains vitamin C",
            "GoodForHealth(x) ::: x is good for health"
        ]
    },
    {
        "premises-NL": [
            "All students attend class.",
            "John is a student.",
            "If John attends class and studies hard, he will get a good grade.",
            "If John studies hard, then John attends class.",
            "John studies hard.",
            "John attends class."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClass(x)) ::: All students attend class.",
            "Student(john) ::: John is a student.",
            "∀x ((AttendsClass(x) ∧ StudiesHard(x)) → GoodGrade(x)) ::: If anyone attends class and studies hard, they will get a good grade.",
            "StudiesHard(john) → AttendsClass(john) ::: If John studies hard, then John attends class.",
            "StudiesHard(john) ::: John studies hard.",
            "AttendsClass(john) ::: John attends class."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "AttendsClass(x) ::: x attends class",
            "GoodGrade(x) ::: x gets a good grade"
        ]
    },
    {
        "premises-NL": [
            "All cats chase mice.",
            "Anyone who likes cream is friendly.",
            "Every cat eats cream or chases mice.",
            "If something eats cream, then it likes cream.",
            "No cat plays with a mouse.",
            "If something does not chase a mouse, it is friendly.",
            "Some cat scratches something.",
            "Some cats eat cream.",
            "If something scratches something, then it is a cat."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → ChasesMouse(x)) ::: All cats chase mice.",
            "∀x (LikesCream(x) → Friendly(x)) ::: Anyone who likes cream is friendly.",
            "∀x (Cat(x) → (Eats(x, cream) ∨ ChasesMouse(x))) ::: Every cat eats cream or chases mice.",
            "∀x (Eats(x, cream) → LikesCream(x)) ::: If something eats cream, then it likes cream.",
            "∀x ¬PlaysWith(x, mouse) ::: No cat plays with a mouse.",
            "∀x (¬ChasesMouse(x) → Friendly(x)) ::: If something does not chase a mouse, it is friendly.",
            "∃x ∃y Scratches(x, y) ::: Some cat scratches something.",
            "∃x Eats(x, cream) ::: Some cats eat cream.",
            "∀x ∀y (Scratches(x, y) → Cat(x)) ::: If something scratches something, then it is a cat."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Friendly(x) ::: x is friendly",
            "ChasesMouse(x) ::: x chases a mouse",
            "LikesCream(x) ::: x likes cream",
            "Eats(x, y) ::: x eats y",
            "Mouse(y) ::: y is a mouse",
            "Cream(y) ::: y is cream",
            "PlaysWith(x, y) ::: x plays with y",
            "Scratches(x, y) ::: x scratches y"
        ]
    },
    {
        "premises-NL": [
            "All doctors are kind.",
            "Sarah is a doctor.",
            "If someone has a license and works at the hospital, then they are kind.",
            "Sarah has a license.",
            "Sarah works at the hospital.",
            "If a doctor is kind, they will help the patient.",
            "Sarah is a patient.",
            "All patients need help.",
            "Doctors treat patients."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Kind(x)) ::: All doctors are kind.",
            "Doctor(sarah) ::: Sarah is a doctor.",
            "∀x (HasLicense(x) ∧ WorksAtHospital(x) → Kind(x)) ::: If someone has a license and works at the hospital, then they are kind.",
            "HasLicense(sarah) ::: Sarah has a license.",
            "WorksAtHospital(sarah) ::: Sarah works at the hospital.",
            "∀x (Doctor(x) ∧ Kind(x) → HelpPatient(x)) ::: If a doctor is kind, they will help the patient.",
            "Patient(sarah) ::: Sarah is a patient.",
            "∀x (Patient(x) → HelpPatient(x)) ::: All patients need help.",
            "∀x (Doctor(x) → HelpPatient(x)) ::: Doctors treat patients."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Kind(x) ::: x is kind",
            "HelpPatient(x) ::: x helps the patient",
            "HasLicense(x) ::: x has a license",
            "WorksAtHospital(x) ::: x works at the hospital",
            "Patient(x) ::: x is a patient"
        ]
    },
    {
        "premises-NL": [
            "All students study if they attend class and read books.",
            "If someone attends class, they like lectures.",
            "Alice attends class.",
            "Alice reads books.",
            "If someone studies and likes lectures, they get good grades.",
            "Alice is a student.",
            "If someone gets good grades, they write essays.",
            "If someone studies, they attend class or read books.",
            "If someone writes essays, they get good grades.",
            "Alice likes lectures.",
            "Alice writes essays."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ AttendsClass(x) ∧ ReadsBooks(x) → Studies(x)) ::: All students study if they attend class and read books.",
            "∀x (AttendsClass(x) → LikesLectures(x)) ::: If someone attends class, they like lectures.",
            "AttendsClass(alice) ::: Alice attends class.",
            "ReadsBooks(alice) ::: Alice reads books.",
            "∀x (Studies(x) ∧ LikesLectures(x) → GoodGrades(x)) ::: If someone studies and likes lectures, they get good grades.",
            "Student(alice) ::: Alice is a student.",
            "∀x (GoodGrades(x) → WritesEssays(x)) ::: If someone gets good grades, they write essays.",
            "∀x (Studies(x) → AttendsClass(x) ∨ ReadsBooks(x)) ::: If someone studies, they attend class or read books.",
            "∀x (WritesEssays(x) → GoodGrades(x)) ::: If someone writes essays, they get good grades.",
            "LikesLectures(alice) ::: Alice likes lectures.",
            "WritesEssays(alice) ::: Alice writes essays."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "GoodGrades(x) ::: x gets good grades",
            "AttendsClass(x) ::: x attends class",
            "ReadsBooks(x) ::: x reads books",
            "LikesLectures(x) ::: x likes lectures",
            "WritesEssays(x) ::: x writes essays"
        ]
    },
    {
        "premises-NL": [
            "If someone works and saves money, they are wealthy.",
            "If someone has a car or a house, they spend money.",
            "Bob works.",
            "If someone likes luxury and spends money, they have a car.",
            "If someone saves money, they don't spend money.",
            "Bob likes luxury.",
            "If someone is wealthy, they have a house.",
            "Bob saves money.",
            "Bob has a car.",
            "Bob has a house.",
            "If someone has a house, they spend money.",
            "If someone works, they save money."
        ],
        "premises-FOL": [
            "∀x (Works(x) ∧ SavesMoney(x) → Wealthy(x)) ::: If someone works and saves money, they are wealthy.",
            "∀x (HasCar(x) ∨ HasHouse(x) → SpendsMoney(x)) ::: If someone has a car or a house, they spend money.",
            "Works(bob) ::: Bob works.",
            "∀x (LikesLuxury(x) ∧ SpendsMoney(x) → HasCar(x)) ::: If someone likes luxury and spends money, they have a car.",
            "∀x (SavesMoney(x) → ¬SpendsMoney(x)) ::: If someone saves money, they don't spend money.",
            "LikesLuxury(bob) ::: Bob likes luxury.",
            "∀x (Wealthy(x) → HasHouse(x)) ::: If someone is wealthy, they have a house.",
            "SavesMoney(bob) ::: Bob saves money.",
            "HasCar(bob) ::: Bob has a car.",
            "HasHouse(bob) ::: Bob has a house.",
            "∀x (HasHouse(x) → SpendsMoney(x)) ::: If someone has a house, they spend money.",
            "∀x (Works(x) → SavesMoney(x)) ::: If someone works, they save money."
        ],
        "predicates": [
            "HasCar(x) ::: x has a car",
            "HasHouse(x) ::: x has a house",
            "Wealthy(x) ::: x is wealthy",
            "Works(x) ::: x works",
            "SavesMoney(x) ::: x saves money",
            "SpendsMoney(x) ::: x spends money",
            "LikesLuxury(x) ::: x likes luxury"
        ]
    },
    {
        "premises-NL": [
            "All students are smart or skilled.",
            "Some students are not smart.",
            "If someone is smart, they are skilled.",
            "If someone is skilled and a student, they get a scholarship.",
            "All students get a scholarship."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Smart(x) ∨ Skilled(x))) ::: All students are smart or skilled.",
            "∃x (Student(x) ∧ ¬Smart(x)) ::: Some students are not smart.",
            "∀x (Smart(x) → Skilled(x)) ::: If someone is smart, they are skilled.",
            "∀x ((Skilled(x) ∧ Student(x)) → Scholarship(x)) ::: If someone is skilled and a student, they get a scholarship.",
            "∀x (Student(x) → Scholarship(x)) ::: All students get a scholarship.",
            "∀x (Skilled(x) → Scholarship(x)) ::: If someone is skilled, they get a scholarship."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Smart(x) ::: x is smart",
            "Skilled(x) ::: x is skilled",
            "Scholarship(x) ::: x gets a scholarship",
            "SmartImpliesSkilled(x) ::: If someone is smart, they are skilled"
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled.",
            "All enrolled students study.",
            "All students attend lectures or take exams.",
            "If someone studies and is not happy, then they attend lectures.",
            "Some students do not take exams.",
            "If someone is enrolled, then they attend a lecture or take an exam.",
            "If a student doesn't take an exam, they are not happy.",
            "Some students study and are unhappy.",
            "Some students do not pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x)) ::: All students are enrolled.",
            "∀x (Enrolled(x) → Studies(x)) ::: All enrolled students study.",
            "∀x (Student(x) → (Attends(x, Lecture) ∨ TakesExam(x))) ::: All students attend lectures or take exams.",
            "∀x ((Studies(x) ∧ ¬Happy(x)) → Attends(x, Lecture)) ::: If someone studies and is not happy, then they attend lectures.",
            "∃x (Student(x) ∧ ¬TakesExam(x)) ::: Some students do not take exams.",
            "∀x (Enrolled(x) → (Attends(x, Lecture) ∨ TakesExam(x))) ::: If someone is enrolled, then they attend a lecture or take an exam.",
            "∀x (Student(x) ∧ ¬TakesExam(x) → ¬Happy(x)) ::: If a student doesn't take an exam, they are not happy.",
            "∃x (Student(x) ∧ Studies(x) ∧ ¬Happy(x)) ::: Some students study and are unhappy.",
            "∃x (Student(x) ∧ ¬ExamPassed(x)) ::: Some students do not pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Happy(x) ::: x is happy",
            "Attends(x, y) ::: x attends y",
            "Lecture(x) ::: x is a lecture",
            "Studies(x) ::: x studies",
            "Enrolled(x) ::: x is enrolled",
            "TakesExam(x) ::: x takes exam",
            "ExamPassed(x) ::: x has passed the exam"
        ]
    },
    {
        "premises-NL": [
            "Every student is either diligent or not diligent.",
            "All diligent students attend lectures.",
            "Students who attend lectures must study.",
            "If a student studies, they will pass the exam.",
            "John is a student.",
            "John is diligent.",
            "John attends lectures.",
            "John studies."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Diligent(x) ∨ ¬Diligent(x))) ::: Every student is either diligent or not diligent.",
            "∀x (Diligent(x) → AttendsLectures(x)) ::: All diligent students attend lectures.",
            "∀x (AttendsLectures(x) → Studies(x)) ::: Students who attend lectures must study.",
            "∀x (Studies(x) → PassExam(x)) ::: If a student studies, they will pass the exam.",
            "Student(john) ::: John is a student.",
            "Diligent(john) ::: John is diligent.",
            "AttendsLectures(john) ::: John attends lectures.",
            "Studies(john) ::: John studies."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsLectures(x) ::: x attends lectures",
            "PassExam(x) ::: x passes the exam",
            "Successful(x) ::: x is successful"
        ]
    },
    {
        "premises-NL": [
            "Anyone who likes dogs, has a pet.",
            "If someone has a pet, they either have a dog or a cat.",
            "If someone has a dog and is a neighbor of Sarah, they are happy.",
            "Everyone who is a neighbor of Sarah likes dogs.",
            "John is a neighbor of Sarah.",
            "John likes dogs.",
            "John has a pet.",
            "John has a dog.",
            "If John has a dog, he is a neighbor of Sarah"
        ],
        "premises-FOL": [
            "∀x (LikesDogs(x) → HasPet(x)) ::: Anyone who likes dogs, has a pet.",
            "∀x (HasPet(x) → (HasDog(x) ∨ HasCat(x))) ::: If someone has a pet, they either have a dog or a cat.",
            "∀x (HasDog(x) ∧ NeighborOf(x, sarah) → Happy(x)) ::: If someone has a dog and is a neighbor of Sarah, they are happy.",
            "∀x (NeighborOf(x, sarah) → LikesDogs(x)) ::: Everyone who is a neighbor of Sarah likes dogs.",
            "NeighborOf(john, sarah) ::: John is a neighbor of Sarah.",
            "LikesDogs(john) ::: John likes dogs.",
            "HasPet(john) ::: John has a pet.",
            "HasDog(john) ::: John has a dog.",
            "∀x (HasDog(x) ∧ NeighborOf(x, sarah))"
        ],
        "predicates": [
            "HasPet(x) ::: x has a pet",
            "NeighborOf(x, y) ::: x is a neighbor of y",
            "Happy(x) ::: x is happy",
            "LikesDogs(x) ::: x likes dogs"
        ]
    },
    {
        "premises-NL": [
            "Every doctor studies medicine.",
            "Anyone who studies medicine, is either a doctor or a nurse.",
            "Every researcher publishes papers.",
            "Those who publish papers are also researchers.",
            "If someone is a doctor and a researcher, then they are skilled.",
            "Alice is a doctor.",
            "Alice is a researcher.",
            "Alice studies medicine.",
            "Alice publishes papers.",
            "Alice is skilled."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → StudiesMedicine(x)) ::: Every doctor studies medicine.",
            "∀x (StudiesMedicine(x) → (Doctor(x) ∨ Nurse(x))) ::: Anyone who studies medicine, is either a doctor or a nurse.",
            "∀x (Researcher(x) → PublishesPapers(x)) ::: Every researcher publishes papers.",
            "∀x (PublishesPapers(x) → Researcher(x)) ::: Those who publish papers are also researchers.",
            "∀x (Doctor(x) ∧ Researcher(x) → Skilled(x)) ::: If someone is a doctor and a researcher, then they are skilled.",
            "Doctor(alice) ::: Alice is a doctor.",
            "Researcher(alice) ::: Alice is a researcher.",
            "StudiesMedicine(alice) ::: Alice studies medicine.",
            "PublishesPapers(alice) ::: Alice publishes papers.",
            "Skilled(alice) ::: Alice is skilled."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Researcher(x) ::: x is a researcher",
            "Skilled(x) ::: x is skilled",
            "StudiesMedicine(x) ::: x studies medicine",
            "PublishesPapers(x) ::: x publishes papers"
        ]
    },
    {
        "premises-NL": [
            "All professors conduct research.",
            "Anyone who conducts research publishes papers.",
            "Anyone who publishes papers is a professor.",
            "A professor either likes teaching or dislikes it.",
            "If a professor likes teaching and conducts research, they are a good mentor.",
            "Bob is a professor.",
            "Bob conducts research.",
            "Bob publishes papers.",
            "Bob likes teaching.",
            "If Bob likes teaching, Bob is a good mentor.",
            "Bob is a professor and likes teaching."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → ConductsResearch(x)) ::: All professors conduct research.",
            "∀x (ConductsResearch(x) → PublishesPapers(x)) ::: Anyone who conducts research publishes papers.",
            "∀x (PublishesPapers(x) → Professor(x)) ::: Anyone who publishes papers is a professor.",
            "∀x (Professor(x) → (LikesTeaching(x) ∨ ¬LikesTeaching(x))) ::: A professor either likes teaching or dislikes it.",
            "∀x (LikesTeaching(x) ∧ ConductsResearch(x) → GoodMentor(x)) ::: If a professor likes teaching and conducts research, they are a good mentor.",
            "Professor(bob) ::: Bob is a professor.",
            "ConductsResearch(bob) ::: Bob conducts research.",
            "PublishesPapers(bob) ::: Bob publishes papers.",
            "LikesTeaching(bob) ::: Bob likes teaching.",
            "∀x (LikesTeaching(x) → GoodMentor(x))",
            "Professor(bob) ∧ LikesTeaching(bob)"
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "LikesTeaching(x) ::: x likes teaching",
            "GoodMentor(x) ::: x is a good mentor",
            "PublishesPapers(x) ::: x publishes papers",
            "ConductsResearch(x) ::: x conducts research"
        ]
    },
    {
        "premises-NL": [
            "All students attend classes.",
            "Anyone who attends classes reads books.",
            "If someone reads books and enjoys learning, they study hard.",
            "If someone studies hard, they succeed.",
            "Sarah is a student.",
            "Sarah attends classes.",
            "Sarah reads books.",
            "Sarah enjoys learning.",
            "Sarah studies hard.",
            "Sarah succeeds.",
            "Sarah is a student, studies hard, and succeeds.",
            "If Sarah studies hard, she will succeed."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClasses(x)) ::: All students attend classes.",
            "∀x (AttendsClasses(x) → ReadsBooks(x)) ::: Anyone who attends classes reads books.",
            "∀x (ReadsBooks(x) ∧ EnjoysLearning(x) → StudiesHard(x)) ::: If someone reads books and enjoys learning, they study hard.",
            "∀x (StudiesHard(x) → Succeed(x)) ::: If someone studies hard, they succeed.",
            "Student(sarah) ::: Sarah is a student.",
            "AttendsClasses(sarah) ::: Sarah attends classes.",
            "ReadsBooks(sarah) ::: Sarah reads books.",
            "EnjoysLearning(sarah) ::: Sarah enjoys learning.",
            "StudiesHard(sarah) ::: Sarah studies hard.",
            "Succeed(sarah) ::: Sarah succeeds.",
            "Student(sarah) ∧ StudiesHard(sarah) ∧ Succeed(sarah)",
            "∀x (StudiesHard(x) → Succeed(x))"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "Succeed(x) ::: x succeeds",
            "AttendsClasses(x) ::: x attends classes",
            "ReadsBooks(x) ::: x reads books",
            "EnjoysLearning(x) ::: x enjoys learning"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard tend to pass the exam.",
            "If a student attends all classes and is smart, they study hard.",
            "If a student likes pizza, they are happy.",
            "Anyone who is happy likes to party.",
            "If a student is smart and likes to party, they attend all classes.",
            "If a student is smart they study hard.",
            "Some students like pizza.",
            "If a student attends all classes they must be smart.",
            "John is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) → PassesExam(x)) ::: All students who study hard tend to pass the exam.",
            "∀x (Student(x) ∧ AttendsClasses(x) ∧ Smart(x) → StudiesHard(x)) ::: If a student attends all classes and is smart, they study hard.",
            "∀x (Student(x) ∧ LikesPizza(x) → IsHappy(x)) ::: If a student likes pizza, they are happy.",
            "∀x (IsHappy(x) → LikesToParty(x)) ::: Anyone who is happy likes to party.",
            "∀x (Student(x) ∧ Smart(x) ∧ LikesToParty(x) → AttendsClasses(x)) ::: If a student is smart and likes to party, they attend all classes.",
            "∀x (Student(x) ∧ Smart(x) → StudiesHard(x)) ::: If a student is smart they study hard.",
            "∃x (Student(x) ∧ LikesPizza(x)) ::: Some students like pizza.",
            "∀x (Student(x) ∧ AttendsClasses(x) → Smart(x)) ::: If a student attends all classes they must be smart.",
            "Student(john) ::: John is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "AttendsClasses(x) ::: x attends classes",
            "PassesExam(x) ::: x passes the exam",
            "LikesPizza(x) ::: x likes pizza",
            "Smart(x) ::: x is smart",
            "HasFriends(x) ::: x has friends",
            "LikesToParty(x) ::: x likes to party",
            "IsHappy(x) ::: x is happy"
        ]
    },
    {
        "premises-NL": [
            "All managers are people.",
            "Managers review all reports.",
            "If a person reviews a report, they read it.",
            "If a person reads a report, they might make a decision.",
            "If a person makes a decision and writes a report, the decision is based on the report.",
            "Anyone that works at a company is a person.",
            "If someone is a senior employee and has authority, they are a manager.",
            "Some managers write reports.",
            "If a report is not written by a manager then the report is not used."
        ],
        "premises-FOL": [
            "∀x (Manager(x) → Person(x)) ::: All managers are people.",
            "∀x ∀y (Manager(x) → ReviewsReport(x, y)) ::: Managers review all reports.",
            "∀x ∀y (ReviewsReport(x, y) → ReadsReport(x, y)) ::: If a person reviews a report, they read it.",
            "∀x ∀y (ReadsReport(x, y) → MakesDecision(x, y)) ::: If a person reads a report, they might make a decision.",
            "∀x ∀y (MakesDecision(x, y) ∧ WritesReport(x, y) → MakesDecision(x, y)) ::: If a person makes a decision and writes a report, the decision is based on the report.",
            "∀x ∀y (IsEmployed(x, y) → Person(x)) ::: Anyone that works at a company is a person.",
            "∀x (Senior(x) ∧ HasAuthority(x) → Manager(x)) ::: If someone is a senior employee and has authority, they are a manager.",
            "∃x ∃y (Manager(x) ∧ WritesReport(x, y)) ::: Some managers write reports.",
            "∀x ∀y (¬WritesReport(x,y) → ¬MakesDecision(x, y)) ::: If a report is not written by a manager then the report is not used."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Manager(x) ::: x is a manager",
            "ReviewsReport(x, y) ::: x reviews report y",
            "MakesDecision(x, y) ::: x makes decision based on report y",
            "WritesReport(x, y) ::: x writes report y",
            "ReadsReport(x, y) ::: x reads report y",
            "IsEmployed(x, y) ::: x is employed by company y",
            "IsImportant(x) ::: x is an important person",
            "Senior(x) ::: x is senior",
            "HasAuthority(x) ::: x has authority"
        ]
    },
    {
        "premises-NL": [
            "All students who like coffee study hard.",
            "Some students like coffee.",
            "All students who study hard attend class.",
            "Some students attend class.",
            "If a student studies hard and attends class, they are successful.",
            "Not all students are unsuccessful.",
            "John is a student.",
            "If John studies hard, he is successful.",
            "If John likes coffee, he studies hard.",
            "John likes coffee."
        ],
        "premises-FOL": [
            "∀x ((Student(x) ∧ LikesCoffee(x)) → StudyHard(x)) ::: All students who like coffee study hard",
            "∃x (Student(x) ∧ LikesCoffee(x)) ::: Some students like coffee",
            "∀x (StudyHard(x) → AttendsClass(x)) ::: All students who study hard attend class",
            "∃x AttendsClass(x) ::: Some students attend class",
            "∀x ((StudyHard(x) ∧ AttendsClass(x)) → Successful(x)) ::: If a student studies hard and attends class, they are successful",
            "¬∀x Successful(x) ::: Not all students are unsuccessful",
            "Student(John) ::: John is a student",
            "StudyHard(John) → Successful(John) ::: If John studies hard, he is successful",
            "LikesCoffee(John) → StudyHard(John) ::: If John likes coffee, he studies hard",
            "LikesCoffee(John) ::: John likes coffee"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudyHard(x) ::: x studies hard",
            "Successful(x) ::: x is successful",
            "LikesCoffee(x) ::: x likes coffee",
            "AttendsClass(x) ::: x attends class"
        ]
    },
    {
        "premises-NL": [
            "Sarah and Michael are friends.",
            "If Sarah likes pizza, then she enjoys movies.",
            "If Michael likes pizza, then he enjoys movies.",
            "Either Sarah likes pizza or she doesn't.",
            "Either Michael likes pizza or he doesn't.",
            "If Sarah and Michael are friends and Sarah enjoys movies, Michael likes pizza.",
            "If Sarah and Michael are friends and Michael enjoys movies, Sarah likes pizza."
        ],
        "premises-FOL": [
            "Friends(sarah, michael) ::: Sarah and Michael are friends.",
            "LikesPizza(sarah) → EnjoysMovies(sarah) ::: If Sarah likes pizza, then she enjoys movies.",
            "LikesPizza(michael) → EnjoysMovies(michael) ::: If Michael likes pizza, then he enjoys movies.",
            "LikesPizza(sarah) ∨ ¬LikesPizza(sarah) ::: Either Sarah likes pizza or she doesn't.",
            "LikesPizza(michael) ∨ ¬LikesPizza(michael) ::: Either Michael likes pizza or he doesn't.",
            "(Friends(sarah, michael) ∧ EnjoysMovies(sarah)) → LikesPizza(michael) ::: If Sarah and Michael are friends and Sarah enjoys movies, Michael likes pizza.",
            "(Friends(sarah, michael) ∧ EnjoysMovies(michael)) → LikesPizza(sarah) ::: If Sarah and Michael are friends and Michael enjoys movies, Sarah likes pizza."
        ],
        "predicates": [
            "LikesPizza(x) ::: x likes pizza",
            "EnjoysMovies(x) ::: x enjoys movies",
            "Friends(x, y) ::: x and y are friends"
        ]
    },
    {
        "premises-NL": [
            "All healthy people are not sick.",
            "Some people are healthy.",
            "If someone is not sick, they don't have a disease.",
            "Everyone either has a disease or is healthy.",
            "No healthy person has a disease.",
            "If someone does not have a disease they are healthy or someone is sick.",
            "Someone has a disease or is healthy.",
            "Some people are sick.",
            "If someone is healthy, they are not sick.",
            "Someone is not sick if and only if they are healthy.",
            "If someone does not have a disease then they are healthy.",
            "No one is both healthy and sick.",
            "Some sick people do not have a disease.",
            "Someone is sick or someone does not have a disease.",
            "Some healthy people are not sick."
        ],
        "premises-FOL": [
            "∀x (Healthy(x) → ¬Sick(x)) ::: All healthy people are not sick.",
            "∃x Healthy(x) ::: Some people are healthy.",
            "∀x (¬Sick(x) → ¬Disease(x)) ::: If someone is not sick, they don't have a disease.",
            "∀x (Disease(x) ∨ Healthy(x)) ::: Everyone either has a disease or is healthy.",
            "∀x (Healthy(x) → ¬Disease(x)) ::: No healthy person has a disease.",
            "∀x (¬Disease(x) → (Healthy(x) ∨ Sick(x))) ::: If someone does not have a disease they are healthy or someone is sick.",
            "∃x (Disease(x) ∨ Healthy(x)) ::: Someone has a disease or is healthy.",
            "∃x Sick(x) ::: Some people are sick.",
            "∀x (Healthy(x) → ¬Sick(x)) ::: If someone is healthy, they are not sick.",
            "∀x (¬Sick(x) ↔ Healthy(x)) ::: Someone is not sick if and only if they are healthy.",
            "∀x (¬Disease(x) → Healthy(x)) ::: If someone does not have a disease then they are healthy.",
            "∀x ¬(Healthy(x) ∧ Sick(x)) ::: No one is both healthy and sick.",
            "∃x (Sick(x) ∧ ¬Disease(x)) ::: Some sick people do not have a disease.",
            "∃x (Sick(x) ∨ ¬Disease(x)) ::: Someone is sick or someone does not have a disease.",
            "∃x (Healthy(x) ∧ ¬Sick(x)) ::: Some healthy people are not sick."
        ],
        "predicates": [
            "Healthy(x) ::: x is healthy.",
            "Disease(x) ::: x has a disease."
        ]
    },
    {
        "premises-NL": [
            "All big objects are round.",
            "All red objects are either big or square.",
            "Some red objects are big.",
            "If something is big, it is round.",
            "If something is red, then it is big or square.",
            "Some objects are red.",
            "No square object is round.",
            "Something is either not big or round.",
            "Something is either red or not big.",
            "If something is red, it is not round.",
            "All red things are not round or something is big.",
            "Something is red, big, and not round.",
            "If something is square, it is not red.",
            "If something is square, it's not red and round.",
            "Something is red and big, and not round.",
            "No red object is both round and big."
        ],
        "premises-FOL": [
            "∀x (Big(x) → Round(x)) ::: All big objects are round.",
            "∀x (Red(x) → (Big(x) ∨ Square(x))) ::: All red objects are either big or square.",
            "∃x (Red(x) ∧ Big(x)) ::: Some red objects are big.",
            "∀x (Big(x) → Round(x)) ::: If something is big, it is round.",
            "∀x (Red(x) → (Big(x) ∨ Square(x))) ::: If something is red, then it is big or square.",
            "∃x Red(x) ::: Some objects are red.",
            "∀x (Square(x) → ¬Round(x)) ::: No square object is round.",
            "∃x (¬Big(x) ∨ Round(x)) ::: Something is either not big or round.",
            "∃x (Red(x) ∨ ¬Big(x)) ::: Something is either red or not big.",
            "∀x (Red(x) → ¬Round(x)) ::: If something is red, it is not round.",
            "∀x (Red(x) → (¬Round(x) ∨ Big(x))) ::: All red things are not round or something is big.",
            "∃x (Red(x) ∧ Big(x) ∧ ¬Round(x)) ::: Something is red, big, and not round.",
            "∀x (Square(x) → ¬Red(x)) ::: If something is square, it is not red.",
            "∀x (Square(x) → (¬Red(x) ∧ ¬Round(x))) ::: If something is square, it's not red and round.",
            "∃x (Red(x) ∧ Big(x) ∧ ¬Round(x)) ::: Something is red and big, and not round.",
            "∀x (Red(x) → ¬(Round(x) ∧ Big(x))) ::: No red object is both round and big."
        ],
        "predicates": [
            "Red(x) ::: x is red.",
            "Round(x) ::: x is round.",
            "Big(x) ::: x is big.",
            "Square(x) ::: x is square."
        ]
    },
    {
        "premises-NL": [
            "All students who like books study history or science.",
            "Some students like books.",
            "If someone studies history they like books.",
            "If someone studies science they like books.",
            "All students study either history or science.",
            "Some students do not study science.",
            "If someone likes books, they are a student.",
            "If someone likes books, they study history or science.",
            "All students who study history do not study science or like books.",
            "Some students who study history do not study science or like books.",
            "Some students study history and do not like books.",
            "All students who study science like books.",
            "Some students like books and do not study science.",
            "Some students do not like books and do not study science.",
            "No student studies both history and science.",
            "Everyone who likes books studies history.",
            "Some students are not science students."
        ],
        "premises-FOL": [
            "∀x ((Student(x) ∧ LikesBooks(x)) → (StudyHistory(x) ∨ StudyScience(x))) ::: All students who like books study history or science.",
            "∃x (Student(x) ∧ LikesBooks(x)) ::: Some students like books.",
            "∀x (StudyHistory(x) → LikesBooks(x)) ::: If someone studies history they like books.",
            "∀x (StudyScience(x) → LikesBooks(x)) ::: If someone studies science they like books.",
            "∀x (Student(x) → (StudyHistory(x) ∨ StudyScience(x))) ::: All students study either history or science.",
            "∃x (Student(x) ∧ ¬StudyScience(x)) ::: Some students do not study science.",
            "∀x (LikesBooks(x) → Student(x)) ::: If someone likes books, they are a student.",
            "∀x (LikesBooks(x) → (StudyHistory(x) ∨ StudyScience(x))) ::: If someone likes books, they study history or science.",
            "∀x ((Student(x) ∧ StudyHistory(x)) → (¬StudyScience(x) ∨ LikesBooks(x))) ::: All students who study history do not study science or like books.",
            "∃x ((Student(x) ∧ StudyHistory(x)) ∧ (¬StudyScience(x) ∨ LikesBooks(x))) ::: Some students who study history do not study science or like books.",
            "∃x (Student(x) ∧ StudyHistory(x) ∧ ¬LikesBooks(x)) ::: Some students study history and do not like books.",
            "∀x ((Student(x) ∧ StudyScience(x)) → LikesBooks(x)) ::: All students who study science like books.",
            "∃x (Student(x) ∧ LikesBooks(x) ∧ ¬StudyScience(x)) ::: Some students like books and do not study science.",
            "∃x (Student(x) ∧ ¬LikesBooks(x) ∧ ¬StudyScience(x)) ::: Some students do not like books and do not study science.",
            "∀x ¬(Student(x) ∧ StudyHistory(x) ∧ StudyScience(x)) ::: No student studies both history and science.",
            "∀x (LikesBooks(x) → StudyHistory(x)) ::: Everyone who likes books studies history.",
            "∃x (Student(x) ∧ ¬StudyScience(x)) ::: Some students are not science students."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudyHistory(x) ::: x studies history.",
            "StudyScience(x) ::: x studies science.",
            "LikesBooks(x) ::: x likes books."
        ]
    },
    {
        "premises-NL": [
            "All students who like math and science are smart.",
            "Some students like math.",
            "If someone likes science they are smart.",
            "If someone is smart they study history.",
            "Some students do not study history.",
            "If someone likes science, they like math.",
            "All students study either history, math, or science.",
            "Some smart people like math and science.",
            "Someone who likes math and studies history also likes science.",
            "If someone is smart, they study history.",
            "Someone likes math.",
            "If someone is smart, then they study history.",
            "Some students who do not study history like math.",
            "Some students who like math and science do not study history.",
            "All students who like math also like science.",
            "If someone likes science and math, they are a student.",
            "If someone likes math, then they like science.",
            "Some students are smart.",
            "No smart person does not like math and science."
        ],
        "premises-FOL": [
            "∀x ((Student(x) ∧ LikesMath(x) ∧ LikesScience(x)) → Smart(x)) ::: All students who like math and science are smart.",
            "∃x (Student(x) ∧ LikesMath(x)) ::: Some students like math.",
            "∀x (LikesScience(x) → Smart(x)) ::: If someone likes science they are smart.",
            "∀x (Smart(x) → StudyHistory(x)) ::: If someone is smart they study history.",
            "∃x (Student(x) ∧ ¬StudyHistory(x)) ::: Some students do not study history.",
            "∀x (LikesScience(x) → LikesMath(x)) ::: If someone likes science, they like math.",
            "∀x (Student(x) → (StudyHistory(x) ∨ LikesMath(x) ∨ LikesScience(x))) ::: All students study either history, math, or science.",
            "∃x (Smart(x) ∧ LikesMath(x) ∧ LikesScience(x)) ::: Some smart people like math and science.",
            "∀x ((LikesMath(x) ∧ StudyHistory(x)) → LikesScience(x)) ::: Someone who likes math and studies history also likes science.",
            "∀x (Smart(x) → StudyHistory(x)) ::: If someone is smart, they study history.",
            "∃x LikesMath(x) ::: Someone likes math.",
            "∀x (Smart(x) → StudyHistory(x)) ::: If someone is smart, then they study history.",
            "∃x (Student(x) ∧ ¬StudyHistory(x) ∧ LikesMath(x)) ::: Some students who do not study history like math.",
            "∃x (Student(x) ∧ LikesMath(x) ∧ LikesScience(x) ∧ ¬StudyHistory(x)) ::: Some students who like math and science do not study history.",
            "∀x ((Student(x) ∧ LikesMath(x)) → LikesScience(x)) ::: All students who like math also like science.",
            "∀x ((LikesScience(x) ∧ LikesMath(x)) → Student(x)) ::: If someone likes science and math, they are a student.",
            "∀x (LikesMath(x) → LikesScience(x)) ::: If someone likes math, then they like science.",
            "∃x (Student(x) ∧ Smart(x)) ::: Some students are smart.",
            "∀x (Smart(x) → (LikesMath(x) ∧ LikesScience(x))) ::: No smart person does not like math and science."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "LikesMath(x) ::: x likes math.",
            "LikesScience(x) ::: x likes science.",
            "StudyHistory(x) ::: x studies history.",
            "Smart(x) ::: x is smart."
        ]
    },
    {
        "premises-NL": [
            "All students either study or do not study.",
            "All students either attend or do not attend classes.",
            "If a student studies and attends classes, they are prepared.",
            "If a student is prepared, they will pass.",
            "If a student does not attend classes, they will fail.",
            "If a student does not study, they will fail.",
            "If a student passes, they are not failing.",
            "If a student has an exam and is prepared, they will pass.",
            "Students have exams.",
            "If a student passes, they must have studied.",
            "If a student attends and studies, they will understand.",
            "If a student understands, they will pass.",
            "No student passes and fails.",
            "If a student is failing, they must have not studied or attended classes.",
            "If a student attends, they either study or are prepared.",
            "If someone studies and doesn't attend, they will fail."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Study(x) ∨ ¬Study(x))) ::: All students either study or do not study.",
            "∀x (Student(x) → (Attend(x) ∨ ¬Attend(x))) ::: All students either attend or do not attend classes.",
            "∀x (Student(x) ∧ Study(x) ∧ Attend(x) → IsPrepared(x)) ::: If a student studies and attends classes, they are prepared.",
            "∀x (Student(x) ∧ IsPrepared(x) → Pass(x)) ::: If a student is prepared, they will pass.",
            "∀x (Student(x) ∧ ¬Attend(x) → Fail(x)) ::: If a student does not attend classes, they will fail.",
            "∀x (Student(x) ∧ ¬Study(x) → Fail(x)) ::: If a student does not study, they will fail.",
            "∀x (Pass(x) → ¬Fail(x)) ::: If a student passes, they are not failing.",
            "∀x (Student(x) ∧ HasExam(x) ∧ IsPrepared(x) → Pass(x)) ::: If a student has an exam and is prepared, they will pass.",
            "∀x (Student(x) → HasExam(x)) ::: Students have exams.",
            "∀x (Pass(x) → Study(x)) ::: If a student passes, they must have studied.",
            "∀x (Student(x) ∧ Attend(x) ∧ Study(x) → Understands(x)) ::: If a student attends and studies, they will understand.",
            "∀x (Student(x) ∧ Understands(x) → Pass(x)) ::: If a student understands, they will pass.",
            "¬∃x (Pass(x) ∧ Fail(x)) ::: No student passes and fails.",
            "∀x (Fail(x) → (¬Study(x) ∨ ¬Attend(x))) ::: If a student is failing, they must have not studied or attended classes.",
            "∀x (Student(x) ∧ Attend(x) → (Study(x) ∨ IsPrepared(x))) ::: If a student attends, they either study or are prepared.",
            "∀x (Student(x) ∧ Study(x) ∧ ¬Attend(x) → Fail(x)) ::: If someone studies and doesn't attend, they will fail."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Study(x) ::: x studies",
            "Attend(x) ::: x attends classes",
            "Pass(x) ::: x passes",
            "Fail(x) ::: x fails",
            "HasExam(x) ::: x has an exam",
            "IsPrepared(x) ::: x is prepared",
            "Understands(x) ::: x understands the material"
        ]
    },
    {
        "premises-NL": [
            "Every person either has a high income or does not.",
            "If a person has a high income, they either save or spend.",
            "If a person saves, they are not in debt.",
            "If a person invests, their portfolio grows.",
            "If a person is rich, they have a high income.",
            "If a person does not spend, they save.",
            "If a person saves, they will invest.",
            "Anyone with a high income either invests or spends.",
            "If a person does not invest, their portfolio does not grow.",
            "If someone does not spend, they either invest or save.",
            "If a person invests and has a high income, their portfolio grows.",
            "People with debt do not invest.",
            "If a person is economically stable and invests, they save.",
            "If a person saves and their portfolio grows, they are not in debt.",
            "If a person is rich, they are economically stable.",
            "If a person has a high income and saves, they will invest.",
            "If a person is economically stable and invests, their portfolio grows."
        ],
        "premises-FOL": [
            "∀x (Person(x) → (HighIncome(x) ∨ ¬HighIncome(x))) ::: Every person either has a high income or does not.",
            "∀x (Person(x) ∧ HighIncome(x) → (Saves(x) ∨ Spends(x))) ::: If a person has a high income, they either save or spend.",
            "∀x (Person(x) ∧ Saves(x) → ¬HasDebt(x)) ::: If a person saves, they are not in debt.",
            "∀x (Person(x) ∧ Invests(x) → Grows(x)) ::: If a person invests, their portfolio grows.",
            "∀x (IsRich(x) → HighIncome(x)) ::: If a person is rich, they have a high income.",
            "∀x (Person(x) ∧ ¬Spends(x) → Saves(x)) ::: If a person does not spend, they save.",
            "∀x (Person(x) ∧ Saves(x) → Invests(x)) ::: If a person saves, they will invest.",
            "∀x (Person(x) ∧ HighIncome(x) → (Invests(x) ∨ Spends(x))) ::: Anyone with a high income either invests or spends.",
            "∀x (Person(x) ∧ ¬Invests(x) → ¬Grows(x)) ::: If a person does not invest, their portfolio does not grow.",
            "∀x (Person(x) ∧ ¬Spends(x) → (Invests(x) ∨ Saves(x))) ::: If someone does not spend, they either invest or save.",
            "∀x (Person(x) ∧ Invests(x) ∧ HighIncome(x) → Grows(x)) ::: If a person invests and has a high income, their portfolio grows.",
            "∀x (Person(x) ∧ HasDebt(x) → ¬Invests(x)) ::: People with debt do not invest.",
            "∀x (Person(x) ∧ IsEconomicallyStable(x) ∧ Invests(x) → Saves(x)) ::: If a person is economically stable and invests, they save.",
            "∀x (Person(x) ∧ Saves(x) ∧ Grows(x) → ¬HasDebt(x)) ::: If a person saves and their portfolio grows, they are not in debt.",
            "∀x (IsRich(x) → IsEconomicallyStable(x)) ::: If a person is rich, they are economically stable.",
            "∀x (Person(x) ∧ HighIncome(x) ∧ Saves(x) → Invests(x)) ::: If a person has a high income and saves, they will invest.",
            "∀x (Person(x) ∧ IsEconomicallyStable(x) ∧ Invests(x) → Grows(x)) ::: If a person is economically stable and invests, their portfolio grows."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "HighIncome(x) ::: x has a high income",
            "Invests(x) ::: x invests",
            "Grows(x) ::: x's portfolio grows",
            "IsRich(x) ::: x is rich",
            "Saves(x) ::: x saves",
            "Spends(x) ::: x spends",
            "HasDebt(x) ::: x has debt",
            "IsEconomicallyStable(x) ::: x is economically stable"
        ]
    },
    {
        "premises-NL": [
            "All people are either members of A or not.",
            "All people either like coffee or tea.",
            "If someone is a member of A, they like coffee or tea.",
            "If someone is a member of B, they like tea or coffee.",
            "If someone likes coffee, they enjoy social events.",
            "If someone likes tea, they enjoy social events.",
            "If someone enjoys social events, they attend meetings.",
            "If someone is a member of club A and attends meetings, they must like tea.",
            "If someone is a member of club B and attends meetings, they must like coffee.",
            "If someone likes both coffee and tea, they are friendly.",
            "If someone is a member of both club A and club B, they must attend meetings.",
            "People in club A are either members of B or don't like tea.",
            "People in club B are either members of A or don't like coffee.",
            "If someone is friendly and attends meetings, they enjoy social events.",
            "Anyone in club A and club B enjoys social events."
        ],
        "premises-FOL": [
            "∀x (Person(x) → (MemberOfA(x) ∨ ¬MemberOfA(x))) ::: All people are either members of A or not.",
            "∀x (Person(x) → (LikesCoffee(x) ∨ LikesTea(x))) ::: All people either like coffee or tea.",
            "∀x (MemberOfA(x) → (LikesCoffee(x) ∨ LikesTea(x))) ::: If someone is a member of A, they like coffee or tea.",
            "∀x (MemberOfB(x) → (LikesTea(x) ∨ LikesCoffee(x))) ::: If someone is a member of B, they like tea or coffee.",
            "∀x (LikesCoffee(x) → EnjoysSocialEvents(x)) ::: If someone likes coffee, they enjoy social events.",
            "∀x (LikesTea(x) → EnjoysSocialEvents(x)) ::: If someone likes tea, they enjoy social events.",
            "∀x (EnjoysSocialEvents(x) → AttendsMeetings(x)) ::: If someone enjoys social events, they attend meetings.",
            "∀x (MemberOfA(x) ∧ AttendsMeetings(x) → LikesTea(x)) ::: If someone is a member of club A and attends meetings, they must like tea.",
            "∀x (MemberOfB(x) ∧ AttendsMeetings(x) → LikesCoffee(x)) ::: If someone is a member of club B and attends meetings, they must like coffee.",
            "∀x (LikesCoffee(x) ∧ LikesTea(x) → Friendly(x)) ::: If someone likes both coffee and tea, they are friendly.",
            "∀x (MemberOfA(x) ∧ MemberOfB(x) → AttendsMeetings(x)) ::: If someone is a member of both club A and club B, they must attend meetings.",
            "∀x (MemberOfA(x) → (MemberOfB(x) ∨ ¬LikesTea(x))) ::: People in club A are either members of B or don't like tea.",
            "∀x (MemberOfB(x) → (MemberOfA(x) ∨ ¬LikesCoffee(x))) ::: People in club B are either members of A or don't like coffee.",
            "∀x (Friendly(x) ∧ AttendsMeetings(x) → EnjoysSocialEvents(x)) ::: If someone is friendly and attends meetings, they enjoy social events.",
            "∀x (MemberOfA(x) ∧ MemberOfB(x) → EnjoysSocialEvents(x)) ::: Anyone in club A and club B enjoys social events."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "MemberOfA(x) ::: x is a member of club A",
            "MemberOfB(x) ::: x is a member of club B",
            "LikesCoffee(x) ::: x likes coffee",
            "LikesTea(x) ::: x likes tea",
            "EnjoysSocialEvents(x) ::: x enjoys social events",
            "AttendsMeetings(x) ::: x attends meetings",
            "Friendly(x) ::: x is friendly"
        ]
    },
    {
        "premises-NL": [
            "All whales are mammals.",
            "No whale is a fish.",
            "All whales are aquatic.",
            "All aquatic creatures live underwater.",
            "If something is a mammal and not a whale, then it is not aquatic.",
            "If something is not aquatic, then it doesn't live underwater.",
            "The object is a whale."
        ],
        "premises-FOL": [
            "∀x (Whale(x) → Mammal(x)) ::: All whales are mammals.",
            "∀x (Whale(x) → ¬Fish(x)) ::: No whale is a fish.",
            "∀x (Whale(x) → Aquatic(x)) ::: All whales are aquatic.",
            "∀x (Aquatic(x) → Underwater(x)) ::: All aquatic creatures live underwater.",
            "∀x ((Mammal(x) ∧ ¬Whale(x)) → ¬Aquatic(x)) ::: If something is a mammal and not a whale, then it is not aquatic.",
            "∀x (¬Aquatic(x) → ¬Underwater(x)) ::: If something is not aquatic, then it doesn't live underwater.",
            "Whale(object) ::: The object is a whale."
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal",
            "Whale(x) ::: x is a whale",
            "Fish(x) ::: x is a fish",
            "Underwater(x) ::: x lives underwater",
            "Aquatic(x) ::: x is aquatic"
        ]
    },
    {
        "premises-NL": [
            "All doctors are either specialists or have a license.",
            "No doctor is both a specialist and has a license.",
            "If someone is a specialist, they cannot prescribe medicine.",
            "If someone has a license, they are able to prescribe medicine.",
            "John is a doctor.",
            "John has a license.",
            "If someone is a doctor and they have a license, then they prescribe medicine."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → (Specialist(x) ∨ HasLicense(x))) ::: All doctors are either specialists or have a license.",
            "∀x (¬(Specialist(x) ∧ HasLicense(x))) ::: No doctor is both a specialist and has a license.",
            "∀x (Specialist(x) → ¬PrescribesMedicine(x)) ::: If someone is a specialist, they cannot prescribe medicine.",
            "∀x (HasLicense(x) → PrescribesMedicine(x)) ::: If someone has a license, they are able to prescribe medicine.",
            "Doctor(john) ::: John is a doctor.",
            "HasLicense(john) ::: John has a license.",
            "∀x ((Doctor(x) ∧ HasLicense(x)) → PrescribesMedicine(x)) ::: If someone is a doctor and they have a license, then they prescribe medicine."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "HasLicense(x) ::: x has a license",
            "Specialist(x) ::: x is a specialist",
            "PrescribesMedicine(x) ::: x prescribes medicine",
            "Licensed(x, y) ::: x has a license for y"
        ]
    },
    {
        "premises-NL": [
            "All apples are fruits.",
            "All red fruits are sweet or sour.",
            "No apple is both sweet and sour.",
            "All apples are red.",
            "If something is sweet and a fruit, it can be eaten.",
            "If something is sour and a fruit, it cannot be eaten.",
            "All apples grow on trees.",
            "The object is an apple.",
            "If a fruit is red and not sweet, then it is sour.",
            "If a fruit is not red, then it is not sweet."
        ],
        "premises-FOL": [
            "∀x (Apple(x) → Fruit(x)) ::: All apples are fruits.",
            "∀x ((Red(x) ∧ Fruit(x)) → (Sweet(x) ∨ Sour(x))) ::: All red fruits are sweet or sour.",
            "∀x (¬(Sweet(x) ∧ Sour(x))) ::: No fruit is both sweet and sour.",
            "∀x (Apple(x) → Red(x)) ::: All apples are red.",
            "∀x ((Sweet(x) ∧ Fruit(x)) → Eats(someone, x)) ::: If something is sweet and a fruit, it can be eaten.",
            "∀x ((Sour(x) ∧ Fruit(x)) → ¬Eats(someone, x)) ::: If something is sour and a fruit, it cannot be eaten.",
            "∀x (Apple(x) → GrowsOnTree(x)) ::: All apples grow on trees.",
            "Apple(object) ::: The object is an apple.",
            "∀x ((Fruit(x) ∧ Red(x) ∧ ¬Sweet(x)) → Sour(x)) ::: If a fruit is red and not sweet, then it is sour.",
            "∀x (¬Red(x) → ¬Sweet(x)) ::: If a fruit is not red, then it is not sweet."
        ],
        "predicates": [
            "Fruit(x) ::: x is a fruit",
            "Red(x) ::: x is red",
            "Sweet(x) ::: x is sweet",
            "Sour(x) ::: x is sour",
            "Apple(x) ::: x is an apple",
            "GrowsOnTree(x) ::: x grows on a tree"
        ]
    },
    {
        "premises-NL": [
            "All scientists either study biology or chemistry.",
            "No scientist studies both biology and chemistry.",
            "All scientists have a degree or work at a university.",
            "If a scientist studies biology, they are also a researcher.",
            "All researchers conduct experiments.",
            "John is a scientist.",
            "John studies biology.",
            "If a scientist has a degree and works at a university, they are considered a researcher.",
            "If John is a scientist and studies biology, then John attends a conference.",
            "If John attends a conference, then John conducts experiments.",
            "If a scientist works at a university and studies biology, then they conduct experiments.",
            "If a scientist does not have a degree, they work at a university.",
            "John has a degree.",
            "If a scientist studies chemistry, then they do not conduct experiments.",
            "If a scientist is a researcher, they conduct experiments."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → (StudiesBiology(x) ∨ StudiesChemistry(x))) ::: All scientists either study biology or chemistry.",
            "∀x (¬(StudiesBiology(x) ∧ StudiesChemistry(x))) ::: No scientist studies both biology and chemistry.",
            "∀x (Scientist(x) → (HasDegree(x) ∨ WorksAt(x, University))) ::: All scientists have a degree or work at a university.",
            "∀x (StudiesBiology(x) → Researcher(x)) ::: If a scientist studies biology, they are also a researcher.",
            "∀x (Researcher(x) → ConductsExperiments(x)) ::: All researchers conduct experiments.",
            "Scientist(john) ::: John is a scientist.",
            "StudiesBiology(john) ::: John studies biology.",
            "∀x ((Scientist(x) ∧ HasDegree(x) ∧ WorksAt(x, University)) → Researcher(x)) ::: If a scientist has a degree and works at a university, they are considered a researcher.",
            "∀x ((Scientist(x) ∧ StudiesBiology(x)) → AttendsConference(x, Conference)) ::: If John is a scientist and studies biology, then John attends a conference.",
            "∀x (AttendsConference(x, Conference) → ConductsExperiments(x)) ::: If John attends a conference, then John conducts experiments.",
            "∀x ((Scientist(x) ∧ StudiesBiology(x) ∧ WorksAt(x, University)) → ConductsExperiments(x)) ::: If a scientist works at a university and studies biology, then they conduct experiments.",
            "∀x (¬HasDegree(x) → WorksAt(x, University)) ::: If a scientist does not have a degree, they work at a university.",
            "HasDegree(john) ::: John has a degree.",
            "∀x (StudiesChemistry(x) → ¬ConductsExperiments(x)) ::: If a scientist studies chemistry, then they do not conduct experiments.",
            "∀x (Researcher(x) → ConductsExperiments(x)) ::: If a scientist is a researcher, they conduct experiments."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "StudiesBiology(x) ::: x studies biology",
            "HasDegree(x) ::: x has a degree",
            "ConductsExperiments(x) ::: x conducts experiments",
            "WorksAt(x, y) ::: x works at y",
            "Researcher(x) ::: x is a researcher",
            "AttendsConference(x, y) ::: x attends conference y"
        ]
    },
    {
        "premises-NL": [
            "All students take either Math or History.",
            "John is a student.",
            "John does not take History.",
            "Sarah is a student.",
            "Sarah is not taking History.",
            "Peter is a student.",
            "Peter does not take History."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (TakesMath(x) ∨ TakesHistory(x))) ::: All students take either Math or History.",
            "Student(john) ::: John is a student.",
            "¬TakesHistory(john) ::: John does not take History.",
            "Student(sarah) ::: Sarah is a student.",
            "¬TakesHistory(sarah) ::: Sarah is not taking History.",
            "Student(peter) ::: Peter is a student.",
            "¬TakesHistory(peter) ::: Peter does not take History."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "TakesMath(x) ::: x takes Math.",
            "TakesHistory(x) ::: x takes History."
        ]
    },
    {
        "premises-NL": [
            "All fruits are plants.",
            "Some fruits are sweet.",
            "Anything that is a fruit is edible.",
            "Anything that is a plant is edible.",
            "Apples are fruits.",
            "The tree has apples.",
            "Oranges are fruits.",
            "Apples are sweet.",
            "The apple grows on the tree."
        ],
        "premises-FOL": [
            "∀x (Fruit(x) → Plant(x)) ::: All fruits are plants.",
            "∃x (Fruit(x) ∧ Sweet(x)) ::: Some fruits are sweet.",
            "∀x (Fruit(x) → Edible(x)) ::: Anything that is a fruit is edible.",
            "∀x (Plant(x) → Edible(x)) ::: Anything that is a plant is edible.",
            "Fruit(apple) ::: Apples are fruits.",
            "GrowsOn(apple, tree) ::: The tree has apples.",
            "Fruit(orange) ::: Oranges are fruits.",
            "Sweet(apple) ::: Apples are sweet.",
            "GrowsOn(apple, tree) ::: The apple grows on the tree."
        ],
        "predicates": [
            "Fruit(x) ::: x is a fruit.",
            "Sweet(x) ::: x is sweet.",
            "Edible(x) ::: x is edible.",
            "Plant(x) ::: x is a plant.",
            "GrowsOn(x, y) ::: x grows on y."
        ]
    },
    {
        "premises-NL": [
            "Every student attends the university.",
            "All students play a sport or work at the university.",
            "If someone plays a sport, they are a student.",
            "John is a student.",
            "John plays a sport.",
            "If someone works at the university, they are a professor.",
            "The university is an institution of higher learning.",
            "A professor is a person who teaches at the university.",
            "John is a student and plays a sport.",
            "Therefore, someone who is a student and plays a sport attends the university."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Attends(x, university)) ::: Every student attends the university.",
            "∀x (Student(x) → (PlaysSport(x) ∨ WorksAt(x, university))) ::: All students play a sport or work at the university.",
            "∀x (PlaysSport(x) → Student(x)) ::: If someone plays a sport, they are a student.",
            "Student(john) ::: John is a student.",
            "PlaysSport(john) ::: John plays a sport.",
            "∀x (WorksAt(x, university) → Professor(x)) ::: If someone works at the university, they are a professor.",
            "InstitutionOfHigherLearning(university) ::: The university is an institution of higher learning.",
            "∀x (Professor(x) → TeachesAt(x, university)) ::: A professor is a person who teaches at the university.",
            "Student(john) ∧ PlaysSport(john) ::: John is a student and plays a sport.",
            "∃x (Student(x) ∧ PlaysSport(x) → Attends(x, university)) ::: Therefore, someone who is a student and plays a sport attends the university."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "PlaysSport(x) ::: x plays a sport.",
            "Attends(x, y) ::: x attends y.",
            "WorksAt(x, y) ::: x works at y.",
            "Professor(x) ::: x is a professor."
        ]
    },
    {
        "premises-NL": [
            "All students are either smart or hard working.",
            "Some students are smart.",
            "All smart people pass their exams.",
            "If someone is hard working, they also study.",
            "Everyone who studies passes their exams.",
            "Not all students are smart or hard working.",
            "Some students study."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Smart(x) ∨ HardWorking(x))) ::: All students are either smart or hard working.",
            "∃x (Student(x) ∧ Smart(x)) ::: Some students are smart.",
            "∀x (Smart(x) → PassExam(x)) ::: All smart people pass their exams.",
            "∀x (HardWorking(x) → Studies(x)) ::: If someone is hard working, they also study.",
            "∀x (Studies(x) → PassExam(x)) ::: Everyone who studies passes their exams.",
            "¬∀x (Student(x) → (Smart(x) ∨ HardWorking(x))) ::: Not all students are smart or hard working.",
            "∃x (Student(x) ∧ Studies(x)) ::: Some students study."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Smart(x) ::: x is smart",
            "HardWorking(x) ::: x is hard working",
            "PassExam(x) ::: x passes the exam",
            "Studies(x) ::: x studies"
        ]
    },
    {
        "premises-NL": [
            "All people who work hard earn money.",
            "Everyone who earns money buys a car.",
            "Some people work hard.",
            "People who work hard are not lazy.",
            "If someone earns money, then they have money.",
            "People who have money are wealthy.",
            "If someone buys a car, then they own a car.",
            "Some people own a car.",
            "Some people are working hard and earn money."
        ],
        "premises-FOL": [
            "∀x (WorksHard(x) → EarnsMoney(x)) ::: All people who work hard earn money.",
            "∀x (EarnsMoney(x) → BuysCar(x)) ::: Everyone who earns money buys a car.",
            "∃x WorksHard(x) ::: Some people work hard.",
            "∀x (WorksHard(x) → ¬Lazy(x)) ::: People who work hard are not lazy.",
            "∀x (EarnsMoney(x) → HasMoney(x)) ::: If someone earns money, then they have money.",
            "∀x (HasMoney(x) → Wealthy(x)) ::: People who have money are wealthy.",
            "∀x (BuysCar(x) → OwnsCar(x)) ::: If someone buys a car, then they own a car.",
            "∃x OwnsCar(x) ::: Some people own a car.",
            "∃x (WorksHard(x) ∧ EarnsMoney(x)) ::: Some people are working hard and earn money."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "OwnsCar(x) ::: x owns a car",
            "Wealthy(x) ::: x is wealthy",
            "Lazy(x) ::: x is lazy",
            "WorksHard(x) ::: x works hard",
            "EarnsMoney(x) ::: x earns money",
            "IfSomeoneWorksHard(x) ::: If someone works hard.",
            "HasMoney(x) ::: x has money",
            "BuysCar(x) ::: x buys a car"
        ]
    },
    {
        "premises-NL": [
            "Every student either eats fruit or drinks juice.",
            "All people who eat fruit are healthy.",
            "Some students drink juice.",
            "Healthy people like fruits.",
            "If someone likes fruits, they like apples or oranges.",
            "All students study hard.",
            "Everyone who studies hard passes their exams.",
            "If someone passes their exams, they eat fruits.",
            "If someone eats fruits, they either eat apples.",
            "Some students eat fruits."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (EatsFruit(x) ∨ DrinksJuice(x))) ::: Every student either eats fruit or drinks juice.",
            "∀x (EatsFruit(x) → IsHealthy(x)) ::: All people who eat fruit are healthy.",
            "∃x (Student(x) ∧ DrinksJuice(x)) ::: Some students drink juice.",
            "∀x (IsHealthy(x) → LikesFruits(x)) ::: Healthy people like fruits.",
            "∀x (LikesFruits(x) → (LikesApples(x) ∨ LikesOranges(x))) ::: If someone likes fruits, they like apples or oranges.",
            "∀x (Student(x) → StudiesHard(x)) ::: All students study hard.",
            "∀x (StudiesHard(x) → PassesExam(x)) ::: Everyone who studies hard passes their exams.",
            "∀x (PassesExam(x) → EatsFruit(x)) ::: If someone passes their exams, they eat fruits.",
            "∀x (EatsFruit(x) → EatsApples(x)) ::: If someone eats fruits, they either eat apples.",
            "∃x (Student(x) ∧ EatsFruit(x)) ::: Some students eat fruits."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "LikesApples(x) ::: x likes apples",
            "LikesOranges(x) ::: x likes oranges",
            "EatsFruit(x) ::: x eats fruit",
            "IsHealthy(x) ::: x is healthy",
            "DrinksJuice(x) ::: x drinks juice",
            "StudiesHard(x) ::: x studies hard",
            "PassesExam(x) ::: x passes the exam",
            "LikesFruits(x) ::: x likes fruits",
            "EatsApples(x) ::: x eats apples"
        ]
    },
    {
        "premises-NL": [
            "All scientists either publish papers or do research.",
            "Everyone who publishes papers attends conferences.",
            "All people who attend conferences have a successful career.",
            "Some scientists are lazy.",
            "People who have a successful career work hard.",
            "If someone works hard, they are not lazy.",
            "Some scientists do research and receive grants.",
            "If someone receives grants, they write articles.",
            "If someone writes articles, then they publish papers.",
            "If someone does research and they work hard, they are successful in their career.",
            "If someone attends seminars and presents work, then they work hard."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → (PublishesPapers(x) ∨ DoesResearch(x))) ::: All scientists either publish papers or do research.",
            "∀x (PublishesPapers(x) → AttendsConferences(x)) ::: Everyone who publishes papers attends conferences.",
            "∀x (AttendsConferences(x) → SuccessfulCareer(x)) ::: All people who attend conferences have a successful career.",
            "∃x (Scientist(x) ∧ Lazy(x)) ::: Some scientists are lazy.",
            "∀x (SuccessfulCareer(x) → WorksHard(x)) ::: People who have a successful career work hard.",
            "∀x (WorksHard(x) → ¬Lazy(x)) ::: If someone works hard, they are not lazy.",
            "∃x (Scientist(x) ∧ DoesResearch(x) ∧ ReceivesGrants(x)) ::: Some scientists do research and receive grants.",
            "∀x (ReceivesGrants(x) → WritesArticles(x)) ::: If someone receives grants, they write articles.",
            "∀x (WritesArticles(x) → PublishesPapers(x)) ::: If someone writes articles, then they publish papers.",
            "∀x ∀y ((DoesResearch(x) ∧ WorksHard(x)) → SuccessfulCareer(x)) ::: If someone does research and they work hard, they are successful in their career.",
            "∀x ∀y ((AttendsSeminars(x) ∧ PresentsWork(x)) → WorksHard(x)) ::: If someone attends seminars and presents work, then they work hard."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "PublishesPapers(x) ::: x publishes papers",
            "DoesResearch(x) ::: x does research",
            "AttendsConferences(x) ::: x attends conferences",
            "SuccessfulCareer(x) ::: x has a successful career",
            "Lazy(x) ::: x is lazy",
            "WorksHard(x) ::: x works hard",
            "ReceivesGrants(x) ::: x receives grants",
            "WritesArticles(x) ::: x writes articles",
            "AttendsSeminars(x) ::: x attends seminars",
            "PresentsWork(x) ::: x presents work"
        ]
    },
    {
        "premises-NL": [
            "David enjoys chess and science.",
            "Everyone who enjoys chess is a member of the chess club.",
            "Everyone who enjoys science is a member of the science club.",
            "Chess is a club.",
            "Science is a club.",
            "David enjoys chess.",
            "David enjoys science.",
            "If someone enjoys something, they belong to a club.",
            "David is a member of either the chess club or the science club.",
            "David is not a member of the chess club.",
            "If someone is a member of chessClub, then they enjoy chess.",
            "∀x (MemberOf(x, chessClub) ↔ Enjoys(x, chess)) ::: If someone is a member of chessClub, then they enjoy chess.",
            "∀x (MemberOf(x, scienceClub) ↔ Enjoys(x, science)) ::: If someone is a member of scienceClub, then they enjoy science."
        ],
        "premises-FOL": [
            "Enjoys(david, chess) ∧ Enjoys(david, science) ::: David enjoys chess and science.",
            "∀x (Enjoys(x, chess) → MemberOf(x, chessClub)) ::: Everyone who enjoys chess is a member of the chess club.",
            "∀x (Enjoys(x, science) → MemberOf(x, scienceClub)) ::: Everyone who enjoys science is a member of the science club.",
            "Club(chessClub) ::: Chess is a club.",
            "Club(scienceClub) ::: Science is a club.",
            "Enjoys(david, chess) ::: David enjoys chess.",
            "Enjoys(david, science) ::: David enjoys science.",
            "∀x ∃y (Enjoys(x, y) → MemberOf(x, y)) ::: If someone enjoys something, they belong to a club.",
            "MemberOf(david, chessClub) ∨ MemberOf(david, scienceClub) ::: David is a member of either the chess club or the science club.",
            "¬MemberOf(david, chessClub) ::: David is not a member of the chess club.",
            "∀x (MemberOf(x, chessClub) → Enjoys(x, chess)) ::: If someone is a member of chessClub, then they enjoy chess.",
            "∀x (MemberOf(x, chessClub) ↔ Enjoys(x, chess)) ::: If someone is a member of chessClub, then they enjoy chess.",
            "∀x (MemberOf(x, scienceClub) ↔ Enjoys(x, science)) ::: If someone is a member of scienceClub, then they enjoy science."
        ],
        "predicates": [
            "MemberOf(x, y) ::: x is a member of y",
            "Enjoys(x, y) ::: x enjoys y",
            "Club(x) ::: x is a club"
        ]
    },
    {
        "premises-NL": [
            "All doctors are educated.",
            "If someone is educated, they have a degree.",
            "Anyone who has a degree can practice medicine.",
            "If a person is practicing medicine, they are helping people.",
            "John is a doctor.",
            "John is practicing medicine.",
            "Mary is a patient.",
            "Mary needs medical attention.",
            "If someone is a doctor, they are educated.",
            "If John is a doctor, he is practicing medicine.",
            "If Mary needs medical attention and is a patient then the doctor must practice medicine."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Educated(x)) ::: All doctors are educated.",
            "∀x (Educated(x) → HasDegree(x)) ::: If someone is educated, they have a degree.",
            "∀x (HasDegree(x) → CanPractice(x)) ::: Anyone who has a degree can practice medicine.",
            "∀x (PracticingMedicine(x) → HelpsPeople(x)) ::: If a person is practicing medicine, they are helping people.",
            "Doctor(john) ::: John is a doctor.",
            "PracticingMedicine(john) ::: John is practicing medicine.",
            "Patient(mary) ::: Mary is a patient.",
            "NeedsMedicalAttention(mary) ::: Mary needs medical attention.",
            "Doctor(x) → Educated(x) ::: If someone is a doctor, they are educated.",
            "Doctor(john) → PracticingMedicine(john) ::: If John is a doctor, he is practicing medicine.",
            "NeedsMedicalAttention(mary) ∧ Patient(mary) → PracticingMedicine(x) ::: If Mary needs medical attention and is a patient then the doctor must practice medicine."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "PracticingMedicine(x) ::: x is practicing medicine",
            "HelpsPeople(x) ::: x helps people",
            "Patient(x) ::: x is a patient"
        ]
    },
    {
        "premises-NL": [
            "If someone has a high income, they can save.",
            "If someone saves money, they will become wealthy.",
            "John has a high income.",
            "If someone does not save, they spend.",
            "Mary has a high income and saves money.",
            "If someone spends money and doesn't save, then they are not wealthy.",
            "If someone saves money, they own property.",
            "If someone has a high income, they are able to save money.",
            "If someone saves money and has a high income then they will be wealthy.",
            "If someone owns property, they will be wealthy.",
            "John and Mary both have high incomes.",
            "John and Mary save money.",
            "If you have a high income then you can save."
        ],
        "premises-FOL": [
            "∀x (HasHighIncome(x) → SavesMoney(x)) ::: If someone has a high income, they can save.",
            "∀x (SavesMoney(x) → WillBeWealthy(x)) ::: If someone saves money, they will become wealthy.",
            "HasHighIncome(john) ::: John has a high income.",
            "∀x (¬SavesMoney(x) → SpendsMoney(x)) ::: If someone does not save, they spend.",
            "HasHighIncome(mary) ∧ SavesMoney(mary) ::: Mary has a high income and saves money.",
            "∀x (SpendsMoney(x) ∧ ¬SavesMoney(x) → ¬WillBeWealthy(x)) ::: If someone spends money and doesn't save, then they are not wealthy.",
            "∀x (SavesMoney(x) → OwnsProperty(x)) ::: If someone saves money, they own property.",
            "∀x (HasHighIncome(x) → SavesMoney(x)) ::: If someone has a high income, they are able to save money.",
            "∀x (SavesMoney(x) ∧ HasHighIncome(x) → WillBeWealthy(x)) ::: If someone saves money and has a high income then they will be wealthy.",
            "∀x (OwnsProperty(x) → WillBeWealthy(x)) ::: If someone owns property, they will be wealthy.",
            "HasHighIncome(john) ∧ HasHighIncome(mary) ::: John and Mary both have high incomes.",
            "SavesMoney(john) ∧ SavesMoney(mary) ::: John and Mary save money.",
            "∀x (HasHighIncome(x) → SavesMoney(x)) ::: If you have a high income then you can save."
        ],
        "predicates": [
            "HasHighIncome(x) ::: x has a high income",
            "SavesMoney(x) ::: x saves money",
            "WillBeWealthy(x) ::: x will be wealthy",
            "SpendsMoney(x) ::: x spends money",
            "OwnsProperty(x) ::: x owns property"
        ]
    },
    {
        "premises-NL": [
            "If someone has an illness, they should see a doctor.",
            "If someone sees a doctor, they are likely to take medication.",
            "If a person takes medication, their condition will improve.",
            "John has an illness.",
            "If John has an illness, he sees a doctor.",
            "If John sees a doctor, he takes medication.",
            "Mary does not feel pain.",
            "If someone takes medication and has an illness, their condition will improve.",
            "If someone does not feel pain, they are healthy.",
            "Mary does not have an illness.",
            "If someone feels pain they see a doctor.",
            "If someone sees the doctor and has an illness then they must take medication.",
            "If someone has an illness and takes medication their condition improves.",
            "People who see doctors and take medication will have their condition improved."
        ],
        "premises-FOL": [
            "∀x (HasIllness(x) → SeesDoctor(x)) ::: If someone has an illness, they should see a doctor.",
            "∀x (SeesDoctor(x) → TakesMedication(x)) ::: If someone sees a doctor, they are likely to take medication.",
            "∀x (TakesMedication(x) → ConditionImproves(x)) ::: If a person takes medication, their condition will improve.",
            "HasIllness(john) ::: John has an illness.",
            "HasIllness(john) → SeesDoctor(john) ::: If John has an illness, he sees a doctor.",
            "SeesDoctor(john) → TakesMedication(john) ::: If John sees a doctor, he takes medication.",
            "¬FeelsPain(mary) ::: Mary does not feel pain.",
            "∀x (TakesMedication(x) ∧ HasIllness(x) → ConditionImproves(x)) ::: If someone takes medication and has an illness, their condition will improve.",
            "∀x (¬FeelsPain(x) → Healthy(x)) ::: If someone does not feel pain, they are healthy.",
            "¬HasIllness(mary) ::: Mary does not have an illness.",
            "∀x (FeelsPain(x) → SeesDoctor(x)) ::: If someone feels pain they see a doctor.",
            "∀x (SeesDoctor(x) ∧ HasIllness(x) → TakesMedication(x)) ::: If someone sees the doctor and has an illness then they must take medication.",
            "∀x (HasIllness(x) ∧ TakesMedication(x) → ConditionImproves(x)) ::: If someone has an illness and takes medication their condition improves.",
            "∀x (SeesDoctor(x) ∧ TakesMedication(x) → ConditionImproves(x)) ::: People who see doctors and take medication will have their condition improved."
        ],
        "predicates": [
            "TakesMedication(x) ::: x takes medication",
            "HasIllness(x) ::: x has an illness",
            "ConditionImproves(x) ::: x's condition improves",
            "SeesDoctor(x) ::: x sees a doctor",
            "FeelsPain(x) ::: x feels pain"
        ]
    },
    {
        "premises-NL": [
            "All students attend classes.",
            "If a student attends classes and does assignments, they will succeed in their studies.",
            "John is a student.",
            "If someone is a student, they read textbooks.",
            "If John attends classes and reads textbooks then he participates in discussions.",
            "If someone reads textbooks and participates in discussions, they will succeed.",
            "Mary is a student.",
            "Mary does the assignments.",
            "If someone does the assignments and succeeds in their studies, they pass exams.",
            "If someone passes exams, they will succeed.",
            "If someone attends classes, they do assignments.",
            "If someone studies and attends classes, they do assignments.",
            "John and Mary are students.",
            "If someone attends classes then they read textbooks.",
            "If John studies then he will succeed in his studies."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClasses(x)) ::: All students attend classes.",
            "∀x (AttendsClasses(x) ∧ DoesAssignments(x) → SucceedsInStudies(x)) ::: If a student attends classes and does assignments, they will succeed in their studies.",
            "Student(john) ::: John is a student.",
            "∀x (Student(x) → ReadsTextbooks(x)) ::: If someone is a student, they read textbooks.",
            "AttendsClasses(john) ∧ ReadsTextbooks(john) → ParticipatesInDiscussions(john) ::: If John attends classes and reads textbooks then he participates in discussions.",
            "∀x (ReadsTextbooks(x) ∧ ParticipatesInDiscussions(x) → SucceedsInStudies(x)) ::: If someone reads textbooks and participates in discussions, they will succeed.",
            "Student(mary) ::: Mary is a student.",
            "DoesAssignments(mary) ::: Mary does the assignments.",
            "∀x (DoesAssignments(x) ∧ SucceedsInStudies(x) → PassesExams(x)) ::: If someone does the assignments and succeeds in their studies, they pass exams.",
            "∀x (PassesExams(x) → SucceedsInStudies(x)) ::: If someone passes exams, they will succeed.",
            "∀x (AttendsClasses(x) → DoesAssignments(x)) ::: If someone attends classes, they do assignments.",
            "∀x (Studies(x) ∧ AttendsClasses(x) → DoesAssignments(x)) ::: If someone studies and attends classes, they do assignments.",
            "Student(john) ∧ Student(mary) ::: John and Mary are students.",
            "∀x (AttendsClasses(x) → ReadsTextbooks(x)) ::: If someone attends classes then they read textbooks.",
            "Studies(john) → SucceedsInStudies(john) ::: If John studies then he will succeed in his studies."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsClasses(x) ::: x attends classes",
            "DoesAssignments(x) ::: x does assignments",
            "SucceedsInStudies(x) ::: x succeeds in their studies",
            "ReadsTextbooks(x) ::: x reads textbooks",
            "PassesExams(x) ::: x passes exams",
            "ParticipatesInDiscussions(x) ::: x participates in discussions"
        ]
    },
    {
        "premises-NL": [
            "All students who studied hard passed the exam.",
            "Some students are enrolled in the advanced course.",
            "All students who passed the exam took the exam.",
            "John is a student who studied hard.",
            "John is not enrolled in the advanced course.",
            "All students who took the exam, if they studied hard, passed the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiedHard(x) → PassedExam(x)) ::: All students who studied hard passed the exam.",
            "∃x (Student(x) ∧ EnrolledAdvanced(x)) ::: Some students are enrolled in the advanced course.",
            "∀x (PassedExam(x) → TookExam(x)) ::: All students who passed the exam took the exam.",
            "Student(John) ∧ StudiedHard(John) ::: John is a student who studied hard.",
            "¬EnrolledAdvanced(John) ::: John is not enrolled in the advanced course.",
            "∀x (TookExam(x) ∧ StudiedHard(x) → PassedExam(x)) ::: All students who took the exam, if they studied hard, passed the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PassedExam(x) ::: x passed the exam",
            "EnrolledAdvanced(x) ::: x is enrolled in the advanced course",
            "TookExam(x) ::: x took the exam",
            "StudiedHard(x) ::: x studied hard"
        ]
    },
    {
        "premises-NL": [
            "All famous artists are artists.",
            "Van Gogh is a famous artist.",
            "Van Gogh creates Starry Night.",
            "All works created by an artist are works.",
            "If something is a work and is created by an artist then that work is exhibited by the artist.",
            "Starry Night is a work."
        ],
        "premises-FOL": [
            "∀x (FamousArtist(x) → Artist(x)) ::: If something is a famous artist, then it is an artist.",
            "FamousArtist(VanGogh) ::: Van Gogh is a famous artist.",
            "Creates(VanGogh, StarryNight) ::: Van Gogh creates Starry Night.",
            "∀x ∀y ((Creates(x, y) ∧ Artist(x)) → Work(y)) ::: If an artist creates something, it's a work.",
            "∀x ∀y ((Work(x) ∧ Creates(y, x)) → Exhibited(x, y)) ::: If a work is created by an artist, it is exhibited by the artist.",
            "Work(StarryNight) ::: Starry Night is a work."
        ],
        "predicates": [
            "Artist(x) ::: x is an artist",
            "Work(x) ::: x is a work",
            "Exhibited(x, y) ::: x is exhibited by y",
            "Creates(x, y) ::: x creates y",
            "Famous(x) ::: x is famous"
        ]
    },
    {
        "premises-NL": [
            "All students study.",
            "David is a student.",
            "Anyone who studies passes an exam.",
            "David likes books.",
            "Anyone who likes something has it.",
            "David is smart.",
            "If someone is smart, they study.",
            "All those who study pass the exam.",
            "Everyone who likes books has a book.",
            "If David studies, then he passes an exam.",
            "David studies or likes books.",
            "If someone has a book, they study or are smart.",
            "David studies and likes books.",
            "If David studies, then he's smart and passes an exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Studies(x)) ::: All students study.",
            "Student(david) ::: David is a student.",
            "∀x (Studies(x) → PassesExam(x)) ::: Anyone who studies passes an exam.",
            "Likes(david, book) ::: David likes books.",
            "∀x ∃y (Likes(x, y) → HasBook(x)) ::: Anyone who likes something has it.",
            "Smart(david) ::: David is smart.",
            "∀x (Smart(x) → Studies(x)) ::: If someone is smart, they study.",
            "∀x (Studies(x) → PassesExam(x)) ::: All those who study pass the exam.",
            "∀x ∃y (Likes(x, y) → HasBook(x)) ::: Everyone who likes books has a book.",
            "Studies(david) → PassesExam(david) ::: If David studies, then he passes an exam.",
            "Studies(david) ∨ Likes(david, book) ::: David studies or likes books.",
            "∀x (HasBook(x) → (Studies(x) ∨ Smart(x))) ::: If someone has a book, they study or are smart.",
            "Studies(david) ∧ Likes(david, book) ::: David studies and likes books.",
            "Studies(david) → (Smart(david) ∧ PassesExam(david)) ::: If David studies, then he's smart and passes an exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "PassesExam(x) ::: x passes an exam",
            "Likes(x, y) ::: x likes y",
            "HasBook(x) ::: x has a book",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All vaccinated people are healthy.",
            "Some people are vaccinated.",
            "Anyone with the flu has a fever.",
            "No one with a fever is healthy.",
            "Everyone is either sick or healthy.",
            "All doctors work at a hospital.",
            "Some doctors are vaccinated.",
            "Some people are sick and have a fever.",
            "Anyone who works at the hospital has the flu or is healthy.",
            "Everyone who eats well is healthy.",
            "Some healthy people are not vaccinated.",
            "David is vaccinated.",
            "If someone has the flu they are sick.",
            "Some doctors eat well.",
            "Some people are not sick and eat well."
        ],
        "premises-FOL": [
            "∀x (Vaccinated(x) → Healthy(x)) ::: All vaccinated people are healthy.",
            "∃x Vaccinated(x) ::: Some people are vaccinated.",
            "∀x (HasFlu(x) → Fever(x)) ::: Anyone with the flu has a fever.",
            "∀x (Fever(x) → ¬Healthy(x)) ::: No one with a fever is healthy.",
            "∀x (Sick(x) ∨ Healthy(x)) ::: Everyone is either sick or healthy.",
            "∀x (IsDoctor(x) → WorksAtHospital(x)) ::: All doctors work at a hospital.",
            "∃x (IsDoctor(x) ∧ Vaccinated(x)) ::: Some doctors are vaccinated.",
            "∃x (Sick(x) ∧ Fever(x)) ::: Some people are sick and have a fever.",
            "∀x (WorksAtHospital(x) → (HasFlu(x) ∨ Healthy(x))) ::: Anyone who works at the hospital has the flu or is healthy.",
            "∀x (EatsWell(x) → Healthy(x)) ::: Everyone who eats well is healthy.",
            "∃x (Healthy(x) ∧ ¬Vaccinated(x)) ::: Some healthy people are not vaccinated.",
            "Vaccinated(david) ::: David is vaccinated.",
            "∀x (HasFlu(x) → Sick(x)) ::: If someone has the flu they are sick.",
            "∃x (IsDoctor(x) ∧ EatsWell(x)) ::: Some doctors eat well.",
            "∃x (¬Sick(x) ∧ EatsWell(x)) ::: Some people are not sick and eat well."
        ],
        "predicates": [
            "Healthy(x) ::: x is healthy",
            "HasFlu(x) ::: x has the flu",
            "Vaccinated(x) ::: x is vaccinated",
            "Fever(x) ::: x has a fever",
            "Sick(x) ::: x is sick",
            "WorksAtHospital(x) ::: x works at a hospital",
            "IsDoctor(x) ::: x is a doctor",
            "EatsWell(x) ::: x eats well"
        ]
    },
    {
        "premises-NL": [
            "All teachers enjoy teaching.",
            "Some students are smart.",
            "All smart people like books.",
            "Some people with degrees are teachers.",
            "All teachers attend lectures.",
            "Anyone who likes books reads books.",
            "Anyone who studies hard is smart.",
            "All those who attend lectures are teachers.",
            "Anyone who is a teacher enjoys teaching.",
            "David is a student.",
            "David doesn't study hard.",
            "Some who don't study hard are students.",
            "Some students don't attend lectures.",
            "Someone enjoys teaching but is not a teacher.",
            "All teachers have degrees.",
            "All teachers read books."
        ],
        "premises-FOL": [
            "∀x (Teacher(x) → EnjoysTeaching(x)) ::: All teachers enjoy teaching.",
            "∃x (Student(x) ∧ Smart(x)) ::: Some students are smart.",
            "∀x (Smart(x) → LikesBooks(x)) ::: All smart people like books.",
            "∃x (HasDegree(x) ∧ Teacher(x)) ::: Some people with degrees are teachers.",
            "∀x (Teacher(x) → AttendsLecture(x)) ::: All teachers attend lectures.",
            "∀x (LikesBooks(x) → ReadsBooks(x)) ::: Anyone who likes books reads books.",
            "∀x (StudiesHard(x) → Smart(x)) ::: Anyone who studies hard is smart.",
            "∀x (AttendsLecture(x) → Teacher(x)) ::: All those who attend lectures are teachers.",
            "∀x (Teacher(x) → EnjoysTeaching(x)) ::: Anyone who is a teacher enjoys teaching.",
            "Student(david) ::: David is a student.",
            "¬StudiesHard(david) ::: David doesn't study hard.",
            "∃x (¬StudiesHard(x) ∧ Student(x)) ::: Some who don't study hard are students.",
            "∃x (Student(x) ∧ ¬AttendsLecture(x)) ::: Some students don't attend lectures.",
            "∃x (EnjoysTeaching(x) ∧ ¬Teacher(x)) ::: Someone enjoys teaching but is not a teacher.",
            "∀x (Teacher(x) → HasDegree(x)) ::: All teachers have degrees.",
            "∀x (Teacher(x) → ReadsBooks(x)) ::: All teachers read books."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Teacher(x) ::: x is a teacher",
            "EnjoysTeaching(x) ::: x enjoys teaching",
            "Smart(x) ::: x is smart",
            "LikesBooks(x) ::: x likes books",
            "HasDegree(x) ::: x has a degree",
            "AttendsLecture(x) ::: x attends a lecture",
            "ReadsBooks(x) ::: x reads books",
            "StudiesHard(x) ::: x studies hard"
        ]
    },
    {
        "premises-NL": [
            "All programmers write code.",
            "Some programmers know Java.",
            "Anyone who knows Java uses an IDE.",
            "Anyone who writes code uses an IDE.",
            "All employed people work on a project.",
            "Some programmers are employed.",
            "Anyone who works on a project writes documentation.",
            "All those who use Python write code.",
            "Anyone who writes documentation uses Python.",
            "David is a programmer.",
            "David doesn't use an IDE.",
            "Some programmers don't write code.",
            "Someone who uses Python is a programmer.",
            "All those who write code are programmers.",
            "All those who write documentation are employed.",
            "Some who are employed use Python.",
            "Someone is a programmer and does not write documentation."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → WritesCode(x)) ::: All programmers write code.",
            "∃x (Programmer(x) ∧ KnowsJava(x)) ::: Some programmers know Java.",
            "∀x (KnowsJava(x) → UsesIDE(x)) ::: Anyone who knows Java uses an IDE.",
            "∀x (WritesCode(x) → UsesIDE(x)) ::: Anyone who writes code uses an IDE.",
            "∀x (Employed(x) → WorksOnProject(x)) ::: All employed people work on a project.",
            "∃x (Programmer(x) ∧ Employed(x)) ::: Some programmers are employed.",
            "∀x (WorksOnProject(x) → WritesDocumentation(x)) ::: Anyone who works on a project writes documentation.",
            "∀x (UsesPython(x) → WritesCode(x)) ::: All those who use Python write code.",
            "∀x (WritesDocumentation(x) → UsesPython(x)) ::: Anyone who writes documentation uses Python.",
            "Programmer(david) ::: David is a programmer.",
            "¬UsesIDE(david) ::: David doesn't use an IDE.",
            "∃x (Programmer(x) ∧ ¬WritesCode(x)) ::: Some programmers don't write code.",
            "∃x (UsesPython(x) ∧ Programmer(x)) ::: Someone who uses Python is a programmer.",
            "∀x (WritesCode(x) → Programmer(x)) ::: All those who write code are programmers.",
            "∀x (WritesDocumentation(x) → Employed(x)) ::: All those who write documentation are employed.",
            "∃x (Employed(x) ∧ UsesPython(x)) ::: Some who are employed use Python.",
            "∃x (Programmer(x) ∧ ¬WritesDocumentation(x)) ::: Someone is a programmer and does not write documentation."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "UsesPython(x) ::: x uses Python",
            "KnowsJava(x) ::: x knows Java",
            "WritesCode(x) ::: x writes code",
            "UsesIDE(x) ::: x uses an IDE",
            "IsEmployed(x) ::: x is employed",
            "WorksOnProject(x) ::: x works on a project",
            "WritesDocumentation(x) ::: x writes documentation"
        ]
    },
    {
        "premises-NL": [
            "All people who have a pet are happy.",
            "Some people who live in the city have a pet.",
            "Anyone who is happy likes to travel.",
            "Anyone who owns a car lives in the city.",
            "All people who enjoy movies read books.",
            "Some people like to travel but don't live in a city.",
            "David has a pet.",
            "Anyone who reads books likes to travel.",
            "All people who own a car go to the park.",
            "Anyone who goes to the park has a pet or likes to travel.",
            "Some who live in the city don't own a car.",
            "Someone who owns a car likes to travel.",
            "Some people are happy and don't live in the city.",
            "Some people do not have a pet and read books.",
            "Some who go to the park are not happy.",
            "Some who are happy go to the park.",
            "Someone who likes to travel does not own a car.",
            "Some who read books do not enjoy movies."
        ],
        "premises-FOL": [
            "∀x (HasPet(x) → IsHappy(x)) ::: All people who have a pet are happy.",
            "∃x (LivesInCity(x) ∧ HasPet(x)) ::: Some people who live in the city have a pet.",
            "∀x (IsHappy(x) → LikesToTravel(x)) ::: Anyone who is happy likes to travel.",
            "∀x (OwnsCar(x) → LivesInCity(x)) ::: Anyone who owns a car lives in the city.",
            "∀x (EnjoysMovies(x) → ReadsBooks(x)) ::: All people who enjoy movies read books.",
            "∃x (LikesToTravel(x) ∧ ¬LivesInCity(x)) ::: Some people like to travel but don't live in a city.",
            "HasPet(david) ::: David has a pet.",
            "∀x (ReadsBooks(x) → LikesToTravel(x)) ::: Anyone who reads books likes to travel.",
            "∀x (OwnsCar(x) → GoesToPark(x)) ::: All people who own a car go to the park.",
            "∀x (GoesToPark(x) → (HasPet(x) ∨ LikesToTravel(x))) ::: Anyone who goes to the park has a pet or likes to travel.",
            "∃x (LivesInCity(x) ∧ ¬OwnsCar(x)) ::: Some who live in the city don't own a car.",
            "∃x (OwnsCar(x) ∧ LikesToTravel(x)) ::: Someone who owns a car likes to travel.",
            "∃x (IsHappy(x) ∧ ¬LivesInCity(x)) ::: Some people are happy and don't live in the city.",
            "∃x (¬HasPet(x) ∧ ReadsBooks(x)) ::: Some people do not have a pet and read books.",
            "∃x (GoesToPark(x) ∧ ¬IsHappy(x)) ::: Some who go to the park are not happy.",
            "∃x (IsHappy(x) ∧ GoesToPark(x)) ::: Some who are happy go to the park.",
            "∃x (LikesToTravel(x) ∧ ¬OwnsCar(x)) ::: Someone who likes to travel does not own a car.",
            "∃x (ReadsBooks(x) ∧ ¬EnjoysMovies(x)) ::: Some who read books do not enjoy movies."
        ],
        "predicates": [
            "HasPet(x) ::: x has a pet",
            "LikesToTravel(x) ::: x likes to travel",
            "LivesInCity(x) ::: x lives in the city",
            "IsHappy(x) ::: x is happy",
            "OwnsCar(x) ::: x owns a car",
            "EnjoysMovies(x) ::: x enjoys movies",
            "ReadsBooks(x) ::: x reads books",
            "GoesToPark(x) ::: x goes to the park"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are specialists.",
            "All surgeons are doctors.",
            "Some doctors treat patients.",
            "Anyone who treats a patient is a doctor.",
            "Some doctors are surgeons.",
            "If someone is a specialist, then they provide advanced care.",
            "If someone provides advanced care, then they are highly trained.",
            "Some doctors are not highly trained.",
            "Some doctors are not specialists."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Specialist(x)) ::: All surgeons are specialists.",
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∃x ∃y (Doctor(x) ∧ Treats(x, y) ∧ Patient(y)) ::: Some doctors treat patients.",
            "∀x ∀y (Treats(x, y) → Doctor(x)) ::: Anyone who treats a patient is a doctor.",
            "∃x (Doctor(x) ∧ Surgeon(x)) ::: Some doctors are surgeons.",
            "∀x (Specialist(x) → ProvidesAdvancedCare(x)) ::: If someone is a specialist, then they provide advanced care.",
            "∀x (ProvidesAdvancedCare(x) → HighlyTrained(x)) ::: If someone provides advanced care, then they are highly trained.",
            "∃x (Doctor(x) ∧ ¬HighlyTrained(x)) ::: Some doctors are not highly trained.",
            "∃x (Doctor(x) ∧ ¬Specialist(x)) ::: Some doctors are not specialists."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Specialist(x) ::: x is a specialist.",
            "Surgeon(x) ::: x is a surgeon.",
            "Treats(x, y) ::: x treats y.",
            "Patient(x) ::: x is a patient."
        ]
    },
    {
        "premises-NL": [
            "All project leads are managers.",
            "All project leads are experienced.",
            "Some employees are supervised by managers.",
            "Everyone who supervises is a manager.",
            "If someone is a project lead, then they are experienced.",
            "Some managers supervise employees who lack experience.",
            "Some managers supervise employees.",
            "All experienced managers are good at their job.",
            "If someone is good at their job, they are respected.",
            "No manager who is respected is inexperienced."
        ],
        "premises-FOL": [
            "∀x (ProjectLead(x) → Manager(x)) ::: All project leads are managers.",
            "∀x (ProjectLead(x) → Experienced(x)) ::: All project leads are experienced.",
            "∃x ∃y (Manager(x) ∧ Supervises(x, y) ∧ Employee(y)) ::: Some employees are supervised by managers.",
            "∀x ∀y (Supervises(x, y) → Manager(x)) ::: Everyone who supervises is a manager.",
            "∀x (ProjectLead(x) → Experienced(x)) ::: If someone is a project lead, then they are experienced.",
            "∃x ∃y (Manager(x) ∧ Supervises(x, y) ∧ ¬Experienced(y)) ::: Some managers supervise employees who lack experience.",
            "∃x ∃y (Manager(x) ∧ Supervises(x, y)) ::: Some managers supervise employees.",
            "∀x (Experienced(x) ∧ Manager(x) → GoodAtJob(x)) ::: All experienced managers are good at their job.",
            "∀x (GoodAtJob(x) → Respected(x)) ::: If someone is good at their job, they are respected.",
            "∀x (Respected(x) → Experienced(x)) ::: No manager who is respected is inexperienced."
        ],
        "predicates": [
            "Manager(x) ::: x is a manager.",
            "Experienced(x) ::: x is experienced.",
            "Supervises(x, y) ::: x supervises y.",
            "Employee(x) ::: x is an employee.",
            "ProjectLead(x) ::: x is a project lead."
        ]
    },
    {
        "premises-NL": [
            "All doctors are people.",
            "All researchers are people.",
            "Some people study medicine.",
            "Anyone who studies medicine is either a doctor or a researcher.",
            "John studies medicine."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Person(x)) ::: All doctors are people.",
            "∀x (Researcher(x) → Person(x)) ::: All researchers are people.",
            "∃x StudiesMedicine(x) ::: Some people study medicine.",
            "∀x (StudiesMedicine(x) → (Doctor(x) ∨ Researcher(x))) ::: Anyone who studies medicine is either a doctor or a researcher.",
            "StudiesMedicine(john) ::: John studies medicine."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "Doctor(x) ::: x is a doctor.",
            "Researcher(x) ::: x is a researcher.",
            "StudiesMedicine(x) ::: x studies medicine."
        ]
    },
    {
        "premises-NL": [
            "All sports cars are cars.",
            "All sports cars are fast.",
            "Some red cars are sports cars.",
            "If something is a car and is red, then it is expensive.",
            "Expensive cars are fast.",
            "Some cars are red.",
            "If something is owned by a person, it is a car.",
            "All sports cars are owned by someone.",
            "All expensive cars are owned by someone.",
            "John owns a car.",
            "John is a person.",
            "All red cars are expensive.",
            "There are cars."
        ],
        "premises-FOL": [
            "∀x (SportsCar(x) → Car(x)) ::: For all x, if x is a sports car, then x is a car.",
            "∀x (SportsCar(x) → Fast(x)) ::: For all x, if x is a sports car, then x is fast.",
            "∃x (Car(x) ∧ Red(x) ∧ SportsCar(x)) ::: There exists an x such that x is a car, x is red and x is a sports car.",
            "∀x (Car(x) ∧ Red(x) → Expensive(x)) ::: For all x, if x is a car and x is red, then x is expensive.",
            "∀x (Expensive(x) → Fast(x)) ::: For all x, if x is expensive, then x is fast.",
            "∃x (Car(x) ∧ Red(x)) ::: There exists a car that is red.",
            "∀x ∃y (OwnedBy(x, y) → Car(x)) ::: For all x, if x is owned by a person, then it is a car.",
            "∀x ∃y (SportsCar(x) → OwnedBy(x, y)) ::: For all x, if x is a sports car, then there exists a y such that x is owned by y.",
            "∀x ∃y (Expensive(x) → OwnedBy(x, y)) ::: For all x, if x is expensive, then there exists a y such that x is owned by y.",
            "∃x (Car(x) ∧ OwnedBy(x, John)) ::: John owns a car.",
            "Person(John) ::: John is a person.",
            "∀x (Car(x) ∧ Red(x) → Expensive(x)) ::: For all x, if x is a car and is red, then x is expensive.",
            "∃x Car(x) ::: There is a car."
        ],
        "predicates": [
            "Car(x) ::: x is a car.",
            "Red(x) ::: x is red.",
            "Fast(x) ::: x is fast.",
            "Expensive(x) ::: x is expensive.",
            "SportsCar(x) ::: x is a sports car.",
            "Color(x, y) ::: The color of x is y.",
            "OwnedBy(x, y) ::: x is owned by y.",
            "Person(x) ::: x is a person."
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All surgeons are skilled.",
            "John is a surgeon.",
            "If someone is a surgeon, they practice surgery.",
            "John practices surgery.",
            "If someone is a doctor and is skilled, they are helpful.",
            "John is helpful."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Surgeon(x) → Skilled(x)) ::: All surgeons are skilled.",
            "Surgeon(john) ::: John is a surgeon.",
            "∀x (Surgeon(x) → PracticesSurgery(x)) ::: If someone is a surgeon, they practice surgery.",
            "PracticesSurgery(john) ::: John practices surgery.",
            "∀x ((Doctor(x) ∧ Skilled(x)) → Helpful(x)) ::: If someone is a doctor and is skilled, they are helpful.",
            "Helpful(john) ::: John is helpful."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "Skilled(x) ::: x is skilled",
            "PracticesSurgery(x) ::: x practices surgery"
        ]
    },
    {
        "premises-NL": [
            "All students study hard or are lazy.",
            "Some students study hard.",
            "If someone studies hard, they are not lazy.",
            "If someone is smart and takes an exam, they study hard.",
            "All students are either smart or lazy.",
            "John is a student.",
            "John takes an exam.",
            "John is smart."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (StudiesHard(x) ∨ Lazy(x))) ::: All students study hard or are lazy.",
            "∃x (Student(x) ∧ StudiesHard(x)) ::: Some students study hard.",
            "∀x (StudiesHard(x) → ¬Lazy(x)) ::: If someone studies hard, they are not lazy.",
            "∀x ((Smart(x) ∧ TakesExam(x)) → StudiesHard(x)) ::: If someone is smart and takes an exam, they study hard.",
            "∀x (Student(x) → (Smart(x) ∨ Lazy(x))) ::: All students are either smart or lazy.",
            "Student(john) ::: John is a student.",
            "TakesExam(john) ::: John takes an exam.",
            "Smart(john) ::: John is smart."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "Lazy(x) ::: x is lazy",
            "Smart(x) ::: x is smart",
            "TakesExam(x) ::: x takes an exam"
        ]
    },
    {
        "premises-NL": [
            "All cats like milk or chase mice.",
            "Some cats hate dogs.",
            "If something likes milk, then it is friendly.",
            "If something chases mice, then it is not friendly.",
            "All cats are either friendly or hate dogs or chase mice.",
            "Whiskers is a cat.",
            "Whiskers likes milk.",
            "Whiskers is cute.",
            "If Whiskers hates dogs, then Whiskers chases mice."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → (LikesMilk(x) ∨ ChasesMice(x))) ::: All cats like milk or chase mice.",
            "∃x (Cat(x) ∧ HatesDogs(x)) ::: Some cats hate dogs.",
            "∀x (LikesMilk(x) → Friendly(x)) ::: If something likes milk, then it is friendly.",
            "∀x (ChasesMice(x) → ¬Friendly(x)) ::: If something chases mice, then it is not friendly.",
            "∀x (Cat(x) → (Friendly(x) ∨ HatesDogs(x) ∨ ChasesMice(x))) ::: All cats are either friendly or hate dogs or chase mice.",
            "Cat(whiskers) ::: Whiskers is a cat.",
            "LikesMilk(whiskers) ::: Whiskers likes milk.",
            "IsCute(whiskers) ::: Whiskers is cute.",
            "HatesDogs(whiskers) → ChasesMice(whiskers) ::: If Whiskers hates dogs, then Whiskers chases mice."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "LikesMilk(x) ::: x likes milk",
            "Friendly(x) ::: x is friendly",
            "HatesDogs(x) ::: x hates dogs",
            "ChasesMice(x) ::: x chases mice",
            "IsCute(x) ::: x is cute"
        ]
    },
    {
        "premises-NL": [
            "All apples are either red or green.",
            "Some apples are green and tasty.",
            "If something is green, then it is not red.",
            "If something is tasty, then it is not rotten.",
            "All apples are either rotten or tasty.",
            "If something is red, it is not tasty.",
            "GrannySmith is an apple.",
            "If GrannySmith grows on a tree, it is green.",
            "GrannySmith grows on a tree.",
            "If GrannySmith is tasty then it is not rotten."
        ],
        "premises-FOL": [
            "∀x (Apple(x) → (Red(x) ∨ Green(x))) ::: All apples are either red or green.",
            "∃x (Apple(x) ∧ Green(x) ∧ Tasty(x)) ::: Some apples are green and tasty.",
            "∀x (Green(x) → ¬Red(x)) ::: If something is green, then it is not red.",
            "∀x (Tasty(x) → ¬Rotten(x)) ::: If something is tasty, then it is not rotten.",
            "∀x (Apple(x) → (Rotten(x) ∨ Tasty(x))) ::: All apples are either rotten or tasty.",
            "∀x (Red(x) → ¬Tasty(x)) ::: If something is red, it is not tasty.",
            "Apple(grannySmith) ::: GrannySmith is an apple.",
            "GrowsOnTree(grannySmith) → Green(grannySmith) ::: If GrannySmith grows on a tree, it is green.",
            "GrowsOnTree(grannySmith) ::: GrannySmith grows on a tree.",
            "Tasty(grannySmith) → ¬Rotten(grannySmith) ::: If GrannySmith is tasty then it is not rotten."
        ],
        "predicates": [
            "Apple(x) ::: x is an apple",
            "Red(x) ::: x is red",
            "Tasty(x) ::: x is tasty",
            "Green(x) ::: x is green",
            "Rotten(x) ::: x is rotten",
            "Eaten(x) ::: x is eaten",
            "GrowsOnTree(x) ::: x grows on a tree"
        ]
    },
    {
        "premises-NL": [
            "All people who have a cold either take medicine or rest.",
            "Some people who have a cold also feel sick.",
            "If someone feels sick, they do not go to work.",
            "If someone takes medicine, they do not have a fever.",
            "If someone rests, they drink water.",
            "Everyone who drinks water or eats healthy food feels better.",
            "If someone has a fever, they have a cold.",
            "If someone avoids crowds, they are not infected.",
            "If someone is infected, they have a cold.",
            "John has a cold.",
            "If John goes to work, he is infected."
        ],
        "premises-FOL": [
            "∀x (Person(x) ∧ HasCold(x) → (TakesMedicine(x) ∨ Rests(x))) ::: All people who have a cold either take medicine or rest.",
            "∃x (Person(x) ∧ HasCold(x) ∧ FeelsSick(x)) ::: Some people who have a cold also feel sick.",
            "∀x (FeelsSick(x) → ¬GoesToWork(x)) ::: If someone feels sick, they do not go to work.",
            "∀x (TakesMedicine(x) → ¬HasFever(x)) ::: If someone takes medicine, they do not have a fever.",
            "∀x (Rests(x) → DrinksWater(x)) ::: If someone rests, they drink water.",
            "∀x ((DrinksWater(x) ∨ EatsHealthyFood(x)) → FeelsBetter(x)) ::: Everyone who drinks water or eats healthy food feels better.",
            "∀x (HasFever(x) → HasCold(x)) ::: If someone has a fever, they have a cold.",
            "∀x (AvoidsCrowds(x) → ¬IsInfected(x)) ::: If someone avoids crowds, they are not infected.",
            "∀x (IsInfected(x) → HasCold(x)) ::: If someone is infected, they have a cold.",
            "HasCold(john) ::: John has a cold.",
            "GoesToWork(john) → IsInfected(john) ::: If John goes to work, he is infected."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "HasCold(x) ::: x has a cold",
            "TakesMedicine(x) ::: x takes medicine",
            "Rests(x) ::: x rests",
            "FeelsSick(x) ::: x feels sick",
            "GoesToWork(x) ::: x goes to work",
            "HasFever(x) ::: x has a fever",
            "DrinksWater(x) ::: x drinks water",
            "EatsHealthyFood(x) ::: x eats healthy food",
            "AvoidsCrowds(x) ::: x avoids crowds",
            "IsInfected(x) ::: x is infected"
        ]
    },
    {
        "premises-NL": [
            "All students study either math or physics.",
            "John is a student.",
            "If someone studies math, they like science.",
            "If someone studies physics, they like science.",
            "If someone takes a course in math, then they study math.",
            "John takes a course in math.",
            "If someone likes science, then he takes either math or physics.",
            "If someone takes a course in physics then they study physics.",
            "John takes a course in physics.",
            "If someone is a student and they study physics then they like science."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Studies(x, math) ∨ Studies(x, physics))) ::: All students study either math or physics.",
            "Student(john) ::: John is a student.",
            "∀x (Studies(x, math) → Likes(x, science)) ::: If someone studies math, they like science.",
            "∀x (Studies(x, physics) → Likes(x, science)) ::: If someone studies physics, they like science.",
            "∀x ∀y (TakesCourse(x, y) ∧ CourseIs(y, math) → Studies(x, math)) ::: If someone takes a course in math, then they study math.",
            "TakesCourse(john, math) ::: John takes a course in math.",
            "∀x (Likes(x, science) → (TakesCourse(x, math) ∨ TakesCourse(x, physics))) ::: If someone likes science, then he takes either math or physics.",
            "∀x ∀y (TakesCourse(x, y) ∧ CourseIs(y, physics) → Studies(x, physics)) ::: If someone takes a course in physics then they study physics.",
            "TakesCourse(john, physics) ::: John takes a course in physics.",
            "∀x (Student(x) ∧ Studies(x, physics) → Likes(x, science)) ::: If someone is a student and they study physics then they like science."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x, y) ::: x studies y",
            "Likes(x, y) ::: x likes y",
            "TakesCourse(x, y) ::: x takes course y"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard will pass the exam.",
            "Alex is a student.",
            "If Alex is a student and attends class, then Alex studies hard.",
            "If Alex attends class, then Alex is smart.",
            "Alex attends class.",
            "Someone is a student.",
            "Someone studies hard.",
            "All smart students pass the exam.",
            "If someone is a student, then they attend class.",
            "Alex is smart.",
            "If someone is a student and they study hard, then they will pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudyHard(x) → PassExam(x)) ::: All students who study hard will pass the exam.",
            "Student(alex) ::: Alex is a student.",
            "Student(alex) ∧ AttendsClass(alex) → StudyHard(alex) ::: If Alex is a student and attends class, then Alex studies hard.",
            "AttendsClass(alex) → Smart(alex) ::: If Alex attends class, then Alex is smart.",
            "AttendsClass(alex) ::: Alex attends class.",
            "∃x Student(x) ::: Someone is a student.",
            "∃x StudyHard(x) ::: Someone studies hard.",
            "∀x (Smart(x) → PassExam(x)) ::: All smart students pass the exam.",
            "∀x (Student(x) → AttendsClass(x)) ::: If someone is a student, then they attend class.",
            "Smart(alex) ::: Alex is smart.",
            "∀x (Student(x) ∧ StudyHard(x) → PassExam(x)) ::: If someone is a student and they study hard, then they will pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudyHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "Smart(x) ::: x is smart",
            "AttendsClass(x) ::: x attends class"
        ]
    },
    {
        "premises-NL": [
            "Sarah is friends with Michael and Michael is friends with Sarah.",
            "If someone likes someone, then they are friends.",
            "If someone shares an interest with someone, they like that person.",
            "If someone attends an event, they share an interest with someone else.",
            "If two people are friends, they know each other.",
            "Sarah attends event A.",
            "Michael shares an interest with Sarah.",
            "Sarah likes Michael.",
            "Michael attends event A.",
            "Event A exists.",
            "Sarah is a person.",
            "Michael is a person.",
            "If Sarah and Michael share an interest, then they are friends."
        ],
        "premises-FOL": [
            "Friends(sarah, michael) ∧ Friends(michael, sarah) ::: Sarah is friends with Michael and Michael is friends with Sarah.",
            "∀x ∀y (Likes(x, y) → Friends(x, y)) ::: If someone likes someone, then they are friends.",
            "∀x ∀y (SharesInterest(x, y) → Likes(x, y)) ::: If someone shares an interest with someone, they like that person.",
            "∀x ∃y (AttendsEvent(x, y) → SharesInterest(x, z)) ::: If someone attends an event, they share an interest with someone else.",
            "∀x ∀y (Friends(x, y) → Knows(x, y)) ::: If two people are friends, they know each other.",
            "AttendsEvent(sarah, a) ::: Sarah attends event A.",
            "SharesInterest(michael, sarah) ::: Michael shares an interest with Sarah.",
            "Likes(sarah, michael) ::: Sarah likes Michael.",
            "AttendsEvent(michael, a) ::: Michael attends event A.",
            "Event(a) ::: Event A exists.",
            "Person(sarah) ::: Sarah is a person.",
            "Person(michael) ::: Michael is a person.",
            "∀x ∀y (SharesInterest(x, y) → Friends(x, y)) ::: If Sarah and Michael share an interest, then they are friends."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Friends(x, y) ::: x is friends with y",
            "Knows(x, y) ::: x knows y",
            "Likes(x, y) ::: x likes y",
            "SharesInterest(x, y) ::: x and y share an interest",
            "AttendsEvent(x, y) ::: x attends event y",
            "Event(y) ::: y is an event"
        ]
    },
    {
        "premises-NL": [
            "Every tomato is a fruit.",
            "A tomato is red and round.",
            "Every red and round fruit grows on a vine.",
            "If something grows on a vine, it's a vegetable.",
            "Tomatoes are eatable.",
            "All tomatoes are sweet.",
            "The object is a fruit.",
            "The object is red.",
            "The object is round."
        ],
        "premises-FOL": [
            "∀x (Tomato(x) → Fruit(x)) ::: For all x, if x is a tomato, then x is a fruit",
            "∀x (Tomato(x) → Red(x) ∧ Round(x)) ::: For all x, if x is a tomato, then x is red and round",
            "∀x ((Fruit(x) ∧ Red(x) ∧ Round(x)) → GrowsOnVine(x)) ::: For all x, if x is a fruit, red and round, then x grows on a vine",
            "∀x (GrowsOnVine(x) → Vegetable(x)) ::: For all x, if x grows on a vine, then x is a vegetable",
            "∀x (Tomato(x) → Eatable(x)) ::: For all x, if x is a tomato, then x is eatable",
            "∀x (Tomato(x) → Sweet(x)) ::: For all x, if x is a tomato, then x is sweet",
            "Fruit(object) ::: The object is a fruit",
            "Red(object) ::: The object is red",
            "Round(object) ::: The object is round"
        ],
        "predicates": [
            "Fruit(x) ::: x is a fruit",
            "Red(x) ::: x is red",
            "Round(x) ::: x is round",
            "Tomato(x) ::: x is a tomato",
            "Eatable(x) ::: x is eatable",
            "GrowsOnVine(x) ::: x grows on a vine",
            "Sweet(x) ::: x is sweet",
            "Vegetable(x) ::: x is a vegetable"
        ]
    },
    {
        "premises-NL": [
            "All students are diligent.",
            "John is a student.",
            "If John is a student then John is diligent.",
            "If someone is diligent then they succeed.",
            "All who succeed are happy.",
            "Some are happy.",
            "There is no one who fails and is happy.",
            "If someone is not happy then they are sad.",
            "If someone is sad they are not diligent.",
            "Someone is not diligent or someone is not a student.",
            "If someone is not diligent and someone is not a student then they are not diligent.",
            "If someone is not happy then they are sad and diligent.",
            "If someone is sad and diligent they are not a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Diligence(x)) ::: All students are diligent.",
            "Student(john) ::: John is a student.",
            "Student(john) → Diligence(john) ::: If John is a student then John is diligent.",
            "∀x (Diligence(x) → Succeed(x)) ::: If someone is diligent then they succeed.",
            "∀x (Succeed(x) → Happy(x)) ::: All who succeed are happy.",
            "∃x Happy(x) ::: Some are happy.",
            "¬∃x (Fail(x) ∧ Happy(x)) ::: There is no one who fails and is happy.",
            "∀x (¬Happy(x) → Sad(x)) ::: If someone is not happy then they are sad.",
            "∀x (Sad(x) → ¬Diligence(x)) ::: If someone is sad they are not diligent.",
            "¬Diligence(x) ∨ ¬Student(x) ::: Someone is not diligent or someone is not a student.",
            "¬Diligence(x) ∧ ¬Student(x) → ¬Diligence(x) ::: If someone is not diligent and someone is not a student then they are not diligent.",
            "¬Happy(x) → (Sad(x) ∧ Diligence(x)) ::: If someone is not happy then they are sad and diligent.",
            "Sad(x) ∧ Diligence(x) → ¬Student(x) ::: If someone is sad and diligent they are not a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Diligence(x) ::: x is diligent."
        ]
    },
    {
        "premises-NL": [
            "All doctors are skilled.",
            "Every skilled person can heal.",
            "If someone is a doctor then they are skilled.",
            "If someone is skilled then they are healthy.",
            "If someone is healthy then they are not sick.",
            "There is no one who is sick and heals.",
            "If someone is not healthy then they are sick.",
            "If someone is not sick then they are healthy.",
            "If someone is a doctor and is skilled then they are healthy.",
            "If someone is a doctor and not skilled then they are not healthy.",
            "If someone is a doctor and not healthy then they are not sick.",
            "If someone is a doctor and is healthy, then they can heal.",
            "If someone is a doctor or not skilled then they are healthy.",
            "If someone is not a doctor or skilled then they are healthy."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Skilled(x)) ::: All doctors are skilled.",
            "∀x (Skilled(x) → Heals(x)) ::: Every skilled person can heal.",
            "Doctor(x) → Skilled(x) ::: If someone is a doctor then they are skilled.",
            "Skilled(x) → Healthy(x) ::: If someone is skilled then they are healthy.",
            "Healthy(x) → ¬Sick(x) ::: If someone is healthy then they are not sick.",
            "¬∃x (Sick(x) ∧ Heals(x)) ::: There is no one who is sick and heals.",
            "∀x (¬Healthy(x) → Sick(x)) ::: If someone is not healthy then they are sick.",
            "∀x (¬Sick(x) → Healthy(x)) ::: If someone is not sick then they are healthy.",
            "Doctor(x) ∧ Skilled(x) → Healthy(x) ::: If someone is a doctor and is skilled then they are healthy.",
            "Doctor(x) ∧ ¬Skilled(x) → ¬Healthy(x) ::: If someone is a doctor and not skilled then they are not healthy.",
            "Doctor(x) ∧ ¬Healthy(x) → ¬Sick(x) ::: If someone is a doctor and not healthy then they are not sick.",
            "Doctor(x) ∧ Healthy(x) → Heals(x) ::: If someone is a doctor and is healthy, then they can heal.",
            "Doctor(x) ∨ ¬Skilled(x) → Healthy(x) ::: If someone is a doctor or not skilled then they are healthy.",
            "¬Doctor(x) ∨ Skilled(x) → Healthy(x) ::: If someone is not a doctor or skilled then they are healthy."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Skilled(x) ::: x is skilled.",
            "Heals(x) ::: x can heal."
        ]
    },
    {
        "premises-NL": [
            "All artists are creative.",
            "Bob is an artist.",
            "Creative people are happy.",
            "If Bob is an artist, then Bob likes music.",
            "If someone likes music, then they are creative.",
            "If someone is creative, then they are happy.",
            "Something is happy.",
            "If someone is happy, they are not sad.",
            "If someone is not sad, they like music.",
            "If someone likes music and is happy then they are creative.",
            "If someone is not creative, then they are not happy.",
            "If someone is not happy, then they are not creative.",
            "If someone is creative and likes music, then they are not sad.",
            "If someone is not happy or is sad, then they are not creative.",
            "If someone is happy or does not like music, then they are creative.",
            "If someone likes music or is happy, then they are creative.",
            "If someone is sad or happy then they are not creative."
        ],
        "premises-FOL": [
            "∀x (Artist(x) → Creative(x)) ::: All artists are creative.",
            "Artist(bob) ::: Bob is an artist.",
            "∀x (Creative(x) → Happy(x)) ::: Creative people are happy.",
            "Artist(bob) → Likes(bob, music) ::: If Bob is an artist, then Bob likes music.",
            "∀x (Likes(x, music) → Creative(x)) ::: If someone likes music, then they are creative.",
            "∀x (Creative(x) → Happy(x)) ::: If someone is creative, then they are happy.",
            "∃x Happy(x) ::: Something is happy.",
            "∀x (Happy(x) → ¬Sad(x)) ::: If someone is happy, they are not sad.",
            "∀x (¬Sad(x) → Likes(x, music)) ::: If someone is not sad, they like music.",
            "Likes(x, music) ∧ Happy(x) → Creative(x) ::: If someone likes music and is happy then they are creative.",
            "∀x (¬Creative(x) → ¬Happy(x)) ::: If someone is not creative, then they are not happy.",
            "∀x (¬Happy(x) → ¬Creative(x)) ::: If someone is not happy, then they are not creative.",
            "Creative(x) ∧ Likes(x, music) → ¬Sad(x) ::: If someone is creative and likes music, then they are not sad.",
            "¬Happy(x) ∨ Sad(x) → ¬Creative(x) ::: If someone is not happy or is sad, then they are not creative.",
            "Happy(x) ∨ ¬Likes(x, music) → Creative(x) ::: If someone is happy or does not like music, then they are creative.",
            "Likes(x, music) ∨ Happy(x) → Creative(x) ::: If someone likes music or is happy, then they are creative.",
            "Sad(x) ∨ Happy(x) → ¬Creative(x) ::: If someone is sad or happy then they are not creative."
        ],
        "predicates": [
            "Artist(x) ::: x is an artist.",
            "Creative(x) ::: x is creative.",
            "Happy(x) ::: x is happy.",
            "Likes(x, y) ::: x likes y.",
            "Music(x) ::: x is music."
        ]
    },
    {
        "premises-NL": [
            "All apples are fruits.",
            "All oranges are fruits.",
            "If something is an apple, then it is not sweet.",
            "If something is an orange, then it is sour.",
            "An apple is a fruit or an orange is a fruit.",
            "If something is a fruit, then it is either an apple or an orange.",
            "There is a fruit."
        ],
        "premises-FOL": [
            "∀x (Apple(x) → Fruit(x)) ::: All apples are fruits.",
            "∀x (Orange(x) → Fruit(x)) ::: All oranges are fruits.",
            "∀x (Apple(x) → ¬Sweet(x)) ::: If something is an apple, then it is not sweet.",
            "∀x (Orange(x) → Sour(x)) ::: If something is an orange, then it is sour.",
            "∃x (Apple(x) ∨ Orange(x)) ::: An apple is a fruit or an orange is a fruit.",
            "∀x (Fruit(x) → (Apple(x) ∨ Orange(x))) ::: If something is a fruit, then it is either an apple or an orange.",
            "∃x Fruit(x) ::: There is a fruit."
        ],
        "predicates": [
            "Fruit(x) ::: x is a fruit",
            "Sour(x) ::: x is sour"
        ]
    },
    {
        "premises-NL": [
            "All artists are creative.",
            "Everyone is either an artist or a musician.",
            "If someone is a musician, then they play an instrument.",
            "If someone plays an instrument, then they like music.",
            "Some musicians like music.",
            "No creative person plays an instrument.",
            "If someone is creative, then they like music or something is not creative.",
            "Everything is a person."
        ],
        "premises-FOL": [
            "∀x (Artist(x) → Creative(x)) ::: All artists are creative.",
            "∀x (Artist(x) ∨ Musician(x)) ::: Everyone is either an artist or a musician.",
            "∀x (Musician(x) → PlaysInstrument(x)) ::: If someone is a musician, then they play an instrument.",
            "∀x (PlaysInstrument(x) → LikesMusic(x)) ::: If someone plays an instrument, then they like music.",
            "∃x (Musician(x) ∧ LikesMusic(x)) ::: Some musicians like music.",
            "∀x (Creative(x) → ¬PlaysInstrument(x)) ::: No creative person plays an instrument.",
            "∀x (Creative(x) → LikesMusic(x) ∨ ¬Creative(x)) ::: If someone is creative, then they like music or something is not creative.",
            "∀x Person(x) ::: Everything is a person."
        ],
        "predicates": [
            "Artist(x) ::: x is an artist",
            "Creative(x) ::: x is creative",
            "Musician(x) ::: x is a musician",
            "PlaysInstrument(x) ::: x plays an instrument",
            "LikesMusic(x) ::: x likes music"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard pass exams.",
            "Someone studies hard.",
            "If someone is a student and attends lectures, they study hard.",
            "Anyone who has a textbook is a student.",
            "If someone is a student, then they either study hard or pass the exam.",
            "If someone has a textbook and studies hard, they pass the exam.",
            "If someone studies hard, then they pass the exam."
        ],
        "premises-FOL": [
            "∀x ((Student(x) ∧ StudiesHard(x)) → PassExam(x)) ::: All students who study hard pass exams.",
            "∃x StudiesHard(x) ::: Someone studies hard.",
            "∀x ((Student(x) ∧ AttendsLecture(x)) → StudiesHard(x)) ::: If someone is a student and attends lectures, they study hard.",
            "∀x (HasTextbook(x) → Student(x)) ::: Anyone who has a textbook is a student.",
            "∀x (Student(x) → (StudiesHard(x) ∨ PassExam(x))) ::: If someone is a student, then they either study hard or pass the exam.",
            "∀x ((HasTextbook(x) ∧ StudiesHard(x)) → PassExam(x)) ::: If someone has a textbook and studies hard, they pass the exam.",
            "∀x (StudiesHard(x) → PassExam(x)) ::: If someone studies hard, then they pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "AttendsLecture(x) ::: x attends lectures",
            "HasTextbook(x) ::: x has a textbook"
        ]
    },
    {
        "premises-NL": [
            "All singers are musicians.",
            "All musicians perform music.",
            "Some artists do not perform music.",
            "All artists are musicians or they are singers.",
            "John is an artist.",
            "If someone is an artist, then they like music.",
            "Mary is a singer.",
            "If someone is a musician, they play an instrument.",
            "Anyone who performs music is a musician.",
            "All musicians like music.",
            "Anyone who is a singer is famous.",
            "Some artists are famous.",
            "All famous people like music.",
            "John is a musician."
        ],
        "premises-FOL": [
            "∀x (Singer(x) → Musician(x)) ::: All singers are musicians.",
            "∀x (Musician(x) → Performs(x, music)) ::: All musicians perform music.",
            "∃x (Artist(x) ∧ ¬Performs(x, music)) ::: Some artists do not perform music.",
            "∀x (Artist(x) → (Musician(x) ∨ Singer(x))) ::: All artists are musicians or they are singers.",
            "Artist(john) ::: John is an artist.",
            "∀x (Artist(x) → Likes(x, music)) ::: If someone is an artist, then they like music.",
            "Singer(mary) ::: Mary is a singer.",
            "∀x (Musician(x) → PlaysInstrument(x)) ::: If someone is a musician, they play an instrument.",
            "∀x (Performs(x, music) → Musician(x)) ::: Anyone who performs music is a musician.",
            "∀x (Musician(x) → Likes(x, music)) ::: All musicians like music.",
            "∀x (Singer(x) → Famous(x)) ::: Anyone who is a singer is famous.",
            "∃x (Artist(x) ∧ Famous(x)) ::: Some artists are famous.",
            "∀x (Famous(x) → Likes(x, music)) ::: All famous people like music.",
            "Musician(john) ::: John is a musician."
        ],
        "predicates": [
            "Artist(x) ::: x is an artist.",
            "Singer(x) ::: x is a singer.",
            "Musician(x) ::: x is a musician.",
            "Performs(x, y) ::: x performs y.",
            "Likes(x, y) ::: x likes y.",
            "PlaysInstrument(x) ::: x plays an instrument.",
            "Famous(x) ::: x is famous."
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "Some surgeons are not specialists.",
            "Surgeons are doctors.",
            "A surgeon does not possess a specialist expertise.",
            "A surgeon practices medicine."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∃x (Surgeon(x) ∧ ¬Specialist(x)) ::: Some surgeons are not specialists.",
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Surgeon(x) → ¬Specialist(x)) ::: Every surgeon isn't a specialist.",
            "∀x (Surgeon(x) → PracticeMedicine(x)) ::: Every surgeon practices medicine."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Specialist(x) ::: x is a specialist",
            "Surgeon(x) ::: x is a surgeon"
        ]
    },
    {
        "premises-NL": [
            "All students take Math or Physics.",
            "John is a student.",
            "John does not take Math."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (TakesMath(x) ∨ TakesPhysics(x))) ::: All students take Math or Physics",
            "Student(John) ::: John is a student",
            "¬TakesMath(John) ::: John does not take Math",
            "Student(Jane) ::: Jane is a student",
            "∀x (Student(x) → (TakesMath(x) ∨ TakesPhysics(x))) ::: All students take Math or Physics",
            "Student(John) ::: John is a student",
            "¬TakesMath(John) ::: John does not take Math",
            "Student(Jane) ::: Jane is a student",
            "∀x (Student(x) → (TakesMath(x) ∨ TakesPhysics(x))) ::: All students take Math or Physics",
            "Student(John) ::: John is a student",
            "¬TakesMath(John) ::: John does not take Math",
            "Student(Jane) ::: Jane is a student"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "TakesMath(x) ::: x takes Math",
            "TakesPhysics(x) ::: x takes Physics"
        ]
    },
    {
        "premises-NL": [
            "All doctors are physicians.",
            "All nurses are physicians.",
            "No surgeon is a physician.",
            "Alice is a doctor.",
            "Bob is a nurse.",
            "Carol is not a surgeon.",
            "Dave is a surgeon.",
            "Eve is a doctor",
            "Frank is a nurse",
            "Gary is not a surgeon",
            "Harry is a doctor",
            "Ivy is a nurse",
            "Jay is not a surgeon"
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Physician(x)) ::: All doctors are physicians",
            "∀x (Nurse(x) → Physician(x)) ::: All nurses are physicians",
            "∀x (Surgeon(x) → ¬Physician(x)) ::: No surgeon is a physician",
            "Doctor(Alice) ::: Alice is a doctor",
            "Nurse(Bob) ::: Bob is a nurse",
            "¬Surgeon(Carol) ::: Carol is not a surgeon",
            "Surgeon(Dave) ::: Dave is a surgeon",
            "Doctor(Eve) ::: Eve is a doctor",
            "Nurse(Frank) ::: Frank is a nurse",
            "¬Surgeon(Gary) ::: Gary is not a surgeon",
            "Doctor(Harry) ::: Harry is a doctor",
            "Nurse(Ivy) ::: Ivy is a nurse",
            "¬Surgeon(Jay) ::: Jay is not a surgeon"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Nurse(x) ::: x is a nurse",
            "Surgeon(x) ::: x is a surgeon",
            "Physician(x) ::: x is a physician"
        ]
    },
    {
        "premises-NL": [
            "All students attend lectures.",
            "Anyone who attends lectures and studies hard passes the exam.",
            "Anyone who passes the exam will succeed.",
            "John is a student.",
            "John studies hard.",
            "Students who study hard and attend lectures pass the exam.",
            "Students who pass the exam will succeed.",
            "Mary attends lectures.",
            "Mary studies hard.",
            "Mary is a student.",
            "David is a student and attends lectures.",
            "David studies hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsLecture(x)) ::: All students attend lectures.",
            "∀x (AttendsLecture(x) ∧ StudiesHard(x) → PassExam(x)) ::: Anyone who attends lectures and studies hard passes the exam.",
            "∀x (PassExam(x) → Succeed(x)) ::: Anyone who passes the exam will succeed.",
            "Student(John) ::: John is a student.",
            "StudiesHard(John) ::: John studies hard.",
            "∀x (Student(x) ∧ StudiesHard(x) ∧ AttendsLecture(x) → PassExam(x)) ::: Students who study hard and attend lectures pass the exam.",
            "∀x (PassExam(x) → Succeed(x)) ::: Students who pass the exam will succeed.",
            "AttendsLecture(Mary) ::: Mary attends lectures.",
            "StudiesHard(Mary) ::: Mary studies hard.",
            "Student(Mary) ::: Mary is a student.",
            "Student(David) ∧ AttendsLecture(David) ::: David is a student and attends lectures.",
            "StudiesHard(David) ::: David studies hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesHard(x) ::: x studies hard.",
            "Succeed(x) ::: x will succeed.",
            "AttendsLecture(x) ::: x attends lectures.",
            "PassExam(x) ::: x passes the exam."
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "Anyone who treats patients practices medicine.",
            "Anyone who practices medicine is ethical if they have a license.",
            "All doctors have a license.",
            "Alice is a doctor.",
            "Bob is a doctor.",
            "All doctors treat patients and have a license.",
            "Anyone who is a doctor treats patients and has a license.",
            "Carol treats patients.",
            "Dave practices medicine.",
            "Alice treats patients and has a license.",
            "Bob treats patients.",
            "Carol has a license."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → TreatsPatients(x)) ::: All doctors treat patients.",
            "∀x (TreatsPatients(x) → PracticesMedicine(x)) ::: Anyone who treats patients practices medicine.",
            "∀x (PracticesMedicine(x) ∧ HasLicense(x) → Ethical(x)) ::: Anyone who practices medicine is ethical if they have a license.",
            "∀x (Doctor(x) → HasLicense(x)) ::: All doctors have a license.",
            "Doctor(Alice) ::: Alice is a doctor.",
            "Doctor(Bob) ::: Bob is a doctor.",
            "∀x (Doctor(x) → (TreatsPatients(x) ∧ HasLicense(x))) ::: All doctors treat patients and have a license.",
            "∀x (Doctor(x) → (TreatsPatients(x) ∧ HasLicense(x))) ::: Anyone who is a doctor treats patients and has a license.",
            "TreatsPatients(Carol) ::: Carol treats patients.",
            "PracticesMedicine(Dave) ::: Dave practices medicine.",
            "TreatsPatients(Alice) ∧ HasLicense(Alice) ::: Alice treats patients and has a license.",
            "TreatsPatients(Bob) ::: Bob treats patients.",
            "HasLicense(Carol) ::: Carol has a license."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "PracticesMedicine(x) ::: x practices medicine.",
            "Ethical(x) ::: x is ethical.",
            "TreatsPatients(x) ::: x treats patients.",
            "HasLicense(x) ::: x has a license."
        ]
    },
    {
        "premises-NL": [
            "All programmers know algorithms.",
            "Anyone who knows algorithms writes good code.",
            "Anyone who writes good code will be employed in IT if they use frameworks.",
            "All programmers use frameworks.",
            "Alice is a programmer.",
            "Bob is a programmer.",
            "All programmers know algorithms and use frameworks.",
            "Anyone who is a programmer knows algorithms and uses frameworks.",
            "Carol knows algorithms.",
            "Dave writes good code.",
            "Alice knows algorithms and uses frameworks.",
            "Bob knows algorithms.",
            "Carol uses frameworks.",
            "Eve is a programmer and uses frameworks."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → KnowsAlgorithms(x)) ::: All programmers know algorithms.",
            "∀x (KnowsAlgorithms(x) → WritesGoodCode(x)) ::: Anyone who knows algorithms writes good code.",
            "∀x (WritesGoodCode(x) ∧ UsesFrameworks(x) → EmployedInIT(x)) ::: Anyone who writes good code will be employed in IT if they use frameworks.",
            "∀x (Programmer(x) → UsesFrameworks(x)) ::: All programmers use frameworks.",
            "Programmer(Alice) ::: Alice is a programmer.",
            "Programmer(Bob) ::: Bob is a programmer.",
            "∀x (Programmer(x) → (KnowsAlgorithms(x) ∧ UsesFrameworks(x))) ::: All programmers know algorithms and use frameworks.",
            "∀x (Programmer(x) → (KnowsAlgorithms(x) ∧ UsesFrameworks(x))) ::: Anyone who is a programmer knows algorithms and uses frameworks.",
            "KnowsAlgorithms(Carol) ::: Carol knows algorithms.",
            "WritesGoodCode(Dave) ::: Dave writes good code.",
            "KnowsAlgorithms(Alice) ∧ UsesFrameworks(Alice) ::: Alice knows algorithms and uses frameworks.",
            "KnowsAlgorithms(Bob) ::: Bob knows algorithms.",
            "UsesFrameworks(Carol) ::: Carol uses frameworks.",
            "Programmer(Eve) ∧ UsesFrameworks(Eve) ::: Eve is a programmer and uses frameworks."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer.",
            "WritesGoodCode(x) ::: x writes good code.",
            "EmployedInIT(x) ::: x is employed in the IT sector.",
            "KnowsAlgorithms(x) ::: x knows algorithms.",
            "UsesFrameworks(x) ::: x uses frameworks."
        ]
    },
    {
        "premises-NL": [
            "All plants are green.",
            "Anything green gets sunlight if it gets water.",
            "Anything that gets sunlight and water has nutrients if it is a plant.",
            "Any plant that has nutrients grows.",
            "Rose is a plant.",
            "Lily is a plant.",
            "All plants get sunlight and water.",
            "Any plant that grows photosynthesizes.",
            "Daisy is green.",
            "Tulip gets sunlight.",
            "Rose gets sunlight and water.",
            "Lily gets water.",
            "Daisy has nutrients.",
            "Tulip gets water and has nutrients.",
            "Rose has nutrients."
        ],
        "premises-FOL": [
            "∀x (Plant(x) → IsGreen(x)) ::: All plants are green.",
            "∀x (IsGreen(x) → (GetsSunlight(x) ∧ GetsWater(x))) ::: Anything green gets sunlight if it gets water.",
            "∀x (Plant(x) ∧ GetsSunlight(x) ∧ GetsWater(x) → HasNutrients(x)) ::: Anything that gets sunlight and water has nutrients if it is a plant.",
            "∀x (Plant(x) ∧ HasNutrients(x) → Grows(x)) ::: Any plant that has nutrients grows.",
            "Plant(Rose) ::: Rose is a plant.",
            "Plant(Lily) ::: Lily is a plant.",
            "∀x (Plant(x) → (GetsSunlight(x) ∧ GetsWater(x))) ::: All plants get sunlight and water.",
            "∀x (Grows(x) → Photosynthesizes(x)) ::: Any plant that grows photosynthesizes.",
            "IsGreen(Daisy) ::: Daisy is green.",
            "GetsSunlight(Tulip) ::: Tulip gets sunlight.",
            "GetsSunlight(Rose) ∧ GetsWater(Rose) ::: Rose gets sunlight and water.",
            "GetsWater(Lily) ::: Lily gets water.",
            "HasNutrients(Daisy) ::: Daisy has nutrients.",
            "GetsWater(Tulip) ∧ HasNutrients(Tulip) ::: Tulip gets water and has nutrients.",
            "HasNutrients(Rose) ::: Rose has nutrients."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant.",
            "GetsSunlight(x) ::: x gets sunlight.",
            "GetsWater(x) ::: x gets water.",
            "HasNutrients(x) ::: x has nutrients.",
            "Grows(x) ::: x grows.",
            "IsGreen(x) ::: x is green.",
            "Photosynthesizes(x) ::: x photosynthesizes."
        ]
    },
    {
        "premises-NL": [
            "All musicians are talented.",
            "Any talented person creates music if they play an instrument that produces sound.",
            "Anyone who plays the guitar plays an instrument.",
            "The guitar produces sound.",
            "David is a musician.",
            "Emily is a musician.",
            "All musicians play the guitar.",
            "Anyone who creates music is talented.",
            "Frank plays the piano.",
            "Grace plays guitar.",
            "David plays the guitar and the guitar produces sound.",
            "Emily plays an instrument that produces sound.",
            "Frank is a musician and creates music.",
            "Grace is a musician and plays guitar.",
            "Grace is talented.",
            "All piano players are musicians."
        ],
        "premises-FOL": [
            "∀x (Musician(x) → IsTalented(x)) ::: All musicians are talented.",
            "∀x (IsTalented(x) ∧ PlaysInstrument(x) ∧ InstrumentProducesSound(x) → CreatesMusic(x)) ::: Any talented person creates music if they play an instrument that produces sound.",
            "∀x (PlaysGuitar(x) → PlaysInstrument(x)) ::: Anyone who plays the guitar plays an instrument.",
            "InstrumentProducesSound(Guitar) ::: The guitar produces sound.",
            "Musician(David) ::: David is a musician.",
            "Musician(Emily) ::: Emily is a musician.",
            "∀x (Musician(x) → PlaysGuitar(x)) ::: All musicians play the guitar.",
            "∀x (CreatesMusic(x) → IsTalented(x)) ::: Anyone who creates music is talented.",
            "PlaysPiano(Frank) ::: Frank plays the piano.",
            "PlaysGuitar(Grace) ::: Grace plays guitar.",
            "PlaysGuitar(David) ∧ InstrumentProducesSound(Guitar) ::: David plays the guitar and the guitar produces sound.",
            "PlaysInstrument(Emily) ∧ InstrumentProducesSound(Instrument) ::: Emily plays an instrument that produces sound.",
            "Musician(Frank) ∧ CreatesMusic(Frank) ::: Frank is a musician and creates music.",
            "Musician(Grace) ∧ PlaysGuitar(Grace) ::: Grace is a musician and plays guitar.",
            "IsTalented(Grace) ::: Grace is talented.",
            "∀x (PlaysPiano(x) → Musician(x)) ::: All piano players are musicians."
        ],
        "predicates": [
            "Musician(x) ::: x is a musician.",
            "PlaysInstrument(x) ::: x plays a musical instrument.",
            "InstrumentProducesSound(x) ::: The instrument produces sound.",
            "CreatesMusic(x) ::: x creates music.",
            "IsTalented(x) ::: x is talented.",
            "PlaysGuitar(x) ::: x plays guitar.",
            "PlaysPiano(x) ::: x plays piano."
        ]
    },
    {
        "premises-NL": [
            "Every student attends the university.",
            "If a student takes an exam, they pass it.",
            "All students are taking exams.",
            "If a student does not pass an exam, they are not enrolled in a course.",
            "Students are either taking exams or not enrolled in a course.",
            "John is a student.",
            "John attends the university.",
            "John is taking an exam.",
            "John passes the exam.",
            "If John is enrolled in a course, then he passes the exam.",
            "If John does not pass an exam, then John does not attend the university."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsUniversity(x)) ::: All students attend the university.",
            "∀x (Student(x) ∧ TakesExam(x) → PassesExam(x)) ::: If a student takes an exam, they pass it.",
            "∀x (Student(x) → TakesExam(x)) ::: All students are taking exams.",
            "∀x (Student(x) ∧ ¬PassesExam(x) → ¬EnrolledInCourse(x)) ::: If a student does not pass an exam, they are not enrolled in a course.",
            "∀x (Student(x) → (TakesExam(x) ∨ ¬EnrolledInCourse(x))) ::: Students are either taking exams or not enrolled in a course.",
            "Student(john) ::: John is a student.",
            "AttendsUniversity(john) ::: John attends the university.",
            "TakesExam(john) ::: John is taking an exam.",
            "PassesExam(john) ::: John passes the exam.",
            "EnrolledInCourse(john) → PassesExam(john) ::: If John is enrolled in a course, then he passes the exam.",
            "¬PassesExam(john) → ¬AttendsUniversity(john) ::: If John does not pass an exam, then John does not attend the university."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsUniversity(x) ::: x attends the university",
            "EnrolledInCourse(x) ::: x is enrolled in a course",
            "TakesExam(x) ::: x takes an exam",
            "PassesExam(x) ::: x passes an exam"
        ]
    },
    {
        "premises-NL": [
            "Every patient is either diagnosed with a disease or does not receive treatment.",
            "If a patient has insurance, then they receive treatment.",
            "Some patients are diagnosed with a disease.",
            "Every patient who does not receive treatment will experience a negative health outcome.",
            "If a patient is diagnosed with a disease and has insurance, they are treated.",
            "If a patient is a patient, then they are treated if they have insurance.",
            "John is a patient.",
            "John is diagnosed with a disease.",
            "If a patient is not diagnosed with a disease, then they are not treated.",
            "If a patient is treated, they will not experience negative health outcomes.",
            "If John is diagnosed with a disease and is not treated, then John has a negative health outcome.",
            "John does not have insurance."
        ],
        "premises-FOL": [
            "∀x (Patient(x) → (DiagnosedWithDisease(x) ∨ ¬ReceivesTreatment(x))) ::: Every patient is either diagnosed or untreated.",
            "∀x (Patient(x) ∧ HasInsurance(x) → ReceivesTreatment(x)) ::: If a patient has insurance, they receive treatment.",
            "∃x (Patient(x) ∧ DiagnosedWithDisease(x)) ::: Some patients are diagnosed.",
            "∀x (Patient(x) ∧ ¬ReceivesTreatment(x) → NegativeHealthOutcome(x)) ::: Untreated patients have negative outcomes.",
            "∀x (Patient(x) ∧ DiagnosedWithDisease(x) ∧ HasInsurance(x) → ReceivesTreatment(x)) ::: If diagnosed and insured, then treated.",
            "∀x (Patient(x) ∧ HasInsurance(x) → ReceivesTreatment(x)) ::: If a patient has insurance, they receive treatment.",
            "Patient(john) ::: John is a patient.",
            "DiagnosedWithDisease(john) ::: John is diagnosed.",
            "∀x (Patient(x) ∧ ¬DiagnosedWithDisease(x) → ¬ReceivesTreatment(x)) ::: Not diagnosed means not treated.",
            "∀x (Patient(x) ∧ ReceivesTreatment(x) → ¬NegativeHealthOutcome(x)) ::: Treated patients have no negative outcomes.",
            "DiagnosedWithDisease(john) ∧ ¬ReceivesTreatment(john) → NegativeHealthOutcome(john) ::: If John is diagnosed but untreated, he has negative outcomes.",
            "¬HasInsurance(john) ::: John does not have insurance."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient",
            "DiagnosedWithDisease(x) ::: x is diagnosed with a disease",
            "ReceivesTreatment(x) ::: x receives treatment",
            "HasInsurance(x) ::: x has insurance",
            "NegativeHealthOutcome(x) ::: x experiences negative health outcomes",
            "Doctor(x) ::: x is a doctor"
        ]
    },
    {
        "premises-NL": [
            "All members of a club have free time.",
            "If a person enjoys social gatherings, they attend events.",
            "If a person has free time and is not busy, they can attend events.",
            "A person is either busy or not working.",
            "If a person is busy, they will not attend the event.",
            "John is a member of the club.",
            "John enjoys social gatherings.",
            "If John has free time and he works, then he is busy.",
            "John is working.",
            "If John attends events, he has free time.",
            "If a person has free time, then they can attend.",
            "John can attend the event.",
            "John is likely to attend the event.",
            "If John attends events and enjoys social gatherings, he will likely attend events."
        ],
        "premises-FOL": [
            "∀x (MemberOfClub(x) → HasFreeTime(x)) ::: All club members have free time.",
            "∀x (EnjoysSocialGatherings(x) → AttendsEvent(x)) ::: Those who enjoy gatherings attend events.",
            "∀x (HasFreeTime(x) ∧ ¬IsBusy(x) → CanAttend(x)) ::: If free and not busy, can attend.",
            "∀x (IsBusy(x) ∨ ¬Works(x)) ::: A person is busy or not working.",
            "∀x (IsBusy(x) → ¬AttendsEvent(x)) ::: Busy people do not attend.",
            "MemberOfClub(john) ::: John is a club member.",
            "EnjoysSocialGatherings(john) ::: John enjoys gatherings.",
            "HasFreeTime(john) ∧ Works(john) → IsBusy(john) ::: If John has free time and works, then he is busy.",
            "Works(john) ::: John works.",
            "AttendsEvent(john) → HasFreeTime(john) ::: If John attends, he has free time.",
            "∀x (HasFreeTime(x) → CanAttend(x)) ::: If a person has free time, then they can attend.",
            "CanAttend(john) ::: John can attend.",
            "LikelyAttendsEvent(john) ::: John is likely to attend the event.",
            "AttendsEvent(john) ∧ EnjoysSocialGatherings(john) → LikelyAttendsEvent(john) ::: If John attends and enjoys gatherings, he is likely to attend."
        ],
        "predicates": [
            "MemberOfClub(x) ::: x is a member of a club",
            "EnjoysSocialGatherings(x) ::: x enjoys social gatherings",
            "AttendsEvent(x) ::: x attends an event",
            "LikelyAttendsEvent(x) ::: x likely attends an event",
            "HasFreeTime(x) ::: x has free time",
            "Works(x) ::: x works",
            "IsBusy(x) ::: x is busy",
            "CanAttend(x) ::: x can attend"
        ]
    },
    {
        "premises-NL": [
            "All people are either healthy or have a disease.",
            "Some people are healthy.",
            "No one is both healthy and has a disease.",
            "If someone is not healthy, then they have a disease.",
            "Not all people have a disease."
        ],
        "premises-FOL": [
            "∀x (Healthy(x) ∨ Disease(x)) ::: Everyone is either healthy or has a disease.",
            "∃x Healthy(x) ::: Someone is healthy.",
            "¬∃x (Healthy(x) ∧ Disease(x)) ::: No one is both healthy and has a disease.",
            "∀x (¬Healthy(x) → Disease(x)) ::: If someone is not healthy, then they have a disease.",
            "¬∀x Disease(x) ::: Not all people have a disease."
        ],
        "predicates": [
            "Healthy(x) ::: x is healthy",
            "Disease(x) ::: x has a disease"
        ]
    },
    {
        "premises-NL": [
            "All scientists are researchers.",
            "Every researcher uses the new equipment or they are not a researcher.",
            "If a researcher uses the new equipment, they conduct an experiment.",
            "If a scientist conducts an experiment, the experiment is successful.",
            "Some scientists conduct experiments.",
            "Not all experiments are successful.",
            "Some researchers are scientists."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Researcher(x)) ::: All scientists are researchers.",
            "∀x (Researcher(x) → UsesEquipment(x)) ::: Every researcher uses the new equipment.",
            "∀x ∀y (UsesEquipment(x) → Experiment(x, y)) ::: If a researcher uses the new equipment, they conduct an experiment.",
            "∀x (Experiment(x,y) → SuccessfulExperiment(x)) ::: If a scientist conducts an experiment, the experiment is successful.",
            "∃x ∃y (Scientist(x) ∧ Experiment(x, y)) ::: Some scientists conduct experiments.",
            "¬∀x SuccessfulExperiment(x) ::: Not all experiments are successful.",
            "∃x (Researcher(x) ∧ Scientist(x)) ::: Some researchers are scientists."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Researcher(x) ::: x is a researcher",
            "UsesEquipment(x) ::: x uses the equipment",
            "NewEquipment(x) ::: x is the new equipment",
            "Experiment(x, y) ::: x conducts the experiment y",
            "ResearcherUsesEquipment(x, y) ::: Researcher x uses the equipment y",
            "SuccessfulExperiment(x) ::: Experiment x is successful"
        ]
    },
    {
        "premises-NL": [
            "Everyone who likes cats either owns a cat or a dog.",
            "If someone owns a cat, they are happy.",
            "If someone is happy, they are a good person.",
            "All good people like cats.",
            "Some people who like cats do not like dogs.",
            "Everyone who owns a cat likes cats.",
            "If someone has a pet, they either own a cat or a dog.",
            "Not everyone likes dogs.",
            "Some people are good persons."
        ],
        "premises-FOL": [
            "∀x (LikesCats(x) → (OwnsCat(x) ∨ OwnsDog(x))) ::: Everyone who likes cats either owns a cat or a dog.",
            "∀x (OwnsCat(x) → IsHappy(x)) ::: If someone owns a cat, they are happy.",
            "∀x (IsHappy(x) → GoodPerson(x)) ::: If someone is happy, they are a good person.",
            "∀x (GoodPerson(x) → LikesCats(x)) ::: All good people like cats.",
            "∃x (LikesCats(x) ∧ ¬LikesDogs(x)) ::: Some people who like cats do not like dogs.",
            "∀x (OwnsCat(x) → LikesCats(x)) ::: Everyone who owns a cat likes cats.",
            "∀x (HasPet(x) → (OwnsCat(x) ∨ OwnsDog(x))) ::: If someone has a pet, they either own a cat or a dog.",
            "¬∀x LikesDogs(x) ::: Not everyone likes dogs.",
            "∃x GoodPerson(x) ::: Some people are good persons."
        ],
        "predicates": [
            "LikesCats(x) ::: x likes cats",
            "OwnsDog(x) ::: x owns a dog",
            "OwnsCat(x) ::: x owns a cat",
            "LikesDogs(x) ::: x likes dogs",
            "FriendOf(x, y) ::: x is a friend of y",
            "IsHappy(x) ::: x is happy",
            "HasPet(x) ::: x has a pet",
            "Animal(x) ::: x is an animal",
            "GoodPerson(x) ::: x is a good person"
        ]
    },
    {
        "premises-NL": [
            "All doctors are researchers.",
            "All researchers are scientists.",
            "Some doctors publish papers.",
            "If someone publishes papers, then they studied something.",
            "If someone studies something, then they are an expert in that subject.",
            "Every expert is a scientist",
            "John is a doctor.",
            "If someone is a doctor and a scientist, then someone is a researcher.",
            "If someone publishes papers, then they are a researcher.",
            "Doctors are experts.",
            "John publishes paper1",
            "Paper1 is a paper"
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Researcher(x)) ::: All doctors are researchers",
            "∀x (Researcher(x) → Scientist(x)) ::: All researchers are scientists",
            "∃x ∃y (Doctor(x) ∧ Publishes(x, y)) ::: Some doctors publish papers",
            "∀x ∀y (Publishes(x, y) → Studied(x, z)) ::: If someone publishes papers, then they studied something",
            "∀x ∀y (Studied(x, y) → Expert(x, y)) ::: If someone studies something, then they are an expert in that subject",
            "∀x (Expert(x, y) → Scientist(x)) ::: Every expert is a scientist",
            "Doctor(john) ::: John is a doctor",
            "∀x (Doctor(x) ∧ Scientist(x) → Researcher(x)) ::: If someone is a doctor and a scientist, then someone is a researcher",
            "∀x ∀y (Publishes(x, y) → Researcher(x)) ::: If someone publishes papers, then they are a researcher",
            "∀x (Doctor(x) → Expert(x, z)) ::: Doctors are experts",
            "Publishes(john, paper1) ::: John publishes paper1",
            "Paper(paper1) ::: Paper1 is a paper"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Scientist(x) ::: x is a scientist",
            "Researcher(x) ::: x is a researcher",
            "Publishes(x, y) ::: x publishes paper y",
            "Studied(x, y) ::: x studied subject y",
            "Expert(x, y) ::: x is an expert in subject y"
        ]
    },
    {
        "premises-NL": [
            "Every biologist is a scientist.",
            "All scientists use microscopes.",
            "Anyone who uses a microscope studies cells.",
            "John is a biologist.",
            "If someone is a biologist, then they work at a lab.",
            "Anyone who studies cells does not work at a lab.",
            "No one is a biologist and works at a lab.",
            "If someone is a scientist, then they work with cells.",
            "Someone studies cells.",
            "Mary is a scientist.",
            "If Mary is a scientist, then she uses microscopes.",
            "If someone studies cells, then they are a scientist or a biologist.",
            "Every scientist works with some elements of the cell.",
            "If someone is a scientist and works at a lab, then they study elements of the cell."
        ],
        "premises-FOL": [
            "∀x (Biologist(x) → Scientist(x)) ::: Every biologist is a scientist.",
            "∀x (Scientist(x) → UsesMicroscope(x)) ::: All scientists use microscopes.",
            "∀x (UsesMicroscope(x) → StudiesCells(x)) ::: Anyone who uses a microscope studies cells.",
            "Biologist(john) ::: John is a biologist.",
            "∀x (Biologist(x) → WorksAtLab(x)) ::: If someone is a biologist, then they work at a lab.",
            "∀x (StudiesCells(x) → ¬WorksAtLab(x)) ::: Anyone who studies cells does not work at a lab.",
            "¬∃x (Biologist(x) ∧ WorksAtLab(x)) ::: No one is a biologist and works at a lab.",
            "∀x (Scientist(x) → StudiesCells(x)) ::: If someone is a scientist, then they work with cells.",
            "∃x StudiesCells(x) ::: Someone studies cells.",
            "Scientist(mary) ::: Mary is a scientist.",
            "Scientist(mary) → UsesMicroscope(mary) ::: If Mary is a scientist, then she uses microscopes.",
            "∀x (StudiesCells(x) → (Scientist(x) ∨ Biologist(x))) ::: If someone studies cells, then they are a scientist or a biologist.",
            "∀x (Scientist(x) → StudiesCellElements(x)) ::: Every scientist works with some elements of the cell.",
            "∀x ((Scientist(x) ∧ WorksAtLab(x)) → StudiesCellElements(x)) ::: If someone is a scientist and works at a lab, then they study elements of the cell."
        ],
        "predicates": [
            "Biologist(x) ::: x is a biologist",
            "StudiesCells(x) ::: x studies cells",
            "UsesMicroscope(x) ::: x uses a microscope",
            "Scientist(x) ::: x is a scientist",
            "WorksAtLab(x) ::: x works at a lab"
        ]
    },
    {
        "premises-NL": [
            "All doctors are employed.",
            "Some employed people are rich.",
            "A doctor is always a person.",
            "If someone is a doctor, they are a person.",
            "If someone is employed, they are a person.",
            "If someone is rich, they are a person.",
            "It is not the case that some doctors are not employed.",
            "It is not the case that all doctors are not employed.",
            "The doctors are a subset of employed people.",
            "Some employed people are a subset of rich people.",
            "Anyone who is rich is employed.",
            "Anyone who is employed is a doctor.",
            "Everyone is either a doctor or employed or rich."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Employed(x)) ::: All doctors are employed.",
            "∃x (Employed(x) ∧ Rich(x)) ::: Some employed people are rich.",
            "∀x (Doctor(x) → Person(x)) ::: A doctor is always a person.",
            "∀x (Doctor(x) → Person(x)) ::: If someone is a doctor, they are a person.",
            "∀x (Employed(x) → Person(x)) ::: If someone is employed, they are a person.",
            "∀x (Rich(x) → Person(x)) ::: If someone is rich, they are a person.",
            "¬∃x (Doctor(x) ∧ ¬Employed(x)) ::: It is not the case that some doctors are not employed.",
            "¬∀x (Doctor(x) → ¬Employed(x)) ::: It is not the case that all doctors are not employed.",
            "∀x (Doctor(x) → Employed(x)) ::: The doctors are a subset of employed people.",
            "∃x (Employed(x) ∧ Rich(x)) ::: Some employed people are a subset of rich people.",
            "∀x (Rich(x) → Employed(x)) ::: Anyone who is rich is employed.",
            "∀x (Employed(x) → Doctor(x)) ::: Anyone who is employed is a doctor.",
            "∀x (Doctor(x) ∨ Employed(x) ∨ Rich(x)) ::: Everyone is either a doctor or employed or rich."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Employed(x) ::: x is employed",
            "Rich(x) ::: x is rich"
        ]
    },
    {
        "premises-NL": [
            "All students who study biology attend lectures.",
            "Some students who study biology like animals.",
            "Anyone who likes animals either has a pet or studies in the library.",
            "If someone studies in the library, they read books.",
            "If someone reads books, they are students.",
            "If someone studies biology, then they attend lectures.",
            "Anyone who attends lectures uses a microscope.",
            "If someone uses a microscope, they are studying biology.",
            "If someone likes animals and is a student, then they study in the library or have a pet.",
            "Some students use a microscope and like animals.",
            "Anyone who studies biology and likes animals is a student.",
            "It is not the case that all students who study biology don't like animals.",
            "If someone uses a microscope and studies biology, then they attend lectures.",
            "Anyone who attends lectures is a student and studies biology.",
            "It is not the case that some students read books and do not study in the library.",
            "If someone studies biology they are a student."
        ],
        "premises-FOL": [
            "∀x ((StudiesBiology(x) ∧ IsStudent(x)) → AttendsLectures(x)) ::: All students who study biology attend lectures.",
            "∃x (StudiesBiology(x) ∧ LikesAnimals(x) ∧ IsStudent(x)) ::: Some students who study biology like animals.",
            "∀x (LikesAnimals(x) → (HasPet(x) ∨ StudiesInLibrary(x))) ::: Anyone who likes animals either has a pet or studies in the library.",
            "∀x (StudiesInLibrary(x) → ReadsBooks(x)) ::: If someone studies in the library, they read books.",
            "∀x (ReadsBooks(x) → IsStudent(x)) ::: If someone reads books, they are students.",
            "∀x (StudiesBiology(x) → AttendsLectures(x)) ::: If someone studies biology, then they attend lectures.",
            "∀x (AttendsLectures(x) → UsesMicroscope(x)) ::: Anyone who attends lectures uses a microscope.",
            "∀x (UsesMicroscope(x) → StudiesBiology(x)) ::: If someone uses a microscope, they are studying biology.",
            "∀x ((LikesAnimals(x) ∧ IsStudent(x)) → (StudiesInLibrary(x) ∨ HasPet(x))) ::: If someone likes animals and is a student, then they study in the library or have a pet.",
            "∃x (UsesMicroscope(x) ∧ LikesAnimals(x) ∧ IsStudent(x)) ::: Some students use a microscope and like animals.",
            "∀x ((StudiesBiology(x) ∧ LikesAnimals(x)) → IsStudent(x)) ::: Anyone who studies biology and likes animals is a student.",
            "¬∀x ((StudiesBiology(x) ∧ IsStudent(x)) → ¬LikesAnimals(x)) ::: It is not the case that all students who study biology don't like animals.",
            "∀x ((UsesMicroscope(x) ∧ StudiesBiology(x)) → AttendsLectures(x)) ::: If someone uses a microscope and studies biology, then they attend lectures.",
            "∀x (AttendsLectures(x) → (IsStudent(x) ∧ StudiesBiology(x))) ::: Anyone who attends lectures is a student and studies biology.",
            "¬∃x (ReadsBooks(x) ∧ ¬StudiesInLibrary(x)) ::: It is not the case that some students read books and do not study in the library.",
            "∀x (StudiesBiology(x) → IsStudent(x)) ::: If someone studies biology they are a student."
        ],
        "predicates": [
            "StudiesBiology(x) ::: x studies biology",
            "LikesAnimals(x) ::: x likes animals",
            "HasPet(x) ::: x has a pet",
            "StudiesInLibrary(x) ::: x studies in the library",
            "IsStudent(x) ::: x is a student",
            "ReadsBooks(x) ::: x reads books",
            "UsesMicroscope(x) ::: x uses a microscope",
            "AttendsLectures(x) ::: x attends lectures"
        ]
    },
    {
        "premises-NL": [
            "All doctors have a degree.",
            "Anyone who works at a hospital is a doctor.",
            "If someone practices medicine, then they work at a hospital.",
            "Someone is a doctor if and only if they practice medicine.",
            "Everyone with a degree is educated.",
            "John works at the hospital.",
            "John practices medicine.",
            "John is a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HasDegree(x)) ::: All doctors have a degree.",
            "∀x (WorksAtHospital(x) → Doctor(x)) ::: Anyone who works at a hospital is a doctor.",
            "∀x (PracticesMedicine(x) → WorksAtHospital(x)) ::: If someone practices medicine, then they work at a hospital.",
            "∀x (Doctor(x) ↔ PracticesMedicine(x)) ::: Someone is a doctor if and only if they practice medicine.",
            "∀x (HasDegree(x) → Educated(x)) ::: Everyone with a degree is educated.",
            "WorksAtHospital(john) ::: John works at the hospital.",
            "PracticesMedicine(john) ::: John practices medicine.",
            "Doctor(john) ::: John is a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Educated(x) ::: x is educated",
            "HasDegree(x) ::: x has a degree",
            "WorksAtHospital(x) ::: x works at a hospital",
            "PracticesMedicine(x) ::: x practices medicine"
        ]
    },
    {
        "premises-NL": [
            "All plants are alive.",
            "If something is alive, and gets sunlight, then it grows.",
            "If something gets water, and is green then it grows.",
            "All small plants are green.",
            "All plants get water.",
            "This is a plant.",
            "This plant is small.",
            "This plant gets sunlight.",
            "This plant is alive."
        ],
        "premises-FOL": [
            "∀x (Plant(x) → IsAlive(x)) ::: All plants are alive.",
            "∀x ((IsAlive(x) ∧ GetsSunlight(x)) → Grows(x)) ::: If something is alive and gets sunlight, then it grows.",
            "∀x ((GetsWater(x) ∧ IsGreen(x)) → Grows(x)) ::: If something gets water and is green, then it grows.",
            "∀x (IsSmall(x) → IsGreen(x)) ::: All small plants are green.",
            "∀x (Plant(x) → GetsWater(x)) ::: All plants get water.",
            "Plant(this) ::: This is a plant.",
            "IsSmall(this) ::: This plant is small.",
            "GetsSunlight(this) ::: This plant gets sunlight.",
            "IsAlive(this) ::: This plant is alive."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "GetsSunlight(x) ::: x gets sunlight",
            "GetsWater(x) ::: x gets water",
            "Grows(x) ::: x grows",
            "IsGreen(x) ::: x is green",
            "IsSmall(x) ::: x is small",
            "IsAlive(x) ::: x is alive"
        ]
    },
    {
        "premises-NL": [
            "All students take classes.",
            "Students are not employed.",
            "John is a student.",
            "If John takes classes and works part-time, John is not a full-time student.",
            "If a student is employed, they have no free time.",
            "If a student doesn't have free time, then they work full-time.",
            "Everyone who studies is a student.",
            "John studies.",
            "John takes classes.",
            "John works part-time."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakesClasses(x, y)) ::: All students take classes.",
            "∀x (Student(x) → ¬Employed(x)) ::: Students are not employed.",
            "Student(john) ::: John is a student.",
            "¬FullTimeStudent(john) ::: If John takes classes and works part-time, John is not a full-time student.",
            "∀x ((Student(x) ∧ Employed(x)) → ¬HasFreeTime(x)) ::: If a student is employed, they have no free time.",
            "∀x (¬HasFreeTime(x) → FullTimeStudent(x)) ::: If a student doesn't have free time, then they work full-time.",
            "∀x (Studies(x) → Student(x)) ::: Everyone who studies is a student.",
            "Studies(john) ::: John studies.",
            "TakesClasses(john, y) ::: John takes classes.",
            "WorksPartTime(john) ::: John works part-time."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Employed(x) ::: x is employed",
            "TakesClasses(x, y) ::: x takes class y",
            "WorksPartTime(x) ::: x works part-time",
            "FullTimeStudent(x) ::: x is a full-time student",
            "HasFreeTime(x) ::: x has free time",
            "Studies(x) ::: x studies"
        ]
    },
    {
        "premises-NL": [
            "All people who are sick take medicine.",
            "If someone is sick, they have a disease.",
            "If a doctor prescribes medicine, then the patient takes it.",
            "John is a doctor.",
            "John prescribes medicine to everyone.",
            "If someone has a disease, they are sick.",
            "Sarah has a disease.",
            "If someone takes medicine, they gets better.",
            "A doctor can prescribe medicine to someone.",
            "Everyone who takes medicine gets better.",
            "If John prescribes someone, then that person takes it.",
            "John prescribes medicine to Sarah.",
            "All people who are sick have a disease."
        ],
        "premises-FOL": [
            "∀x (Sick(x) → TakesMedicine(x)) ::: All people who are sick take medicine.",
            "∀x (Sick(x) → HasDisease(x)) ::: If someone is sick, they have a disease.",
            "∀x ∀y (Prescribed(x, y) → TakesMedicine(y)) ::: If a doctor prescribes medicine, then the patient takes it.",
            "IsDoctor(john) ::: John is a doctor.",
            "∀x Prescribed(john, x) ::: John prescribes medicine to everyone.",
            "∀x (HasDisease(x) → Sick(x)) ::: If someone has a disease, they are sick.",
            "HasDisease(sarah) ::: Sarah has a disease.",
            "∀x (TakesMedicine(x) → GetsBetter(x)) ::: If someone takes medicine, they gets better.",
            "∃x ∀y Prescribed(x, y) ::: A doctor can prescribe medicine to someone.",
            "∀x (TakesMedicine(x) → GetsBetter(x)) ::: Everyone who takes medicine gets better.",
            "∀x (Prescribed(john, x) → TakesMedicine(x)) ::: If John prescribes someone, then that person takes it.",
            "Prescribed(john, sarah) ::: John prescribes medicine to Sarah.",
            "∀x (Sick(x) → HasDisease(x)) ::: All people who are sick have a disease."
        ],
        "predicates": [
            "Sick(x) ::: x is sick",
            "TakesMedicine(x) ::: x takes medicine",
            "GetsBetter(x) ::: x gets better",
            "HasDisease(x) ::: x has a disease",
            "Prescribed(x, y) ::: x prescribes y",
            "IsDoctor(x) ::: x is a doctor"
        ]
    },
    {
        "premises-NL": [
            "All musicians play an instrument.",
            "Anyone who plays an instrument either has a gig or is not wealthy.",
            "Some musicians do not have gigs.",
            "All famous people are musicians.",
            "No famous person is wealthy.",
            "Musicians, or their fans, must eat."
        ],
        "premises-FOL": [
            "∀x (Musician(x) → PlaysInstrument(x)) ::: All musicians play an instrument.",
            "∀x (PlaysInstrument(x) → (HasGig(x) ∨ ¬Wealthy(x))) ::: Anyone who plays an instrument either has a gig or is not wealthy.",
            "∃x (Musician(x) ∧ ¬HasGig(x)) ::: Some musicians do not have gigs.",
            "∀x (Famous(x) → Musician(x)) ::: All famous people are musicians.",
            "∀x (Famous(x) → ¬Wealthy(x)) ::: No famous person is wealthy.",
            "∀x (Musician(x) ∨ ¬Wealthy(x)) ::: Musicians, or their fans, must eat."
        ],
        "predicates": [
            "Musician(x) ::: x is a musician",
            "PlaysInstrument(x) ::: x plays an instrument",
            "Wealthy(x) ::: x is wealthy",
            "HasGig(x) ::: x has a gig",
            "Famous(x) ::: x is famous"
        ]
    },
    {
        "premises-NL": [
            "All cars are vehicles.",
            "Bob owns a car.",
            "Everyone who owns a vehicle needs fuel.",
            "If someone owns a car, they need fuel.",
            "Bob has a license.",
            "If someone has a license, they can drive a vehicle.",
            "Bob can drive a car.",
            "If something is a car, then it is a vehicle.",
            "If someone needs fuel, they can drive.",
            "Everything is a vehicle, needs fuel and has a license.",
            "If something needs fuel, then it is a car.",
            "Every vehicle needs fuel.",
            "If someone owns something and it is a car, then they can drive that car.",
            "Everyone can drive something.",
            "If Bob owns a car, then he is not a pedestrian.",
            "If someone can drive, then they need fuel.",
            "If something is a car, it needs fuel.",
            "Bob has a license and owns a car."
        ],
        "premises-FOL": [
            "∀x (IsCar(x) → IsVehicle(x)) ::: All cars are vehicles.",
            "Owns(bob, car) ::: Bob owns a car.",
            "∀x ∀y (Owns(x, y) ∧ IsVehicle(y) → NeedsFuel(x)) ::: Everyone who owns a vehicle needs fuel.",
            "∀x (Owns(x, car) → NeedsFuel(x)) ::: If someone owns a car, they need fuel.",
            "HasLicense(bob) ::: Bob has a license.",
            "∀x ∀y (HasLicense(x) ∧ IsVehicle(y) → CanDrive(x, y)) ::: If someone has a license, they can drive a vehicle.",
            "CanDrive(bob, car) ::: Bob can drive a car.",
            "∀x (IsCar(x) → IsVehicle(x)) ::: If something is a car, then it is a vehicle.",
            "∀x (NeedsFuel(x) → CanDrive(x, y)) ::: If someone needs fuel, they can drive.",
            "∀x (IsVehicle(x) ∧ NeedsFuel(x) ∧ HasLicense(x)) ::: Everything is a vehicle, needs fuel and has a license.",
            "∀x (NeedsFuel(x) → IsCar(x)) ::: If something needs fuel, then it is a car.",
            "∀x (IsVehicle(x) → NeedsFuel(x)) ::: Every vehicle needs fuel.",
            "∀x ∀y (Owns(x, y) ∧ IsCar(y) → CanDrive(x, y)) ::: If someone owns something and it is a car, then they can drive that car.",
            "∀x ∃y CanDrive(x, y) ::: Everyone can drive something.",
            "Owns(bob, car) → ¬Pedestrian(bob) ::: If Bob owns a car, then he is not a pedestrian.",
            "∀x (CanDrive(x, y) → NeedsFuel(x)) ::: If someone can drive, then they need fuel.",
            "∀x (IsCar(x) → NeedsFuel(x)) ::: If something is a car, it needs fuel.",
            "HasLicense(bob) ∧ Owns(bob, car) ::: Bob has a license and owns a car."
        ],
        "predicates": [
            "Owns(x, y) ::: x owns y",
            "CanDrive(x, y) ::: x can drive y",
            "HasLicense(x) ::: x has a license",
            "IsVehicle(x) ::: x is a vehicle",
            "IsCar(x) ::: x is a car",
            "NeedsFuel(x) ::: x needs fuel"
        ]
    },
    {
        "premises-NL": [
            "All students with high GPAs take exams.",
            "All students who study hard take exams.",
            "Anyone who takes exams and studies hard graduates.",
            "Some students have high GPAs.",
            "Some students study hard.",
            "If a student takes exams then they study hard.",
            "A student that has a high GPA also studies hard.",
            "Some students do not graduate.",
            "All students who take exams graduate.",
            "Some students are both taking exams and have a high GPA."
        ],
        "premises-FOL": [
            "∀x (HighGPA(x) → TakesExams(x)) ::: All students with high GPAs take exams.",
            "∀x (StudiesHard(x) → TakesExams(x)) ::: All students who study hard take exams.",
            "∀x (TakesExams(x) ∧ StudiesHard(x) → Graduates(x)) ::: Anyone who takes exams and studies hard graduates.",
            "∃x HighGPA(x) ::: Some students have high GPAs.",
            "∃x StudiesHard(x) ::: Some students study hard.",
            "∀x (TakesExams(x) → StudiesHard(x)) ::: If a student takes exams then they study hard.",
            "∀x (HighGPA(x) → StudiesHard(x)) ::: A student that has a high GPA also studies hard.",
            "∃x ¬Graduates(x) ::: Some students do not graduate.",
            "∀x (TakesExams(x) → Graduates(x)) ::: All students who take exams graduate.",
            "∃x (TakesExams(x) ∧ HighGPA(x)) ::: Some students are both taking exams and have a high GPA."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "HighGPA(x) ::: x has a high GPA",
            "StudiesHard(x) ::: x studies hard",
            "Graduates(x) ::: x graduates",
            "TakesExams(x) ::: x takes exams"
        ]
    },
    {
        "premises-NL": [
            "All students are registered.",
            "Some students attend lectures.",
            "A student is either registered or not registered.",
            "A student is either attending lectures or not.",
            "If someone is a student, then they are registered.",
            "If someone is registered, then they are a student.",
            "If someone attends a lecture, then they are a student.",
            "If someone is a student, then they attend a lecture or not."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Registered(x)) ::: All students are registered.",
            "∃x (Student(x) ∧ AttendsLecture(x)) ::: Some students attend lectures.",
            "∀x (Registered(x) ∨ ¬Registered(x)) ::: A student is either registered or not registered.",
            "∀x (AttendsLecture(x) ∨ ¬AttendsLecture(x)) ::: A student is either attending lectures or not.",
            "∀x (Student(x) → Registered(x)) ::: If someone is a student, then they are registered.",
            "∀x (Registered(x) → Student(x)) ::: If someone is registered, then they are a student.",
            "∀x (AttendsLecture(x) → Student(x)) ::: If someone attends a lecture, then they are a student.",
            "∀x (Student(x) → (AttendsLecture(x) ∨ ¬AttendsLecture(x))) ::: If someone is a student, then they attend a lecture or not."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Registered(x) ::: x is registered",
            "AttendsLecture(x) ::: x attends a lecture"
        ]
    },
    {
        "premises-NL": [
            "All experienced doctors are doctors.",
            "All skilled surgeons are surgeons.",
            "Some doctors are experienced.",
            "Some surgeons are skilled.",
            "If someone is a surgeon, they are a doctor.",
            "If someone is a doctor, they may be a surgeon.",
            "If someone is not a surgeon, then they are not skilled.",
            "If someone is not experienced, then they are not a doctor.",
            "All experienced doctors are also surgeons."
        ],
        "premises-FOL": [
            "∀x (ExperiencedDoctor(x) → Doctor(x)) ::: All experienced doctors are doctors.",
            "∀x (SkilledSurgeon(x) → Surgeon(x)) ::: All skilled surgeons are surgeons.",
            "∃x (Doctor(x) ∧ ExperiencedDoctor(x)) ::: Some doctors are experienced.",
            "∃x (Surgeon(x) ∧ SkilledSurgeon(x)) ::: Some surgeons are skilled.",
            "∀x (Surgeon(x) → Doctor(x)) ::: If someone is a surgeon, they are a doctor.",
            "∀x (Doctor(x) → Surgeon(x) ∨ ¬Surgeon(x)) ::: If someone is a doctor, they may be a surgeon.",
            "∀x (¬Surgeon(x) → ¬SkilledSurgeon(x)) ::: If someone is not a surgeon, then they are not skilled.",
            "∀x (¬ExperiencedDoctor(x) → ¬Doctor(x)) ::: If someone is not experienced, then they are not a doctor.",
            "∀x (ExperiencedDoctor(x) → Surgeon(x)) ::: All experienced doctors are also surgeons."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "ExperiencedDoctor(x) ::: x is an experienced doctor",
            "Surgeon(x) ::: x is a surgeon",
            "SkilledSurgeon(x) ::: x is a skilled surgeon"
        ]
    },
    {
        "premises-NL": [
            "All athletes are strong.",
            "All athletes can run a marathon.",
            "If someone is healthy, they are an athlete or not.",
            "Some healthy people are athletes.",
            "If someone is not healthy, then they cannot run a marathon.",
            "If someone can run a marathon, then they are strong.",
            "Everyone is either healthy or not healthy.",
            "Some people are both healthy and strong.",
            "If someone is an athlete, then they are healthy.",
            "Some people who are not athletes can run marathons."
        ],
        "premises-FOL": [
            "∀x (Athlete(x) → Strong(x)) ::: All athletes are strong.",
            "∀x (Athlete(x) → CanRunMarathon(x)) ::: All athletes can run a marathon.",
            "∀x (Healthy(x) → (Athlete(x) ∨ ¬Athlete(x))) ::: If someone is healthy, they are an athlete or not.",
            "∃x (Healthy(x) ∧ Athlete(x)) ::: Some healthy people are athletes.",
            "∀x (¬Healthy(x) → ¬CanRunMarathon(x)) ::: If someone is not healthy, then they cannot run a marathon.",
            "∀x (CanRunMarathon(x) → Strong(x)) ::: If someone can run a marathon, then they are strong.",
            "∀x (Healthy(x) ∨ ¬Healthy(x)) ::: Everyone is either healthy or not healthy.",
            "∃x (Healthy(x) ∧ Strong(x)) ::: Some people are both healthy and strong.",
            "∀x (Athlete(x) → Healthy(x)) ::: If someone is an athlete, then they are healthy.",
            "∃x (¬Athlete(x) ∧ CanRunMarathon(x)) ::: Some people who are not athletes can run marathons."
        ],
        "predicates": [
            "Healthy(x) ::: x is healthy",
            "Athlete(x) ::: x is an athlete",
            "CanRunMarathon(x) ::: x can run a marathon",
            "Strong(x) ::: x is strong"
        ]
    },
    {
        "premises-NL": [
            "All people are either employed or unemployed.",
            "Some employed people own cars.",
            "Some people own cars and have a license or not.",
            "Some people have a driver's license and are employed.",
            "If someone is employed, they either own a car or have a license.",
            "If someone has a license, they are a person.",
            "No one owns a car who doesn't have a license.",
            "Some people are employed.",
            "If someone owns a car, they are a person.",
            "If someone is unemployed, they do not own a car.",
            "Some people have neither a car nor a license."
        ],
        "premises-FOL": [
            "∀x (Person(x) → (Employed(x) ∨ ¬Employed(x))) ::: All people are either employed or unemployed.",
            "∃x (Employed(x) ∧ OwnsCar(x)) ::: Some employed people own cars.",
            "∃x (OwnsCar(x) ∧ (HasLicense(x) ∨ ¬HasLicense(x))) ::: Some people own cars and have a license or not.",
            "∃x (HasLicense(x) ∧ Employed(x)) ::: Some people have a driver's license and are employed.",
            "∀x (Employed(x) → (OwnsCar(x) ∨ HasLicense(x))) ::: If someone is employed, they either own a car or have a license.",
            "∀x (HasLicense(x) → Person(x)) ::: If someone has a license, they are a person.",
            "∀x (OwnsCar(x) → HasLicense(x)) ::: No one owns a car who doesn't have a license.",
            "∃x Employed(x) ::: Some people are employed.",
            "∀x (OwnsCar(x) → Person(x)) ::: If someone owns a car, they are a person.",
            "∀x (¬Employed(x) → ¬OwnsCar(x)) ::: If someone is unemployed, they do not own a car.",
            "∃x (¬OwnsCar(x) ∧ ¬HasLicense(x)) ::: Some people have neither a car nor a license."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "OwnsCar(x) ::: x owns a car",
            "HasLicense(x) ::: x has a driver's license",
            "Employed(x) ::: x is employed"
        ]
    },
    {
        "premises-NL": [
            "All scientists are researchers.",
            "Some researchers are also teachers.",
            "Some teachers publish papers.",
            "If someone is a researcher, then they publish papers.",
            "If someone publishes papers, then they are a teacher or not.",
            "If someone is a scientist, then they teach or not.",
            "Everyone is either a teacher or not.",
            "Some scientists are also teachers.",
            "If someone is a teacher, they publish papers.",
            "If someone is a researcher, then they are a teacher or not.",
            "Some researchers are scientists or not.",
            "Some people are both a teacher and a researcher."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Researcher(x)) ::: All scientists are researchers.",
            "∃x (Researcher(x) ∧ Teacher(x)) ::: Some researchers are also teachers.",
            "∃x (Teacher(x) ∧ Publishes(x)) ::: Some teachers publish papers.",
            "∀x (Researcher(x) → Publishes(x)) ::: If someone is a researcher, then they publish papers.",
            "∀x (Publishes(x) → (Teacher(x) ∨ ¬Teacher(x))) ::: If someone publishes papers, then they are a teacher or not.",
            "∀x (Scientist(x) → (Teacher(x) ∨ ¬Teacher(x))) ::: If someone is a scientist, then they teach or not.",
            "∀x (Teacher(x) ∨ ¬Teacher(x)) ::: Everyone is either a teacher or not.",
            "∃x (Scientist(x) ∧ Teacher(x)) ::: Some scientists are also teachers.",
            "∀x (Teacher(x) → Publishes(x)) ::: If someone is a teacher, they publish papers.",
            "∀x (Researcher(x) → (Teacher(x) ∨ ¬Teacher(x))) ::: If someone is a researcher, then they are a teacher or not.",
            "∃x (Researcher(x) ∨ ¬Scientist(x)) ::: Some researchers are scientists or not.",
            "∃x (Teacher(x) ∧ Researcher(x)) ::: Some people are both a teacher and a researcher."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Researcher(x) ::: x is a researcher",
            "Teacher(x) ::: x is a teacher",
            "Publishes(x) ::: x publishes papers"
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "Some students study.",
            "Anyone who studies knows someone who studies.",
            "Every smart student takes Calculus.",
            "If someone takes Calculus, they will pass the exam.",
            "If someone passes the exam, they do homework.",
            "All students are taking either Calculus or Physics.",
            "Every smart student takes Physics.",
            "John is a student.",
            "If a student is smart, then they take Calculus.",
            "If a student is not smart, then they take Physics."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "∃x (Student(x) ∧ Studies(x)) ::: Some students study.",
            "∀x ∀y ((Studies(x) ∧ Knows(x, y)) → Studies(y)) ::: Anyone who studies knows someone who studies.",
            "∀x (Smart(x) → TakesCalculus(x)) ::: Every smart student takes Calculus.",
            "∀x (TakesCalculus(x) → PassesExam(x)) ::: If someone takes Calculus, they will pass the exam.",
            "∀x (PassesExam(x) → Homework(x)) ::: If someone passes the exam, they do homework.",
            "∀x (Student(x) → (TakesCalculus(x) ∨ TakesPhysics(x))) ::: All students are taking either Calculus or Physics.",
            "∀x (Smart(x) → TakesPhysics(x)) ::: Every smart student takes Physics.",
            "Student(john) ::: John is a student.",
            "∀x (Student(x) ∧ Smart(x) → TakesCalculus(x)) ::: If a student is smart, then they take Calculus.",
            "∀x (Student(x) ∧ ¬Smart(x) → TakesPhysics(x)) ::: If a student is not smart, then they take Physics."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "TakesCalculus(x) ::: x takes Calculus",
            "TakesPhysics(x) ::: x takes Physics",
            "Smart(x) ::: x is smart",
            "Studies(x) ::: x studies",
            "Knows(x, y) ::: x knows y",
            "Homework(x) ::: x does homework",
            "PassesExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "Everyone who is a member of the club attends the meeting.",
            "Everyone who is invited is a member of the club.",
            "Some people are invited.",
            "Everyone who attends the meeting likes either tea or coffee.",
            "If someone likes tea, they do not like coffee.",
            "Someone who likes tea is not a member of the club.",
            "Everyone who likes tea or coffee is a coffee lover.",
            "If someone likes coffee, they are a coffee lover."
        ],
        "premises-FOL": [
            "∀x (MemberOfClub(x) → AttendsMeeting(x)) ::: Everyone who is a member of the club attends the meeting.",
            "∀x (Invited(x) → MemberOfClub(x)) ::: Everyone who is invited is a member of the club.",
            "∃x Invited(x) ::: Some people are invited.",
            "∀x (AttendsMeeting(x) → LikesTea(x) ∨ LikesCoffee(x)) ::: Everyone who attends the meeting likes either tea or coffee.",
            "∀x (LikesTea(x) → ¬LikesCoffee(x)) ::: If someone likes tea, they do not like coffee.",
            "∃x (LikesTea(x) ∧ ¬MemberOfClub(x)) ::: Someone who likes tea is not a member of the club.",
            "∀x (LikesTea(x) ∨ LikesCoffee(x) → IsCoffeeLover(x)) ::: Everyone who likes tea or coffee is a coffee lover.",
            "∀x (LikesCoffee(x) → IsCoffeeLover(x)) ::: If someone likes coffee, they are a coffee lover."
        ],
        "predicates": [
            "MemberOfClub(x) ::: x is a member of the club",
            "LikesCoffee(x) ::: x likes coffee",
            "AttendsMeeting(x) ::: x attends the meeting",
            "Invited(x) ::: x is invited",
            "LikesTea(x) ::: x likes tea",
            "CoffeeOrTea(x) ::: x likes coffee or tea"
        ]
    },
    {
        "premises-NL": [
            "All students read books.",
            "If someone reads books, then they attend class.",
            "If someone attends class, then they pass the exam.",
            "All who attend class are smart.",
            "John is a student.",
            "If John reads books, then John is smart.",
            "If John attends class, then John is smart.",
            "If anyone is a student, then they read books.",
            "If anyone passes an exam, then they are smart.",
            "All students are smart.",
            "If someone reads books, then they are smart.",
            "If someone passes the exam, then they attend class.",
            "John reads books.",
            "If John is smart, then he passes the exam.",
            "If someone is a student, then they are smart.",
            "If John passes the exam, then John is smart."
        ],
        "premises-FOL": [
            "∀x Student(x) → ReadsBooks(x) ::: All students read books",
            "∀x ReadsBooks(x) → AttendsClass(x) ::: If someone reads books, then they attend class",
            "∀x AttendsClass(x) → PassesExam(x) ::: If someone attends class, then they pass the exam",
            "∀x AttendsClass(x) → Smart(x) ::: All who attend class are smart",
            "Student(John) ::: John is a student",
            "ReadsBooks(John) → Smart(John) ::: If John reads books, then John is smart",
            "AttendsClass(John) → Smart(John) ::: If John attends class, then John is smart",
            "∀x Student(x) → ReadsBooks(x) ::: If anyone is a student, then they read books",
            "∀x PassesExam(x) → Smart(x) ::: If anyone passes an exam, then they are smart",
            "∀x Student(x) → Smart(x) ::: All students are smart",
            "∀x ReadsBooks(x) → Smart(x) ::: If someone reads books, then they are smart",
            "∀x PassesExam(x) → AttendsClass(x) ::: If someone passes the exam, then they attend class",
            "ReadsBooks(John) ::: John reads books",
            "Smart(John) → PassesExam(John) ::: If John is smart, then he passes the exam",
            "∀x Student(x) → Smart(x) ::: If someone is a student, then they are smart",
            "PassesExam(John) → Smart(John) ::: If John passes the exam, then John is smart"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Smart(x) ::: x is smart",
            "ReadsBooks(x) ::: x reads books",
            "AttendsClass(x) ::: x attends class",
            "PassesExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "All lawyers are honest.",
            "If anyone is honest, they are trusted.",
            "Some lawyers are not rich.",
            "If anyone is rich, they are happy.",
            "Some people are lawyers.",
            "If anyone is trusted, they are not rich.",
            "If someone is honest, then they are trusted.",
            "Some lawyers are happy.",
            "If someone is a lawyer, then they are honest.",
            "All honest people are trusted.",
            "If anyone is not rich, they are happy.",
            "If any lawyer is trusted, they are not rich.",
            "If anyone is happy, they are honest.",
            "If someone is happy, then they are trusted.",
            "If anyone is a lawyer, then they are trusted.",
            "If a lawyer is honest, then he is trusted.",
            "If someone is honest, they are happy."
        ],
        "premises-FOL": [
            "∀x Lawyer(x) → Honest(x) ::: All lawyers are honest",
            "∀x Honest(x) → Trusted(x) ::: If anyone is honest, they are trusted",
            "∃x (Lawyer(x) ∧ ¬Rich(x)) ::: Some lawyers are not rich",
            "∀x Rich(x) → Happy(x) ::: If anyone is rich, they are happy",
            "∃x Lawyer(x) ::: Some people are lawyers",
            "∀x Trusted(x) → ¬Rich(x) ::: If anyone is trusted, they are not rich",
            "∀x Honest(x) → Trusted(x) ::: If someone is honest, then they are trusted",
            "∃x (Lawyer(x) ∧ Happy(x)) ::: Some lawyers are happy",
            "∀x Lawyer(x) → Honest(x) ::: If someone is a lawyer, then they are honest",
            "∀x Honest(x) → Trusted(x) ::: All honest people are trusted",
            "∀x ¬Rich(x) → Happy(x) ::: If anyone is not rich, they are happy",
            "∀x (Lawyer(x) ∧ Trusted(x)) → ¬Rich(x) ::: If any lawyer is trusted, they are not rich",
            "∀x Happy(x) → Honest(x) ::: If anyone is happy, they are honest",
            "∀x Happy(x) → Trusted(x) ::: If someone is happy, then they are trusted",
            "∀x Lawyer(x) → Trusted(x) ::: If anyone is a lawyer, then they are trusted",
            "∀x (Lawyer(x) ∧ Honest(x)) → Trusted(x) ::: If a lawyer is honest, then he is trusted",
            "∀x Honest(x) → Happy(x) ::: If someone is honest, they are happy"
        ],
        "predicates": [
            "Lawyer(x) ::: x is a lawyer",
            "Honest(x) ::: x is honest",
            "Trusted(x) ::: x is trusted",
            "Rich(x) ::: x is rich",
            "Happy(x) ::: x is happy"
        ]
    },
    {
        "premises-NL": [
            "All scientists are friendly.",
            "John is a scientist.",
            "If someone is friendly, then they work hard.",
            "If someone works hard, they are successful.",
            "If someone is successful, then they are intelligent.",
            "All scientists are intelligent.",
            "If John is friendly, then John works hard.",
            "If John works hard, then John is successful.",
            "If John is successful, then John is intelligent.",
            "If anyone is a scientist, they are friendly.",
            "If anyone is intelligent, then they are successful.",
            "If John is a scientist, then John is intelligent.",
            "If someone is a scientist, then they are intelligent.",
            "If someone is friendly, then they are intelligent.",
            "If anyone is successful, then they are intelligent.",
            "If someone is intelligent, then they are friendly.",
            "If John is intelligent, then John is successful.",
            "John is friendly."
        ],
        "premises-FOL": [
            "∀x Scientist(x) → Friendly(x) ::: All scientists are friendly",
            "Scientist(John) ::: John is a scientist",
            "∀x Friendly(x) → WorksHard(x) ::: If someone is friendly, then they work hard",
            "∀x WorksHard(x) → Successful(x) ::: If someone works hard, they are successful",
            "∀x Successful(x) → Intelligent(x) ::: If someone is successful, then they are intelligent",
            "∀x Scientist(x) → Intelligent(x) ::: All scientists are intelligent",
            "Friendly(John) → WorksHard(John) ::: If John is friendly, then John works hard",
            "WorksHard(John) → Successful(John) ::: If John works hard, then John is successful",
            "Successful(John) → Intelligent(John) ::: If John is successful, then John is intelligent",
            "∀x Scientist(x) → Friendly(x) ::: If anyone is a scientist, they are friendly",
            "∀x Intelligent(x) → Successful(x) ::: If anyone is intelligent, then they are successful",
            "Scientist(John) → Intelligent(John) ::: If John is a scientist, then John is intelligent",
            "∀x Scientist(x) → Intelligent(x) ::: If someone is a scientist, then they are intelligent",
            "∀x Friendly(x) → Intelligent(x) ::: If someone is friendly, then they are intelligent",
            "∀x Successful(x) → Intelligent(x) ::: If anyone is successful, then they are intelligent",
            "∀x Intelligent(x) → Friendly(x) ::: If someone is intelligent, then they are friendly",
            "Intelligent(John) → Successful(John) ::: If John is intelligent, then John is successful",
            "Friendly(John) ::: John is friendly"
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Intelligent(x) ::: x is intelligent",
            "Friendly(x) ::: x is friendly",
            "WorksHard(x) ::: x works hard",
            "Successful(x) ::: x is successful"
        ]
    },
    {
        "premises-NL": [
            "All doctors know medicine.",
            "All doctors have a medical license.",
            "If someone knows medicine and has a medical license, then they care for the sick.",
            "Alex is a doctor.",
            "If Alex is a doctor then Alex knows medicine.",
            "If Alex is a doctor then Alex has a medical license.",
            "Alex is a doctor"
        ],
        "premises-FOL": [
            "∀x Doctor(x) → KnowsMedicine(x) ::: All doctors know medicine.",
            "∀x Doctor(x) → HasMedicalLicense(x) ::: All doctors have a medical license.",
            "∀x (KnowsMedicine(x) ∧ HasMedicalLicense(x)) → CaresForSick(x) ::: If someone knows medicine and has a medical license, then they care for the sick.",
            "Doctor(Alex) ::: Alex is a doctor.",
            "Doctor(Alex) → KnowsMedicine(Alex) ::: If Alex is a doctor then Alex knows medicine.",
            "Doctor(Alex) → HasMedicalLicense(Alex) ::: If Alex is a doctor then Alex has a medical license.",
            "Doctor(Alex) ::: Alex is a doctor.",
            "Doctor(Alex) → CaresForSick(Alex) ::: If Alex is a doctor, then Alex cares for the sick."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "CaresForSick(x) ::: x cares for the sick",
            "KnowsMedicine(x) ::: x knows medicine",
            "HasMedicalLicense(x) ::: x has a medical license"
        ]
    },
    {
        "premises-NL": [
            "All graduate students attend university.",
            "Anyone who attends university, conducts research and has a research project.",
            "If someone conducts research, that person writes a thesis.",
            "If someone is a graduate student, then he has a research project or attends university.",
            "Alex is a graduate student.",
            "Alex has a research project.",
            "If Alex is a graduate student, then Alex will write a thesis.",
            "If Alex has a research project and is a graduate student then Alex will write a thesis.",
            "Alex is a graduate student and has a research project."
        ],
        "premises-FOL": [
            "∀x GraduateStudent(x) → AttendsUniversity(x) ::: All graduate students attend university.",
            "∀x AttendsUniversity(x) → (ConductsResearch(x) ∧ HasResearchProject(x)) ::: Anyone who attends university, conducts research and has a research project.",
            "∀x ConductsResearch(x) → WritesThesis(x) ::: If someone conducts research, that person writes a thesis.",
            "∀x GraduateStudent(x) → (HasResearchProject(x) ∨ AttendsUniversity(x)) ::: If someone is a graduate student, then he has a research project or attends university.",
            "GraduateStudent(Alex) ::: Alex is a graduate student.",
            "HasResearchProject(Alex) ::: Alex has a research project.",
            "GraduateStudent(Alex) → WritesThesis(Alex) ::: If Alex is a graduate student, then Alex will write a thesis.",
            "(HasResearchProject(Alex) ∧ GraduateStudent(Alex)) → WritesThesis(Alex) ::: If Alex has a research project and is a graduate student then Alex will write a thesis.",
            "(GraduateStudent(Alex) ∧ HasResearchProject(Alex)) ::: Alex is a graduate student and has a research project."
        ],
        "predicates": [
            "GraduateStudent(x) ::: x is a graduate student",
            "HasResearchProject(x) ::: x has a research project",
            "AttendsUniversity(x) ::: x attends university",
            "ConductsResearch(x) ::: x conducts research",
            "WritesThesis(x) ::: x writes a thesis"
        ]
    },
    {
        "premises-NL": [
            "If a patient takes medication A and medication B, then the patient receives treatment.",
            "If a patient receives treatment and has a disease, then the patient's condition improves.",
            "All patients who take medication A also take medication B.",
            "Some patients take medication A.",
            "If a patient takes medication A, they are treated.",
            "If a patient takes medication B and has a disease, then their condition will improve.",
            "If someone takes medication A and has a disease then their condition improves.",
            "Alex takes medication A and has a disease.",
            "If a patient takes medication B, then they receive treatment.",
            "Alex takes medication A.",
            "premises-FOL",
            "(TakesMedicationA(x) ∧ TakesMedicationB(x)) → ReceivesTreatment(x) ::: If a patient takes medication A and medication B, then the patient receives treatment.",
            "(ReceivesTreatment(x) ∧ HasDisease(x)) → ImprovesCondition(x) ::: If a patient receives treatment and has a disease, then the patient's condition improves.",
            "∀x TakesMedicationA(x) → TakesMedicationB(x) ::: All patients who take medication A also take medication B.",
            "∃x TakesMedicationA(x) ::: Some patients take medication A.",
            "∀x TakesMedicationA(x) → ReceivesTreatment(x) ::: If a patient takes medication A, they are treated.",
            "(TakesMedicationB(x) ∧ HasDisease(x)) → ImprovesCondition(x) ::: If a patient takes medication B and has a disease, then their condition will improve.",
            "(TakesMedicationA(x) ∧ HasDisease(x)) → ImprovesCondition(x) ::: If someone takes medication A and has a disease then their condition improves.",
            "(TakesMedicationA(Alex) ∧ HasDisease(Alex)) ::: Alex takes medication A and has a disease.",
            "∀x TakesMedicationB(x) → ReceivesTreatment(x) ::: If a patient takes medication B, then they receive treatment.",
            "TakesMedicationA(Alex) ::: Alex takes medication A."
        ],
        "premises-FOL": [],
        "predicates": [
            "TakesMedicationA(x) ::: x takes medication A",
            "TakesMedicationB(x) ::: x takes medication B",
            "HasDisease(x) ::: x has a disease",
            "ReceivesTreatment(x) ::: x receives treatment",
            "ImprovesCondition(x) ::: x's condition improves"
        ]
    },
    {
        "premises-NL": [
            "Anyone who studies hard attends class.",
            "Anyone who attends class and understands the material passes the exam.",
            "Anyone who is intelligent understands the material.",
            "Alex studies hard and is intelligent.",
            "If Alex studies hard and is intelligent, then Alex attends class.",
            "If Alex studies hard, then Alex attends class.",
            "If Alex studies hard and attends class, then Alex passes the exam.",
            "Anyone who is intelligent studies hard.",
            "If Alex is intelligent and studies hard, then Alex understands the material.",
            "If Alex understands the material, then Alex passes the exam.",
            "If Alex studies hard and attends class and understands the material, then Alex passes the exam."
        ],
        "premises-FOL": [
            "∀x StudiesHard(x) → AttendsClass(x) ::: Anyone who studies hard attends class.",
            "∀x (AttendsClass(x) ∧ UnderstandsMaterial(x)) → PassesExam(x) ::: Anyone who attends class and understands the material passes the exam.",
            "∀x Intelligent(x) → UnderstandsMaterial(x) ::: Anyone who is intelligent understands the material.",
            "(StudiesHard(Alex) ∧ Intelligent(Alex)) ::: Alex studies hard and is intelligent.",
            "(StudiesHard(Alex) ∧ Intelligent(Alex)) → AttendsClass(Alex) ::: If Alex studies hard and is intelligent, then Alex attends class.",
            "StudiesHard(Alex) → AttendsClass(Alex) ::: If Alex studies hard, then Alex attends class.",
            "(StudiesHard(Alex) ∧ AttendsClass(Alex)) → PassesExam(Alex) ::: If Alex studies hard and attends class, then Alex passes the exam.",
            "∀x Intelligent(x) → StudiesHard(x) ::: Anyone who is intelligent studies hard.",
            "(Intelligent(Alex) ∧ StudiesHard(Alex)) → UnderstandsMaterial(Alex) ::: If Alex is intelligent and studies hard, then Alex understands the material.",
            "UnderstandsMaterial(Alex) → PassesExam(Alex) ::: If Alex understands the material, then Alex passes the exam.",
            "(StudiesHard(Alex) ∧ AttendsClass(Alex) ∧ UnderstandsMaterial(Alex)) → PassesExam(Alex) ::: If Alex studies hard and attends class and understands the material, then Alex passes the exam."
        ],
        "predicates": [
            "StudiesHard(x) ::: x studies hard",
            "Intelligent(x) ::: x is intelligent",
            "AttendsClass(x) ::: x attends class",
            "PassesExam(x) ::: x passes the exam",
            "UnderstandsMaterial(x) ::: x understands the material"
        ]
    },
    {
        "premises-NL": [
            "All fruits are edible and grow on a tree.",
            "If something is red, then it is sweet or it is a source of Vitamin A.",
            "Anything that grows on a tree is a source of Vitamin C or Vitamin A.",
            "If something is a fruit and red, it is a source of Vitamin C.",
            "If something is edible and red, then it is a source of Vitamin C or A.",
            "Apples are fruits and red.",
            "If something is a fruit and red, then it is edible.",
            "Something is a fruit and a source of Vitamin C.",
            "If something is red, then it is a source of Vitamin C.",
            "If something is sweet, then it is a source of Vitamin A.",
            "If something is fruit and red, then is not the source of Vitamin A.",
            "Anything red and edible is a source of Vitamin C"
        ],
        "premises-FOL": [
            "∀x Fruit(x) → (Edible(x) ∧ GrowsOnTree(x)) ::: All fruits are edible and grow on a tree.",
            "∀x Red(x) → (Sweet(x) ∨ SourceOfVitaminA(x)) ::: If something is red, then it is sweet or it is a source of Vitamin A.",
            "∀x GrowsOnTree(x) → (SourceOfVitaminC(x) ∨ SourceOfVitaminA(x)) ::: Anything that grows on a tree is a source of Vitamin C or Vitamin A.",
            "∀x (Fruit(x) ∧ Red(x)) → SourceOfVitaminC(x) ::: If something is a fruit and red, it is a source of Vitamin C.",
            "∀x (Edible(x) ∧ Red(x)) → (SourceOfVitaminC(x) ∨ SourceOfVitaminA(x)) ::: If something is edible and red, then it is a source of Vitamin C or A.",
            "(Fruit(Apple) ∧ Red(Apple)) ::: Apples are fruits and red.",
            "∀x (Fruit(x) ∧ Red(x)) → Edible(x) ::: If something is a fruit and red, then it is edible.",
            "∃x (Fruit(x) ∧ SourceOfVitaminC(x)) ::: Something is a fruit and a source of Vitamin C.",
            "∀x Red(x) → SourceOfVitaminC(x) ::: If something is red, then it is a source of Vitamin C.",
            "∀x Sweet(x) → SourceOfVitaminA(x) ::: If something is sweet, then it is a source of Vitamin A.",
            "∀x (Fruit(x) ∧ Red(x)) → ¬SourceOfVitaminA(x) ::: If something is fruit and red, then is not the source of Vitamin A.",
            "∀x (Red(x) ∧ Edible(x)) → SourceOfVitaminC(x) ::: Anything red and edible is a source of Vitamin C"
        ],
        "predicates": [
            "Fruit(x) ::: x is a fruit",
            "Red(x) ::: x is red",
            "SourceOfVitaminC(x) ::: x is a source of Vitamin C",
            "SourceOfVitaminA(x) ::: x is a source of Vitamin A",
            "GrowsOnTree(x) ::: x grows on a tree",
            "Sweet(x) ::: x is sweet",
            "Edible(x) ::: x is edible"
        ]
    },
    {
        "premises-NL": [
            "All students who study logic understand logic.",
            "Some students study logic.",
            "Every student is either a student of computer science or a student of mathematics.",
            "No student studies computer science and mathematics together.",
            "If someone studies computer science, they don't understand logic.",
            "If someone studies mathematics, they understand logic.",
            "If someone studies logic, they are a student of mathematics.",
            "Anyone who studies logic is a student.",
            "If a student understands logic, they are happy.",
            "If someone is happy, then they are studying logic.",
            "There is a student who studies logic.",
            "Someone who studies mathematics is a student.",
            "No one studies computer science and understands logic."
        ],
        "premises-FOL": [
            "∀x (StudiesLogic(x) → UnderstandsLogic(x)) ::: All students who study logic understand logic.",
            "∃x StudiesLogic(x) ::: Some students study logic.",
            "∀x (Student(x) → (StudiesComputerScience(x) ∨ StudiesMathematics(x))) ::: Every student is either a student of computer science or a student of mathematics.",
            "∀x ¬(StudiesComputerScience(x) ∧ StudiesMathematics(x)) ::: No student studies computer science and mathematics together.",
            "∀x (StudiesComputerScience(x) → ¬UnderstandsLogic(x)) ::: If someone studies computer science, they don't understand logic.",
            "∀x (StudiesMathematics(x) → UnderstandsLogic(x)) ::: If someone studies mathematics, they understand logic.",
            "∀x (StudiesLogic(x) → StudiesMathematics(x)) ::: If someone studies logic, they are a student of mathematics.",
            "∀x (StudiesLogic(x) → Student(x)) ::: Anyone who studies logic is a student.",
            "∀x (UnderstandsLogic(x) → Happy(x)) ::: If a student understands logic, they are happy.",
            "∀x (Happy(x) → StudiesLogic(x)) ::: If someone is happy, then they are studying logic.",
            "∃x (Student(x) ∧ StudiesLogic(x)) ::: There is a student who studies logic.",
            "∀x (StudiesMathematics(x) → Student(x)) ::: Someone who studies mathematics is a student.",
            "∀x ¬(StudiesComputerScience(x) ∧ UnderstandsLogic(x)) ::: No one studies computer science and understands logic."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesLogic(x) ::: x studies logic.",
            "UnderstandsLogic(x) ::: x understands logic."
        ]
    },
    {
        "premises-NL": [
            "All students eat apples or bananas.",
            "If someone eats apples, then they like apples.",
            "If someone eats bananas, then they like bananas.",
            "No student likes both apples and bananas.",
            "Some students study logic.",
            "All students either like apples or bananas.",
            "Anyone who likes apples eats apples.",
            "Anyone who likes bananas eats bananas.",
            "If someone studies logic, they eat apples.",
            "If someone studies logic, they eat bananas.",
            "Every student studies something.",
            "If someone studies, they like something.",
            "If someone likes something, they are happy.",
            "If a student likes something, they eat it.",
            "Anyone who enjoys logic eats apples or bananas.",
            "If someone eats apples and bananas, they are a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Eats(x, apples) ∨ Eats(x, bananas))) ::: All students eat apples or bananas.",
            "∀x (Eats(x, apples) → Likes(x, apples)) ::: If someone eats apples, then they like apples.",
            "∀x (Eats(x, bananas) → Likes(x, bananas)) ::: If someone eats bananas, then they like bananas.",
            "∀x ¬(Likes(x, apples) ∧ Likes(x, bananas)) ::: No student likes both apples and bananas.",
            "∃x (Student(x) ∧ Studies(x, logic)) ::: Some students study logic.",
            "∀x (Student(x) → (Likes(x, apples) ∨ Likes(x, bananas))) ::: All students either like apples or bananas.",
            "∀x (Likes(x, apples) → Eats(x, apples)) ::: Anyone who likes apples eats apples.",
            "∀x (Likes(x, bananas) → Eats(x, bananas)) ::: Anyone who likes bananas eats bananas.",
            "∀x (Studies(x, logic) → Eats(x, apples)) ::: If someone studies logic, they eat apples.",
            "∀x (Studies(x, logic) → Eats(x, bananas)) ::: If someone studies logic, they eat bananas.",
            "∀x ∃z Studies(x, z) ::: Every student studies something.",
            "∀x ∃z (Studies(x, z) → Likes(x, z)) ::: If someone studies, they like something.",
            "∀x ∃z (Likes(x, z) → Happy(x)) ::: If someone likes something, they are happy.",
            "∀x ∀y (Student(x) ∧ Likes(x, y) → Eats(x, y)) ::: If a student likes something, they eat it.",
            "∀x (Enjoys(x, logic) → (Eats(x, apples) ∨ Eats(x, bananas))) ::: Anyone who enjoys logic eats apples or bananas.",
            "∀x ((Eats(x, apples) ∧ Eats(x, bananas)) → Student(x)) ::: If someone eats apples and bananas, they are a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Likes(x, y) ::: x likes y.",
            "Eats(x, y) ::: x eats y.",
            "Apple(y) ::: y is an apple.",
            "Banana(y) ::: y is a banana.",
            "Studies(x, z) ::: x studies z.",
            "Enjoys(x, z) ::: x enjoys z."
        ]
    },
    {
        "premises-NL": [
            "All rich people own a house and a car.",
            "Some people are rich.",
            "Anyone who owns a car does not work at any company.",
            "If someone has a job, they are employed by a company.",
            "If someone is employed by a company, they have a job.",
            "Some people have jobs.",
            "Everyone is a person.",
            "If someone has a job and owns a house, they are rich.",
            "Some people work at a company.",
            "If someone works at a company, they have a job.",
            "If someone has a job, they own a house.",
            "Anyone who owns a house is rich or poor.",
            "No one is both rich and poor.",
            "If someone does not own a car, they are not rich.",
            "Some people own a house.",
            "Some people own a car."
        ],
        "premises-FOL": [
            "∀x (Rich(x) → (Owns(x, car) ∧ Owns(x, house))) ::: All rich people own a house and a car.",
            "∃x Rich(x) ::: Some people are rich.",
            "∀x ∀y (Owns(x, car) → ¬WorksAt(x, y)) ::: Anyone who owns a car does not work at any company.",
            "∀x ∀y (HasJob(x) → IsEmployedBy(x, y)) ::: If someone has a job, they are employed by a company.",
            "∀x ∀y (IsEmployedBy(x, y) → HasJob(x)) ::: If someone is employed by a company, they have a job.",
            "∃x HasJob(x) ::: Some people have jobs.",
            "∀x Person(x) ::: Everyone is a person.",
            "∀x (HasJob(x) ∧ Owns(x, house) → Rich(x)) ::: If someone has a job and owns a house, they are rich.",
            "∃x ∃y WorksAt(x, y) ::: Some people work at a company.",
            "∀x ∀y (WorksAt(x, y) → HasJob(x)) ::: If someone works at a company, they have a job.",
            "∀x (HasJob(x) → Owns(x, house)) ::: If someone has a job, they own a house.",
            "∀x (Owns(x, house) → (Rich(x) ∨ Poor(x))) ::: Anyone who owns a house is rich or poor.",
            "∀x ¬(Rich(x) ∧ Poor(x)) ::: No one is both rich and poor.",
            "∀x (¬Owns(x, car) → ¬Rich(x)) ::: If someone does not own a car, they are not rich.",
            "∃x Owns(x, house) ::: Some people own a house.",
            "∃x Owns(x, car) ::: Some people own a car."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "Owns(x, y) ::: x owns y.",
            "Car(x) ::: x is a car.",
            "House(x) ::: x is a house.",
            "Rich(x) ::: x is rich.",
            "HasJob(x) ::: x has a job.",
            "WorksAt(x, y) ::: x works at y.",
            "Company(y) ::: y is a company.",
            "IsEmployedBy(x, y) ::: x is employed by y."
        ]
    },
    {
        "premises-NL": [
            "All athletes have free time.",
            "All volunteers have free time.",
            "Anyone who has free time might not be a student.",
            "If someone plays a sport, they are an athlete.",
            "If someone supports a cause, they are a volunteer.",
            "Sarah plays soccer.",
            "Sarah supports the environment.",
            "Some athlete has free time."
        ],
        "premises-FOL": [
            "∀x (Athlete(x) → HasFreeTime(x)) ::: All athletes have free time.",
            "∀x (Volunteer(x) → HasFreeTime(x)) ::: All volunteers have free time.",
            "∀x (HasFreeTime(x) → ¬Student(x)) ::: Anyone who has free time might not be a student.",
            "∀x ∀y (PlaysSport(x, y) → Athlete(x)) ::: If someone plays a sport, they are an athlete.",
            "∀x ∀y (SupportsCause(x, y) → Volunteer(x)) ::: If someone supports a cause, they are a volunteer.",
            "PlaysSport(Sarah, Soccer) ::: Sarah plays soccer.",
            "SupportsCause(Sarah, Environment) ::: Sarah supports the environment.",
            "∃x (Athlete(x) ∧ HasFreeTime(x)) ::: Some athlete has free time."
        ],
        "predicates": [
            "Athlete(x) ::: x is an athlete",
            "Volunteer(x) ::: x is a volunteer",
            "Student(x) ::: x is a student",
            "HasFreeTime(x) ::: x has free time",
            "PlaysSport(x, y) ::: x plays sport y",
            "SupportsCause(x, y) ::: x supports cause y"
        ]
    },
    {
        "premises-NL": [
            "Anyone who is vegetarian doesn't eat meat.",
            "All vegetarians love animals.",
            "All people who have pets love animals.",
            "Anyone who loves animals might be vegetarian.",
            "John has a pet.",
            "John is vegetarian.",
            "John eats vegetables.",
            "Someone who eats meat is not vegetarian.",
            "If John buys food, then he eats vegetables.",
            "John does not eat meat."
        ],
        "premises-FOL": [
            "∀x (Vegetarian(x) → ¬EatsMeat(x)) ::: Anyone who is vegetarian doesn't eat meat.",
            "∀x (Vegetarian(x) → LovesAnimals(x)) ::: All vegetarians love animals.",
            "∀x (HasPet(x) → LovesAnimals(x)) ::: All people who have pets love animals.",
            "∀x (LovesAnimals(x) → Vegetarian(x)) ::: Anyone who loves animals might be vegetarian.",
            "HasPet(John) ::: John has a pet.",
            "Vegetarian(John) ::: John is vegetarian.",
            "EatsVegetables(John) ::: John eats vegetables.",
            "∀x (EatsMeat(x) → ¬Vegetarian(x)) ::: Someone who eats meat is not vegetarian.",
            "∀x (BuysFood(John, x) → EatsVegetables(John)) ::: If John buys food, then he eats vegetables.",
            "¬EatsMeat(John) ::: John does not eat meat."
        ],
        "predicates": [
            "HasPet(x) ::: x has a pet",
            "Vegetarian(x) ::: x is a vegetarian",
            "EatsMeat(x) ::: x eats meat",
            "LovesAnimals(x) ::: x loves animals",
            "EatsVegetables(x) ::: x eats vegetables",
            "IsHealthy(x) ::: x is healthy",
            "BuysFood(x, y) ::: x buys food y"
        ]
    },
    {
        "premises-NL": [
            "Anyone who follows a healthy diet does not eat fast food.",
            "All people who exercise regularly are healthy.",
            "Anyone who is healthy might not be obese.",
            "If someone eats fast food, they have high cholesterol.",
            "If someone has high cholesterol, they visit a doctor.",
            "John follows a healthy diet.",
            "John exercises regularly.",
            "John eats vegetables.",
            "If John exercises regularly, he is healthy.",
            "John does not eat fast food.",
            "John does not like sweets."
        ],
        "premises-FOL": [
            "∀x (FollowsHealthyDiet(x) → ¬EatsFastFood(x)) ::: Anyone who follows a healthy diet does not eat fast food.",
            "∀x (ExercisesRegularly(x) → IsHealthy(x)) ::: All people who exercise regularly are healthy.",
            "∀x (IsHealthy(x) → ¬Obese(x)) ::: Anyone who is healthy might not be obese.",
            "∀x (EatsFastFood(x) → HasHighCholesterol(x)) ::: If someone eats fast food, they have high cholesterol.",
            "∀x (HasHighCholesterol(x) → VisitsDoctor(x)) ::: If someone has high cholesterol, they visit a doctor.",
            "FollowsHealthyDiet(John) ::: John follows a healthy diet.",
            "ExercisesRegularly(John) ::: John exercises regularly.",
            "EatsVegetables(John) ::: John eats vegetables.",
            "∀x (ExercisesRegularly(John) → IsHealthy(John)) ::: If John exercises regularly, he is healthy.",
            "¬EatsFastFood(John) ::: John does not eat fast food.",
            "¬LikesSweets(John) ::: John does not like sweets."
        ],
        "predicates": [
            "FollowsHealthyDiet(x) ::: x follows a healthy diet",
            "ExercisesRegularly(x) ::: x exercises regularly",
            "Obese(x) ::: x is obese",
            "EatsFastFood(x) ::: x eats fast food",
            "HasHighCholesterol(x) ::: x has high cholesterol",
            "VisitsDoctor(x) ::: x visits a doctor",
            "Smokes(x) ::: x smokes",
            "EatsVegetables(x) ::: x eats vegetables",
            "IsHealthy(x) ::: x is healthy",
            "DrinksAlcohol(x) ::: x drinks alcohol",
            "LikesSweets(x) ::: x likes sweets"
        ]
    },
    {
        "premises-NL": [
            "All students who study diligently will pass the exam.",
            "John is a student.",
            "John studies diligently.",
            "If someone is a student and likes pizza then they study diligently.",
            "If John does not study diligently then he likes pizza.",
            "John is a student and likes pizza.",
            "If John likes pizza, then he will not pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesDiligently(x) → PassExam(x)) ::: All students who study diligently will pass the exam",
            "Student(john) ::: John is a student",
            "StudiesDiligently(john) ::: John studies diligently",
            "∀x (Student(x) ∧ LikesPizza(x) → StudiesDiligently(x)) ::: If someone is a student and likes pizza then they study diligently",
            "¬StudiesDiligently(john) → LikesPizza(john) ::: If John does not study diligently then he likes pizza",
            "Student(john) ∧ LikesPizza(john) ::: John is a student and likes pizza",
            "LikesPizza(john) → ¬PassExam(john) ::: If John likes pizza, then he will not pass the exam"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesDiligently(x) ::: x studies diligently",
            "PassExam(x) ::: x passes the exam",
            "LikesPizza(x) ::: x likes pizza"
        ]
    },
    {
        "premises-NL": [
            "If Sarah attends the seminar, she gets information.",
            "If Sarah gets information, she will not miss the opportunity.",
            "Sarah is a student and interested in the topic.",
            "All students interested in the topic attend the seminar.",
            "The speaker is a student.",
            "If Sarah attends the seminar, she gets access.",
            "If Sarah gets access, she gets information.",
            "If Sarah doesn't attend the seminar, she's not interested in the topic."
        ],
        "premises-FOL": [
            "AttendsSeminar(sarah) → GetsInformation(sarah) ::: If Sarah attends the seminar, she gets information.",
            "GetsInformation(sarah) → ¬MissOpportunity(sarah) ::: If Sarah gets information, she will not miss the opportunity.",
            "Student(sarah) ∧ InterestedInTopic(sarah) ::: Sarah is a student and interested in the topic.",
            "∀x (Student(x) ∧ InterestedInTopic(x) → AttendsSeminar(x)) ::: All students interested in the topic attend the seminar.",
            "∃x (IsSpeaker(x) ∧ Student(x)) ::: The speaker is a student.",
            "AttendsSeminar(sarah) → HasAccess(sarah, seminar) ::: If Sarah attends the seminar, she gets access.",
            "HasAccess(sarah, seminar) → GetsInformation(sarah) ::: If Sarah gets access, she gets information.",
            "¬AttendsSeminar(sarah) → ¬InterestedInTopic(sarah) ::: If Sarah doesn't attend the seminar, she's not interested in the topic."
        ],
        "predicates": [
            "AttendsSeminar(x) ::: x attends the seminar",
            "MissOpportunity(x) ::: x misses the opportunity",
            "InterestedInTopic(x) ::: x is interested in the topic",
            "GetsInformation(x) ::: x gets the information",
            "HasAccess(x, y) ::: x has access to y",
            "IsSpeaker(x) ::: x is a speaker"
        ]
    },
    {
        "premises-NL": [
            "If a company's stock price increases, the company is profitable.",
            "If a company is profitable, then its revenue will rise.",
            "The stock price is increasing.",
            "If a company has a good reputation, then its stock price will increase.",
            "If someone invests in a company, it has a good reputation.",
            "If a company generates revenue and is successful, it's profitable.",
            "The company is successful.",
            "If the company generates revenue, it is not profitable.",
            "The company generates revenue."
        ],
        "premises-FOL": [
            "Increases(stockPrice) → Profitable(company) ::: If a company's stock price increases, the company is profitable.",
            "Profitable(company) → Rise(companyRevenue) ::: If a company is profitable, then its revenue will rise.",
            "Increases(stockPrice) ::: The stock price is increasing.",
            "HasGoodReputation(company) → Increases(stockPrice) ::: If a company has a good reputation, then its stock price will increase.",
            "∀x ∃y (Invests(x, company) → HasGoodReputation(company)) ::: If someone invests in a company, it has a good reputation.",
            "GeneratesRevenue(company) ∧ IsSuccessful(company) → Profitable(company) ::: If a company generates revenue and is successful, it's profitable.",
            "IsSuccessful(company) ::: The company is successful.",
            "GeneratesRevenue(company) → ¬Profitable(company) ::: If the company generates revenue, it is not profitable.",
            "GeneratesRevenue(company) ::: The company generates revenue."
        ],
        "predicates": [
            "Increases(x) ::: x increases",
            "Rise(x) ::: x rises",
            "Profitable(x) ::: x is profitable",
            "Invests(x, y) ::: x invests in y",
            "HasGoodReputation(x) ::: x has a good reputation",
            "IsSuccessful(x) ::: x is successful",
            "GeneratesRevenue(x) ::: x generates revenue"
        ]
    },
    {
        "premises-NL": [
            "If a patient takes the medication, then they receive treatment.",
            "If a patient receives treatment, they will not experience side effects.",
            "If a patient is sick and needs medication, then they take the medication.",
            "The patient is sick.",
            "If the patient is healthy, they do not take the medication.",
            "If someone has a disease, they need medication.",
            "The patient needs medication.",
            "If the patient has immunity, they are healthy.",
            "The patient receives treatment.",
            "If a patient recovers, they are healthy."
        ],
        "premises-FOL": [
            "TakesMedication(patient) → ReceivesTreatment(patient) ::: If a patient takes the medication, then they receive treatment.",
            "ReceivesTreatment(patient) → ¬HasSideEffects(patient) ::: If a patient receives treatment, they will not experience side effects.",
            "IsSick(patient) ∧ NeedsMedication(patient) → TakesMedication(patient) ::: If a patient is sick and needs medication, then they take the medication.",
            "IsSick(patient) ::: The patient is sick.",
            "IsHealthy(patient) → ¬TakesMedication(patient) ::: If the patient is healthy, they do not take the medication.",
            "∀x ∃y (HasDisease(x, y) → NeedsMedication(x)) ::: If someone has a disease, they need medication.",
            "NeedsMedication(patient) ::: The patient needs medication.",
            "HasImmunity(patient) → IsHealthy(patient) ::: If the patient has immunity, they are healthy.",
            "ReceivesTreatment(patient) ::: The patient receives treatment.",
            "Recovers(patient) → IsHealthy(patient) ::: If a patient recovers, they are healthy."
        ],
        "predicates": [
            "TakesMedication(x) ::: x takes the medication",
            "HasSideEffects(x) ::: x has side effects",
            "IsSick(x) ::: x is sick",
            "NeedsMedication(x) ::: x needs medication",
            "IsHealthy(x) ::: x is healthy",
            "HasDisease(x, y) ::: x has disease y",
            "HasImmunity(x) ::: x has immunity",
            "Recovers(x) ::: x recovers",
            "ReceivesTreatment(x) ::: x receives treatment"
        ]
    },
    {
        "premises-NL": [
            "All doctors are skilled.",
            "Some doctors are on-call.",
            "Doctors who are not on-call are not available.",
            "If someone is on-call, then they are a doctor.",
            "Sarah is a doctor.",
            "Sarah is not on-call."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Skilled(x)) ::: All doctors are skilled.",
            "∃x (Doctor(x) ∧ OnCall(x)) ::: Some doctors are on-call.",
            "∀x (Doctor(x) ∧ ¬OnCall(x) → ¬Available(x)) ::: Doctors who are not on-call are not available.",
            "∀x (OnCall(x) → Doctor(x)) ::: If someone is on-call, then they are a doctor.",
            "Doctor(Sarah) ::: Sarah is a doctor.",
            "¬OnCall(Sarah) ::: Sarah is not on-call."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "OnCall(x) ::: x is on call",
            "Available(x) ::: x is available"
        ]
    },
    {
        "premises-NL": [
            "All students study.",
            "John is a student.",
            "If someone is a student, then that person studies.",
            "Either John is not a student, or he studies.",
            "It is not the case that John is a student and does not study.",
            "If John studies, then he understands the material."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Studies(x)) ::: All students study.",
            "Student(John) ::: John is a student.",
            "∀x (Student(x) → Studies(x)) ::: If someone is a student, then that person studies.",
            "(¬Student(John) ∨ Studies(John)) ::: Either John is not a student, or he studies.",
            "¬(Student(John) ∧ ¬Studies(John)) ::: It is not the case that John is a student and does not study.",
            "Studies(John) → UnderstandsMaterial(John) ::: If John studies, then he understands the material."
        ],
        "predicates": [
            "Studies(x) ::: x studies.",
            "Student(x) ::: x is a student."
        ]
    },
    {
        "premises-NL": [
            "All programmers use either Python or Java.",
            "Alex is a programmer.",
            "If someone is a programmer, they either use Python or Java.",
            "If someone doesn't use Python, they might use Java.",
            "Alex doesn't use both Python and Java.",
            "Programmers are not students.",
            "If Alex uses Java, then he can build web applications."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → (UsesPython(x) ∨ UsesJava(x))) ::: All programmers use either Python or Java.",
            "Programmer(Alex) ::: Alex is a programmer.",
            "∀x (Programmer(x) → (UsesPython(x) ∨ UsesJava(x))) ::: If someone is a programmer, they either use Python or Java.",
            "∀x (¬UsesPython(x) → UsesJava(x)) ::: If someone doesn't use Python, they might use Java.",
            "¬(UsesPython(Alex) ∧ UsesJava(Alex)) ::: Alex doesn't use both Python and Java.",
            "∀x (Programmer(x) → ¬Student(x)) ::: Programmers are not students.",
            "UsesJava(Alex) → CanBuildWebApp(Alex) ::: If Alex uses Java, then he can build web applications."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer.",
            "UsesPython(x) ::: x uses Python.",
            "UsesJava(x) ::: x uses Java."
        ]
    },
    {
        "premises-NL": [
            "All students who study medicine must pass exams.",
            "Anyone who passes exams will be a doctor.",
            "Only those who study medicine are students.",
            "All those who study medicine attend classes",
            "Someone who studies medicine is smart.",
            "People who study medicine enroll in a university.",
            "A person has to pass exams to get a certificate.",
            "Anyone who has a certificate will be a doctor.",
            "If someone studies medicine, they have to attend classes.",
            "If someone fails an exam, they are not smart.",
            "If someone studies medicine and is smart, they will pass the exam.",
            "Only if someone has a degree they will be a doctor."
        ],
        "premises-FOL": [
            "∀x (StudiesMedicine(x) ∧ IsStudent(x) → PassesExams(x)) ::: All students who study medicine must pass exams.",
            "∀x (PassesExams(x) → WillBeDoctor(x)) ::: Anyone who passes exams will be a doctor.",
            "∀x (IsStudent(x) → StudiesMedicine(x)) ::: Only those who study medicine are students.",
            "∀x (StudiesMedicine(x) → AttendsClasses(x)) ::: All those who study medicine attend classes.",
            "∃x (StudiesMedicine(x) ∧ IsSmart(x)) ::: Someone who studies medicine is smart.",
            "∀x (StudiesMedicine(x) → EnrollsInUniversity(x)) ::: People who study medicine enroll in a university.",
            "∀x (PassesExams(x) → HasCertificate(x)) ::: A person has to pass exams to get a certificate.",
            "∀x (HasCertificate(x) → WillBeDoctor(x)) ::: Anyone who has a certificate will be a doctor.",
            "∀x (StudiesMedicine(x) → AttendsClasses(x)) ::: If someone studies medicine, they have to attend classes.",
            "∀x (FailsExams(x) → ¬IsSmart(x)) ::: If someone fails an exam, they are not smart.",
            "∀x (StudiesMedicine(x) ∧ IsSmart(x) → PassesExams(x)) ::: If someone studies medicine and is smart, they will pass the exam.",
            "∀x (IsDoctor(x) → HasDegree(x)) ::: Only if someone has a degree they will be a doctor."
        ],
        "predicates": [
            "StudiesMedicine(x) ::: x studies medicine",
            "PassesExams(x) ::: x passes exams",
            "WillBeDoctor(x) ::: x will be a doctor",
            "IsStudent(x) ::: x is a student",
            "NeedsCertificate(x) ::: x needs a certificate",
            "HasCertificate(x) ::: x has a certificate",
            "IsDoctor(x) ::: x is a doctor",
            "AttendsClasses(x) ::: x attends classes",
            "FailsExams(x) ::: x fails exams",
            "IsSmart(x) ::: x is smart",
            "EnrollsInUniversity(x) ::: x enrolls in university",
            "NeedsDegree(x) ::: x needs a degree"
        ]
    },
    {
        "premises-NL": [
            "All students study hard if they read textbooks and do homework.",
            "A student will pass the exam if and only if they are prepared.",
            "Students who attend classes are smart only if they understand the material.",
            "If a student studies hard and is smart, they will understand the material.",
            "Students who are prepared for the exam have good grades.",
            "If a student studies hard and doesn't skip classes, then they attends all classes.",
            "Students who don't study hard will fail the exam.",
            "If a student asks questions, they understand the material.",
            "If a student understands the material, then they will pass the exam.",
            "If a student has a study group and all group members study hard and attends classes, they will pass the exam.",
            "Students who skip classes do not study hard.",
            "Students with good grades will be prepared for the exam.",
            "If a student studies hard they read textbooks and does homework.",
            "If a student attends classes and asks questions, they study hard."
        ],
        "premises-FOL": [
            "∀x (IsStudent(x) ∧ (ReadsTextbooks(x) ∧ DoesHomework(x)) → StudiesHard(x)) ::: All students study hard if they read textbooks and do homework.",
            "∀x (IsStudent(x) → (PassesExam(x) ↔ IsPrepared(x))) ::: A student will pass the exam if and only if they are prepared.",
            "∀x (AttendsClasses(x) → (IsSmart(x) ↔ UnderstandsMaterial(x))) ::: Students who attend classes are smart only if they understand the material.",
            "∀x (StudiesHard(x) ∧ IsSmart(x) → UnderstandsMaterial(x)) ::: If a student studies hard and is smart, they will understand the material.",
            "∀x (IsPrepared(x) → HasGoodGrades(x)) ::: Students who are prepared for the exam have good grades.",
            "∀x (StudiesHard(x) ∧ ¬SkipsClasses(x) → AttendsClasses(x)) ::: If a student studies hard and doesn't skip classes, then they attends all classes.",
            "∀x (¬StudiesHard(x) → FailsExam(x)) ::: Students who don't study hard will fail the exam.",
            "∀x (AsksQuestions(x) → UnderstandsMaterial(x)) ::: If a student asks questions, they understand the material.",
            "∀x (UnderstandsMaterial(x) → PassesExam(x)) ::: If a student understands the material, then they will pass the exam.",
            "∀x ∀y (HasStudyGroup(x, y) ∧ StudiesHard(x) ∧ StudiesHard(y) ∧ AttendsClasses(x) ∧ AttendsClasses(y) → PassesExam(x)) ::: If a student has a study group and all group members study hard and attends classes, they will pass the exam.",
            "∀x (SkipsClasses(x) → ¬StudiesHard(x)) ::: Students who skip classes do not study hard.",
            "∀x (HasGoodGrades(x) → IsPrepared(x)) ::: Students with good grades will be prepared for the exam.",
            "∀x (StudiesHard(x) → (ReadsTextbooks(x) ∧ DoesHomework(x))) ::: If a student studies hard they read textbooks and does homework.",
            "∀x (AttendsClasses(x) ∧ AsksQuestions(x) → StudiesHard(x)) ::: If a student attends classes and asks questions, they study hard."
        ],
        "predicates": [
            "StudiesHard(x) ::: Student x studies hard",
            "AttendsClasses(x) ::: Student x attends all classes",
            "PassesExam(x) ::: Student x passes the exam",
            "IsStudent(x) ::: x is a student",
            "ReadsTextbooks(x) ::: Student x reads textbooks",
            "DoesHomework(x) ::: Student x does homework",
            "AsksQuestions(x) ::: Student x asks questions in class",
            "UnderstandsMaterial(x) ::: Student x understands the material",
            "IsPrepared(x) ::: Student x is prepared for the exam",
            "IsSmart(x) ::: Student x is smart",
            "HasGoodGrades(x) ::: Student x has good grades",
            "SkipsClasses(x) ::: Student x skips classes",
            "FailsExam(x) ::: Student x fails the exam",
            "HasStudyGroup(x, y) ::: Student x is in a study group with y"
        ]
    },
    {
        "premises-NL": [
            "Everyone is either employed or owns a business.",
            "If someone is employed and not in debt, then they have a high income.",
            "If someone owns a business, they pay taxes.",
            "If someone pays taxes and has a high income, they can afford a luxury item.",
            "Alice is employed and not in debt.",
            "Bob owns a business.",
            "Bob is not in debt.",
            "If someone has a low income, then they are in debt."
        ],
        "premises-FOL": [
            "∀x (Person(x) → (Employed(x) ∨ OwnsBusiness(x))) ::: Everyone is either employed or owns a business",
            "∀x ((Employed(x) ∧ ¬InDebt(x)) → HighIncome(x)) ::: If someone is employed and not in debt, then they have a high income",
            "∀x (OwnsBusiness(x) → PaysTaxes(x)) ::: If someone owns a business, they pay taxes",
            "∀x ((PaysTaxes(x) ∧ HighIncome(x)) → AffordLuxury(x)) ::: If someone pays taxes and has a high income, they can afford a luxury item",
            "Employed(Alice) ∧ ¬InDebt(Alice) ::: Alice is employed and not in debt",
            "OwnsBusiness(Bob) ::: Bob owns a business",
            "¬InDebt(Bob) ::: Bob is not in debt",
            "∀x (LowIncome(x) → InDebt(x)) ::: If someone has a low income, then they are in debt"
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "HighIncome(x) ::: x has a high income",
            "InDebt(x) ::: x is in debt",
            "AffordLuxury(x) ::: x can afford a luxury item",
            "OwnsBusiness(x) ::: x owns a business",
            "PaysTaxes(x) ::: x pays taxes",
            "Employed(x) ::: x is employed",
            "LowIncome(x) ::: x has low income"
        ]
    },
    {
        "premises-NL": [
            "All programmers use a computer.",
            "Anyone who uses a computer knows to code.",
            "If someone knows how to code and is a student, they are not a programmer.",
            "All programmers are students or not.",
            "Some programmers are students.",
            "Students use computers.",
            "Some students know to code.",
            "Every programmer is either a student or not a student.",
            "If someone uses a computer, they know how to code.",
            "All programmers are students.",
            "No students know to code.",
            "Some people are programmers."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → UsesComputer(x)) ::: All programmers use a computer.",
            "∀x (UsesComputer(x) → KnowsToCode(x)) ::: Anyone who uses a computer knows to code.",
            "∀x (KnowsToCode(x) ∧ IsStudent(x) → ¬Programmer(x)) ::: If someone knows how to code and is a student, they are not a programmer.",
            "∀x (Programmer(x) → IsStudent(x) ∨ ¬IsStudent(x)) ::: All programmers are students or not.",
            "∃x (Programmer(x) ∧ IsStudent(x)) ::: Some programmers are students.",
            "∀x (IsStudent(x) → UsesComputer(x)) ::: Students use computers.",
            "∃x (IsStudent(x) ∧ KnowsToCode(x)) ::: Some students know to code.",
            "∀x (Programmer(x) → (IsStudent(x) ∨ ¬IsStudent(x))) ::: Every programmer is either a student or not a student.",
            "∀x (UsesComputer(x) → KnowsToCode(x)) ::: If someone uses a computer, they know how to code.",
            "∀x (Programmer(x) → IsStudent(x)) ::: All programmers are students.",
            "∀x (IsStudent(x) → ¬KnowsToCode(x)) ::: No students know to code.",
            "∃x Programmer(x) ::: Some people are programmers."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "KnowsToCode(x) ::: x knows to code",
            "UsesComputer(x) ::: x uses a computer",
            "IsStudent(x) ::: x is a student"
        ]
    },
    {
        "premises-NL": [
            "All biologists are scientists.",
            "All scientists who study biology are experts.",
            "Some scientists study biology.",
            "No experts work at a university.",
            "Anyone who works at a university is a scientist.",
            "If someone is a scientist and studies biology, they are an expert.",
            "Every biologist studies biology.",
            "Some scientists are biologists.",
            "Some scientists are not biologists.",
            "Everyone is either a scientist or a biologist.",
            "If someone is a scientist, they work at a university.",
            "Some scientists study biology and are not biologists.",
            "All biologists are experts."
        ],
        "premises-FOL": [
            "∀x (Biologist(x) → Scientist(x)) ::: All biologists are scientists.",
            "∀x (Scientist(x) ∧ StudiesBiology(x) → Expert(x)) ::: All scientists who study biology are experts.",
            "∃x (Scientist(x) ∧ StudiesBiology(x)) ::: Some scientists study biology.",
            "∀x (Expert(x) → ¬WorksAtUniversity(x)) ::: No experts work at a university.",
            "∀x (WorksAtUniversity(x) → Scientist(x)) ::: Anyone who works at a university is a scientist.",
            "∀x ((Scientist(x) ∧ StudiesBiology(x)) → Expert(x)) ::: If someone is a scientist and studies biology, they are an expert.",
            "∀x (Biologist(x) → StudiesBiology(x)) ::: Every biologist studies biology.",
            "∃x (Scientist(x) ∧ Biologist(x)) ::: Some scientists are biologists.",
            "∃x (Scientist(x) ∧ ¬Biologist(x)) ::: Some scientists are not biologists.",
            "∀x (Scientist(x) ∨ Biologist(x)) ::: Everyone is either a scientist or a biologist.",
            "∀x (Scientist(x) → WorksAtUniversity(x)) ::: If someone is a scientist, they work at a university.",
            "∃x (Scientist(x) ∧ StudiesBiology(x) ∧ ¬Biologist(x)) ::: Some scientists study biology and are not biologists.",
            "∀x (Biologist(x) → Expert(x)) ::: All biologists are experts."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "StudiesBiology(x) ::: x studies biology",
            "Biologist(x) ::: x is a biologist",
            "Expert(x) ::: x is an expert",
            "WorksAtUniversity(x) ::: x works at a university"
        ]
    },
    {
        "premises-NL": [
            "Everyone likes themselves.",
            "David is a person.",
            "Sarah likes David.",
            "If someone likes someone, then they are friends.",
            "Sarah is a person."
        ],
        "premises-FOL": [
            "∀x (Likes(x, x)) ::: Everyone likes themselves.",
            "Person(david) ::: David is a person.",
            "Likes(sarah, david) ::: Sarah likes David.",
            "∀x ∀y (Likes(x, y) → Friend(x, y)) ::: If someone likes someone, then they are friends.",
            "Person(sarah) ::: Sarah is a person."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Friend(x, y) ::: x is a friend of y",
            "Likes(x, y) ::: x likes y"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All surgeons treat patients.",
            "Anyone who treats patients is helpful.",
            "If someone is a doctor, then they are either a surgeon or not.",
            "John is a surgeon.",
            "John is a doctor."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Surgeon(x) → TreatsPatients(x, x)) ::: All surgeons treat patients.",
            "∀x ∀y (TreatsPatients(x, y) → Helpful(x)) ::: Anyone who treats patients is helpful.",
            "∀x (Doctor(x) → (Surgeon(x) ∨ ¬Surgeon(x))) ::: If someone is a doctor, then they are either a surgeon or not.",
            "Surgeon(john) ::: John is a surgeon.",
            "Doctor(john) ::: John is a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "Helpful(x) ::: x is helpful",
            "TreatsPatients(x, y) ::: x treats patients y"
        ]
    },
    {
        "premises-NL": [
            "David is a student.",
            "Anyone who studies hard takes the exam.",
            "David studied hard.",
            "If someone takes the exam, they will pass it.",
            "If someone passes the exam, they studied hard.",
            "All students must take the exam.",
            "John is a student.",
            "Students who study hard pass exam.",
            "David is a student and studies hard."
        ],
        "premises-FOL": [
            "Student(david) ::: David is a student.",
            "∀x (StudiedHard(x) → TakesExam(x)) ::: Anyone who studies hard takes the exam.",
            "StudiedHard(david) ::: David studied hard.",
            "∀x (TakesExam(x) → PassExam(x)) ::: If someone takes the exam, they will pass it.",
            "∀x (PassExam(x) → StudiedHard(x)) ::: If someone passes the exam, they studied hard.",
            "∀x (Student(x) → TakesExam(x)) ::: All students must take the exam.",
            "Student(john) ::: John is a student.",
            "∀x (Student(x) ∧ StudiedHard(x) → PassExam(x)) ::: Students who study hard pass exam.",
            "Student(david) ∧ StudiedHard(david) ::: David is a student and studies hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiedHard(x) ::: x studied hard",
            "PassExam(x) ::: x will pass the exam",
            "TakesExam(x) ::: x takes the exam"
        ]
    },
    {
        "premises-NL": [
            "Alice likes Bob.",
            "Bob likes Carol.",
            "If someone likes someone, they are friends.",
            "Alice works with David.",
            "Friends trust each other.",
            "If someone trusts someone, they like them.",
            "Bob works with Eve.",
            "Alice likes Bob and Bob likes Carol.",
            "Alice trusts Bob.",
            "David is a friend of Alice.",
            "If two people are friends and one likes someone, the other one likes the same person."
        ],
        "premises-FOL": [
            "Likes(alice, bob) ::: Alice likes Bob.",
            "Likes(bob, carol) ::: Bob likes Carol.",
            "∀x ∀y (Likes(x, y) → IsFriend(x, y)) ::: If someone likes someone, they are friends.",
            "WorksWith(alice, david) ::: Alice works with David.",
            "∀x ∀y (IsFriend(x, y) → Trusts(x, y)) ::: Friends trust each other.",
            "∀x ∀y (Trusts(x, y) → Likes(x, y)) ::: If someone trusts someone, they like them.",
            "WorksWith(bob, eve) ::: Bob works with Eve.",
            "Likes(alice, bob) ∧ Likes(bob, carol) ::: Alice likes Bob and Bob likes Carol.",
            "Trusts(alice, bob) ::: Alice trusts Bob.",
            "IsFriend(david, alice) ::: David is a friend of Alice.",
            "∀x ∀y ∀z (IsFriend(x, y) ∧ Likes(x, z) → Likes(y, z)) ::: If two people are friends and one likes someone, the other one likes the same person."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "IsFriend(x, y) ::: x is a friend of y",
            "WorksWith(x, y) ::: x works with y",
            "Trusts(x, y) ::: x trusts y"
        ]
    },
    {
        "premises-NL": [
            "All people are either healthy or have a disease.",
            "Some people are healthy."
        ],
        "premises-FOL": [
            "∀x (Person(x) → (Healthy(x) ∨ HasDisease(x))) ::: For all x, if x is a person, then x is healthy or has a disease.",
            "∃x (Person(x) ∧ Healthy(x)) ::: There exists a person who is healthy."
        ],
        "predicates": [
            "Healthy(x) ::: x is healthy",
            "HasDisease(x) ::: x has a disease"
        ]
    },
    {
        "premises-NL": [
            "All happy people are wealthy.",
            "Some programmers are not wealthy.",
            "Some programmers are happy.",
            "Everyone either works for Google or Facebook.",
            "John is a programmer.",
            "Everyone who works for Facebook is wealthy.",
            "Some happy people work for google.",
            "Programmers are people."
        ],
        "premises-FOL": [
            "∀x (Happy(x) → Wealthy(x)) ::: All happy people are wealthy.",
            "∃x (Programmer(x) ∧ ¬Wealthy(x)) ::: Some programmers are not wealthy.",
            "∃x (Programmer(x) ∧ Happy(x)) ::: Some programmers are happy.",
            "∀x (Person(x) → (WorksFor(x, Google) ∨ WorksFor(x, Facebook))) ::: Everyone either works for Google or Facebook.",
            "Programmer(John) ::: John is a programmer.",
            "∀x (WorksFor(x, Facebook) → Wealthy(x)) ::: Everyone who works for Facebook is wealthy.",
            "∃x (Happy(x) ∧ WorksFor(x, Google)) ::: Some happy people work for google.",
            "∀x Programmer(x) → Person(x) ::: Programmers are people."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "Happy(x) ::: x is happy",
            "Wealthy(x) ::: x is wealthy",
            "WorksFor(x, y) ::: x works for y"
        ]
    },
    {
        "premises-NL": [
            "All people are either healthy or not healthy.",
            "People who eat healthy food are healthy.",
            "Healthy people exercise regularly.",
            "People who get enough sleep are healthy.",
            "People with good genes are healthy.",
            "If a person smokes, they are not healthy.",
            "If a person drinks alcohol excessively, they are not healthy.",
            "If a person is happy, they are healthy.",
            "People who have good friends are happy.",
            "People who get regular checkups are healthy.",
            "If a person eats unhealthy food, they are not healthy.",
            "If a person is stressed, they are not healthy.",
            "If a person avoids stress, they are healthy.",
            "People who follow doctor's advice are healthy.",
            "People who exercise regularly live long lives.",
            "Some people are healthy."
        ],
        "premises-FOL": [
            "∀x (Person(x) → (Healthy(x) ∨ ¬Healthy(x))) ::: All people are either healthy or not healthy.",
            "∀x (EatsHealthyFood(x) → Healthy(x)) ::: People who eat healthy food are healthy.",
            "∀x (Healthy(x) → ExercisesRegularly(x)) ::: Healthy people exercise regularly.",
            "∀x (GetsEnoughSleep(x) → Healthy(x)) ::: People who get enough sleep are healthy.",
            "∀x (HasGoodGenes(x) → Healthy(x)) ::: People with good genes are healthy.",
            "∀x (Smokes(x) → ¬Healthy(x)) ::: If a person smokes, they are not healthy.",
            "∀x (DrinksAlcohol(x) → ¬Healthy(x)) ::: If a person drinks alcohol excessively, they are not healthy.",
            "∀x (IsHappy(x) → Healthy(x)) ::: If a person is happy, they are healthy.",
            "∀x (HasGoodFriends(x) → IsHappy(x)) ::: People who have good friends are happy.",
            "∀x (GetsRegularCheckups(x) → Healthy(x)) ::: People who get regular checkups are healthy.",
            "∀x (EatsUnhealthyFood(x) → ¬Healthy(x)) ::: If a person eats unhealthy food, they are not healthy.",
            "∀x (IsStressed(x) → ¬Healthy(x)) ::: If a person is stressed, they are not healthy.",
            "∀x (AvoidsStress(x) → Healthy(x)) ::: If a person avoids stress, they are healthy.",
            "∀x (FollowsDoctorsAdvice(x) → Healthy(x)) ::: People who follow doctor's advice are healthy.",
            "∀x (ExercisesRegularly(x) → LongLife(x)) ::: People who exercise regularly live long lives.",
            "∃x Healthy(x) ::: Some people are healthy."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "Healthy(x) ::: x is healthy.",
            "ExercisesRegularly(x) ::: x exercises regularly.",
            "LongLife(x) ::: x lives a long life.",
            "EatsHealthyFood(x) ::: x eats healthy food.",
            "GetsEnoughSleep(x) ::: x gets enough sleep.",
            "HasGoodGenes(x) ::: x has good genes.",
            "Smokes(x) ::: x smokes.",
            "DrinksAlcohol(x) ::: x drinks alcohol.",
            "IsHappy(x) ::: x is happy.",
            "HasGoodFriends(x) ::: x has good friends.",
            "GetsRegularCheckups(x) ::: x gets regular checkups.",
            "EatsUnhealthyFood(x) ::: x eats unhealthy food.",
            "IsStressed(x) ::: x is stressed.",
            "AvoidsStress(x) ::: x avoids stress.",
            "FollowsDoctorsAdvice(x) ::: x follows the doctor's advice."
        ]
    },
    {
        "premises-NL": [
            "All scientists publish papers.",
            "Scientists who conduct research need equipment.",
            "Scientists who publish papers attend conferences.",
            "Those who attend conferences present results.",
            "Scientists with mentors get help.",
            "Mentors help scientists secure funding.",
            "Scientists who present results receive grants.",
            "Scientists who receive grants share data.",
            "Scientists who share data with others collaborate.",
            "Scientists who secure funding use a lab.",
            "Scientists who use a lab need support.",
            "Scientists who secure funding work on a project.",
            "Some scientists conduct research.",
            "If a scientist publishes papers, they finds interesting topics.",
            "If a scientist works on a project, they collaborate."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → PublishesPapers(x)) ::: All scientists publish papers.",
            "∀x (ConductsResearch(x) → NeedsEquipment(x)) ::: Scientists who conduct research need equipment.",
            "∀x (PublishesPapers(x) → AttendsConferences(x)) ::: Scientists who publish papers attend conferences.",
            "∀x (AttendsConferences(x) → PresentsResults(x)) ::: Those who attend conferences present results.",
            "∀x (HasMentors(x) → MentorsHelp(x, x)) ::: Scientists with mentors get help.",
            "∀x ∀y (MentorsHelp(x, y) → SecuresFunding(y)) ::: Mentors help scientists secure funding.",
            "∀x (PresentsResults(x) → ReceivesGrants(x)) ::: Scientists who present results receive grants.",
            "∀x (ReceivesGrants(x) → SharesData(x, x)) ::: Scientists who receive grants share data.",
            "∀x (SharesData(x, x) → Collaborates(x)) ::: Scientists who share data with others collaborate.",
            "∀x (SecuresFunding(x) → UsesLab(x)) ::: Scientists who secure funding use a lab.",
            "∀x (UsesLab(x) → NeedsSupport(x)) ::: Scientists who use a lab need support.",
            "∀x ∀y (SecuresFunding(x) → WorksOnProject(x, y)) ::: Scientists who secure funding work on a project.",
            "∃x ConductsResearch(x) ::: Some scientists conduct research.",
            "∀x (PublishesPapers(x) → FindsInterestingTopics(x)) ::: If a scientist publishes papers, they finds interesting topics.",
            "∀x ∀y (WorksOnProject(x, y) → Collaborates(x)) ::: If a scientist works on a project, they collaborate."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist.",
            "PublishesPapers(x) ::: x publishes papers.",
            "SecuresFunding(x) ::: x secures funding.",
            "Collaborates(x) ::: x collaborates.",
            "ConductsResearch(x) ::: x conducts research.",
            "NeedsEquipment(x) ::: x needs equipment.",
            "AttendsConferences(x) ::: x attends conferences.",
            "PresentsResults(x) ::: x presents results.",
            "HasMentors(x) ::: x has mentors.",
            "MentorsHelp(x, y) ::: mentor x helps y.",
            "ReceivesGrants(x) ::: x receives grants.",
            "SharesData(x, y) ::: x shares data with y.",
            "UsesLab(x) ::: x uses lab.",
            "NeedsSupport(x) ::: x needs support.",
            "FindsInterestingTopics(x) ::: x finds interesting topics.",
            "WorksOnProject(x, y) ::: x works on project y."
        ]
    },
    {
        "premises-NL": [
            "All leaders have a good vision.",
            "People with a good vision inspire others.",
            "People who inspire others motivate their team.",
            "Leaders set goals.",
            "People who communicate effectively build relationships.",
            "People who make decisions understand people.",
            "Leaders are confident.",
            "People who take risks overcome challenges.",
            "People who learn from mistakes are leaders.",
            "People who follow rules help others.",
            "Those who have integrity are leaders.",
            "Leaders who motivate their team achieve great things.",
            "If a person sets goals and builds relationships, they are leaders.",
            "If a person has a good vision and communicates effectively, they are leaders.",
            "Some people are leaders.",
            "If a person is confident and takes risks, they inspire others.",
            "If a person overcomes challenges, they achieve great things.",
            "Leaders must have integrity."
        ],
        "premises-FOL": [
            "∀x (Leader(x) → GoodVision(x)) ::: All leaders have a good vision.",
            "∀x (GoodVision(x) → InspiresOthers(x)) ::: People with a good vision inspire others.",
            "∀x (InspiresOthers(x) → MotivatesTeam(x)) ::: People who inspire others motivate their team.",
            "∀x (Leader(x) → SetsGoals(x)) ::: Leaders set goals.",
            "∀x (CommunicatesEffectively(x) → BuildsRelationships(x)) ::: People who communicate effectively build relationships.",
            "∀x (MakesDecisions(x) → UnderstandsPeople(x)) ::: People who make decisions understand people.",
            "∀x (Leader(x) → IsConfident(x)) ::: Leaders are confident.",
            "∀x (TakesRisks(x) → OvercomesChallenges(x)) ::: People who take risks overcome challenges.",
            "∀x (LearnsFromMistakes(x) → Leader(x)) ::: People who learn from mistakes are leaders.",
            "∀x (FollowsRules(x) → HelpsOthers(x)) ::: People who follow rules help others.",
            "∀x (HasIntegrity(x) → Leader(x)) ::: Those who have integrity are leaders.",
            "∀x (MotivatesTeam(x) → AchievesGreatThings(x)) ::: Leaders who motivate their team achieve great things.",
            "∀x (SetsGoals(x) ∧ BuildsRelationships(x) → Leader(x)) ::: If a person sets goals and builds relationships, they are leaders.",
            "∀x (GoodVision(x) ∧ CommunicatesEffectively(x) → Leader(x)) ::: If a person has a good vision and communicates effectively, they are leaders.",
            "∃x Leader(x) ::: Some people are leaders.",
            "∀x (IsConfident(x) ∧ TakesRisks(x) → InspiresOthers(x)) ::: If a person is confident and takes risks, they inspire others.",
            "∀x (OvercomesChallenges(x) → AchievesGreatThings(x)) ::: If a person overcomes challenges, they achieve great things.",
            "∀x (Leader(x) → HasIntegrity(x)) ::: Leaders must have integrity."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "Leader(x) ::: x is a leader.",
            "GoodVision(x) ::: x has a good vision.",
            "InspiresOthers(x) ::: x inspires others.",
            "AchievesGreatThings(x) ::: x achieves great things.",
            "MotivatesTeam(x) ::: x motivates a team.",
            "SetsGoals(x) ::: x sets goals.",
            "CommunicatesEffectively(x) ::: x communicates effectively.",
            "BuildsRelationships(x) ::: x builds relationships.",
            "MakesDecisions(x) ::: x makes decisions.",
            "UnderstandsPeople(x) ::: x understands people.",
            "IsConfident(x) ::: x is confident.",
            "TakesRisks(x) ::: x takes risks.",
            "OvercomesChallenges(x) ::: x overcomes challenges.",
            "LearnsFromMistakes(x) ::: x learns from mistakes.",
            "FollowsRules(x) ::: x follows rules.",
            "HelpsOthers(x) ::: x helps others.",
            "HasIntegrity(x) ::: x has integrity."
        ]
    },
    {
        "premises-NL": [
            "All students attend lectures.",
            "John is a student.",
            "If someone attends a lecture, they are in class.",
            "John studies."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsLecture(x)) ::: All students attend lectures",
            "Student(john) ::: John is a student",
            "∀x (AttendsLecture(x) → InClass(x)) ::: If someone attends a lecture, they are in class",
            "Studies(john) ::: John studies"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsLecture(x) ::: x attends lectures"
        ]
    },
    {
        "premises-NL": [
            "All doctors are researchers.",
            "John is a doctor.",
            "If someone is a doctor, they help patients.",
            "John publishes articles.",
            "All articles require research.",
            "If someone publishes an article, they are a researcher."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Researcher(x)) ::: All doctors are researchers",
            "Doctor(john) ::: John is a doctor",
            "∀x (Doctor(x) → HelpsPatients(x)) ::: If someone is a doctor, they help patients",
            "∃y (Article(y) ∧ Publishes(john, y)) ::: John publishes articles",
            "∀y (Article(y) → RequiresResearch(y)) ::: All articles require research",
            "∀x ∃y (Publishes(x, y) → Researcher(x)) ::: If someone publishes an article, they are a researcher"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Researcher(x) ::: x is a researcher",
            "Publishes(x, y) ::: x publishes y",
            "Article(y) ::: y is an article"
        ]
    },
    {
        "premises-NL": [
            "Anyone with a high salary is rich.",
            "Anyone who is rich can afford a luxury car.",
            "If someone owns a luxury car they are rich.",
            "Rich people often make investments.",
            "People with high salaries spend money.",
            "If someone spends money, they are not necessarily happy.",
            "If someone has a high salary and invests they are not happy.",
            "If someone owns a luxury car, they spend money.",
            "Healthy people don't have high salaries.",
            "If someone has high salary they are happy.",
            "Someone who has high salary is not healthy.",
            "Someone who is happy and makes investments is rich.",
            "Anyone who can afford a luxury car doesn't have insurance.",
            "Anyone with a high salary can afford a luxury car.",
            "People with high salaries are likely to be happy.",
            "If someone can afford a luxury car, they don't always make investments.",
            "If someone is rich they are happy.",
            "If someone is happy they don't spend their money."
        ],
        "premises-FOL": [
            "∀x (HighSalary(x) → Rich(x)) ::: Anyone with a high salary is rich.",
            "∀x (Rich(x) → CanAffordLuxuryCar(x)) ::: Anyone who is rich can afford a luxury car.",
            "∀x (OwnsLuxuryCar(x) → Rich(x)) ::: If someone owns a luxury car they are rich.",
            "∀x (Rich(x) → MakesInvestments(x)) ::: Rich people often make investments.",
            "∀x (HighSalary(x) → SpendsMoney(x)) ::: People with high salaries spend money.",
            "∀x (SpendsMoney(x) → ¬Happy(x)) ::: If someone spends money, they are not necessarily happy.",
            "∀x (HighSalary(x) ∧ MakesInvestments(x) → ¬Happy(x)) ::: If someone has a high salary and invests they are not happy.",
            "∀x (OwnsLuxuryCar(x) → SpendsMoney(x)) ::: If someone owns a luxury car, they spend money.",
            "∀x (Healthy(x) → ¬HighSalary(x)) ::: Healthy people don't have high salaries.",
            "∀x (HighSalary(x) → Happy(x)) ::: If someone has high salary they are happy.",
            "∃x (HighSalary(x) ∧ ¬Healthy(x)) ::: Someone who has high salary is not healthy.",
            "∀x (Happy(x) ∧ MakesInvestments(x) → Rich(x)) ::: Someone who is happy and makes investments is rich.",
            "∀x (CanAffordLuxuryCar(x) → ¬HasInsurance(x)) ::: Anyone who can afford a luxury car doesn't have insurance.",
            "∀x (HighSalary(x) → CanAffordLuxuryCar(x)) ::: Anyone with a high salary can afford a luxury car.",
            "∀x (HighSalary(x) → Happy(x)) ::: People with high salaries are likely to be happy.",
            "∀x (CanAffordLuxuryCar(x) → ¬MakesInvestments(x)) ::: If someone can afford a luxury car, they don't always make investments.",
            "∀x (Rich(x) → Happy(x)) ::: If someone is rich they are happy.",
            "∀x (Happy(x) → ¬SpendsMoney(x)) ::: If someone is happy they don't spend their money."
        ],
        "predicates": [
            "HighSalary(x) ::: x has a high salary",
            "CanAffordLuxuryCar(x) ::: x can afford a luxury car",
            "Happy(x) ::: x is happy",
            "Rich(x) ::: x is rich",
            "OwnsLuxuryCar(x) ::: x owns a luxury car",
            "MakesInvestments(x) ::: x makes investments",
            "SpendsMoney(x) ::: x spends money",
            "Healthy(x) ::: x is healthy",
            "HasInsurance(x) ::: x has insurance"
        ]
    },
    {
        "premises-NL": [
            "Every employee is a graduate.",
            "No student is an employee.",
            "If someone is a student, then they are not an employee.",
            "If someone is a graduate, then they are either an employee or not a student.",
            "Anyone who is not a graduate is not an employee.",
            "Some graduates are not employees.",
            "If someone is an employee, they are a graduate.",
            "No one is both a student and an employee.",
            "All employees are graduates."
        ],
        "premises-FOL": [
            "∀x (Employee(x) → Graduate(x)) ::: Every employee is a graduate.",
            "¬∃x (Student(x) ∧ Employee(x)) ::: No student is an employee.",
            "∀x (Student(x) → ¬Employee(x)) ::: If someone is a student, then they are not an employee.",
            "∀x (Graduate(x) → (Employee(x) ∨ ¬Student(x))) ::: If someone is a graduate, then they are either an employee or not a student.",
            "∀x (¬Graduate(x) → ¬Employee(x)) ::: Anyone who is not a graduate is not an employee.",
            "∃x (Graduate(x) ∧ ¬Employee(x)) ::: Some graduates are not employees.",
            "∀x (Employee(x) → Graduate(x)) ::: If someone is an employee, they are a graduate.",
            "¬∃x (Student(x) ∧ Employee(x)) ::: No one is both a student and an employee.",
            "∀x (Employee(x) → Graduate(x)) ::: All employees are graduates."
        ],
        "predicates": [
            "Employee(x) ::: x is an employee.",
            "Graduate(x) ::: x is a graduate.",
            "Student(x) ::: x is a student."
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "All smart people like programming.",
            "All students study hard.",
            "Everyone who studies hard enjoys gaming.",
            "Some students exist.",
            "If someone is a student, then they're smart.",
            "If someone is smart, then they like programming.",
            "If someone is a student, then they study hard.",
            "If someone studies hard, then they enjoy gaming.",
            "Someone is both a student and studies hard.",
            "Some students like programming and enjoy gaming.",
            "Everything is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart",
            "∀x (Smart(x) → LikesProgramming(x)) ::: All smart people like programming",
            "∀x (Student(x) → StudiesHard(x)) ::: All students study hard",
            "∀x (StudiesHard(x) → EnjoysGaming(x)) ::: Everyone who studies hard enjoys gaming",
            "∃x Student(x) ::: Some students exist",
            "∀x (Student(x) → Smart(x)) ::: If someone is a student, then they're smart",
            "∀x (Smart(x) → LikesProgramming(x)) ::: If someone is smart, then they like programming",
            "∀x (Student(x) → StudiesHard(x)) ::: If someone is a student, then they study hard",
            "∀x (StudiesHard(x) → EnjoysGaming(x)) ::: If someone studies hard, then they enjoy gaming",
            "∃x (Student(x) ∧ StudiesHard(x)) ::: Someone is both a student and studies hard",
            "∃x (Student(x) ∧ LikesProgramming(x) ∧ EnjoysGaming(x)) ::: Some students like programming and enjoy gaming",
            "∀x Student(x) ::: Everything is a student"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "LikesProgramming(x) ::: x likes programming",
            "EnjoysGaming(x) ::: x enjoys gaming",
            "Smart(x) ::: x is smart",
            "StudiesHard(x) ::: x studies hard"
        ]
    },
    {
        "premises-NL": [
            "Person A and B are in the same club, club1.",
            "Person A is a member of club1.",
            "Person B is a member of club1.",
            "If someone is a leader, they are a member.",
            "Person A is a leader of club1.",
            "The leader of club1 always attends all meetings.",
            "If someone is a member and follows the leader’s instructions, they will attend a meeting.",
            "Person B always follows the instructions of the leader."
        ],
        "premises-FOL": [
            "SameClub(personA, personB, club1) ::: Person A and B are in club1.",
            "Member(personA, club1) ::: Person A is a member of club1.",
            "Member(personB, club1) ::: Person B is a member of club1.",
            "∀x ∀z (Leader(x, z) → Member(x, z)) ::: For all x and z, if x is a leader of z, then x is a member of z.",
            "Leader(personA, club1) ::: Person A is a leader of club1.",
            "∀x ∀m (Leader(x, club1) → AttendsMeeting(x)) ::: For all x and m, if x is a leader of club1, then x attends the meeting m.",
            "∀x ∀y (Member(x, club1) ∧ FollowsInstructions(x, y) → AttendsMeeting(x)) ::: For all x and y, if x is a member of club1 and x follows instructions from y, then x attends the meeting.",
            "∀x (FollowsInstructions(personB, personA)) ::: Person B always follows the instructions of the leader."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Club(z) ::: z is a club",
            "SameClub(x, y, z) ::: x and y are in club z",
            "Member(x, z) ::: x is a member of club z",
            "AttendsMeeting(x) ::: x attends a meeting",
            "Meeting(m) ::: m is a meeting",
            "Leader(x, z) ::: x is the leader of z",
            "FollowsInstructions(x, y) ::: x follows instructions of y"
        ]
    },
    {
        "premises-NL": [
            "Everyone who has a pet is a pet owner.",
            "All pet owners enjoy nature.",
            "If someone enjoys nature, they like to visit the park.",
            "If someone enjoys nature, they like to watch birds.",
            "If someone has a pet, they have free time.",
            "If someone has free time, they go outside.",
            "Everyone who is outside can observe birds.",
            "Some people are pet owners.",
            "Someone likes to visit the park.",
            "Some people enjoys watching birds."
        ],
        "premises-FOL": [
            "∀x (HasPet(x) → PetOwner(x)) ::: For all x, if x has a pet, then x is a pet owner.",
            "∀x (PetOwner(x) → EnjoysNature(x)) ::: For all x, if x is a pet owner, then x enjoys nature.",
            "∀x (EnjoysNature(x) → LikesToVisit(x, park)) ::: For all x, if x enjoys nature, then x likes to visit the park.",
            "∀x (EnjoysNature(x) → LikesWatching(x, birds)) ::: For all x, if x enjoys nature, then x likes watching birds.",
            "∀x (HasPet(x) → HasFreeTime(x)) ::: For all x, if x has a pet, then x has free time.",
            "∀x (HasFreeTime(x) → IsOutside(x)) ::: For all x, if x has free time, then x is outside.",
            "∀x (IsOutside(x) → ObservesBirds(x)) ::: For all x, if x is outside, then x observes birds.",
            "∃x PetOwner(x) ::: There exists an x such that x is a pet owner.",
            "∃x LikesToVisit(x, park) ::: There exists an x who likes to visit the park.",
            "∃x LikesWatching(x, birds) ::: There exists an x who likes watching birds."
        ],
        "predicates": [
            "HasPet(x) ::: x has a pet.",
            "LikesToVisit(x, y) ::: x likes to visit y.",
            "Park(y) ::: y is the park.",
            "LikesWatching(x, z) ::: x likes watching z.",
            "Birds(z) ::: z are birds.",
            "EnjoysNature(x) ::: x enjoys nature.",
            "VisitsPark(x) ::: x visits the park.",
            "ObservesBirds(x) ::: x observes birds.",
            "IsOutside(x) ::: x is outside.",
            "HasFreeTime(x) ::: x has free time.",
            "PetOwner(x) ::: x is a pet owner."
        ]
    },
    {
        "premises-NL": [
            "Every student is enrolled in a course.",
            "If someone is enrolled in a course, they study."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x)) ::: Every student is enrolled in a course.",
            "∀x (Enrolled(x) → Studies(x)) ::: If someone is enrolled in a course, they study.",
            "Student(alice) ::: Alice is a student.",
            "Student(bob) ::: Bob is a student.",
            "Course(math) ::: Math is a course.",
            "Enrolled(alice) ::: Alice is enrolled.",
            "Enrolled(bob) ::: Bob is enrolled.",
            "∀x (Studies(x) → PassesExam(x)) ::: If someone studies, then they pass the exam.",
            "¬PassesExam(bob) ::: Bob does not pass the exam.",
            "∀x (AttendsLecture(x) → Studies(x)) ::: If someone attends lecture, then they study.",
            "AttendsLecture(alice) ::: Alice attends lecture.",
            "∃x Studies(x) ::: someone studies.",
            "∀x (PassesExam(x) ∨ FailsExam(x)) ::: Everyone passes or fails the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x) ::: x is enrolled in a course",
            "Course(y) ::: y is a course",
            "Studies(x) ::: x studies"
        ]
    },
    {
        "premises-NL": [
            "Every student is either tall or short.",
            "All tall students are athletes.",
            "Some students attend the logic class.",
            "All students enrolled in a class are students.",
            "Anyone who knows someone in the logic class is a student.",
            "Every friend of a student is also a student.",
            "Every athlete plays some sport.",
            "All who play a sport like it.",
            "Some students like sports.",
            "Every tall person is a student.",
            "Someone is a student.",
            "No short person is an athlete.",
            "The logic class is a class.",
            "John is tall."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Tall(x) ∨ Short(x))) ::: For all x, if x is a student, then x is tall or short.",
            "∀x (Tall(x) → Athlete(x)) ::: For all x, if x is tall, then x is an athlete.",
            "∃x ∃y (Student(x) ∧ AttendsClass(x, y) ∧ Class(y)) ::: There exists an x and a y such that x is a student and x attends class y and y is a class.",
            "∀x ∀y (EnrolledIn(x, y) → Student(x)) ::: For all x and y, if x is enrolled in y, then x is a student.",
            "∀x ∀y ((Knows(x, y) ∧ AttendsClass(y, z)) → Student(x)) ::: For all x, y and z, if x knows y and y attends class z, then x is a student.",
            "∀x ∀y (FriendOf(x, y) → Student(x)) ::: For all x and y, if x is a friend of y, then x is a student.",
            "∀x ∃y (Athlete(x) → PlaysSport(x, y)) ::: For all x, if x is an athlete, then there exists a y such that x plays sport y.",
            "∀x ∀y (PlaysSport(x, y) → Likes(x, y)) ::: For all x and y, if x plays sport y, then x likes y.",
            "∃x ∃y (Student(x) ∧ Likes(x, y) ∧ Sport(y)) ::: There exists an x and a y such that x is a student and x likes y and y is a sport.",
            "∀x (Tall(x) → Student(x)) ::: For all x, if x is tall, then x is a student.",
            "∃x Student(x) ::: There exists an x such that x is a student.",
            "∀x (¬Short(x) ∨ ¬Athlete(x)) ::: For all x, x is not short or x is not an athlete.",
            "∀x (Class(x) → Class(x)) ::: For all x, if x is a class then x is a class.",
            "Tall(john) ::: John is tall."
        ],
        "predicates": [
            "Tall(x) ::: x is tall.",
            "Student(x) ::: x is a student.",
            "Athlete(x) ::: x is an athlete.",
            "AttendsClass(x, y) ::: x attends class y.",
            "Class(y) ::: y is a class.",
            "EnrolledIn(x, y) ::: x is enrolled in y.",
            "Knows(x, y) ::: x knows y.",
            "FriendOf(x, y) ::: x is a friend of y.",
            "PlaysSport(x, y) ::: x plays sport y.",
            "Sport(y) ::: y is a sport.",
            "Likes(x, y) ::: x likes y."
        ]
    },
    {
        "premises-NL": [
            "All items made of glass are fragile.",
            "Every fragile item is breakable.",
            "If something is expensive, it's valuable.",
            "All valuable items are insured.",
            "If something is made of glass, it needs special handling.",
            "Some items are expensive.",
            "Some fragile items are delivered to recipients.",
            "Anything that contains a fragile item is a package.",
            "A package contains an item",
            "If something is insured, then handle it with care.",
            "Every package is an item.",
            "Every breakable item needs special handling.",
            "Something is made of glass or costs a lot.",
            "If something costs a lot, then it is expensive.",
            "All items are either expensive or not expensive."
        ],
        "premises-FOL": [
            "∀x (MadeOfGlass(x) → Fragile(x)) ::: For all x, if x is made of glass, then x is fragile.",
            "∀x (Fragile(x) → Breakable(x)) ::: For all x, if x is fragile, then x is breakable.",
            "∀x (Expensive(x) → Valuable(x)) ::: For all x, if x is expensive, then x is valuable.",
            "∀x (Valuable(x) → Insured(x)) ::: For all x, if x is valuable, then x is insured.",
            "∀x (MadeOfGlass(x) → NeedsSpecialHandling(x)) ::: For all x, if x is made of glass, then x needs special handling.",
            "∃x Expensive(x) ::: There exists an x such that x is expensive.",
            "∃x ∃y (Fragile(x) ∧ Delivered(x, y) ∧ Recipient(y)) ::: There exists an x and y such that x is fragile and x is delivered to y and y is a recipient.",
            "∀x ∀y ((Fragile(y) ∧ Contains(x, y)) → Package(x)) ::: For all x and y, if y is fragile and x contains y, then x is a package.",
            "∀x ∃y (Package(x) ∧ Contains(x,y) ∧ Item(y)) ::: For all x, there exists a y such that x is a package and x contains y and y is an item.",
            "∀x (Insured(x) → HandleWithCare(x)) ::: For all x, if x is insured, then handle x with care.",
            "∀x (Package(x) → Item(x)) ::: For all x, if x is a package, then x is an item.",
            "∀x (Breakable(x) → NeedsSpecialHandling(x)) ::: For all x, if x is breakable, then x needs special handling.",
            "∃x (MadeOfGlass(x) ∨ CostMoreThan(x, 1000)) ::: There exists an x such that x is made of glass or x costs more than 1000.",
            "∀x (CostMoreThan(x,1000) → Expensive(x)) ::: For all x, if x costs more than 1000, then x is expensive.",
            "∀x (Expensive(x) ∨ ¬Expensive(x)) ::: For all x, x is expensive or x is not expensive."
        ],
        "predicates": [
            "Fragile(x) ::: x is fragile.",
            "Expensive(x) ::: x is expensive.",
            "NeedsSpecialHandling(x) ::: x needs special handling.",
            "Item(x) ::: x is an item.",
            "MadeOfGlass(x) ::: x is made of glass.",
            "CostMoreThan(x, y) ::: x costs more than y.",
            "Price(x, y) ::: x's price is y.",
            "Material(x, y) ::: x is made of material y.",
            "HandleWithCare(x) ::: Handle x with care.",
            "Breakable(x) ::: x is breakable.",
            "Insured(x) ::: x is insured.",
            "Valuable(x) ::: x is valuable.",
            "Delivered(x, y) ::: x is delivered to y.",
            "Recipient(y) ::: y is the recipient.",
            "Contains(x, y) ::: x contains y.",
            "Package(x) ::: x is a package."
        ]
    },
    {
        "premises-NL": [
            "All students read books.",
            "Anyone who reads books and is smart attends lectures.",
            "Every smart person will pass the exam.",
            "Some people are students.",
            "Anyone who is a student is smart."
        ],
        "premises-FOL": [
            "∀x (Student(x) → ReadsBooks(x)) ::: All students read books.",
            "∀x (ReadsBooks(x) ∧ Smart(x) → AttendsLectures(x)) ::: Anyone who reads books and is smart attends lectures.",
            "∀x (Smart(x) → PassExam(x)) ::: Every smart person will pass the exam.",
            "∃x Student(x) ::: Some people are students.",
            "∀x (Student(x) → Smart(x)) ::: Anyone who is a student is smart."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsLectures(x) ::: x attends lectures",
            "PassExam(x) ::: x passes the exam",
            "ReadsBooks(x) ::: x reads books",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "If a project is successful, the project leader gets a bonus.",
            "Everyone involved in a successful project is cooperative.",
            "The project leader participates in all projects.",
            "If someone shares knowledge with the project leader, then that person is cooperative.",
            "If someone knows details of a project, then they participate in it.",
            "If someone is reliable, then they share knowledge with the project leader.",
            "If a project is successful, all involved people are cooperative.",
            "The project leader is involved in all projects.",
            "If someone knows the details of a successful project, then the project is successful."
        ],
        "premises-FOL": [
            "∀x ∀y (SuccessfulProject(y) ∧ ProjectLeader(x, y) → GetsBonus(x)) ::: If a project is successful, the project leader gets a bonus.",
            "∀x ∀y (SuccessfulProject(y) ∧ InvolvedIn(x, y) → Cooperative(x)) ::: Everyone involved in a successful project is cooperative.",
            "∀x ∀y (ProjectLeader(x, y) → ParticipatesIn(x, y)) ::: The project leader participates in all projects.",
            "∀x ∀y (SharesKnowledge(x, z) ∧ ProjectLeader(z, w) → Cooperative(x)) ::: If someone shares knowledge with the project leader, then that person is cooperative.",
            "∀x ∀y (KnowsDetails(x, y) → ParticipatesIn(x, y)) ::: If someone knows details of a project, then they participate in it.",
            "∀x ∀y (Reliable(x) ∧ ProjectLeader(z, w) → SharesKnowledge(x, z)) ::: If someone is reliable, then they share knowledge with the project leader.",
            "∀x ∀y (SuccessfulProject(y) → (InvolvedIn(x, y) ∧ Cooperative(x))) ::: If a project is successful, all involved people are cooperative.",
            "∀x ∀y (ProjectLeader(x, y) → InvolvedIn(x, y)) ::: The project leader is involved in all projects.",
            "∀x ∀y (KnowsDetails(x, y) ∧ SuccessfulProject(y) → SuccessfulProject(y)) ::: If someone knows the details of a successful project, then the project is successful."
        ],
        "predicates": [
            "Cooperative(x) ::: x is cooperative",
            "SuccessfulProject(x) ::: x is a successful project",
            "GetsBonus(x) ::: x gets a bonus",
            "ProjectLeader(x, y) ::: x is the project leader of project y",
            "ParticipatesIn(x, y) ::: x participates in project y",
            "SharesKnowledge(x, y) ::: x shares knowledge with y",
            "KnowsDetails(x, y) ::: x knows the details of y",
            "InvolvedIn(x, y) ::: x is involved in y",
            "Reliable(x) ::: x is reliable"
        ]
    },
    {
        "premises-NL": [
            "If Alice likes to code, then she is smart.",
            "If Alice likes pizza, she eats pizza.",
            "If Alice is smart and eats pizza, then she is happy.",
            "Alice has a friend.",
            "If someone has a friend and plays games, then they are happy.",
            "Alice likes pizza or she doesn't like pizza.",
            "If Alice is happy, then she enjoys music.",
            "If Alice is happy, then she watches movies.",
            "If Alice likes to code, then she is happy.",
            "If Alice likes pizza, she also likes to code.",
            "If Alice is smart, then she likes to code.",
            "If Alice is happy, she reads a book.",
            "Alice likes to code.",
            "Alice likes pizza.",
            "If Alice likes to code and likes pizza, then she is happy.",
            "If Alice has a dog, then she likes pizza.",
            "Alice plays games."
        ],
        "premises-FOL": [
            "LikesToCode(Alice) → IsSmart(Alice) ::: If Alice likes to code, then she is smart.",
            "LikesPizza(Alice) → EatsPizza(Alice) ::: If Alice likes pizza, she eats pizza.",
            "(IsSmart(Alice) ∧ EatsPizza(Alice)) → IsHappy(Alice) ::: If Alice is smart and eats pizza, then she is happy.",
            "∃y HasFriend(Alice, y) ::: Alice has a friend.",
            "∀x (HasFriend(x, x) ∧ PlaysGames(x) → IsHappy(x)) ::: If someone has a friend and plays games, then they are happy.",
            "LikesPizza(Alice) ∨ ¬LikesPizza(Alice) ::: Alice likes pizza or she doesn't like pizza.",
            "IsHappy(Alice) → EnjoysMusic(Alice) ::: If Alice is happy, then she enjoys music.",
            "IsHappy(Alice) → WatchesMovies(Alice) ::: If Alice is happy, then she watches movies.",
            "LikesToCode(Alice) → IsHappy(Alice) ::: If Alice likes to code, then she is happy.",
            "LikesPizza(Alice) → LikesToCode(Alice) ::: If Alice likes pizza, she also likes to code.",
            "IsSmart(Alice) → LikesToCode(Alice) ::: If Alice is smart, then she likes to code.",
            "IsHappy(Alice) → ReadsBook(Alice) ::: If Alice is happy, she reads a book.",
            "LikesToCode(Alice) ::: Alice likes to code.",
            "LikesPizza(Alice) ::: Alice likes pizza.",
            "(LikesToCode(Alice) ∧ LikesPizza(Alice)) → IsHappy(Alice) ::: If Alice likes to code and likes pizza, then she is happy.",
            "HasDog(Alice) → LikesPizza(Alice) ::: If Alice has a dog, then she likes pizza.",
            "PlaysGames(Alice) ::: Alice plays games."
        ],
        "predicates": [
            "LikesToCode(x) ::: x likes to code.",
            "LikesPizza(x) ::: x likes pizza.",
            "IsHappy(x) ::: x is happy.",
            "HasFriend(x, y) ::: x has friend y.",
            "PlaysGames(x) ::: x plays games.",
            "IsSmart(x) ::: x is smart.",
            "EatsPizza(x) ::: x eats pizza.",
            "HasDog(x) ::: x has a dog.",
            "ReadsBook(x) ::: x reads a book.",
            "EnjoysMusic(x) ::: x enjoys music.",
            "WatchesMovies(x) ::: x watches movies."
        ]
    },
    {
        "premises-NL": [
            "All students either have homework or attend class.",
            "Bob is a student.",
            "If Bob has homework, he studies hard.",
            "If Bob attends class, he likes learning.",
            "Bob likes learning or he doesn't like learning.",
            "If Bob studies hard, he gets good grades.",
            "If Bob gets good grades, he succeeds.",
            "Bob is diligent or he isn't diligent.",
            "If Bob is diligent, then he studies hard.",
            "Bob reads books.",
            "If Bob reads books, then he likes learning.",
            "If Bob likes learning and studies hard, then he succeeds.",
            "If Bob is a student and studies hard, he will succeed.",
            "Bob attends class.",
            "If Bob has homework, he attends class.",
            "If Bob attends class and studies hard, he gets good grades.",
            "If Bob gets good grades, he likes learning.",
            "If Bob is diligent, he gets good grades."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (HasHomework(x) ∨ AttendsClass(x))) ::: All students either have homework or attend class.",
            "Student(Bob) ::: Bob is a student.",
            "HasHomework(Bob) → StudiesHard(Bob) ::: If Bob has homework, he studies hard.",
            "AttendsClass(Bob) → LikesLearning(Bob) ::: If Bob attends class, he likes learning.",
            "LikesLearning(Bob) ∨ ¬LikesLearning(Bob) ::: Bob likes learning or he doesn't like learning.",
            "StudiesHard(Bob) → GetsGoodGrades(Bob) ::: If Bob studies hard, he gets good grades.",
            "GetsGoodGrades(Bob) → Succeeds(Bob) ::: If Bob gets good grades, he succeeds.",
            "IsDiligent(Bob) ∨ ¬IsDiligent(Bob) ::: Bob is diligent or he isn't diligent.",
            "IsDiligent(Bob) → StudiesHard(Bob) ::: If Bob is diligent, then he studies hard.",
            "ReadsBooks(Bob) ::: Bob reads books.",
            "ReadsBooks(Bob) → LikesLearning(Bob) ::: If Bob reads books, then he likes learning.",
            "(LikesLearning(Bob) ∧ StudiesHard(Bob)) → Succeeds(Bob) ::: If Bob likes learning and studies hard, then he succeeds.",
            "(Student(Bob) ∧ StudiesHard(Bob)) → Succeeds(Bob) ::: If Bob is a student and studies hard, he will succeed.",
            "AttendsClass(Bob) ::: Bob attends class.",
            "HasHomework(Bob) → AttendsClass(Bob) ::: If Bob has homework, he attends class.",
            "(AttendsClass(Bob) ∧ StudiesHard(Bob)) → GetsGoodGrades(Bob) ::: If Bob attends class and studies hard, he gets good grades.",
            "GetsGoodGrades(Bob) → LikesLearning(Bob) ::: If Bob gets good grades, he likes learning.",
            "IsDiligent(Bob) → GetsGoodGrades(Bob) ::: If Bob is diligent, he gets good grades."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesHard(x) ::: x studies hard.",
            "Succeeds(x) ::: x succeeds.",
            "HasHomework(x) ::: x has homework.",
            "AttendsClass(x) ::: x attends class.",
            "GetsGoodGrades(x) ::: x gets good grades.",
            "IsDiligent(x) ::: x is diligent.",
            "ReadsBooks(x) ::: x reads books.",
            "LikesLearning(x) ::: x likes learning."
        ]
    },
    {
        "premises-NL": [
            "All students study hard.",
            "David is a student.",
            "If someone studies hard, they pass the exam.",
            "Anyone who passes the exam succeeds.",
            "David likes pizza.",
            "No one who likes pizza fails the exam.",
            "If a student passes the exam, they like pizza.",
            "David studies hard.",
            "If you study hard, you will pass the exam.",
            "If you study hard, you like pizza.",
            "Everyone who succeeds likes pizza.",
            "If David passes the exam, he likes pizza.",
            "If David likes pizza, he succeeds.",
            "David passes the exam.",
            "If someone succeeds, then they pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → StudiesHard(x)) ::: All students study hard.",
            "Student(David) ::: David is a student.",
            "∀x (StudiesHard(x) → PassesExam(x)) ::: If someone studies hard, they pass the exam.",
            "∀x (PassesExam(x) → Succeeds(x)) ::: Anyone who passes the exam succeeds.",
            "LikesPizza(David) ::: David likes pizza.",
            "¬∃x (LikesPizza(x) ∧ ¬PassesExam(x)) ::: No one who likes pizza fails the exam.",
            "∀x (PassesExam(x) → LikesPizza(x)) ::: If a student passes the exam, they like pizza.",
            "StudiesHard(David) ::: David studies hard.",
            "∀x (StudiesHard(x) → PassesExam(x)) ::: If you study hard, you will pass the exam.",
            "∀x (StudiesHard(x) → LikesPizza(x)) ::: If you study hard, you like pizza.",
            "∀x (Succeeds(x) → LikesPizza(x)) ::: Everyone who succeeds likes pizza.",
            "PassesExam(David) → LikesPizza(David) ::: If David passes the exam, he likes pizza.",
            "LikesPizza(David) → Succeeds(David) ::: If David likes pizza, he succeeds.",
            "PassesExam(David) ::: David passes the exam.",
            "∀x (Succeeds(x) → PassesExam(x)) ::: If someone succeeds, then they pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassesExam(x) ::: x passes the exam",
            "Succeeds(x) ::: x succeeds",
            "LikesPizza(x) ::: x likes pizza"
        ]
    },
    {
        "premises-NL": [
            "Alex is a student.",
            "Alex studies hard.",
            "Students who study hard usually pass exams.",
            "Alex likes coffee.",
            "People who like coffee are often not tired.",
            "Alex has a book.",
            "Alex attends class.",
            "Alex knows the professor.",
            "Alex reads the book.",
            "Alex is smart.",
            "Alex enjoys learning."
        ],
        "premises-FOL": [
            "Student(Alex) ::: Alex is a student",
            "StudiesHard(Alex) ::: Alex studies hard",
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: Students who study hard usually pass exams",
            "LikesCoffee(Alex) ::: Alex likes coffee",
            "∀x (LikesCoffee(x) → ¬IsTired(x)) ::: People who like coffee are often not tired",
            "HasBook(Alex) ::: Alex has a book",
            "AttendsClass(Alex) ::: Alex attends class",
            "KnowsProfessor(Alex) ::: Alex knows the professor",
            "ReadsBook(Alex) ::: Alex reads the book",
            "IsSmart(Alex) ::: Alex is smart",
            "EnjoysLearning(Alex) ::: Alex enjoys learning"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "LikesCoffee(x) ::: x likes coffee",
            "IsTired(x) ::: x is tired",
            "HasBook(x) ::: x has a book",
            "AttendsClass(x) ::: x attends class",
            "KnowsProfessor(x) ::: x knows the professor",
            "ReadsBook(x) ::: x reads the book",
            "IsSmart(x) ::: x is smart",
            "EnjoysLearning(x) ::: x enjoys learning"
        ]
    },
    {
        "premises-NL": [
            "All plants are either exposed to sunlight or they are not.",
            "If a plant is exposed to sunlight and water, and has nutrients, then it will grow.",
            "If a plant grows, it must be a plant.",
            "All plants are either a flower or not a flower.",
            "Some plants are exposed to sunlight.",
            "Some plants are exposed to water.",
            "Some plants have nutrients.",
            "If a plant is a flower it will grow.",
            "If a plant is not a flower it will also grow.",
            "Plants exposed to water also have nutrients.",
            "Plants exposed to sunlight are also exposed to water.",
            "If a plant is not exposed to sunlight, it is not a plant.",
            "Some plants grow.",
            "If a plant has nutrients and is exposed to sunlight, it will grow."
        ],
        "premises-FOL": [
            "∀x (Plant(x) → (ExposedToSunlight(x) ∨ ¬ExposedToSunlight(x))) ::: All plants are either exposed to sunlight or they are not.",
            "∀x (ExposedToSunlight(x) ∧ ExposedToWater(x) ∧ HasNutrients(x) → Grows(x)) ::: If a plant is exposed to sunlight and water, and has nutrients, then it will grow.",
            "∀x (Grows(x) → Plant(x)) ::: If a plant grows, it must be a plant.",
            "∀x (Plant(x) → (IsAFlower(x) ∨ ¬IsAFlower(x))) ::: All plants are either a flower or not a flower.",
            "∃x ExposedToSunlight(x) ::: Some plants are exposed to sunlight.",
            "∃x ExposedToWater(x) ::: Some plants are exposed to water.",
            "∃x HasNutrients(x) ::: Some plants have nutrients.",
            "∀x (IsAFlower(x) → Grows(x)) ::: If a plant is a flower it will grow.",
            "∀x (¬IsAFlower(x) → Grows(x)) ::: If a plant is not a flower it will also grow.",
            "∀x (ExposedToWater(x) → HasNutrients(x)) ::: Plants exposed to water also have nutrients.",
            "∀x (ExposedToSunlight(x) → ExposedToWater(x)) ::: Plants exposed to sunlight are also exposed to water.",
            "∀x (¬ExposedToSunlight(x) → ¬Plant(x)) ::: If a plant is not exposed to sunlight, it is not a plant.",
            "∃x Grows(x) ::: Some plants grow.",
            "∀x (HasNutrients(x) ∧ ExposedToSunlight(x) → Grows(x)) ::: If a plant has nutrients and is exposed to sunlight, it will grow."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "ExposedToSunlight(x) ::: x is exposed to sunlight",
            "ExposedToWater(x) ::: x is exposed to water",
            "HasNutrients(x) ::: x has nutrients",
            "Grows(x) ::: x grows",
            "IsAFlower(x) ::: x is a flower"
        ]
    },
    {
        "premises-NL": [
            "All doctors are people.",
            "Some doctors have completed medical school.",
            "If someone is a doctor and has completed medical school, and is a surgeon, then they can perform surgeries.",
            "If a doctor specializes in cardiology, they are a surgeon.",
            "All surgeons are doctors.",
            "If someone can perform heart surgery, then they are a surgeon.",
            "Some doctors specialize in cardiology.",
            "If a person can perform surgery, they are a doctor.",
            "If a doctor has completed medical school and specializes in cardiology, they can perform heart surgery.",
            "All surgeons have completed medical school.",
            "Some doctors have completed medical school and are surgeons.",
            "If someone is a doctor and a surgeon, they can perform surgery.",
            "Some people are doctors and are surgeons.",
            "If a surgeon specializes in cardiology, then they can perform heart surgeries."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Person(x)) ::: All doctors are people.",
            "∃x (Doctor(x) ∧ CompletedMedicalSchool(x)) ::: Some doctors have completed medical school.",
            "∀x ∀y (Doctor(x) ∧ CompletedMedicalSchool(x) ∧ Surgeon(x) → CanPerformSurgery(x, y)) ::: If someone is a doctor and has completed medical school, and is a surgeon, then they can perform surgeries.",
            "∀x (Doctor(x) ∧ SpecializesIn(x, \"Cardiology\") → Surgeon(x)) ::: If a doctor specializes in cardiology, they are a surgeon.",
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (CanPerformSurgery(x, \"Heart\") → Surgeon(x)) ::: If someone can perform heart surgery, then they are a surgeon.",
            "∃x (Doctor(x) ∧ SpecializesIn(x, \"Cardiology\")) ::: Some doctors specialize in cardiology.",
            "∀x (CanPerformSurgery(x, y) → Doctor(x)) ::: If a person can perform surgery, they are a doctor.",
            "∀x (Doctor(x) ∧ CompletedMedicalSchool(x) ∧ SpecializesIn(x, \"Cardiology\") → CanPerformSurgery(x, \"Heart\")) ::: If a doctor has completed medical school and specializes in cardiology, they can perform heart surgery.",
            "∀x (Surgeon(x) → CompletedMedicalSchool(x)) ::: All surgeons have completed medical school.",
            "∃x (Doctor(x) ∧ CompletedMedicalSchool(x) ∧ Surgeon(x)) ::: Some doctors have completed medical school and are surgeons.",
            "∀x (Doctor(x) ∧ Surgeon(x) → CanPerformSurgery(x, y)) ::: If someone is a doctor and a surgeon, they can perform surgery.",
            "∃x (Person(x) ∧ Doctor(x) ∧ Surgeon(x)) ::: Some people are doctors and are surgeons.",
            "∀x (Surgeon(x) ∧ SpecializesIn(x, \"Cardiology\") → CanPerformSurgery(x, \"Heart\")) ::: If a surgeon specializes in cardiology, then they can perform heart surgeries."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Doctor(x) ::: x is a doctor",
            "CompletedMedicalSchool(x) ::: x completed medical school",
            "SpecializesIn(x, y) ::: x specializes in field y",
            "CanPerformSurgery(x, y) ::: x can perform surgery on y",
            "Surgeon(x) ::: x is a surgeon"
        ]
    },
    {
        "premises-NL": [
            "All companies are either profitable or not.",
            "If a company is profitable, it expands.",
            "If a company invests in research and has good management, its stock value increases.",
            "If a company's stock value increases, it expands.",
            "If a company expands and is profitable, it invests in research.",
            "If a company has good management, it is profitable.",
            "Some companies are profitable.",
            "Some companies invest in research.",
            "If a company is profitable and has good management, its stock value increases.",
            "If a company expands and invests in research, its stock value increases.",
            "If a company is profitable and expands, it has good management.",
            "A company either invests in research or it doesn't.",
            "If a company is not profitable, its stock value does not increase.",
            "If a company's stock value increases, it also has good management.",
            "If a company invests in research, it expands."
        ],
        "premises-FOL": [
            "∀x (Company(x) → (Profitable(x) ∨ ¬Profitable(x))) ::: All companies are either profitable or not.",
            "∀x (Profitable(x) → Expands(x)) ::: If a company is profitable, it expands.",
            "∀x (InvestsInResearch(x) ∧ HasGoodManagement(x) → StockValueIncreases(x)) ::: If a company invests in research and has good management, its stock value increases.",
            "∀x (StockValueIncreases(x) → Expands(x)) ::: If a company's stock value increases, it expands.",
            "∀x (Expands(x) ∧ Profitable(x) → InvestsInResearch(x)) ::: If a company expands and is profitable, it invests in research.",
            "∀x (HasGoodManagement(x) → Profitable(x)) ::: If a company has good management, it is profitable.",
            "∃x Profitable(x) ::: Some companies are profitable.",
            "∃x InvestsInResearch(x) ::: Some companies invest in research.",
            "∀x (Profitable(x) ∧ HasGoodManagement(x) → StockValueIncreases(x)) ::: If a company is profitable and has good management, its stock value increases.",
            "∀x (Expands(x) ∧ InvestsInResearch(x) → StockValueIncreases(x)) ::: If a company expands and invests in research, its stock value increases.",
            "∀x (Profitable(x) ∧ Expands(x) → HasGoodManagement(x)) ::: If a company is profitable and expands, it has good management.",
            "∀x (InvestsInResearch(x) ∨ ¬InvestsInResearch(x)) ::: A company either invests in research or it doesn't.",
            "∀x (¬Profitable(x) → ¬StockValueIncreases(x)) ::: If a company is not profitable, its stock value does not increase.",
            "∀x (StockValueIncreases(x) → HasGoodManagement(x)) ::: If a company's stock value increases, it also has good management.",
            "∀x (InvestsInResearch(x) → Expands(x)) ::: If a company invests in research, it expands."
        ],
        "predicates": [
            "Company(x) ::: x is a company",
            "Profitable(x) ::: x is profitable",
            "InvestsInResearch(x) ::: x invests in research",
            "StockValueIncreases(x) ::: stock value increases for x",
            "HasGoodManagement(x) ::: x has good management",
            "Expands(x) ::: x expands"
        ]
    },
    {
        "premises-NL": [
            "All students are either intelligent or not.",
            "If a student studies, they are likely to attend lectures.",
            "If a student studies and attends lectures, then they are likely to get good grades.",
            "Students who get good grades are also likely to have support.",
            "Some students study.",
            "Some students attend lectures.",
            "Students who get good grades are also intelligent.",
            "Students either study or do not study.",
            "If a student doesn't study, they may not get good grades.",
            "If a student has support and studies, they will get good grades.",
            "If a student is intelligent and attends lectures, then they are likely to get good grades.",
            "If a student is not intelligent, they may not get good grades.",
            "If a student gets good grades and attends lectures, they are more likely to have support.",
            "If a student does not attend lectures, they may not get good grades.",
            "If a student has support, they will get good grades.",
            "Some students have support."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (IsIntelligent(x) ∨ ¬IsIntelligent(x))) ::: All students are either intelligent or not.",
            "∀x (StudentStudies(x) → AttendsLectures(x)) ::: If a student studies, they are likely to attend lectures.",
            "∀x (StudentStudies(x) ∧ AttendsLectures(x) → GetsGoodGrades(x)) ::: If a student studies and attends lectures, then they are likely to get good grades.",
            "∀x (GetsGoodGrades(x) → HasSupport(x)) ::: Students who get good grades are also likely to have support.",
            "∃x StudentStudies(x) ::: Some students study.",
            "∃x AttendsLectures(x) ::: Some students attend lectures.",
            "∀x (GetsGoodGrades(x) → IsIntelligent(x)) ::: Students who get good grades are also intelligent.",
            "∀x (StudentStudies(x) ∨ ¬StudentStudies(x)) ::: Students either study or do not study.",
            "∀x (¬StudentStudies(x) → ¬GetsGoodGrades(x)) ::: If a student doesn't study, they may not get good grades.",
            "∀x (HasSupport(x) ∧ StudentStudies(x) → GetsGoodGrades(x)) ::: If a student has support and studies, they will get good grades.",
            "∀x (IsIntelligent(x) ∧ AttendsLectures(x) → GetsGoodGrades(x)) ::: If a student is intelligent and attends lectures, then they are likely to get good grades.",
            "∀x (¬IsIntelligent(x) → ¬GetsGoodGrades(x)) ::: If a student is not intelligent, they may not get good grades.",
            "∀x (GetsGoodGrades(x) ∧ AttendsLectures(x) → HasSupport(x)) ::: If a student gets good grades and attends lectures, they are more likely to have support.",
            "∀x (¬AttendsLectures(x) → ¬GetsGoodGrades(x)) ::: If a student does not attend lectures, they may not get good grades.",
            "∀x (HasSupport(x) → GetsGoodGrades(x)) ::: If a student has support, they will get good grades.",
            "∃x HasSupport(x) ::: Some students have support."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudentStudies(x) ::: x studies",
            "AttendsLectures(x) ::: x attends lectures",
            "GetsGoodGrades(x) ::: x gets good grades",
            "IsIntelligent(x) ::: x is intelligent",
            "HasSupport(x) ::: x has support"
        ]
    },
    {
        "premises-NL": [
            "Every student either studies logic or is a doctor.",
            "Some students study logic.",
            "All students who study logic will pass the exam.",
            "Every student knows the answer to easy questions.",
            "The exam contains only easy questions.",
            "If a student studies logic, they will pass the exam.",
            "If a student knows all answers, they pass the exam.",
            "Anyone who knows the answers to the exam questions, passes the exam.",
            "There is a student.",
            "There is some student that studies logic.",
            "Every student who knows answers passes the exam.",
            "Only easy questions are in the exam.",
            "Anyone who is studying logic knows the answers.",
            "Every student studies logic or is a doctor."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (StudiesLogic(x) ∨ Doctor(x))) ::: Every student either studies logic or is a doctor",
            "∃x (Student(x) ∧ StudiesLogic(x)) ::: Some students study logic",
            "∀x (StudiesLogic(x) → PassExam(x)) ::: All students who study logic will pass the exam",
            "∀x ∃y (Student(x) → KnowsAnswer(x, y)) ::: Every student knows the answer to easy questions",
            "∀x (Question(x) → EasyQuestion(x)) ::: The exam contains only easy questions",
            "∀x (StudiesLogic(x) → PassExam(x)) ::: If a student studies logic, they will pass the exam",
            "∀x (KnowsAllAnswers(x) → PassExam(x)) ::: If a student knows all answers, they pass the exam",
            "∀x (KnowsAnswers(x) → PassExam(x)) ::: Anyone who knows the answers to the exam questions, passes the exam",
            "∃x Student(x) ::: There is a student",
            "∃x (Student(x) ∧ StudiesLogic(x)) ::: There is some student that studies logic",
            "∀x (KnowsAnswers(x) → PassExam(x)) ::: Every student who knows answers passes the exam",
            "∀x (Question(x) → EasyQuestion(x)) ::: Only easy questions are in the exam",
            "∀x (StudiesLogic(x) → KnowsAnswers(x)) ::: Anyone who is studying logic knows the answers",
            "∀x (Student(x) → (StudiesLogic(x) ∨ Doctor(x))) ::: Every student studies logic or is a doctor"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesLogic(x) ::: x studies logic",
            "PassExam(x) ::: x passes the exam",
            "KnowsAnswer(x, y) ::: x knows the answer to question y",
            "EasyQuestion(x) ::: x is an easy question"
        ]
    },
    {
        "premises-NL": [
            "All doctors are persons.",
            "Every doctor has a degree.",
            "Anyone who has a degree is trained.",
            "All doctors are either employed or have a high income.",
            "Every doctor can treat patients.",
            "Some doctors work at hospitals.",
            "Every doctor is a person.",
            "Anyone who works at a hospital is employed.",
            "If someone is a doctor, then they have a degree.",
            "Every employed person has a degree.",
            "Anyone who has a degree is employed or has a high income.",
            "Every doctor works at a hospital or is employed.",
            "Doctors are trained.",
            "Everyone who works at a hospital is employed.",
            "If someone is a doctor, then they are employed or they have a high income.",
            "If someone is a doctor, then they have a high income.",
            "If someone is a doctor, then they work at a hospital."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Person(x)) ::: All doctors are persons",
            "∀x (Doctor(x) → HasDegree(x)) ::: Every doctor has a degree",
            "∀x (HasDegree(x) → IsTrained(x)) ::: Anyone who has a degree is trained",
            "∀x (Doctor(x) → (Employed(x) ∨ HighIncome(x))) ::: All doctors are either employed or have a high income",
            "∀x ∀y (Doctor(x) → CanTreat(x, y)) ::: Every doctor can treat patients",
            "∃x (Doctor(x) ∧ WorksAtHospital(x)) ::: Some doctors work at hospitals",
            "∀x (Doctor(x) → Person(x)) ::: Every doctor is a person",
            "∀x (WorksAtHospital(x) → Employed(x)) ::: Anyone who works at a hospital is employed",
            "∀x (Doctor(x) → HasDegree(x)) ::: If someone is a doctor, then they have a degree",
            "∀x (Employed(x) → HasDegree(x)) ::: Every employed person has a degree",
            "∀x (HasDegree(x) → (Employed(x) ∨ HighIncome(x))) ::: Anyone who has a degree is employed or has a high income",
            "∀x (Doctor(x) → (WorksAtHospital(x) ∨ Employed(x))) ::: Every doctor works at a hospital or is employed",
            "∀x IsTrained(x) ::: Doctors are trained",
            "∀x (WorksAtHospital(x) → Employed(x)) ::: Everyone who works at a hospital is employed",
            "∀x (Doctor(x) → (Employed(x) ∨ HighIncome(x))) ::: If someone is a doctor, then they are employed or they have a high income",
            "∀x (Doctor(x) → HighIncome(x)) ::: If someone is a doctor, then they have a high income",
            "∀x (Doctor(x) → WorksAtHospital(x)) ::: If someone is a doctor, then they work at a hospital"
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Doctor(x) ::: x is a doctor",
            "Employed(x) ::: x is employed",
            "HasDegree(x) ::: x has a degree",
            "HighIncome(x) ::: x has a high income",
            "WorksAtHospital(x) ::: x works at a hospital",
            "IsTrained(x) ::: x is trained",
            "CanTreat(x, y) ::: x can treat y"
        ]
    },
    {
        "premises-NL": [
            "All products made of expensive materials are luxury products.",
            "All luxury products are sold at a high price.",
            "If the demand for a product is high, then the price is not high.",
            "If the price is not high, the demand is high.",
            "If something is a luxury product, it has low demand.",
            "If something is made of expensive material, then the price is high.",
            "Product A is made of expensive material.",
            "If a consumer buys a product and that product has a low price, they will buy it.",
            "Product B has a high demand.",
            "No product has both low and high demand.",
            "If a product is not made of expensive material, it is sold at a low price.",
            "Product C is not made of expensive material."
        ],
        "premises-FOL": [
            "∀x (ExpensiveMaterial(x) → LuxuryProduct(x)) ::: All products made of expensive materials are luxury products.",
            "∀x (LuxuryProduct(x) → HighPrice(x)) ::: All luxury products are sold at a high price.",
            "∀x (HighDemand(x) → ¬HighPrice(x)) ::: If the demand for a product is high, then the price is not high.",
            "∀x (¬HighPrice(x) → HighDemand(x)) ::: If the price is not high, the demand is high.",
            "∀x (LuxuryProduct(x) → LowDemand(x)) ::: If something is a luxury product, it has low demand.",
            "∀x (ExpensiveMaterial(x) → HighPrice(x)) ::: If something is made of expensive material, then the price is high.",
            "ExpensiveMaterial(A) ::: Product A is made of expensive material.",
            "∀x ∀y ((ConsumerBuys(x, y) ∧ LowPrice(y)) → ConsumerBuys(x, y)) ::: If a consumer buys a product and that product has a low price, they will buy it.",
            "HighDemand(B) ::: Product B has a high demand.",
            "¬∃x (LowDemand(x) ∧ HighDemand(x)) ::: No product has both low and high demand.",
            "∀x (¬ExpensiveMaterial(x) → LowPrice(x)) ::: If a product is not made of expensive material, it is sold at a low price.",
            "¬ExpensiveMaterial(C) ::: Product C is not made of expensive material."
        ],
        "predicates": [
            "Product(x) ::: x is a product.",
            "HighPrice(x) ::: x is sold at a high price.",
            "LowDemand(x) ::: the demand for x is low.",
            "ExpensiveMaterial(x) ::: x is made of expensive material.",
            "LuxuryProduct(x) ::: x is a luxury product.",
            "HighDemand(x) ::: the demand for x is high.",
            "LowPrice(x) ::: x is sold at a low price.",
            "ConsumerBuys(x, y) ::: consumer x buys product y."
        ]
    },
    {
        "premises-NL": [
            "Every student either likes programming or studies hard.",
            "John is a student.",
            "If someone studies hard and is a student, then they will succeed.",
            "John likes programming or studies hard.",
            "If someone likes programming and is a student, then they are enrolled in a course.",
            "If someone is enrolled in a course, they will succeed.",
            "If John is a student, then John is enrolled in a course.",
            "If John likes programming, then John studies hard.",
            "If John is not a student, John will fail.",
            "John is a student and studies hard.",
            "If someone is a student, they succeed."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (LikesProgramming(x) ∨ StudiesHard(x))) ::: Every student either likes programming or studies hard.",
            "Student(john) ::: John is a student.",
            "∀x ((StudiesHard(x) ∧ Student(x)) → Succeed(x)) ::: If someone studies hard and is a student, then they will succeed.",
            "LikesProgramming(john) ∨ StudiesHard(john) ::: John likes programming or studies hard.",
            "∀x ((LikesProgramming(x) ∧ Student(x)) → EnrolledIn(x, course)) ::: If someone likes programming and is a student, then they are enrolled in a course.",
            "∀x (EnrolledIn(x, course) → Succeed(x)) ::: If someone is enrolled in a course, they will succeed.",
            "Student(john) → Succeed(john) ::: If John is a student, then John is enrolled in a course.",
            "LikesProgramming(john) → StudiesHard(john) ::: If John likes programming, then John studies hard.",
            "¬Student(john) → ¬Succeed(john) ::: If John is not a student, John will fail.",
            "(Student(john) ∧ StudiesHard(john)) ::: John is a student and studies hard.",
            "∀x (Student(x) → Succeed(x)) ::: If someone is a student, they succeed."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "LikesProgramming(x) ::: x likes programming",
            "StudiesHard(x) ::: x studies hard",
            "Succeed(x) ::: x will succeed",
            "EnrolledIn(x, y) ::: x is enrolled in y",
            "TakesCourse(x, y) ::: x takes course y"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard will pass the exam.",
            "John is a student.",
            "John studies hard.",
            "Anyone who likes pizza is a student.",
            "John likes pizza.",
            "If John studies hard and likes pizza, then he passes the exam.",
            "If John studies hard, then he likes pizza.",
            "John is a student and studies hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: All students who study hard will pass the exam.",
            "Student(john) ::: John is a student.",
            "StudiesHard(john) ::: John studies hard.",
            "∀x (LikesPizza(x) → Student(x)) ::: Anyone who likes pizza is a student.",
            "LikesPizza(john) ::: John likes pizza.",
            "StudiesHard(john) ∧ LikesPizza(john) → PassExam(john) ::: If John studies hard and likes pizza, then he passes the exam.",
            "StudiesHard(john) → LikesPizza(john) ::: If John studies hard, then he likes pizza.",
            "Student(john) ∧ StudiesHard(john) ::: John is a student and studies hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesHard(x) ::: x studies hard.",
            "PassExam(x) ::: x passes the exam.",
            "LikesPizza(x) ::: x likes pizza."
        ]
    },
    {
        "premises-NL": [
            "All students who study hard will pass the exam.",
            "John is a student.",
            "John studies hard.",
            "Anyone who likes pizza is a student.",
            "John likes pizza.",
            "If John studies hard and likes pizza, then he passes the exam.",
            "If John studies hard, then he likes pizza.",
            "John is a student and studies hard.",
            "All students attend class.",
            "Anyone who studies hard, also attends class.",
            "If someone studies hard and attends class, they pass the exam.",
            "If someone studies hard, and likes pizza, then they attend class."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: All students who study hard will pass the exam.",
            "Student(john) ::: John is a student.",
            "StudiesHard(john) ::: John studies hard.",
            "∀x (LikesPizza(x) → Student(x)) ::: Anyone who likes pizza is a student.",
            "LikesPizza(john) ::: John likes pizza.",
            "StudiesHard(john) ∧ LikesPizza(john) → PassExam(john) ::: If John studies hard and likes pizza, then he passes the exam.",
            "StudiesHard(john) → LikesPizza(john) ::: If John studies hard, then he likes pizza.",
            "Student(john) ∧ StudiesHard(john) ::: John is a student and studies hard.",
            "∀x (Student(x) → AttendsClass(x)) ::: All students attend class.",
            "∀x (StudiesHard(x) → AttendsClass(x)) ::: Anyone who studies hard, also attends class.",
            "∀x (StudiesHard(x) ∧ AttendsClass(x) → PassExam(x)) ::: If someone studies hard and attends class, they pass the exam.",
            "∀x (StudiesHard(x) ∧ LikesPizza(x) → AttendsClass(x)) ::: If someone studies hard, and likes pizza, then they attend class."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesHard(x) ::: x studies hard.",
            "PassExam(x) ::: x passes the exam.",
            "LikesPizza(x) ::: x likes pizza.",
            "AttendsClass(x) ::: x attends class."
        ]
    },
    {
        "premises-NL": [
            "Every student is either a student.",
            "John is a student.",
            "Every student is a learner.",
            "Someone who works at the library is an employee.",
            "If a person is an employee, then they are employed.",
            "If a person is an employee, then they are employed by the library.",
            "If John is a student, then he is a learner.",
            "Working at the library means you are employed.",
            "Working at the library implies you are an employee.",
            "People who work at the library are employees.",
            "Anyone who is a librarian works at the library."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Student(x)) ::: Every student is either a student.",
            "Student(John) ::: John is a student.",
            "∀x (Student(x) → Learner(x)) ::: Every student is a learner.",
            "∀x (WorksAtLibrary(x) → Employee(x)) ::: Someone who works at the library is an employee.",
            "∀x (Employee(x) → Employed(x)) ::: If a person is an employee, then they are employed.",
            "∀x (Employee(x) → EmployedBy(x, Library)) ::: If a person is an employee, then they are employed by the library.",
            "Student(John) → Learner(John) ::: If John is a student, then he is a learner.",
            "∀x (WorksAtLibrary(x) → Employed(x)) ::: Working at the library means you are employed.",
            "∀x (WorksAtLibrary(x) → Employee(x)) ::: Working at the library implies you are an employee.",
            "∀x (WorksAtLibrary(x) → Employee(x)) ::: People who work at the library are employees.",
            "∀x (Librarian(x) → WorksAtLibrary(x)) ::: Anyone who is a librarian works at the library."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "WorksAtLibrary(x) ::: x works at the library",
            "Employee(x) ::: x is an employee",
            "EnrolledInCourse(x, y) ::: x is enrolled in course y",
            "IsProfessorOf(x, y) ::: x is professor of y",
            "Course(x) ::: x is a course",
            "Teaches(x, y) ::: x teaches y",
            "Takes(x, y) ::: x takes y",
            "Librarian(x) ::: x is a librarian",
            "EmployedBy(x, y) ::: x is employed by y"
        ]
    },
    {
        "premises-NL": [
            "People with a high income often have savings.",
            "If someone has savings, they may want to buy a house.",
            "If a person wants to buy a house and is employed, they are likely to buy a house.",
            "John has a high income.",
            "John is employed.",
            "Married people tend to want to buy houses.",
            "People with children want to buy a house.",
            "If someone earns a good salary they have a high income.",
            "Being resident of a place means that they can buy a house.",
            "People with high credit scores can obtain a loan.",
            "People with a high income, are employed or have a high credit score.",
            "People who have a loan can buy a house."
        ],
        "premises-FOL": [
            "∀x (HighIncome(x) → HasSavings(x)) ::: People with a high income often have savings.",
            "∀x (HasSavings(x) → WantsToBuyHouse(x)) ::: If someone has savings, they may want to buy a house.",
            "∀x (WantsToBuyHouse(x) ∧ Employed(x) → LikelyToBuyHouse(x)) ::: If a person wants to buy a house and is employed, they are likely to buy a house.",
            "HighIncome(John) ::: John has a high income.",
            "Employed(John) ::: John is employed.",
            "∀x (IsMarried(x) → WantsToBuyHouse(x)) ::: Married people tend to want to buy houses.",
            "∀x (HasChildren(x) → WantsToBuyHouse(x)) ::: People with children want to buy a house.",
            "∀x (Earns(x, y) → HighIncome(x)) ::: If someone earns a good salary they have a high income.",
            "∀x (IsResidentOf(x, y) → WantsToBuyHouse(x)) ::: Being resident of a place means that they can buy a house.",
            "∀x (HighCreditScore(x) → HasLoan(x)) ::: People with high credit scores can obtain a loan.",
            "∀x (HighIncome(x) ∨ Employed(x) ∨ HighCreditScore(x)) ::: People with a high income, are employed or have a high credit score.",
            "∀x (HasLoan(x) → LikelyToBuyHouse(x)) ::: People who have a loan can buy a house."
        ],
        "predicates": [
            "HighIncome(x) ::: x has a high income",
            "Employed(x) ::: x is employed",
            "LikelyToBuyHouse(x) ::: x is likely to buy a house",
            "HasSavings(x) ::: x has savings",
            "WantsToBuyHouse(x) ::: x wants to buy a house",
            "IsMarried(x) ::: x is married",
            "HasChildren(x) ::: x has children",
            "Earns(x, y) ::: x earns y",
            "IsResidentOf(x, y) ::: x is resident of y",
            "HighCreditScore(x) ::: x has a high credit score",
            "HasLoan(x) ::: x has a loan"
        ]
    },
    {
        "premises-NL": [
            "All marathon runners are athletes.",
            "Some marathon runners are fast.",
            "All marathon runners participate in track events.",
            "Some track events require strength.",
            "If someone participates in a track event that requires strength, then they are strong."
        ],
        "premises-FOL": [
            "∀x (MarathonRunner(x) → Athlete(x)) ::: For all x, if x is a marathon runner, then x is an athlete.",
            "∃x (MarathonRunner(x) ∧ Fast(x)) ::: There exists an x such that x is a marathon runner and fast.",
            "∀x ∃y (MarathonRunner(x) → ParticipatesIn(x, y) ∧ TrackEvent(y)) ::: For all x, if x is a marathon runner, then there exists a y such that x participates in y and y is a track event.",
            "∃y (TrackEvent(y) ∧ RequiresStrength(y)) ::: There exists a y such that y is a track event and requires strength.",
            "∀x ∀y ((ParticipatesIn(x, y) ∧ RequiresStrength(y)) → Strong(x)) ::: For all x and y, if x participates in y and y requires strength, then x is strong."
        ],
        "predicates": [
            "Athlete(x) ::: x is an athlete.",
            "Fast(x) ::: x is fast.",
            "Strong(x) ::: x is strong.",
            "ParticipatesIn(x, y) ::: x participates in y.",
            "TrackEvent(y) ::: y is a track event."
        ]
    },
    {
        "premises-NL": [
            "All students who like coffee are happy.",
            "John studies, and if he studies he likes coffee.",
            "John is a student.",
            "If someone is a student and happy, they pass the exam.",
            "John studies.",
            "John likes coffee."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ LikesCoffee(x) → Happy(x)) ::: All students who like coffee are happy.",
            "Studies(john) ∧ (Studies(john) → LikesCoffee(john)) ::: John studies, and if he studies he likes coffee.",
            "Student(john) ::: John is a student.",
            "∀x (Student(x) ∧ Happy(x) → PassesExam(x)) ::: If someone is a student and happy, they pass the exam.",
            "Studies(john) ::: John studies.",
            "LikesCoffee(john) ::: John likes coffee."
        ],
        "predicates": [
            "Studies(x) ::: x studies",
            "LikesCoffee(x) ::: x likes coffee",
            "Happy(x) ::: x is happy",
            "PassesExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled in either math class or science class.",
            "If someone likes physics, then they are enrolled in the science class.",
            "If someone likes chemistry, then they are enrolled in the math class.",
            "John likes physics and chemistry.",
            "If John is a student and likes physics, he is in science class.",
            "If John is a student and likes chemistry, he is in math class.",
            "John is a student.",
            "If John is in the math class and the science class, then the teacher is happy."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (InMathClass(x) ∨ InScienceClass(x))) ::: All students are enrolled in either math class or science class.",
            "∀x (LikesPhysics(x) → InScienceClass(x)) ::: If someone likes physics, then they are enrolled in the science class.",
            "∀x (LikesChemistry(x) → InMathClass(x)) ::: If someone likes chemistry, then they are enrolled in the math class.",
            "LikesPhysics(john) ∧ LikesChemistry(john) ::: John likes physics and chemistry.",
            "Student(john) ∧ LikesPhysics(john) → InScienceClass(john) ::: If John is a student and likes physics, he is in science class.",
            "Student(john) ∧ LikesChemistry(john) → InMathClass(john) ::: If John is a student and likes chemistry, he is in math class.",
            "Student(john) ::: John is a student.",
            "InMathClass(john) ∧ InScienceClass(john) → Happy(teacher) ::: If John is in the math class and the science class, then the teacher is happy."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "InMathClass(x) ::: x is in the math class",
            "InScienceClass(x) ::: x is in the science class",
            "LikesPhysics(x) ::: x likes physics",
            "LikesChemistry(x) ::: x likes chemistry",
            "EnrolledIn(x, y) ::: x is enrolled in class y",
            "IsClass(x) ::: x is a class",
            "Teaches(x, y) ::: x teaches y"
        ]
    },
    {
        "premises-NL": [
            "All employees attend workshops.",
            "If someone attends a workshop, they are trained.",
            "If an employee knows marketing strategy, they work in marketing.",
            "If someone is trained and works in marketing, they use social media.",
            "An employee knows marketing strategy.",
            "If someone attends the workshop and is good at communication, they are using social media.",
            "If someone works in marketing, they are good at communication.",
            "All marketing employees are good at communication.",
            "John is an employee who knows marketing strategy."
        ],
        "premises-FOL": [
            "∀x (Employee(x) → AttendsWorkshop(x)) ::: All employees attend workshops.",
            "∀x (AttendsWorkshop(x) → Trained(x)) ::: If someone attends a workshop, they are trained.",
            "∀x (Employee(x) ∧ KnowsStrategy(x) → WorksInMarketing(x)) ::: If an employee knows marketing strategy, they work in marketing.",
            "∀x (Trained(x) ∧ WorksInMarketing(x) → UsesSocialMedia(x)) ::: If someone is trained and works in marketing, they use social media.",
            "∃x (Employee(x) ∧ KnowsStrategy(x)) ::: An employee knows marketing strategy.",
            "∀x (AttendsWorkshop(x) ∧ GoodAtCommunication(x) → UsesSocialMedia(x)) ::: If someone attends the workshop and is good at communication, they are using social media.",
            "∀x (WorksInMarketing(x) → GoodAtCommunication(x)) ::: If someone works in marketing, they are good at communication.",
            "∀x (WorksInMarketing(x) → GoodAtCommunication(x)) ::: All marketing employees are good at communication.",
            "Employee(john) ∧ KnowsStrategy(john) ::: John is an employee who knows marketing strategy."
        ],
        "predicates": [
            "Employee(x) ::: x is an employee",
            "Trained(x) ::: x is trained",
            "WorksInMarketing(x) ::: x works in marketing",
            "UsesSocialMedia(x) ::: x uses social media",
            "AttendsWorkshop(x) ::: x attends a workshop",
            "Department(x, y) ::: x works in department y",
            "KnowsStrategy(x) ::: x knows marketing strategy",
            "GoodAtCommunication(x) ::: x is good at communication"
        ]
    },
    {
        "premises-NL": [
            "All Scottish Folds are cats.",
            "All Scottish Folds have fur.",
            "Some Scottish Folds are not black.",
            "All cats have fur.",
            "If something is white, then it has fur.",
            "If something has fur, it is either black or white.",
            "If something is a cat, then it has fur.",
            "There is a Scottish Fold."
        ],
        "premises-FOL": [
            "∀x (ScottishFold(x) → Cat(x)) ::: All Scottish Folds are cats.",
            "∀x (ScottishFold(x) → HasFur(x)) ::: All Scottish Folds have fur.",
            "∃x (ScottishFold(x) ∧ ¬Black(x)) ::: Some Scottish Folds are not black.",
            "∀x (Cat(x) → HasFur(x)) ::: All cats have fur.",
            "∀x (White(x) → HasFur(x)) ::: If something is white, then it has fur.",
            "∀x (HasFur(x) → (Black(x) ∨ White(x))) ::: If something has fur, it is either black or white.",
            "∀x (Cat(x) → HasFur(x)) ::: If something is a cat, then it has fur.",
            "∃x ScottishFold(x) ::: There is a Scottish Fold."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Black(x) ::: x is black",
            "White(x) ::: x is white",
            "ScottishFold(x) ::: x is a Scottish Fold",
            "HasFur(x) ::: x has fur"
        ]
    },
    {
        "premises-NL": [
            "All programmers use logic.",
            "Anyone who uses logic is good at math.",
            "John is a programmer.",
            "John uses the language Python.",
            "Anyone who uses Python studies computer science.",
            "All those who study computer science know calculus.",
            "Anyone who knows calculus is good at math.",
            "John has a degree in computer science.",
            "All computer scientists have a degree related to it.",
            "Anyone with a degree related to computer science is a programmer."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → UsesLogic(x)) ::: All programmers use logic.",
            "∀x (UsesLogic(x) → GoodAtMath(x)) ::: Anyone who uses logic is good at math.",
            "Programmer(john) ::: John is a programmer.",
            "UsesProgrammingLanguage(john, python) ::: John uses the language Python.",
            "∀x (UsesProgrammingLanguage(x, python) → StudiesComputerScience(x)) ::: Anyone who uses Python studies computer science.",
            "∀x (StudiesComputerScience(x) → KnowsCalculus(x)) ::: All those who study computer science know calculus.",
            "∀x (KnowsCalculus(x) → GoodAtMath(x)) ::: Anyone who knows calculus is good at math.",
            "HasDegree(john, computerscience) ::: John has a degree in computer science.",
            "∀x ∀y (StudiesComputerScience(x) → HasDegree(x, y)) ::: All computer scientists have a degree related to it.",
            "∀x ∀y (HasDegree(x, y) ∧ StudiesComputerScience(y) → Programmer(x)) ::: Anyone with a degree related to computer science is a programmer."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "GoodAtMath(x) ::: x is good at math",
            "UsesLogic(x) ::: x uses logic",
            "KnowsCalculus(x) ::: x knows calculus",
            "StudiesComputerScience(x) ::: x studies computer science",
            "UsesProgrammingLanguage(x, y) ::: x uses programming language y",
            "HasDegree(x, y) ::: x has degree y"
        ]
    },
    {
        "premises-NL": [
            "All programmers know Python.",
            "Anyone who knows Python is employable.",
            "John is a programmer.",
            "If someone likes cats, they are smart.",
            "John likes cats.",
            "All smart people are employable.",
            "John knows Python.",
            "Anyone who is a programmer and knows Python will be employed."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → KnowsPython(x)) ::: All programmers know Python.",
            "∀x (KnowsPython(x) → Employed(x)) ::: Anyone who knows Python is employable.",
            "Programmer(john) ::: John is a programmer.",
            "∀x (LikesCats(x) → Smart(x)) ::: If someone likes cats, they are smart.",
            "LikesCats(john) ::: John likes cats.",
            "∀x (Smart(x) → Employed(x)) ::: All smart people are employable.",
            "KnowsPython(john) ::: John knows Python.",
            "∀x (Programmer(x) ∧ KnowsPython(x) → Employed(x)) ::: Anyone who is a programmer and knows Python will be employed."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "KnowsPython(x) ::: x knows Python",
            "Employed(x) ::: x is employed",
            "LikesCats(x) ::: x likes cats",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "If it is raining, the ground is wet.",
            "If there is thunder, there was a storm.",
            "It is raining.",
            "If there is lightning, there was a storm.",
            "The ground is wet.",
            "If it is raining and the ground is wet, then there was a storm.",
            "If the sky is cloudy, it might rain.",
            "There is lightning.",
            "There is thunder."
        ],
        "premises-FOL": [
            "∀x (Raining(x) → WetGround(x)) ::: If it is raining, the ground is wet.",
            "∀x (Thunder(x) → Storm(x)) ::: If there is thunder, there was a storm.",
            "Raining(x) ::: It is raining.",
            "∀x (Lightning(x) → Storm(x)) ::: If there is lightning, there was a storm.",
            "WetGround(x) ::: The ground is wet.",
            "Raining(x) ∧ WetGround(x) → Storm(x) ::: If it is raining and the ground is wet, then there was a storm.",
            "∀x (Cloudy(x) → Raining(x)) ::: If the sky is cloudy, it might rain.",
            "Lightning(x) ::: There is lightning.",
            "Thunder(x) ::: There is thunder."
        ],
        "predicates": [
            "Raining(x) ::: It is raining",
            "WetGround(x) ::: The ground is wet",
            "Storm(x) ::: There was a storm",
            "Cloudy(x) ::: The sky is cloudy",
            "Thunder(x) ::: There is thunder",
            "Lightning(x) ::: There is lightning"
        ]
    },
    {
        "premises-NL": [
            "Alex is a student.",
            "If a student studies hard, then they will pass the exam.",
            "Alex studies hard."
        ],
        "premises-FOL": [
            "Student(alex) ::: Alex is a student",
            "∀x (Student(x) ∧ Hard(x) → PassExam(x)) ::: If a student studies hard, then they will pass the exam",
            "Hard(alex) ::: Alex studies hard"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x, y) ::: x studies y",
            "Hard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "Sarah is a doctor.",
            "If someone treats patients, then they are busy.",
            "If someone is not busy then they are available.",
            "Sarah is a doctor and treats patients."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → TreatsPatients(x)) ::: All doctors treat patients",
            "Doctor(sarah) ::: Sarah is a doctor",
            "∀x (TreatsPatients(x) → Busy(x)) ::: If someone treats patients, then they are busy",
            "∀x (¬Busy(x) → Available(x)) ::: If someone is not busy then they are available",
            "Doctor(sarah) ∧ TreatsPatients(sarah) ::: Sarah is a doctor and treats patients"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "TreatsPatients(x) ::: x treats patients",
            "Busy(x) ::: x is busy",
            "Available(x) ::: x is available"
        ]
    },
    {
        "premises-NL": [
            "All students take classes.",
            "If someone studies hard, they will pass the exam.",
            "John is a student.",
            "John studies hard.",
            "If a student studies hard and takes a class, then they will pass the exam.",
            "Mary is a student who studies hard and takes a class",
            "Some students study hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakesClass(x, y)) ::: All students take classes",
            "∀x (Hard(x) → PassExam(x)) ::: If someone studies hard, they will pass the exam",
            "Student(john) ::: John is a student",
            "Hard(john) ::: John studies hard",
            "∀x (Student(x) ∧ Hard(x) ∧ TakesClass(x, y) → PassExam(x)) ::: If a student studies hard and takes a class, then they will pass the exam",
            "Student(mary) ∧ Hard(mary) ∧ TakesClass(mary, y) ::: Mary is a student who studies hard and takes a class",
            "∃x (Student(x) ∧ Hard(x)) ::: Some students study hard"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x, y) ::: x studies y",
            "Hard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "TakesClass(x, y) ::: x takes class y"
        ]
    },
    {
        "premises-NL": [
            "All students study.",
            "If someone studies, they attend classes.",
            "If someone attends classes, they take exams.",
            "John studies.",
            "If John takes an exam, he either passes or fails.",
            "John is a student.",
            "If John does not pass an exam, he fails.",
            "If someone passes the exam, they studied."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Study(x)) ::: All students study",
            "∀x (Study(x) → AttendsClasses(x)) ::: If someone studies, they attend classes",
            "∀x (AttendsClasses(x) → TakesExam(x)) ::: If someone attends classes, they take exams",
            "Study(john) ::: John studies",
            "∀x (TakesExam(x) → (PassesExam(x) ∨ FailsExam(x))) ::: If someone takes an exam, they either pass or fail",
            "Student(john) ::: John is a student",
            "∀x (¬PassesExam(x) → FailsExam(x)) ::: If John does not pass an exam, he fails",
            "∀x (PassesExam(x) → Study(x)) ::: If someone passes the exam, they studied"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsClasses(x) ::: x attends classes",
            "TakesExam(x) ::: x takes an exam",
            "PassesExam(x) ::: x passes an exam",
            "Study(x) ::: x studies"
        ]
    },
    {
        "premises-NL": [
            "John studies hard.",
            "John attends all classes.",
            "If someone studies hard and attends classes, they are likely to pass the exam.",
            "If John likes pizza, he is likely to be happy.",
            "John likes pizza.",
            "If someone is smart, they will pass the exam.",
            "John is smart.",
            "Anyone who is happy and smart is likely to pass the exam.",
            "If someone is happy and smart, they will pass the exam."
        ],
        "premises-FOL": [
            "StudyHard(john) ::: John studies hard",
            "AttendClasses(john) ::: John attends all classes",
            "∀x (StudyHard(x) ∧ AttendClasses(x) → PassExam(x)) ::: If someone studies hard and attends classes, they are likely to pass the exam.",
            "∀x (LikesPizza(x) → Happy(x)) ::: If John likes pizza, he is likely to be happy.",
            "LikesPizza(john) ::: John likes pizza.",
            "∀x (Smart(x) → PassExam(x)) ::: If someone is smart, they will pass the exam.",
            "Smart(john) ::: John is smart.",
            "∀x (Happy(x) ∧ Smart(x) → PassExam(x)) ::: Anyone who is happy and smart is likely to pass the exam.",
            "Happy(john) ∧ Smart(john) → PassExam(john) ::: If someone is happy and smart, they will pass the exam."
        ],
        "predicates": [
            "StudyHard(x) ::: x studies hard",
            "AttendClasses(x) ::: x attends classes",
            "PassExam(x) ::: x passes the exam",
            "LikesPizza(x) ::: x likes pizza",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "Sarah is a doctor.",
            "Sarah specializes in cardiology.",
            "All cardiologists know about heart disease.",
            "John is a patient.",
            "John has heart disease.",
            "Doctors treat patients with diseases.",
            "If someone is a doctor, they are educated.",
            "If someone is educated, they know about diseases.",
            "If someone specializes in cardiology, they know about heart disease.",
            "Mary treats John.",
            "Mary is a doctor."
        ],
        "premises-FOL": [
            "Doctor(sarah) ::: Sarah is a doctor.",
            "SpecializesIn(sarah, cardiology) ::: Sarah specializes in cardiology.",
            "∀x (SpecializesIn(x, cardiology) → KnowsAbout(x, heartDisease)) ::: All cardiologists know about heart disease.",
            "IsPatient(john) ::: John is a patient.",
            "HasDisease(john, heartDisease) ::: John has heart disease.",
            "∀x ∀y (Doctor(x) ∧ HasDisease(y, heartDisease) → Treats(x,y)) ::: Doctors treat patients with diseases.",
            "∀x (Doctor(x) → Educated(x)) ::: If someone is a doctor, they are educated.",
            "∀x (Educated(x) → KnowsAbout(x, diseases)) ::: If someone is educated, they know about diseases.",
            "∀x (SpecializesIn(x, cardiology) → KnowsAbout(x, heartDisease)) ::: If someone specializes in cardiology, they know about heart disease.",
            "Treats(mary, john) ::: Mary treats John.",
            "Doctor(mary) ::: Mary is a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "SpecializesIn(x, y) ::: x specializes in y",
            "KnowsAbout(x, y) ::: x knows about y",
            "IsPatient(x) ::: x is a patient",
            "HasDisease(x, y) ::: x has disease y",
            "Treats(x, y) ::: x treats y"
        ]
    },
    {
        "premises-NL": [
            "Alice and Bob are friends.",
            "Bob likes pizza.",
            "If someone likes pizza, they are happy.",
            "If Alice and Bob are friends, Alice is kind.",
            "If someone is kind, they are generous.",
            "Bob eats pizza.",
            "Alice is wealthy or Bob is not happy.",
            "If Bob is happy and generous, he shares pizza.",
            "If Bob shares pizza with Alice, then Alice likes pizza.",
            "Alice and Bob are friends and likes pizza and Alice is rich.",
            "Alice is wealthy."
        ],
        "premises-FOL": [
            "Friends(alice, bob) ::: Alice and Bob are friends.",
            "Likes(bob, pizza) ::: Bob likes pizza.",
            "∀x (Likes(x, pizza) → Happy(x)) ::: If someone likes pizza, they are happy.",
            "∀x ∀y (Friends(x, y) → Kind(x)) ::: If Alice and Bob are friends, Alice is kind.",
            "∀x (Kind(x) → Generous(x)) ::: If someone is kind, they are generous.",
            "Eats(bob, pizza) ::: Bob eats pizza.",
            "Wealthy(alice) ∨ ¬Happy(bob) ::: Alice is wealthy or Bob is not happy.",
            "∀x ∀y (Happy(x) ∧ Generous(x) → SharesWith(x, y, pizza)) ::: If Bob is happy and generous, he shares pizza.",
            "∀x ∀y (SharesWith(bob, alice, pizza) → Likes(alice, pizza)) ::: If Bob shares pizza with Alice, then Alice likes pizza.",
            "Friends(alice, bob) ∧ Likes(bob, pizza) ∧ Wealthy(alice) ::: Alice and Bob are friends and likes pizza and Alice is rich.",
            "Wealthy(alice) ::: Alice is wealthy."
        ],
        "predicates": [
            "Friends(x, y) ::: x and y are friends",
            "Likes(x, y) ::: x likes y",
            "Happy(x) ::: x is happy",
            "Eats(x, y) ::: x eats y",
            "Generous(x) ::: x is generous",
            "SharesWith(x, y, z) ::: x shares z with y",
            "Kind(x) ::: x is kind",
            "Wealthy(x) ::: x is wealthy"
        ]
    },
    {
        "premises-NL": [
            "Mary is enrolled.",
            "Peter is enrolled.",
            "If someone is enrolled, then they are a student.",
            "Mary is a student.",
            "Peter is a student.",
            "If Mary and Peter are both enrolled, then Peter is enrolled."
        ],
        "premises-FOL": [
            "Enrolled(mary) ::: Mary is enrolled.",
            "Enrolled(peter) ::: Peter is enrolled.",
            "∀x (Enrolled(x) → Student(x)) ::: If someone is enrolled, then they are a student.",
            "Student(mary) ::: Mary is a student.",
            "Student(peter) ::: Peter is a student.",
            "∀x ∀y ((Enrolled(x) ∧ Enrolled(y)) → Enrolled(y)) ::: If Mary and Peter are both enrolled, then Peter is enrolled."
        ],
        "predicates": [
            "Enrolled(x) ::: x is enrolled in a course.",
            "Student(x) ::: x is a student.",
            "Course(x) ::: x is a course.",
            "Takes(x, y) ::: x takes course y.",
            "Professor(x) ::: x is a professor.",
            "Teaches(x, y) ::: x teaches course y."
        ]
    },
    {
        "premises-NL": [
            "John sent a message to Mary.",
            "Mary sent a message to Peter.",
            "If someone sends a message to someone, then they communicate with them.",
            "If someone communicates with someone, then they might know each other.",
            "If John communicates with Mary and Mary communicates with Peter, then John knows Peter.",
            "Everyone knows themselves.",
            "If John sent a message to Mary and Mary sent a message to Peter, then John and Peter are connected.",
            "John sent a message to Mary, and Mary sent a message to Peter."
        ],
        "premises-FOL": [
            "Sent(john, mary) ::: John sent a message to Mary.",
            "Sent(mary, peter) ::: Mary sent a message to Peter.",
            "∀x ∀y (Sent(x, y) → Communicates(x, y)) ::: If someone sends a message to someone, then they communicate with them.",
            "∀x ∀y (Communicates(x, y) → Knows(x, y) ∨ Knows(y, x)) ::: If someone communicates with someone, then they might know each other.",
            "∀x ∀y ∀z ((Communicates(x, y) ∧ Communicates(y, z)) → Knows(x, z)) ::: If John communicates with Mary and Mary communicates with Peter, then John knows Peter.",
            "∀x Knows(x, x) ::: Everyone knows themselves.",
            "∀x ∀y ∀z ((Sent(x, y) ∧ Sent(y, z)) → Knows(x, z)) ::: If John sent a message to Mary and Mary sent a message to Peter, then John and Peter are connected.",
            "Sent(john, mary) ∧ Sent(mary, peter) ::: John sent a message to Mary, and Mary sent a message to Peter."
        ],
        "predicates": [
            "Sent(x, y) ::: x sent a message to y.",
            "Knows(x, y) ::: x knows y.",
            "Friend(x, y) ::: x is a friend of y.",
            "Likes(x, y) ::: x likes y.",
            "Hates(x, y) ::: x hates y.",
            "Communicates(x, y) ::: x communicates with y.",
            "SharedSecret(x, y) ::: x and y shared a secret.",
            "Follows(x, y) ::: x follows y."
        ]
    },
    {
        "premises-NL": [
            "All students who study hard will pass if they are diligent",
            "Alice is a student.",
            "Alice studies hard.",
            "Alice is diligent.",
            "Bob is a student.",
            "Bob studies hard.",
            "Bob doesn't like coffee.",
            "Bob reads books.",
            "Bob enjoys movies.",
            "Bob has friends."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) ∧ Diligent(x) → Passes(x)) ::: All students who study hard and are diligent will pass.",
            "Student(alice) ::: Alice is a student.",
            "StudiesHard(alice) ::: Alice studies hard.",
            "Diligent(alice) ::: Alice is diligent.",
            "Student(bob) ::: Bob is a student.",
            "StudiesHard(bob) ::: Bob studies hard.",
            "¬LikesCoffee(bob) ::: Bob does not like coffee.",
            "ReadsBooks(bob) ::: Bob reads books.",
            "EnjoysMovies(bob) ::: Bob enjoys movies.",
            "HasFriends(bob) ::: Bob has friends."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "Diligent(x) ::: x is diligent",
            "Passes(x) ::: x passes the exam",
            "LikesCoffee(x) ::: x likes coffee",
            "ReadsBooks(x) ::: x reads books",
            "EnjoysMovies(x) ::: x enjoys movies",
            "HasFriends(x) ::: x has friends",
            "IsHappy(x) ::: x is happy",
            "SleepsEnough(x) ::: x sleeps enough"
        ]
    },
    {
        "premises-NL": [
            "All scientists are researchers.",
            "All researchers who work together, collaborate.",
            "Emily is a scientist.",
            "David is a scientist.",
            "Emily and David work at the same institution.",
            "Emily publishes a paper every year.",
            "David studies climate change.",
            "Emily has a grant.",
            "David attends conferences.",
            "Emily knows English.",
            "David enjoys music.",
            "Emily plays sports."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Researcher(x)) ::: All scientists are researchers.",
            "∀x ∀y (Researcher(x) ∧ Researcher(y) ∧ WorksAt(x, z) ∧ WorksAt(y, z) → Collaborates(x, y)) ::: All researchers who work together, collaborate.",
            "Scientist(emily) ::: Emily is a scientist.",
            "Scientist(david) ::: David is a scientist.",
            "WorksAt(emily, institution) ∧ WorksAt(david, institution) ::: Emily and David work at the same institution.",
            "∀x (Scientist(x) → PublishesPaper(x)) ::: Emily publishes a paper every year.",
            "Studies(david, climateChange) ::: David studies climate change.",
            "HasGrant(emily) ::: Emily has a grant.",
            "AttendsConference(david) ::: David attends conferences.",
            "KnowsLanguage(emily, english) ::: Emily knows English.",
            "EnjoysMusic(david) ::: David enjoys music.",
            "PlaysSport(emily) ::: Emily plays sports."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Researcher(x) ::: x is a researcher",
            "WorksAt(x, y) ::: x works at y",
            "Collaborates(x, y) ::: x collaborates with y",
            "PublishesPaper(x) ::: x publishes a paper",
            "Studies(x, y) ::: x studies y",
            "HasGrant(x) ::: x has a grant",
            "AttendsConference(x) ::: x attends a conference",
            "KnowsLanguage(x, y) ::: x knows language y",
            "EnjoysMusic(x) ::: x enjoys music",
            "PlaysSport(x) ::: x plays a sport",
            "ReadsBooks(x) ::: x reads books"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard attend lectures.",
            "Alex is a student.",
            "Some students are smart.",
            "If a student attends lectures and is smart, then they pass the exam.",
            "Alex studies hard.",
            "All students who attend lectures study hard.",
            "Some students study hard.",
            "Alex is a student who attends lectures."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) → AttendsLectures(x)) ::: All students who study hard attend lectures",
            "Student(alex) ::: Alex is a student",
            "∃x Smart(x) ::: Some students are smart",
            "∀x (Student(x) ∧ AttendsLectures(x) ∧ Smart(x) → PassesExam(x)) ::: If a student attends lectures and is smart, then they pass the exam",
            "StudiesHard(alex) ::: Alex studies hard",
            "∀x (Student(x) ∧ AttendsLectures(x) → StudiesHard(x)) ::: All students who attend lectures study hard",
            "∃x StudiesHard(x) ::: Some students study hard",
            "Student(alex) ∧ AttendsLectures(alex) ::: Alex is a student who attends lectures"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "AttendsLectures(x) ::: x attends lectures",
            "PassesExam(x) ::: x passes the exam",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All doctors are skilled.",
            "John is a doctor.",
            "All surgeons are doctors.",
            "If someone is a surgeon, they practice medicine.",
            "Anyone who practices medicine helps patients.",
            "John is skilled.",
            "Some doctors are surgeons.",
            "All skilled doctors help patients.",
            "Doctors who are surgeons are skilled."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Skilled(x)) ::: All doctors are skilled",
            "Doctor(john) ::: John is a doctor",
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors",
            "∀x (Surgeon(x) → PracticesMedicine(x)) ::: If someone is a surgeon, they practice medicine",
            "∀x (PracticesMedicine(x) → HelpsPatients(x)) ::: Anyone who practices medicine helps patients",
            "Skilled(john) ::: John is skilled",
            "∃x (Doctor(x) ∧ Surgeon(x)) ::: Some doctors are surgeons",
            "∀x (Skilled(x) ∧ Doctor(x) → HelpsPatients(x)) ::: All skilled doctors help patients",
            "∀x (Doctor(x) ∧ Surgeon(x) → Skilled(x)) ::: Doctors who are surgeons are skilled"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Skilled(x) ::: x is skilled",
            "HelpsPatients(x) ::: x helps patients",
            "Surgeon(x) ::: x is a surgeon",
            "PracticesMedicine(x) ::: x practices medicine"
        ]
    },
    {
        "premises-NL": [
            "All cats like fish.",
            "Garfield is a cat.",
            "All cats eat food.",
            "If something likes fish, it eats food.",
            "Garfield is orange.",
            "All cats chase mice.",
            "Some cats are orange.",
            "If something is orange, then it is a cat.",
            "Anything that eats food likes fish.",
            "Garfield eats food.",
            "Anything that chases mice is a cat.",
            "Garfield chases mice."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → LikesFish(x)) ::: All cats like fish",
            "Cat(garfield) ::: Garfield is a cat",
            "∀x (Cat(x) → EatsFood(x)) ::: All cats eat food",
            "∀x (LikesFish(x) → EatsFood(x)) ::: If something likes fish, it eats food",
            "IsOrange(garfield) ::: Garfield is orange",
            "∀x (Cat(x) → ChasesMice(x)) ::: All cats chase mice",
            "∃x (Cat(x) ∧ IsOrange(x)) ::: Some cats are orange",
            "∀x (IsOrange(x) → Cat(x)) ::: If something is orange, then it is a cat",
            "∀x (EatsFood(x) → LikesFish(x)) ::: Anything that eats food likes fish",
            "EatsFood(garfield) ::: Garfield eats food",
            "∀x (ChasesMice(x) → Cat(x)) ::: Anything that chases mice is a cat",
            "ChasesMice(garfield) ::: Garfield chases mice"
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "LikesFish(x) ::: x likes fish",
            "EatsFood(x) ::: x eats food",
            "ChasesMice(x) ::: x chases mice",
            "IsOrange(x) ::: x is orange"
        ]
    },
    {
        "premises-NL": [
            "All scientists are researchers.",
            "Some researchers work at universities.",
            "All researchers who work at universities have grants.",
            "Anyone who has a grant publishes papers.",
            "All scientists publish papers.",
            "Anyone who publishes papers is rich or a scientist.",
            "Not all scientists are rich.",
            "Dr. Jones is a scientist.",
            "Dr. Jones is a researcher.",
            "Dr. Jones works at a university.",
            "Dr. Jones has a grant.",
            "Dr. Jones publishes papers."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Researcher(x)) ::: All scientists are researchers.",
            "∃x (Researcher(x) ∧ WorksAtUniversity(x)) ::: Some researchers work at universities.",
            "∀x (Researcher(x) ∧ WorksAtUniversity(x) → HasGrant(x)) ::: All researchers who work at universities have grants.",
            "∀x (HasGrant(x) → PublishesPapers(x)) ::: Anyone who has a grant publishes papers.",
            "∀x (Scientist(x) → PublishesPapers(x)) ::: All scientists publish papers.",
            "∀x (PublishesPapers(x) → (Rich(x) ∨ Scientist(x))) ::: Anyone who publishes papers is rich or a scientist.",
            "¬∀x (Scientist(x) → Rich(x)) ::: Not all scientists are rich.",
            "Scientist(jones) ::: Dr. Jones is a scientist.",
            "Researcher(jones) ::: Dr. Jones is a researcher.",
            "WorksAtUniversity(jones) ::: Dr. Jones works at a university.",
            "HasGrant(jones) ::: Dr. Jones has a grant.",
            "PublishesPapers(jones) ::: Dr. Jones publishes papers."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Researcher(x) ::: x is a researcher",
            "Rich(x) ::: x is rich",
            "WorksAtUniversity(x) ::: x works at a university",
            "HasGrant(x) ::: x has a grant",
            "PublishesPapers(x) ::: x publishes papers"
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled.",
            "All students who study computer science are smart.",
            "Some students are not lazy.",
            "All students who are smart, are not lazy.",
            "All students who are smart study computer science.",
            "If a student takes an exam, they are enrolled.",
            "If a student is enrolled, they are a student.",
            "John is a student.",
            "John studies computer science.",
            "John is smart.",
            "John takes an exam.",
            "Everyone who studies computer science takes an exam.",
            "Everyone who studies computer science is smart.",
            "If John takes an exam, then he is a student and enrolled and not lazy."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x)) ::: All students are enrolled.",
            "∀x (Student(x) ∧ Studies(x, computerScience) → Smart(x)) ::: All students who study computer science are smart.",
            "∃x (Student(x) ∧ ¬Lazy(x)) ::: Some students are not lazy.",
            "∀x (Smart(x) → ¬Lazy(x)) ::: All students who are smart, are not lazy.",
            "∀x (Smart(x) → Studies(x, computerScience)) ::: All students who are smart study computer science.",
            "∀x (TakesExam(x) → Enrolled(x)) ::: If a student takes an exam, they are enrolled.",
            "∀x (Enrolled(x) → Student(x)) ::: If a student is enrolled, they are a student.",
            "Student(john) ::: John is a student.",
            "Studies(john, computerScience) ::: John studies computer science.",
            "Smart(john) ::: John is smart.",
            "TakesExam(john) ::: John takes an exam.",
            "∀x (Studies(x, computerScience) → TakesExam(x)) ::: Everyone who studies computer science takes an exam.",
            "∀x (Studies(x, computerScience) → Smart(x)) ::: Everyone who studies computer science is smart.",
            "∀x (TakesExam(john) → (Student(john) ∧ Enrolled(john) ∧ ¬Lazy(john))) ::: If John takes an exam, then he is a student and enrolled and not lazy."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x, y) ::: x studies y",
            "ComputerScience(x) ::: x is computer science",
            "Lazy(x) ::: x is lazy",
            "Smart(x) ::: x is smart",
            "Enrolled(x) ::: x is enrolled",
            "TakesExam(x) ::: x takes an exam"
        ]
    },
    {
        "premises-NL": [
            "Anyone who works hard can get a high income.",
            "If someone has a high income and saves money, then they can buy a house.",
            "Anyone who has a high income, is rich.",
            "If someone is rich and saves money, they can buy a house.",
            "If someone works hard, they save money.",
            "People with high incomes, either save money or spend money.",
            "If someone saves money, they do not have debt.",
            "Those who are rich do not have debt.",
            "People who work hard have high income.",
            "If someone has debt, they cannot buy a house.",
            "Anyone who has high income either saves or spends.",
            "Someone who has high income and spends money does not save money.",
            "If someone saves money, they will not have debt.",
            "If someone does not have debt, they will buy a house.",
            "People with high income and debt cannot buy a house.",
            "If someone can buy a house, they don't have debt.",
            "If someone saves money and does not have debt, they can buy a house.",
            "Anyone can have a high income if they work hard."
        ],
        "premises-FOL": [
            "∀x (WorksHard(x) → HighIncome(x)) ::: Anyone who works hard can get a high income.",
            "∀x ((HighIncome(x) ∧ SavesMoney(x)) → CanBuyHouse(x)) ::: If someone has a high income and saves money, then they can buy a house.",
            "∀x (HighIncome(x) → IsRich(x)) ::: Anyone who has a high income, is rich.",
            "∀x ((IsRich(x) ∧ SavesMoney(x)) → CanBuyHouse(x)) ::: If someone is rich and saves money, they can buy a house.",
            "∀x (WorksHard(x) → SavesMoney(x)) ::: If someone works hard, they save money.",
            "∀x (HighIncome(x) → (SavesMoney(x) ∨ SpendsMoney(x))) ::: People with high incomes, either save money or spend money.",
            "∀x (SavesMoney(x) → ¬HasDebt(x)) ::: If someone saves money, they do not have debt.",
            "∀x (IsRich(x) → ¬HasDebt(x)) ::: Those who are rich do not have debt.",
            "∀x (WorksHard(x) → HighIncome(x)) ::: People who work hard have high income.",
            "∀x (HasDebt(x) → ¬CanBuyHouse(x)) ::: If someone has debt, they cannot buy a house.",
            "∀x (HighIncome(x) → (SavesMoney(x) ∨ SpendsMoney(x))) ::: Anyone who has high income either saves or spends.",
            "∀x ((HighIncome(x) ∧ SpendsMoney(x)) → ¬SavesMoney(x)) ::: Someone who has high income and spends money does not save money.",
            "∀x (SavesMoney(x) → ¬HasDebt(x)) ::: If someone saves money, they will not have debt.",
            "∀x (¬HasDebt(x) → CanBuyHouse(x)) ::: If someone does not have debt, they will buy a house.",
            "∀x ((HighIncome(x) ∧ HasDebt(x)) → ¬CanBuyHouse(x)) ::: People with high income and debt cannot buy a house.",
            "∀x (CanBuyHouse(x) → ¬HasDebt(x)) ::: If someone can buy a house, they don't have debt.",
            "∀x ((SavesMoney(x) ∧ ¬HasDebt(x)) → CanBuyHouse(x)) ::: If someone saves money and does not have debt, they can buy a house.",
            "∀x (WorksHard(x) → HighIncome(x)) ::: Anyone can have a high income if they work hard."
        ],
        "predicates": [
            "HighIncome(x) ::: x has a high income",
            "SavesMoney(x) ::: x saves money",
            "CanBuyHouse(x) ::: x can buy a house",
            "WorksHard(x) ::: x works hard",
            "IsRich(x) ::: x is rich",
            "SpendsMoney(x) ::: x spends money",
            "HasDebt(x) ::: x has debt"
        ]
    },
    {
        "premises-NL": [
            "All students study hard or like pizza.",
            "Alex is a student.",
            "If someone likes pizza, they don't study hard.",
            "If someone is a student and doesn't like pizza, then they pass the exam.",
            "Alex is a student who enjoys the movie.",
            "If Alex enjoys the movie, then Alex likes pizza.",
            "If someone studies hard, then they pass the exam.",
            "All students who enjoy a movie likes pizza.",
            "Alex is a student",
            "Alex doesn't like pizza.",
            "If someone is a student, they either study hard or enjoys the movie.",
            "If someone enjoys the movie, then they don't study hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (StudyHard(x) ∨ LikesPizza(x))) ::: All students study hard or like pizza.",
            "Student(alex) ::: Alex is a student.",
            "∀x (LikesPizza(x) → ¬StudyHard(x)) ::: If someone likes pizza, they don't study hard.",
            "∀x ((Student(x) ∧ ¬LikesPizza(x)) → PassExam(x)) ::: If someone is a student and doesn't like pizza, then they pass the exam.",
            "Student(alex) ∧ EnjoysMovie(alex) ::: Alex is a student who enjoys the movie.",
            "EnjoysMovie(alex) → LikesPizza(alex) ::: If Alex enjoys the movie, then Alex likes pizza.",
            "∀x (StudyHard(x) → PassExam(x)) ::: If someone studies hard, then they pass the exam.",
            "∀x (Student(x) ∧ EnjoysMovie(x) → LikesPizza(x)) ::: All students who enjoy a movie likes pizza.",
            "Student(alex) ::: Alex is a student",
            "¬LikesPizza(alex) ::: Alex doesn't like pizza.",
            "∀x (Student(x) → (StudyHard(x) ∨ EnjoysMovie(x))) ::: If someone is a student, they either study hard or enjoys the movie.",
            "∀x (EnjoysMovie(x) → ¬StudyHard(x)) ::: If someone enjoys the movie, then they don't study hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudyHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "LikesPizza(x) ::: x likes pizza",
            "EnjoysMovie(x) ::: x enjoys the movie"
        ]
    },
    {
        "premises-NL": [
            "All doctors have medical degrees.",
            "Anyone who has a medical degree and is employed by a hospital is qualified to practice medicine.",
            "Anyone who is qualified to practice medicine cares for patients.",
            "John is a doctor.",
            "Medical school students do not care for patients.",
            "If someone is a doctor, then they attended medical school.",
            "A person can be a doctor if they have a medical degree."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HasMedicalDegree(x)) ::: All doctors have medical degrees.",
            "∀x ((HasMedicalDegree(x) ∧ EmployedByHospital(x)) → QualifiedToPractice(x)) ::: Anyone who has a medical degree and is employed by a hospital is qualified to practice medicine.",
            "∀x (QualifiedToPractice(x) → CareForPatients(x)) ::: Anyone who is qualified to practice medicine cares for patients.",
            "Doctor(john) ::: John is a doctor.",
            "∀x (AttendsMedicalSchool(x) → ¬CareForPatients(x)) ::: Medical school students do not care for patients.",
            "∀x (Doctor(x) → AttendsMedicalSchool(x)) ::: If someone is a doctor, then they attended medical school.",
            "∀x (HasMedicalDegree(x) → Doctor(x)) ::: A person can be a doctor if they have a medical degree."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Patient(x) ::: x is a patient",
            "CareForPatients(x) ::: x cares for patients",
            "HasMedicalDegree(x) ::: x has a medical degree",
            "EmployedByHospital(x) ::: x is employed by a hospital",
            "AttendsMedicalSchool(x) ::: x attends medical school",
            "QualifiedToPractice(x) ::: x is qualified to practice medicine"
        ]
    },
    {
        "premises-NL": [
            "All experts in biology know about cell structure.",
            "Anyone who knows about cell structure understands photosynthesis.",
            "John is an expert in biology.",
            "John studies a plant.",
            "Anyone interested in plants studies them.",
            "If someone has a degree in biology, then they are an expert in biology.",
            "Anyone who reads scientific journals is an expert in biology.",
            "No one who studies an animal studies plants.",
            "All scientists read scientific journals."
        ],
        "premises-FOL": [
            "∀x (ExpertInBiology(x) → KnowsAboutCellStructure(x)) ::: All experts in biology know about cell structure.",
            "∀x (KnowsAboutCellStructure(x) → UnderstandsPhotosynthesis(x)) ::: Anyone who knows about cell structure understands photosynthesis.",
            "ExpertInBiology(john) ::: John is an expert in biology.",
            "StudiesPlant(john) ::: John studies a plant.",
            "∀x (InterestedInPlants(x) → StudiesPlant(x)) ::: Anyone interested in plants studies them.",
            "∀x (HasDegreeInBiology(x) → ExpertInBiology(x)) ::: If someone has a degree in biology, then they are an expert in biology.",
            "∀x (ReadsScientificJournals(x) → ExpertInBiology(x)) ::: Anyone who reads scientific journals is an expert in biology.",
            "∀x (StudiesAnimal(x) → ¬StudiesPlant(x)) ::: No one who studies an animal studies plants.",
            "∀x (IsScientist(x) → ReadsScientificJournals(x)) ::: All scientists read scientific journals."
        ],
        "predicates": [
            "ExpertInBiology(x) ::: x is an expert in biology",
            "StudiesPlant(x) ::: x studies a plant",
            "UnderstandsPhotosynthesis(x) ::: x understands photosynthesis",
            "KnowsAboutCellStructure(x) ::: x knows about cell structure",
            "InterestedInPlants(x) ::: x is interested in plants",
            "HasDegreeInBiology(x) ::: x has a degree in biology",
            "ReadsScientificJournals(x) ::: x reads scientific journals",
            "StudiesAnimal(x) ::: x studies an animal",
            "IsScientist(x) ::: x is a scientist"
        ]
    },
    {
        "premises-NL": [
            "All students attend classes.",
            "Anyone who studies hard reads textbooks.",
            "Anyone who reads textbooks knows the material.",
            "Anyone who knows the material will pass the exam.",
            "John is a student.",
            "John studies hard.",
            "Anyone who skips classes is not diligent.",
            "If someone is diligent, then they do not cheat on exams.",
            "Lazy people skip classes.",
            "Diligent students study hard.",
            "Anyone who cheats on the exam will fail it.",
            "If someone fails the exam, they did not study hard.",
            "Anyone that has homework, studies hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClasses(x)) ::: All students attend classes.",
            "∀x (StudiesHard(x) → ReadsTextbooks(x)) ::: Anyone who studies hard reads textbooks.",
            "∀x (ReadsTextbooks(x) → KnowsMaterial(x)) ::: Anyone who reads textbooks knows the material.",
            "∀x (KnowsMaterial(x) → PassExam(x)) ::: Anyone who knows the material will pass the exam.",
            "Student(john) ::: John is a student.",
            "StudiesHard(john) ::: John studies hard.",
            "∀x (SkipsClasses(x) → ¬IsDiligent(x)) ::: Anyone who skips classes is not diligent.",
            "∀x (IsDiligent(x) → ¬CheatsOnExam(x)) ::: If someone is diligent, then they do not cheat on exams.",
            "∀x (IsLazy(x) → SkipsClasses(x)) ::: Lazy people skip classes.",
            "∀x (Student(x) ∧ IsDiligent(x) → StudiesHard(x)) ::: Diligent students study hard.",
            "∀x (CheatsOnExam(x) → FailsExam(x)) ::: Anyone who cheats on the exam will fail it.",
            "∀x (FailsExam(x) → ¬StudiesHard(x)) ::: If someone fails the exam, they did not study hard.",
            "∀x (HasHomework(x) → StudiesHard(x)) ::: Anyone that has homework, studies hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x will pass the exam",
            "AttendsClasses(x) ::: x attends classes",
            "ReadsTextbooks(x) ::: x reads textbooks",
            "GetsGoodGrades(x) ::: x gets good grades",
            "FailsExam(x) ::: x fails the exam",
            "SkipsClasses(x) ::: x skips classes",
            "IsLazy(x) ::: x is lazy",
            "IsDiligent(x) ::: x is diligent",
            "CheatsOnExam(x) ::: x cheats on the exam",
            "KnowsMaterial(x) ::: x knows material",
            "HasHomework(x) ::: x has homework"
        ]
    },
    {
        "premises-NL": [
            "All doctors are researchers.",
            "Some researchers publish papers.",
            "Anyone who publishes a paper is helpful.",
            "A is a doctor.",
            "B publishes a paper.",
            "A is interested in the research of B.",
            "C is a researcher.",
            "C is a doctor.",
            "D publishes a paper."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Researcher(x)) ::: All doctors are researchers.",
            "∃x (Researcher(x) ∧ PublishesPaper(x)) ::: Some researchers publish papers.",
            "∀x (PublishesPaper(x) → Helpful(x)) ::: Anyone who publishes a paper is helpful.",
            "Doctor(A) ::: A is a doctor.",
            "PublishesPaper(B) ::: B publishes a paper.",
            "InterestedInResearch(A, B) ::: A is interested in the research of B.",
            "Researcher(C) ::: C is a researcher.",
            "Doctor(C) ::: C is a doctor.",
            "PublishesPaper(D) ::: D publishes a paper."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Researcher(x) ::: x is a researcher",
            "Helpful(x) ::: x is helpful",
            "PublishesPaper(x) ::: x publishes a paper",
            "InterestedInResearch(x, y) ::: x is interested in the research of y"
        ]
    },
    {
        "premises-NL": [
            "Anyone who studies will either pass or fail.",
            "Someone who prepares for the exam studies.",
            "A prepares for the exam.",
            "B studies.",
            "C is an exam taker.",
            "D takes an exam.",
            "E studies.",
            "F prepares for the exam.",
            "G prepares for the exam.",
            "H studies.",
            "I will pass."
        ],
        "premises-FOL": [
            "∀x (Studies(x, Exam) → (Pass(x) ∨ Fail(x))) ::: Anyone who studies will either pass or fail.",
            "∃x (Prepares(x, Exam) → Studies(x, Exam)) ::: Someone who prepares for the exam studies.",
            "Prepares(A, Exam) ::: A prepares for the exam.",
            "Studies(B, Exam) ::: B studies.",
            "TakesExam(C) ::: C is an exam taker.",
            "TakesExam(D) ::: D takes an exam.",
            "Studies(E, Exam) ::: E studies.",
            "Prepares(F, Exam) ::: F prepares for the exam.",
            "Prepares(G, Exam) ::: G prepares for the exam.",
            "Studies(H, Exam) ::: H studies.",
            "Pass(I) ::: I will pass."
        ],
        "predicates": [
            "TakesExam(x) ::: x takes an exam",
            "Studies(x, y) ::: x studies subject y",
            "Pass(x) ::: x passes",
            "Fail(x) ::: x fails",
            "Prepares(x, y) ::: x prepares for y"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All surgeons treat patients.",
            "If someone treats patients, then they help patients.",
            "Some doctors are surgeons.",
            "No specialists are surgeons.",
            "Some doctors are specialists.",
            "A surgeon is not a specialist.",
            "If someone is a doctor, then they are either a surgeon or a specialist.",
            "Being a specialist implies helping patients."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Surgeon(x) → Treats(x, y)) ::: All surgeons treat patients.",
            "∀x (Treats(x, y) → HelpsPatients(x)) ::: If someone treats patients, then they help patients.",
            "∃x (Doctor(x) ∧ Surgeon(x)) ::: Some doctors are surgeons.",
            "∀x (¬Specialist(x) ∨ ¬Surgeon(x)) ::: No specialists are surgeons.",
            "∃x (Doctor(x) ∧ Specialist(x)) ::: Some doctors are specialists.",
            "∀x (Surgeon(x) → ¬Specialist(x)) ::: A surgeon is not a specialist.",
            "∀x (Doctor(x) → (Surgeon(x) ∨ Specialist(x))) ::: If someone is a doctor, then they are either a surgeon or a specialist.",
            "∀x (Specialist(x) → HelpsPatients(x)) ::: Being a specialist implies helping patients."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "Patient(x) ::: x is a patient",
            "HelpsPatients(x) ::: x helps patients",
            "Treats(x, y) ::: x treats y",
            "Specialist(x) ::: x is a specialist"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard pass their exams.",
            "All students who pass exams attend classes.",
            "If someone attends classes, they get good grades.",
            "If someone gets good grades, they are smart.",
            "All smart students read books.",
            "Someone studies hard.",
            "All students either study hard or don't attend classes.",
            "If someone reads books, they either study hard or are smart.",
            "A student who gets good grades studies hard.",
            "Not all students are smart.",
            "All students who don't attend classes don't get good grades."
        ],
        "premises-FOL": [
            "∀x (StudiesHard(x) → PassExams(x)) ::: All students who study hard pass their exams.",
            "∀x (PassExams(x) → AttendsClasses(x)) ::: All students who pass exams attend classes.",
            "∀x (AttendsClasses(x) → GetsGoodGrades(x)) ::: If someone attends classes, they get good grades.",
            "∀x (GetsGoodGrades(x) → IsSmart(x)) ::: If someone gets good grades, they are smart.",
            "∀x (IsSmart(x) → ReadsBooks(x)) ::: All smart students read books.",
            "∃x StudiesHard(x) ::: Someone studies hard.",
            "∀x (Student(x) → (StudiesHard(x) ∨ ¬AttendsClasses(x))) ::: All students either study hard or don't attend classes.",
            "∀x (ReadsBooks(x) → (StudiesHard(x) ∨ IsSmart(x))) ::: If someone reads books, they either study hard or are smart.",
            "∀x (GetsGoodGrades(x) → StudiesHard(x)) ::: A student who gets good grades studies hard.",
            "∃x ¬IsSmart(x) ::: Not all students are smart.",
            "∀x (¬AttendsClasses(x) → ¬GetsGoodGrades(x)) ::: All students who don't attend classes don't get good grades."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExams(x) ::: x passes exams",
            "AttendsClasses(x) ::: x attends classes",
            "GetsGoodGrades(x) ::: x gets good grades",
            "IsSmart(x) ::: x is smart",
            "ReadsBooks(x) ::: x reads books"
        ]
    },
    {
        "premises-NL": [
            "All people who invest in the stock market buy stocks.",
            "All people who buy stocks own stocks.",
            "All people who own stocks sell stocks.",
            "All people who sell stocks gain profit.",
            "If someone knows finance, they understand the market.",
            "If someone understands the market and has money, they invest in the stock market.",
            "Someone has money.",
            "If someone is rich they invest in the stock market.",
            "If someone invests in the stock market, they know finance.",
            "People who gains profit are rich.",
            "Anyone who is rich, succeeds",
            "People who succeeds gain profit."
        ],
        "premises-FOL": [
            "∀x (Invests(x, stock) → BuysStocks(x)) ::: All people who invest in the stock market buy stocks.",
            "∀x (BuysStocks(x) → OwnsStocks(x)) ::: All people who buy stocks own stocks.",
            "∀x (OwnsStocks(x) → SellsStocks(x)) ::: All people who own stocks sell stocks.",
            "∀x (SellsStocks(x) → GainsProfit(x)) ::: All people who sell stocks gain profit.",
            "∀x (KnowsFinance(x) → UnderstandsMarket(x)) ::: If someone knows finance, they understand the market.",
            "∀x (UnderstandsMarket(x) ∧ HasMoney(x) → Invests(x, stock)) ::: If someone understands the market and has money, they invest in the stock market.",
            "∃x HasMoney(x) ::: Someone has money.",
            "∀x (IsRich(x) → Invests(x, stock)) ::: If someone is rich they invest in the stock market.",
            "∀x (Invests(x, stock) → KnowsFinance(x)) ::: If someone invests in the stock market, they know finance.",
            "∀x (GainsProfit(x) → IsRich(x)) ::: People who gains profit are rich.",
            "∀x (IsRich(x) → Succeeds(x)) ::: Anyone who is rich, succeeds",
            "∀x (Succeeds(x) → GainsProfit(x)) ::: People who succeeds gain profit."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Invests(x, y) ::: x invests in y",
            "GainsProfit(x) ::: x gains profit",
            "OwnsStocks(x) ::: x owns stocks",
            "StockMarket(stock) ::: stock is the stock market",
            "KnowsFinance(x) ::: x knows finance",
            "IsRich(x) ::: x is rich",
            "BuysStocks(x) ::: x buys stocks",
            "SellsStocks(x) ::: x sells stocks",
            "HasMoney(x) ::: x has money",
            "UnderstandsMarket(x) ::: x understands the market",
            "Succeeds(x) ::: x succeeds"
        ]
    },
    {
        "premises-NL": [
            "All doctors study medicine.",
            "All people who study medicine pass exams.",
            "All people who pass exams are licensed.",
            "All licensed people work in a hospital.",
            "All people who work in a hospital treat patients.",
            "All doctors are licensed.",
            "If someone studies medicine, then they have medical knowledge.",
            "Doctors diagnose diseases.",
            "If someone is a specialist, then they have medical knowledge.",
            "If someone diagnoses a disease they also prescribe medication.",
            "Someone helps people.",
            "If someone prescribes medication, then they know drugs.",
            "If someone knows drugs, they can diagnose diseases."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → StudiesMedicine(x)) ::: All doctors study medicine.",
            "∀x (StudiesMedicine(x) → PassesExams(x)) ::: All people who study medicine pass exams.",
            "∀x (PassesExams(x) → IsLicensed(x)) ::: All people who pass exams are licensed.",
            "∀x (IsLicensed(x) → WorksInHospital(x)) ::: All licensed people work in a hospital.",
            "∀x (WorksInHospital(x) → TreatsPatients(x)) ::: All people who work in a hospital treat patients.",
            "∀x (Doctor(x) → IsLicensed(x)) ::: All doctors are licensed.",
            "∀x (StudiesMedicine(x) → HasMedicalKnowledge(x)) ::: If someone studies medicine, then they have medical knowledge.",
            "∀x ∃y (Doctor(x) → DiagnosesDisease(x, y)) ::: Doctors diagnose diseases.",
            "∀x (IsSpecialist(x) → HasMedicalKnowledge(x)) ::: If someone is a specialist, then they have medical knowledge.",
            "∀x ∀y (DiagnosesDisease(x, y) → PrescribesMedication(x, y)) ::: If someone diagnoses a disease they also prescribe medication.",
            "∃x HelpsPeople(x) ::: Someone helps people.",
            "∀x ∀y (PrescribesMedication(x, y) → KnowsDrugs(x)) ::: If someone prescribes medication, then they know drugs.",
            "∀x ∀y (KnowsDrugs(x) → DiagnosesDisease(x, y)) ::: If someone knows drugs, they can diagnose diseases."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Patient(y) ::: y is a patient",
            "HasMedicalKnowledge(x) ::: x has medical knowledge",
            "TreatsPatients(x) ::: x treats patients",
            "StudiesMedicine(x) ::: x studies medicine",
            "PassesExams(x) ::: x passes exams",
            "IsLicensed(x) ::: x is licensed",
            "WorksInHospital(x) ::: x works in a hospital",
            "PrescribesMedication(x, y) ::: x prescribes medication to y",
            "DiagnosesDisease(x, y) ::: x diagnoses disease of y",
            "IsSpecialist(x) ::: x is a specialist",
            "HelpsPeople(x) ::: x helps people",
            "KnowsDrugs(x) ::: x knows drugs"
        ]
    },
    {
        "premises-NL": [
            "All students are either diligent or lazy.",
            "Some students study hard.",
            "All students who study hard are diligent.",
            "There are exams.",
            "Every diligent student passes every exam.",
            "If a student passes every exam, then they pass all exams.",
            "Some students are students."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Diligent(x) ∨ ¬Diligent(x))) ::: All students are either diligent or not diligent.",
            "∃x (Student(x) ∧ ¬Diligent(x)) ::: Some students are not diligent.",
            "∀x (¬Diligent(x) → ¬Student(x)) ::: All students are diligent.",
            "∃x Exam(x) ::: There exists an exam.",
            "∀x ∀y ((Diligent(x) ∧ Exam(y)) → PassExam(x, y)) ::: Every diligent student passes every exam.",
            "∀x (PassExam(x,y) → PassAllExams(x)) ::: If a student passes every exam, they pass all exams.",
            "∃x Student(x) ::: Some students are students."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Diligent(x) ::: x is diligent",
            "PassExam(x, y) ::: x passes exam y",
            "Exam(y) ::: y is an exam",
            "PassAllExams(x) ::: x passes all exams"
        ]
    },
    {
        "premises-NL": [
            "All students are diligent.",
            "Some students are successful.",
            "If someone is both a student and diligent, they are successful.",
            "If someone is a student, they are diligent.",
            "If someone is diligent and a student, they are successful.",
            "If someone is successful and a student, they are diligent."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Diligence(x)) ::: All students are diligent.",
            "∃x (Student(x) ∧ Successful(x)) ::: Some students are successful.",
            "∀x ((Student(x) ∧ Diligence(x)) → Successful(x)) ::: If someone is both a student and diligent, they are successful.",
            "∀x (Student(x) → Diligence(x)) ::: If someone is a student, they are diligent.",
            "∀x ((Diligence(x) ∧ Student(x)) → Successful(x)) ::: If someone is diligent and a student, they are successful.",
            "∀x ((Successful(x) ∧ Student(x)) → Diligence(x)) ::: If someone is successful and a student, they are diligent."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Diligence(x) ::: x is diligent.",
            "Successful(x) ::: x is successful."
        ]
    },
    {
        "premises-NL": [
            "All specialists are doctors.",
            "Some doctors are poor.",
            "No one is both rich and poor.",
            "If someone is a doctor, they are either a specialist or poor.",
            "Doctors are specialists or poor people",
            "Some doctors are not rich.",
            "Every doctor is either a specialist or poor."
        ],
        "premises-FOL": [
            "∀x (Specialist(x) → Doctor(x)) ::: All specialists are doctors.",
            "∃x (Doctor(x) ∧ ¬Rich(x)) ::: Some doctors are poor.",
            "∀x ¬(Rich(x) ∧ ¬Rich(x)) ::: No one is both rich and poor.",
            "∀x (Doctor(x) → (Specialist(x) ∨ ¬Rich(x))) ::: If someone is a doctor, they are either a specialist or poor.",
            "∀x (Doctor(x) → (Specialist(x) ∨ ¬Rich(x))) ::: Doctors are specialists or poor people",
            "∃x (Doctor(x) ∧ ¬Rich(x)) ::: Some doctors are not rich.",
            "∀x (Doctor(x) → (Specialist(x) ∨ ¬Rich(x))) ::: Every doctor is either a specialist or poor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Specialist(x) ::: x is a specialist.",
            "Rich(x) ::: x is rich."
        ]
    },
    {
        "premises-NL": [
            "All athletes are players.",
            "Everyone who enjoys games loves to play.",
            "If someone is a player, they enjoy games.",
            "Anyone who is an athlete is a player.",
            "Athletes enjoy games.",
            "If someone is an athlete, then they enjoy games.",
            "Someone is an athlete and loves to play.",
            "If someone is a player, they love to play."
        ],
        "premises-FOL": [
            "∀x (Athlete(x) → Player(x)) ::: All athletes are players.",
            "∀x (EnjoysGames(x) → LovesToPlay(x)) ::: Everyone who enjoys games loves to play.",
            "∀x (Player(x) → EnjoysGames(x)) ::: If someone is a player, they enjoy games.",
            "∀x (Athlete(x) → Player(x)) ::: Anyone who is an athlete is a player.",
            "∀x (Athlete(x) → EnjoysGames(x)) ::: Athletes enjoy games.",
            "∀x (Athlete(x) → EnjoysGames(x)) ::: If someone is an athlete, then they enjoy games.",
            "∃x (Athlete(x) ∧ LovesToPlay(x)) ::: Someone is an athlete and loves to play.",
            "∀x (Player(x) → LovesToPlay(x)) ::: If someone is a player, they love to play."
        ],
        "predicates": [
            "Athlete(x) ::: x is an athlete.",
            "LovesToPlay(x) ::: x loves to play.",
            "Player(x) ::: x is a player.",
            "EnjoysGames(x) ::: x enjoys games."
        ]
    },
    {
        "premises-NL": [
            "All doctors study medicine.",
            "All doctors love helping people.",
            "If someone studies medicine and loves helping people, they are a helper.",
            "If someone is a doctor, they help people.",
            "Some doctors have patients.",
            "Every doctor is a helper.",
            "If someone studies medicine, they are a doctor.",
            "If someone is a helper they love helping people.",
            "All doctors are both doctors and helpers.",
            "Some people are doctors."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → StudiesMedicine(x)) ::: All doctors study medicine.",
            "∀x (Doctor(x) → LovesHelpingPeople(x)) ::: All doctors love helping people.",
            "∀x (StudiesMedicine(x) ∧ LovesHelpingPeople(x) → Helper(x)) ::: If someone studies medicine and loves helping people, they are a helper.",
            "∀x (Doctor(x) → Helper(x)) ::: If someone is a doctor, they help people.",
            "∃x ∃y (Doctor(x) ∧ Patient(y)) ::: Some doctors have patients.",
            "∀x (Doctor(x) → Helper(x)) ::: Every doctor is a helper.",
            "∀x (StudiesMedicine(x) → Doctor(x)) ::: If someone studies medicine, they are a doctor.",
            "∀x (Helper(x) → LovesHelpingPeople(x)) ::: If someone is a helper they love helping people.",
            "∀x (Doctor(x) → (Doctor(x) ∧ Helper(x))) ::: All doctors are both doctors and helpers.",
            "∃x Doctor(x) ::: Some people are doctors."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "StudiesMedicine(x) ::: x studies medicine.",
            "LovesHelpingPeople(x) ::: x loves helping people.",
            "Helper(x) ::: x is a helper.",
            "Patient(y) ::: y is a patient."
        ]
    },
    {
        "premises-NL": [
            "If John and Mary are students and study together, then they must be friends.",
            "If John and Mary take the same courses, they are friends.",
            "If John and Mary are friends, they will study together.",
            "John is a student.",
            "Mary is a student.",
            "If John and Mary take the same courses, they attend the same classes.",
            "If people attend the same class, they take the same courses.",
            "If John and Mary study together, then they attend the same classes.",
            "John likes reading.",
            "If someone likes reading, they study together.",
            "The same courses implies same lecturers.",
            "If someone takes the same course, they will read the same books.",
            "If someone reads the same books, then they study together.",
            "If John passed the exam, he will study hard.",
            "Courses can have lecturers.",
            "If someone passes the exam, they attend classes."
        ],
        "premises-FOL": [
            "∀x ∀y ((Student(x) ∧ Student(y) ∧ StudyTogether(x, y)) → Friend(x, y)) ::: If John and Mary are students and study together, then they must be friends.",
            "∀x ∀y (SameCourse(x, y) → Friend(x, y)) ::: If John and Mary take the same courses, they are friends.",
            "∀x ∀y (Friend(x, y) → StudyTogether(x, y)) ::: If John and Mary are friends, they will study together.",
            "Student(john) ::: John is a student.",
            "Student(mary) ::: Mary is a student.",
            "∀x ∀y (SameCourse(x, y) → AttendClass(x, y)) ::: If John and Mary take the same courses, they attend the same classes.",
            "∀x ∀y (AttendClass(x, y) → SameCourse(x, y)) ::: If people attend the same class, they take the same courses.",
            "∀x ∀y (StudyTogether(x, y) → AttendClass(x, y)) ::: If John and Mary study together, then they attend the same classes.",
            "∀x (Likes(x, reading) ∧ StudyTogether(x, y)) ::: John likes reading.",
            "∀x ∀y (Likes(x, y) → StudyTogether(x, y)) ::: If someone likes reading, they study together.",
            "∀x ∀y (SameCourse(x, y) → SameLecturer(x, y)) ::: The same courses implies same lecturers.",
            "∀x ∀y (SameCourse(x, y) → ReadsBook(x, y)) ::: If someone takes the same course, they will read the same books.",
            "∀x ∀y (ReadsBook(x, y) → StudyTogether(x, y)) ::: If someone reads the same books, then they study together.",
            "∀x (PassedExam(x, y) → StudyHard(x)) ::: If John passed the exam, he will study hard.",
            "∃x Course(x) ::: Courses can have lecturers.",
            "∀x ∀y (PassedExam(x, y) → AttendClass(x, y)) ::: If someone passes the exam, they attend classes."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudyTogether(x, y) ::: x and y study together.",
            "SameCourse(x, y) ::: x and y take the same courses.",
            "Likes(x, y) ::: x likes y.",
            "Friend(x, y) ::: x is a friend of y.",
            "AttendClass(x, y) ::: x attends class y.",
            "Course(x) ::: x is a course.",
            "Lecturer(x, y) ::: x is a lecturer of y.",
            "Knows(x, y) ::: x knows y.",
            "PassedExam(x, y) ::: x passed exam for course y.",
            "Teaches(x, y) ::: x teaches y.",
            "ReadsBook(x, y) ::: x reads book y."
        ]
    },
    {
        "premises-NL": [
            "All researchers are professors.",
            "No professors are administrators.",
            "Some researchers grant funding to students.",
            "All students receive funding.",
            "If someone grants funding, then that person is a researcher.",
            "If someone is a professor, they don't receive funding.",
            "If someone is an administrator, they don't grant funding.",
            "There is a researcher.",
            "All administrators are professors."
        ],
        "premises-FOL": [
            "∀x (Researcher(x) → Professor(x)) ::: All researchers are professors.",
            "∀x (Professor(x) → ¬Administrator(x)) ::: No professors are administrators.",
            "∃x ∃y (Researcher(x) ∧ GrantsFunding(x, y) ∧ Student(y)) ::: Some researchers grant funding to students.",
            "∀x (Student(x) → ReceivesFunding(x)) ::: All students receive funding.",
            "∀x (GrantsFunding(x, y) → Researcher(x)) ::: If someone grants funding, then that person is a researcher.",
            "∀x (Professor(x) → ¬ReceivesFunding(x)) ::: If someone is a professor, they don't receive funding.",
            "∀x (Administrator(x) → ¬GrantsFunding(x, y)) ::: If someone is an administrator, they don't grant funding.",
            "∃x Researcher(x) ::: There is a researcher.",
            "∀x (Administrator(x) → Professor(x)) ::: All administrators are professors."
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher.",
            "Professor(x) ::: x is a professor.",
            "Administrator(x) ::: x is an administrator.",
            "GrantsFunding(x, y) ::: x grants funding to y.",
            "Student(x) ::: x is a student.",
            "ReceivesFunding(x) ::: x receives funding."
        ]
    },
    {
        "premises-NL": [
            "All programmers write efficient code.",
            "Anyone who uses Java is a programmer.",
            "Anyone who uses Python is a programmer.",
            "Anyone who knows data structures is a programmer.",
            "John uses Java.",
            "John works on a specific project.",
            "All programmers work on specific projects.",
            "Some senior programmers know data structures.",
            "Senior programmers use Python.",
            "If someone is a programmer, they are senior."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → WritesEfficientCode(x)) ::: All programmers write efficient code.",
            "∀x (UsesJava(x) → Programmer(x)) ::: Anyone who uses Java is a programmer.",
            "∀x (UsesPython(x) → Programmer(x)) ::: Anyone who uses Python is a programmer.",
            "∀x (KnowsDataStructures(x) → Programmer(x)) ::: Anyone who knows data structures is a programmer.",
            "UsesJava(john) ::: John uses Java.",
            "∃y WorksOnProject(john, y) ::: John works on a specific project.",
            "∀x ∃y (Programmer(x) → WorksOnProject(x, y)) ::: All programmers work on specific projects.",
            "∃x (IsSenior(x) ∧ KnowsDataStructures(x)) ::: Some senior programmers know data structures.",
            "∀x (IsSenior(x) → UsesPython(x)) ::: Senior programmers use Python.",
            "∀x (Programmer(x) → IsSenior(x)) ::: If someone is a programmer, they are senior."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer.",
            "WritesEfficientCode(x) ::: x writes efficient code.",
            "UsesJava(x) ::: x uses Java.",
            "UsesPython(x) ::: x uses Python.",
            "KnowsDataStructures(x) ::: x knows data structures.",
            "WorksOnProject(x, y) ::: x works on project y.",
            "Project(y) ::: y is a project.",
            "IsSenior(x) ::: x is senior."
        ]
    },
    {
        "premises-NL": [
            "All scientists are intelligent.",
            "Some intelligent people are not artists.",
            "All scientists read books.",
            "Some people who read books write code.",
            "Anyone who loves music plays guitar.",
            "John is a scientist.",
            "John teaches students.",
            "All scientists publish papers.",
            "Anyone who publishes papers knows math.",
            "No artists know math.",
            "If someone is a scientist, then they reads books."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Intelligent(x)) ::: All scientists are intelligent.",
            "∃x (Intelligent(x) ∧ ¬Artist(x)) ::: Some intelligent people are not artists.",
            "∀x (Scientist(x) → ReadsBooks(x)) ::: All scientists read books.",
            "∃x ∃y (ReadsBooks(x) ∧ WritesCode(y)) ::: Some people who read books write code.",
            "∀x (LovesMusic(x) → PlaysGuitar(x)) ::: Anyone who loves music plays guitar.",
            "Scientist(john) ::: John is a scientist.",
            "∃y Teaches(john, y) ∧ Student(y) ::: John teaches students.",
            "∀x (Scientist(x) → PublishesPapers(x)) ::: All scientists publish papers.",
            "∀x (PublishesPapers(x) → KnowsMath(x)) ::: Anyone who publishes papers knows math.",
            "∀x (Artist(x) → ¬KnowsMath(x)) ::: No artists know math.",
            "∀x (Scientist(x) → ReadsBooks(x)) ::: If someone is a scientist, then they reads books."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist.",
            "Intelligent(x) ::: x is intelligent.",
            "Artist(x) ::: x is an artist.",
            "ReadsBooks(x) ::: x reads books.",
            "WritesCode(x) ::: x writes code.",
            "LovesMusic(x) ::: x loves music.",
            "PlaysGuitar(x) ::: x plays guitar.",
            "Teaches(x, y) ::: x teaches y.",
            "Student(y) ::: y is a student.",
            "PublishesPapers(x) ::: x publishes papers.",
            "KnowsMath(x) ::: x knows math."
        ]
    },
    {
        "premises-NL": [
            "All mammals are warm-blooded.",
            "No reptiles are warm-blooded.",
            "All reptiles live on land.",
            "All reptiles have scales.",
            "Some animals eat meat.",
            "All reptiles lay eggs.",
            "All cold-blooded animals are reptiles.",
            "Some dangerous animals are reptiles.",
            "All aquatic animals are not reptiles.",
            "John is a mammal.",
            "No animals who hunts in packs are reptiles.",
            "All animals that run fast eat meat."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → WarmBlooded(x)) ::: All mammals are warm-blooded.",
            "∀x (Reptile(x) → ¬WarmBlooded(x)) ::: No reptiles are warm-blooded.",
            "∀x (Reptile(x) → LivesOnLand(x)) ::: All reptiles live on land.",
            "∀x (Reptile(x) → HasScales(x)) ::: All reptiles have scales.",
            "∃x EatsMeat(x) ::: Some animals eat meat.",
            "∀x (Reptile(x) → LaysEggs(x)) ::: All reptiles lay eggs.",
            "∀x (IsColdBlooded(x) → Reptile(x)) ::: All cold-blooded animals are reptiles.",
            "∃x (IsDangerous(x) ∧ Reptile(x)) ::: Some dangerous animals are reptiles.",
            "∀x (IsAquatic(x) → ¬Reptile(x)) ::: All aquatic animals are not reptiles.",
            "Mammal(john) ::: John is a mammal.",
            "∀x (HuntsInPacks(x) → ¬Reptile(x)) ::: No animals who hunts in packs are reptiles.",
            "∀x (RunsFast(x) → EatsMeat(x)) ::: All animals that run fast eat meat."
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal.",
            "WarmBlooded(x) ::: x is warm-blooded.",
            "Reptile(x) ::: x is a reptile.",
            "LivesOnLand(x) ::: x lives on land.",
            "HasScales(x) ::: x has scales.",
            "EatsMeat(x) ::: x eats meat.",
            "LaysEggs(x) ::: x lays eggs.",
            "IsColdBlooded(x) ::: x is cold-blooded.",
            "IsDangerous(x) ::: x is dangerous.",
            "IsAquatic(x) ::: x is aquatic.",
            "HuntsInPacks(x) ::: x hunts in packs.",
            "RunsFast(x) ::: x runs fast."
        ]
    },
    {
        "premises-NL": [
            "All mammals are warm-blooded.",
            "Fido is a mammal.",
            "Fido is a dog."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → WarmBlooded(x)) ::: All mammals are warm-blooded",
            "Mammal(fido) ::: Fido is a mammal",
            "Dog(fido) ::: Fido is a dog"
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal",
            "WarmBlooded(x) ::: x is warm-blooded",
            "Fido is a dog"
        ]
    },
    {
        "premises-NL": [
            "All athletes are fit.",
            "Anyone who is fit is strong.",
            "If someone is an athlete, they eat well.",
            "Someone is an athlete.",
            "Someone eats well.",
            "Anyone who is strong can compete"
        ],
        "premises-FOL": [
            "∀x (Athlete(x) → Fit(x)) ::: All athletes are fit",
            "∀x (Fit(x) → Strong(x)) ::: Anyone who is fit is strong",
            "∀x (Athlete(x) → EatsWell(x)) ::: If someone is an athlete, they eat well",
            "∃x Athlete(x) ::: Someone is an athlete",
            "∃x EatsWell(x) ::: Someone eats well",
            "∀x (Strong(x) → CanCompete(x)) ::: Anyone who is strong can compete"
        ],
        "predicates": [
            "Athlete(x) ::: x is an athlete",
            "Fit(x) ::: x is fit",
            "EatsWell(x) ::: x eats well",
            "Strong(x) ::: x is strong"
        ]
    },
    {
        "premises-NL": [
            "Everyone holds a degree.",
            "Every degree is not a job.",
            "Anyone who holds a degree, also studies it.",
            "If someone studies a degree and is qualified for a job, then they apply for that job.",
            "If someone applies for a job, then they don't get it.",
            "If someone gets a job, they also hold it.",
            "If someone holds a job, they teaches it.",
            "Anyone who teaches a job, is not qualified for it.",
            "If someone holds a degree, then they don't hold a job or applies for a job.",
            "John holds degreeA."
        ],
        "premises-FOL": [
            "∀x ∃y (Person(x) → HoldsDegree(x, y)) ::: Everyone holds a degree.",
            "∀x ∀y (Degree(x) → ¬Job(y)) ::: Every degree is not a job.",
            "∀x ∀y (HoldsDegree(x, y) → Studies(x, y)) ::: Anyone who holds a degree, also studies it.",
            "∀x ∀y (Studies(x, y) ∧ QualifiedFor(x, y) → AppliesFor(x, y)) ::: If someone studies a degree and is qualified for a job, then they apply for that job.",
            "∀x ∀y (AppliesFor(x, y) → ¬Gets(x, y)) ::: If someone applies for a job, then they don't get it.",
            "∀x ∀y (Gets(x, y) → HoldsJob(x, y)) ::: If someone gets a job, they also hold it.",
            "∀x ∀y (HoldsJob(x, y) → Teaches(x, y)) ::: If someone holds a job, they teaches it.",
            "∀x ∀y (Teaches(x, y) → ¬QualifiedFor(x, y)) ::: Anyone who teaches a job, is not qualified for it.",
            "∀x ∀y (HoldsDegree(x, y) → (¬HoldsJob(x, y) ∨ AppliesFor(x, y))) ::: If someone holds a degree, then they don't hold a job or applies for a job.",
            "HoldsDegree(John, degreeA) ::: John holds degreeA."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "HoldsDegree(x, y) ::: x holds degree y",
            "HoldsJob(x, y) ::: x holds job y",
            "Studies(x, y) ::: x studies y",
            "Degree(y) ::: y is a degree",
            "Job(y) ::: y is a job",
            "QualifiedFor(x, y) ::: x is qualified for y",
            "AppliesFor(x, y) ::: x applies for y",
            "Gets(x, y) ::: x gets y",
            "Teaches(x, y) ::: x teaches y"
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "Alex is a student.",
            "If someone is smart, they study.",
            "If someone studies, they will pass.",
            "Alex is smart.",
            "If Alex studies, then Alex gets an A.",
            "Alex studies.",
            "Someone who is not smart won't pass.",
            "If someone is a student, then they study.",
            "Students like to learn.",
            "If Alex gets an A, he passes."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "Student(alex) ::: Alex is a student.",
            "∀x (Smart(x) → Studies(x)) ::: If someone is smart, they study.",
            "∀x (Studies(x) → Passes(x)) ::: If someone studies, they will pass.",
            "Smart(alex) ::: Alex is smart.",
            "Studies(alex) → GetsA(alex) ::: If Alex studies, then Alex gets an A.",
            "Studies(alex) ::: Alex studies.",
            "∀x (¬Smart(x) → ¬Passes(x)) ::: Someone who is not smart won't pass.",
            "∀x (Student(x) → Studies(x)) ::: If someone is a student, then they study.",
            "∀x (Student(x) → LikesLearning(x)) ::: Students like to learn.",
            "GetsA(alex) → Passes(alex) ::: If Alex gets an A, he passes."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "Passes(x) ::: x passes",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All students either like math or science.",
            "If someone likes math, they study math.",
            "If someone likes science, they study science.",
            "Sarah is a student.",
            "Sarah likes math."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (LikesMath(x) ∨ LikesScience(x))) ::: All students either like math or science.",
            "∀x (LikesMath(x) → StudiesMath(x)) ::: If someone likes math, they study math.",
            "∀x (LikesScience(x) → StudiesScience(x)) ::: If someone likes science, they study science.",
            "Student(sarah) ::: Sarah is a student.",
            "LikesMath(sarah) ::: Sarah likes math."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesMath(x) ::: x studies math",
            "StudiesScience(x) ::: x studies science",
            "LikesMath(x) ::: x likes math",
            "Studies(x, y) ::: x studies y"
        ]
    },
    {
        "premises-NL": [
            "John has a pet.",
            "All of John's pets are either cats or dogs.",
            "Cats are friendly.",
            "If something is friendly, then it makes its owner happy.",
            "John's dog is not happy.",
            "If an animal is a dog, it is not a cat."
        ],
        "premises-FOL": [
            "∃x Pet(x, john) ::: John has a pet.",
            "∀x (Pet(x, john) → (Cat(x) ∨ Dog(x))) ::: All of John's pets are either cats or dogs.",
            "∀x (Cat(x) → Friendly(x)) ::: Cats are friendly.",
            "∀x (Friendly(x) → IsHappy(john)) ::: If something is friendly, then it makes its owner happy.",
            "¬IsHappy(john) ::: John's dog is not happy.",
            "∀x (Dog(x) → ¬Cat(x)) ::: If an animal is a dog, it is not a cat."
        ],
        "predicates": [
            "Pet(x, y) ::: x is a pet of y",
            "Cat(x) ::: x is a cat",
            "Dog(x) ::: x is a dog",
            "Likes(x, y) ::: x likes y",
            "Friendly(x) ::: x is friendly",
            "IsHappy(x) ::: x is happy"
        ]
    },
    {
        "premises-NL": [
            "All mammals are animals.",
            "All mammals are warm-blooded.",
            "Every animal that eats meat is a carnivore.",
            "Every mammal has fur.",
            "If an animal lives in a forest, it is a carnivore.",
            "If an animal has claws, then it eats meat.",
            "If an animal is a carnivore, it eats meat.",
            "All animals are either mammals or live in a forest.",
            "All animals are either carnivores or have fur.",
            "All animals that hunt are carnivores.",
            "All animals that eat meat are either carnivores or have claws.",
            "All animals are either nocturnal or not nocturnal.",
            "Some animals are mammals.",
            "Some animals hunt.",
            "All mammals are not nocturnal.",
            "All animals are carnivores or mammals."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → Animal(x)) ::: All mammals are animals.",
            "∀x (Mammal(x) → IsWarmBlooded(x)) ::: All mammals are warm-blooded.",
            "∀x (EatsMeat(x) → IsCarnivore(x)) ::: Every animal that eats meat is a carnivore.",
            "∀x (Mammal(x) → HasFur(x)) ::: Every mammal has fur.",
            "∀x (LivesInForest(x) → IsCarnivore(x)) ::: If an animal lives in a forest, it is a carnivore.",
            "∀x (HasClaws(x) → EatsMeat(x)) ::: If an animal has claws, then it eats meat.",
            "∀x (IsCarnivore(x) → EatsMeat(x)) ::: If an animal is a carnivore, it eats meat.",
            "∀x (Animal(x) → (Mammal(x) ∨ LivesInForest(x))) ::: All animals are either mammals or live in a forest.",
            "∀x (Animal(x) → (IsCarnivore(x) ∨ HasFur(x))) ::: All animals are either carnivores or have fur.",
            "∀x ∀y (Hunts(x, y) → IsCarnivore(x)) ::: All animals that hunt are carnivores.",
            "∀x (EatsMeat(x) → (IsCarnivore(x) ∨ HasClaws(x))) ::: All animals that eat meat are either carnivores or have claws.",
            "∀x (Animal(x) → (IsNocturnal(x) ∨ ¬IsNocturnal(x))) ::: All animals are either nocturnal or not nocturnal.",
            "∃x (Animal(x) ∧ Mammal(x)) ::: Some animals are mammals.",
            "∃x ∃y Hunts(x,y) ::: Some animals hunt.",
            "∀x (Mammal(x) → ¬IsNocturnal(x)) ::: All mammals are not nocturnal.",
            "∀x (Animal(x) → (IsCarnivore(x) ∨ Mammal(x))) ::: All animals are carnivores or mammals."
        ],
        "predicates": [
            "Animal(x) ::: x is an animal",
            "Mammal(x) ::: x is a mammal",
            "HasFur(x) ::: x has fur",
            "EatsMeat(x) ::: x eats meat",
            "IsCarnivore(x) ::: x is a carnivore",
            "LivesInForest(x) ::: x lives in a forest",
            "IsWarmBlooded(x) ::: x is warm-blooded",
            "HasClaws(x) ::: x has claws",
            "Hunts(x, y) ::: x hunts y",
            "IsNocturnal(x) ::: x is nocturnal"
        ]
    },
    {
        "premises-NL": [
            "All students are either diligent or do not attend classes.",
            "Everyone who studies hard passes the exam.",
            "If someone is diligent and attends classes, they get good grades.",
            "If someone passes the exam, they succeed.",
            "If someone is intelligent and gets good grades, they will succeed.",
            "All students do homework.",
            "Everyone who attends classes studies hard.",
            "All who get good grades are intelligent.",
            "Some students are intelligent.",
            "Everyone who studies hard is diligent.",
            "Anyone who is diligent will pass the exam.",
            "Anyone who does homework will pass the exam.",
            "Some students study hard.",
            "All who pass the exam get good grades.",
            "Anyone who is intelligent will pass the exam.",
            "All intelligent students do homework.",
            "All who succeed are intelligent."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (IsDiligent(x) ∨ ¬AttendsClasses(x))) ::: All students are either diligent or do not attend classes.",
            "∀x (StudiesHard(x) → PassesExam(x)) ::: Everyone who studies hard passes the exam.",
            "∀x (IsDiligent(x) ∧ AttendsClasses(x) → GetsGoodGrades(x)) ::: If someone is diligent and attends classes, they get good grades.",
            "∀x (PassesExam(x) → Succeeds(x)) ::: If someone passes the exam, they succeed.",
            "∀x (IsIntelligent(x) ∧ GetsGoodGrades(x) → Succeeds(x)) ::: If someone is intelligent and gets good grades, they will succeed.",
            "∀x (Student(x) → DoesHomework(x)) ::: All students do homework.",
            "∀x (AttendsClasses(x) → StudiesHard(x)) ::: Everyone who attends classes studies hard.",
            "∀x (GetsGoodGrades(x) → IsIntelligent(x)) ::: All who get good grades are intelligent.",
            "∃x (Student(x) ∧ IsIntelligent(x)) ::: Some students are intelligent.",
            "∀x (StudiesHard(x) → IsDiligent(x)) ::: Everyone who studies hard is diligent.",
            "∀x (IsDiligent(x) → PassesExam(x)) ::: Anyone who is diligent will pass the exam.",
            "∀x (DoesHomework(x) → PassesExam(x)) ::: Anyone who does homework will pass the exam.",
            "∃x (Student(x) ∧ StudiesHard(x)) ::: Some students study hard.",
            "∀x (PassesExam(x) → GetsGoodGrades(x)) ::: All who pass the exam get good grades.",
            "∀x (IsIntelligent(x) → PassesExam(x)) ::: Anyone who is intelligent will pass the exam.",
            "∀x (Student(x) ∧ IsIntelligent(x) → DoesHomework(x)) ::: All intelligent students do homework.",
            "∀x (Succeeds(x) → IsIntelligent(x)) ::: All who succeed are intelligent."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassesExam(x) ::: x passes the exam",
            "AttendsClasses(x) ::: x attends classes",
            "IsIntelligent(x) ::: x is intelligent",
            "Succeeds(x) ::: x succeeds",
            "GetsGoodGrades(x) ::: x gets good grades",
            "DoesHomework(x) ::: x does homework",
            "IsDiligent(x) ::: x is diligent"
        ]
    },
    {
        "premises-NL": [
            "All students are taking the exam.",
            "If someone is taking the exam, then they have a chance to pass.",
            "John is a student.",
            "If John takes the exam, he will pass."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakingExam(x)) ::: All students are taking the exam",
            "∀x (TakingExam(x) → PossibilityPass(x)) ::: If someone is taking the exam, then they have a chance to pass",
            "Student(john) ::: John is a student",
            "TakingExam(john) → PassExam(john) ::: If John takes the exam, he will pass"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PassExam(x) ::: x passed the exam"
        ]
    },
    {
        "premises-NL": [
            "All cats chase mice.",
            "Mittens is a cat.",
            "If something chases a mouse, it is fast.",
            "If something is fast and eats mice, then it is a predator.",
            "All predators eat mice.",
            "Cats are predators.",
            "If something is a predator, it is an animal.",
            "If an animal is a cat, it is a mammal.",
            "Mittens is an animal."
        ],
        "premises-FOL": [
            "∀x ∀y (Cat(x) ∧ Mouse(y) → Chases(x, y)) ::: All cats chase mice",
            "Cat(mittens) ::: Mittens is a cat",
            "∀x ∀y (Chases(x, y) → Fast(x)) ::: If something chases a mouse, it is fast",
            "∀x ∀y (Fast(x) ∧ Eats(x, y) → Predator(x)) ::: If something is fast and eats mice, then it is a predator",
            "∀x ∀y (Predator(x) ∧ Mouse(y) → Eats(x, y)) ::: All predators eat mice",
            "∀x (Cat(x) → Predator(x)) ::: Cats are predators",
            "∀x (Predator(x) → Animal(x)) ::: If something is a predator, it is an animal",
            "∀x (Cat(x) → Mammal(x)) ::: If an animal is a cat, it is a mammal",
            "Animal(mittens) ::: Mittens is an animal"
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Mouse(x) ::: x is a mouse",
            "Chases(x, y) ::: x chases y",
            "Eats(x, y) ::: x eats y"
        ]
    },
    {
        "premises-NL": [
            "All squares are rectangles.",
            "All rectangles have four sides.",
            "Shape1 is a square.",
            "If something is a rectangle, it is a polygon.",
            "If something is a polygon and has four sides, it's a quadrilateral.",
            "All squares are polygons.",
            "Shape2 is a circle.",
            "If a shape is not a circle, it is a shape.",
            "If a shape is a quadrilateral, then it is a geometric shape."
        ],
        "premises-FOL": [
            "∀x (Square(x) → Rectangle(x)) ::: All squares are rectangles",
            "∀x (Rectangle(x) → HasFourSides(x)) ::: All rectangles have four sides",
            "Square(shape1) ::: Shape1 is a square",
            "∀x (Rectangle(x) → Polygon(x)) ::: If something is a rectangle, it is a polygon",
            "∀x (Polygon(x) ∧ HasFourSides(x) → Quadrilateral(x)) ::: If something is a polygon and has four sides, it's a quadrilateral",
            "∀x (Square(x) → Polygon(x)) ::: All squares are polygons",
            "Circle(shape2) ::: Shape2 is a circle",
            "∀x (¬Circle(x) → Shape(x)) ::: If a shape is not a circle, it is a shape",
            "∀x (Quadrilateral(x) → GeometricShape(x)) ::: If a shape is a quadrilateral, then it is a geometric shape"
        ],
        "predicates": [
            "Square(x) ::: x is a square",
            "Rectangle(x) ::: x is a rectangle",
            "HasFourSides(x) ::: x has four sides",
            "Circle(x) ::: x is a circle"
        ]
    },
    {
        "premises-NL": [
            "All engineers work at Google.",
            "Anyone who works at Google likes coding.",
            "Anyone who works at Google likes designing.",
            "Bob is an engineer.",
            "Bob works at Google.",
            "Bob is an engineer who likes coding and designing."
        ],
        "premises-FOL": [
            "∀x (Engineer(x) → WorksAt(x, google)) ::: All engineers work at Google.",
            "∀x (WorksAt(x, google) → LikesCoding(x)) ::: Anyone who works at Google likes coding.",
            "∀x (WorksAt(x, google) → LikesDesigning(x)) ::: Anyone who works at Google likes designing.",
            "Engineer(bob) ::: Bob is an engineer.",
            "WorksAt(bob, google) ::: Bob works at Google.",
            "Engineer(bob) ∧ LikesCoding(bob) ∧ LikesDesigning(bob) ::: Bob is an engineer who likes coding and designing."
        ],
        "predicates": [
            "Engineer(x) ::: x is an engineer.",
            "LikesCoding(x) ::: x likes coding.",
            "LikesDesigning(x) ::: x likes designing.",
            "WorksAt(x, y) ::: x works at y."
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All surgeons can operate.",
            "Anyone who can operate helps patients.",
            "John is a surgeon.",
            "John can operate.",
            "Anyone who helps a patient is a doctor.",
            "Anyone is a doctor or not."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Surgeon(x) → CanOperate(x)) ::: All surgeons can operate.",
            "∀x (CanOperate(x) → HelpsPatient(x)) ::: Anyone who can operate helps patients.",
            "Surgeon(john) ::: John is a surgeon.",
            "CanOperate(john) ::: John can operate.",
            "∀x (HelpsPatient(x) → Doctor(x)) ::: Anyone who helps a patient is a doctor.",
            "∀x (Doctor(x) ∨ ¬Doctor(x)) ::: Anyone is a doctor or not."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Surgeon(x) ::: x is a surgeon.",
            "HelpsPatient(x) ::: x helps patient.",
            "CanOperate(x) ::: x can operate."
        ]
    },
    {
        "premises-NL": [
            "All programmers use a programming language.",
            "All projects require a programming language.",
            "If someone uses a language, and a project requires that language, then that person works on the project.",
            "Alice is a programmer.",
            "Project X requires Python.",
            "Alice uses Python.",
            "Anyone who works on a project contributes to the success of the project.",
            "If a programmer works on a project and uses a language, the project use that language.",
            "If a project uses a language and someone works on the project, this person uses this language."
        ],
        "premises-FOL": [
            "∀x ∃z UsesLanguage(x, z) ::: All programmers use a programming language.",
            "∀y ∃z ProjectRequires(y, z) ::: All projects require a programming language.",
            "∀x ∀y ∀z ((UsesLanguage(x, z) ∧ ProjectRequires(y, z)) → WorksOn(x, y)) ::: If someone uses a language, and a project requires that language, then that person works on the project.",
            "Programmer(alice) ::: Alice is a programmer.",
            "ProjectRequires(projectX, python) ::: Project X requires Python.",
            "UsesLanguage(alice, python) ::: Alice uses Python.",
            "∀x ∀y WorksOn(x, y) → ContributesToSuccess(x, y) ::: Anyone who works on a project contributes to the success of the project.",
            "∀x ∀y ∀z ((WorksOn(x, y) ∧ UsesLanguage(x, z)) → ProjectRequires(y, z)) ::: If a programmer works on a project and uses a language, the project use that language.",
            "∀x ∀y ∀z ((ProjectRequires(y, z) ∧ WorksOn(x, y)) → UsesLanguage(x, z)) ::: If a project uses a language and someone works on the project, this person uses this language."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer.",
            "WorksOn(x, y) ::: x works on project y.",
            "ContributesToSuccess(x, y) ::: x contributes to the success of project y.",
            "UsesLanguage(x, z) ::: x uses language z.",
            "ProjectRequires(y, z) ::: project y requires language z."
        ]
    },
    {
        "premises-NL": [
            "All officers are members of a club.",
            "If a person is an officer and leads a meeting, they attend the meeting.",
            "If a person is a member of a club and pays dues, then they are an active member.",
            "John is an officer of the club.",
            "John leads the monthly meeting.",
            "The club has members.",
            "If a person is an active member and organizes an event, then they are engaged.",
            "If someone participates in an event, they attend the meeting.",
            "Mary is a member of the club.",
            "John pays club dues.",
            "Mary participates in the event."
        ],
        "premises-FOL": [
            "∀x (Officer(x) → MemberOfClub(x)) ::: All officers are members of a club.",
            "∀x ∀y (Officer(x) ∧ LeadsMeeting(x, y) → AttendsMeeting(x)) ::: If a person is an officer and leads a meeting, they attend the meeting.",
            "∀x (MemberOfClub(x) ∧ PaysDues(x) → ActiveMember(x)) ::: If a person is a member of a club and pays dues, then they are an active member.",
            "Officer(John) ::: John is an officer of the club.",
            "LeadsMeeting(John, MonthlyMeeting) ::: John leads the monthly meeting.",
            "∃x (MemberOfClub(x)) ::: The club has members.",
            "∀x ∀y (ActiveMember(x) ∧ OrganizesEvent(x, y) → Engaged(x)) ::: If a person is an active member and organizes an event, then they are engaged.",
            "∀x ∀y (ParticipatesInEvent(x, y) → AttendsMeeting(x)) ::: If someone participates in an event, they attend the meeting.",
            "MemberOfClub(Mary) ::: Mary is a member of the club.",
            "PaysDues(John) ::: John pays club dues.",
            "ParticipatesInEvent(Mary, Event) ::: Mary participates in the event."
        ],
        "predicates": [
            "MemberOfClub(x) ::: x is a member of a club",
            "AttendsMeeting(x) ::: x attends a meeting",
            "Engaged(x) ::: x is engaged in club activities",
            "Officer(x) ::: x is an officer of the club",
            "LeadsMeeting(x, y) ::: x leads meeting y",
            "Club(y) ::: y is a club",
            "HasMembership(x, y) ::: x has membership to club y",
            "PaysDues(x) ::: x pays club dues",
            "ActiveMember(x) ::: x is an active member",
            "OrganizesEvent(x, y) ::: x organizes event y",
            "ParticipatesInEvent(x, y) ::: x participates in event y"
        ]
    },
    {
        "premises-NL": [
            "All people are kind if they give advice.",
            "Everyone helps someone who needs help.",
            "If someone is a friend, they help that friend.",
            "If someone is a good friend, they always help the friend.",
            "If someone is a good friend, then they are friends.",
            "Some people have problems.",
            "If someone is a friend and helps another person, then they are kind.",
            "If someone is a good friend, they are also kind.",
            "Some people have a friend who is a good friend.",
            "If a person needs help from a friend, that friend helps them.",
            "If someone is a friend of another, they are both friends.",
            "Every person who needs help has a problem.",
            "If a person has a friend, then that friend is also a person.",
            "Some people are friends.",
            "Every good friend helps his friend."
        ],
        "premises-FOL": [
            "∀x (Person(x) ∧ GivesAdvice(x, y) → IsKind(x)) ::: All people are kind if they give advice.",
            "∀x ∃y (NeedsHelp(x, y) → Helps(y, x)) ::: Everyone helps someone who needs help.",
            "∀x ∀y (Friends(x, y) → Helps(x, y)) ::: If someone is a friend, they help that friend.",
            "∀x ∀y (IsGoodFriend(x, y) → Helps(x, y)) ::: If someone is a good friend, they always help the friend.",
            "∀x ∀y (IsGoodFriend(x, y) → Friends(x, y)) ::: If someone is a good friend, then they are friends.",
            "∃x ∃y (Person(x) ∧ HasProblem(x, y)) ::: Some people have problems.",
            "∀x ∀y (Friends(x, y) ∧ Helps(x, y) → IsKind(x)) ::: If someone is a friend and helps another person, then they are kind.",
            "∀x ∀y (IsGoodFriend(x, y) → IsKind(x)) ::: If someone is a good friend, they are also kind.",
            "∃x ∃y (Person(x) ∧ IsGoodFriend(y, x)) ::: Some people have a friend who is a good friend.",
            "∀x ∀y ((Friends(x, y) ∧ NeedsHelp(x, y)) → Helps(y, x)) ::: If a person needs help from a friend, that friend helps them.",
            "∀x ∀y (Friends(x, y) → (Person(x) ∧ Person(y))) ::: If someone is a friend of another, they are both friends.",
            "∀x ∃y (NeedsHelp(x, y) → HasProblem(x, y)) ::: Every person who needs help has a problem.",
            "∀x ∀y (Friends(x, y) → Person(y)) ::: If a person has a friend, then that friend is also a person.",
            "∃x ∃y (Person(x) ∧ Friends(x, y)) ::: Some people are friends.",
            "∀x ∀y (IsGoodFriend(x, y) → Helps(x, y)) ::: Every good friend helps his friend."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Friends(x, y) ::: x and y are friends",
            "Helps(x, y) ::: x helps y",
            "NeedsHelp(x, y) ::: x needs help from y",
            "IsKind(x) ::: x is kind",
            "GivesAdvice(x, y) ::: x gives advice to y",
            "HasProblem(x, y) ::: x has problem y",
            "IsGoodFriend(x, y) ::: x is a good friend of y"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "John is a doctor.",
            "All knowledgeable people are helpful.",
            "If someone is helpful, they treat patients.",
            "All doctors are knowledgeable.",
            "John is not a patient.",
            "If John is a patient, then John is sick.",
            "Anyone who is a patient, and is not sick, has a problem.",
            "If John has a problem, then he is not a doctor.",
            "If John is not a doctor, then he is not knowledgeable.",
            "If John is knowledgeable, John is a patient."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Treats(x, y)) ::: All doctors treat patients.",
            "Doctor(john) ::: John is a doctor.",
            "∀x (Knowledgeable(x) → Helpful(x)) ::: All knowledgeable people are helpful.",
            "∀x (Helpful(x) → Treats(x, y)) ::: If someone is helpful, they treat patients.",
            "∀x (Doctor(x) → Knowledgeable(x)) ::: All doctors are knowledgeable.",
            "¬Patient(john) ::: John is not a patient.",
            "Patient(john) → Sick(john) ::: If John is a patient, then John is sick.",
            "∀x (Patient(x) ∧ ¬Sick(x) → Problem(x)) ::: Anyone who is a patient, and is not sick, has a problem.",
            "Problem(john) → ¬Doctor(john) ::: If John has a problem, then he is not a doctor.",
            "¬Doctor(john) → ¬Knowledgeable(john) ::: If John is not a doctor, then he is not knowledgeable.",
            "Knowledgeable(john) → Patient(john) ::: If John is knowledgeable, John is a patient."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Knowledgeable(x) ::: x is knowledgeable.",
            "Patient(x) ::: x is a patient.",
            "Treats(x, y) ::: x treats y."
        ]
    },
    {
        "premises-NL": [
            "All students study hard.",
            "Sarah and Michael are students.",
            "If someone studies hard, they pass the exam.",
            "If someone attends class, they study hard.",
            "Every smart student passes the exam.",
            "Sarah is smart.",
            "Michael attends class.",
            "If someone does not pass the exam, they fail.",
            "Anyone who fails does not study hard.",
            "If someone studies hard, they are smart.",
            "John is not a student.",
            "If John attends class, then John is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → StudiesHard(x)) ::: All students study hard.",
            "Student(sarah) ∧ Student(michael) ::: Sarah and Michael are students.",
            "∀x (StudiesHard(x) → PassesExam(x)) ::: If someone studies hard, they pass the exam.",
            "∀x (AttendsClass(x) → StudiesHard(x)) ::: If someone attends class, they study hard.",
            "∀x (Smart(x) ∧ Student(x) → PassesExam(x)) ::: Every smart student passes the exam.",
            "Smart(sarah) ::: Sarah is smart.",
            "AttendsClass(michael) ::: Michael attends class.",
            "∀x (¬PassesExam(x) → Fails(x)) ::: If someone does not pass the exam, they fail.",
            "∀x (Fails(x) → ¬StudiesHard(x)) ::: Anyone who fails does not study hard.",
            "∀x (StudiesHard(x) → Smart(x)) ::: If someone studies hard, they are smart.",
            "¬Student(john) ::: John is not a student.",
            "AttendsClass(john) → Student(john) ::: If John attends class, then John is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesHard(x) ::: x studies hard.",
            "PassesExam(x) ::: x passes the exam.",
            "AttendsClass(x) ::: x attends class.",
            "Smart(x) ::: x is smart."
        ]
    },
    {
        "premises-NL": [
            "All programmers use a computer.",
            "John is a programmer.",
            "If someone uses a computer and writes code, they are a programmer.",
            "Anyone who is a programmer likes coding.",
            "If someone likes coding, they enjoy work.",
            "If someone enjoys work, they use a computer.",
            "Anyone who writes code likes coding.",
            "If John likes coding, he uses a computer.",
            "If John is a programmer and enjoys work, then John is smart.",
            "If John is smart, he likes coding.",
            "All people who write code enjoy work.",
            "John does not write code.",
            "If John uses a computer, then John is a programmer."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → UsesComputer(x)) ::: All programmers use a computer.",
            "Programmer(john) ::: John is a programmer.",
            "∀x (UsesComputer(x) ∧ WritesCode(x) → Programmer(x)) ::: If someone uses a computer and writes code, they are a programmer.",
            "∀x (Programmer(x) → LikesCoding(x)) ::: Anyone who is a programmer likes coding.",
            "∀x (LikesCoding(x) → EnjoysWork(x)) ::: If someone likes coding, they enjoy work.",
            "∀x (EnjoysWork(x) → UsesComputer(x)) ::: If someone enjoys work, they use a computer.",
            "∀x (WritesCode(x) → LikesCoding(x)) ::: Anyone who writes code likes coding.",
            "LikesCoding(john) → UsesComputer(john) ::: If John likes coding, he uses a computer.",
            "Programmer(john) ∧ EnjoysWork(john) → Smart(john) ::: If John is a programmer and enjoys work, then John is smart.",
            "Smart(john) → LikesCoding(john) ::: If John is smart, he likes coding.",
            "∀x (WritesCode(x) → EnjoysWork(x)) ::: All people who write code enjoy work.",
            "¬WritesCode(john) ::: John does not write code.",
            "UsesComputer(john) → Programmer(john) ::: If John uses a computer, then John is a programmer."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer.",
            "LikesCoding(x) ::: x likes coding.",
            "UsesComputer(x) ::: x uses a computer.",
            "WritesCode(x) ::: x writes code.",
            "EnjoysWork(x) ::: x enjoys work."
        ]
    },
    {
        "premises-NL": [
            "All doctors are caring.",
            "Alice is a doctor.",
            "All researchers are smart.",
            "If someone is smart, then they like apples.",
            "If someone is a student and studies medicine, then they will become a doctor.",
            "Bob is a student.",
            "Bob studies medicine.",
            "Anyone who helps people is caring.",
            "All doctors help people.",
            "Alice has a patient.",
            "Anyone who has a patient is a doctor.",
            "If someone is a doctor, they are researcher.",
            "If someone is a researcher, they are a doctor.",
            "If x likes apples, they are caring.",
            "If someone is smart, they are caring."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Caring(x)) ::: All doctors are caring.",
            "Doctor(alice) ::: Alice is a doctor.",
            "∀x (Researcher(x) → Smart(x)) ::: All researchers are smart.",
            "∀x (Smart(x) → LikesApples(x)) ::: If someone is smart, then they like apples.",
            "∀x (Student(x) ∧ StudiesMedicine(x) → Doctor(x)) ::: If someone is a student and studies medicine, then they will become a doctor.",
            "Student(bob) ::: Bob is a student.",
            "StudiesMedicine(bob) ::: Bob studies medicine.",
            "∀x (HelpsPeople(x) → Caring(x)) ::: Anyone who helps people is caring.",
            "∀x (Doctor(x) → HelpsPeople(x)) ::: All doctors help people.",
            "HasAPatient(alice) ::: Alice has a patient.",
            "∀x (HasAPatient(x) → Doctor(x)) ::: Anyone who has a patient is a doctor.",
            "∀x (Doctor(x) → Researcher(x)) ::: If someone is a doctor, they are researcher.",
            "∀x (Researcher(x) → Doctor(x)) ::: If someone is a researcher, they are a doctor.",
            "∀x (LikesApples(x) → Caring(x)) ::: If x likes apples, they are caring.",
            "∀x (Smart(x) → Caring(x)) ::: If someone is smart, they are caring."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Researcher(x) ::: x is a researcher",
            "Caring(x) ::: x is caring",
            "Smart(x) ::: x is smart",
            "LikesApples(x) ::: x likes apples",
            "Student(x) ::: x is a student",
            "StudiesMedicine(x) ::: x studies medicine",
            "HelpsPeople(x) ::: x helps people",
            "HasAPatient(x) ::: x has a patient"
        ]
    },
    {
        "premises-NL": [
            "All professors teach.",
            "Charlie teaches.",
            "If someone teaches, they like books.",
            "Charlie likes books.",
            "All smart people attend classes.",
            "If someone attends a class, they are at the university.",
            "Charlie is at the university.",
            "Someone who studies is a student.",
            "If someone is a student, then they read books.",
            "Charlie reads books.",
            "If Charlie is not a student, then he is a professor.",
            "All students are smart.",
            "All smart people are students.",
            "If someone is at university, they attend a class.",
            "Everyone who attends a class is smart.",
            "If x studies, then he is a student."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Teaches(x, x)) ::: All professors teach.",
            "Teaches(charlie, charlie) ::: Charlie teaches.",
            "∀x (Teaches(x, x) → Likes(x, \"books\")) ::: If someone teaches, they like books.",
            "Likes(charlie, \"books\") ::: Charlie likes books.",
            "∀x (Smart(x) → AttendsClass(x, x)) ::: All smart people attend classes.",
            "∀x (AttendsClass(x, x) → IsAtUniversity(x)) ::: If someone attends a class, they are at the university.",
            "IsAtUniversity(charlie) ::: Charlie is at the university.",
            "∀x (Studies(x, x) → Student(x)) ::: Someone who studies is a student.",
            "∀x (Student(x) → ReadsBooks(x)) ::: If someone is a student, then they read books.",
            "ReadsBooks(charlie) ::: Charlie reads books.",
            "¬Student(charlie) → Professor(charlie) ::: If Charlie is not a student, then he is a professor.",
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "∀x (Smart(x) → Student(x)) ::: All smart people are students.",
            "∀x (IsAtUniversity(x) → AttendsClass(x, x)) ::: If someone is at university, they attend a class.",
            "∀x (AttendsClass(x, x) → Smart(x)) ::: Everyone who attends a class is smart.",
            "∀x (Studies(x, x) → Student(x)) ::: If x studies, then he is a student."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "Student(x) ::: x is a student",
            "Teaches(x, y) ::: x teaches y",
            "Likes(x, y) ::: x likes y",
            "Smart(x) ::: x is smart",
            "AttendsClass(x, y) ::: x attends class y",
            "IsAtUniversity(x) ::: x is at university",
            "Studies(x, y) ::: x studies y",
            "ReadsBooks(x) ::: x reads books"
        ]
    },
    {
        "premises-NL": [
            "All patients with a disease should be treated.",
            "If a patient is not treated, they will suffer.",
            "John is a patient and has disease X.",
            "If a doctor treats a patient for a disease, the patient is treated.",
            "John is a patient.",
            "Disease X exists.",
            "All patients either are treated or suffer.",
            "No doctor is also a patient.",
            "John has disease X."
        ],
        "premises-FOL": [
            "∀x ∀y (HasDisease(x, y) → Treated(x, y)) ::: All patients with a disease should be treated.",
            "∀x (¬Treated(x, y) → Suffers(x)) ::: If a patient is not treated, they will suffer.",
            "HasDisease(John, X) ::: John is a patient and has disease X.",
            "∀x ∀y ∀z (Doctor(z) ∧ Treats(z, x, y) → Treated(x, y)) ::: If a doctor treats a patient for a disease, the patient is treated.",
            "Patient(John) ::: John is a patient.",
            "Disease(X) ::: Disease X exists.",
            "∀x (Treated(x, y) ∨ Suffers(x)) ::: All patients either are treated or suffer.",
            "∀x ¬(Doctor(x) ∧ Patient(x)) ::: No doctor is also a patient.",
            "HasDisease(John, X) ::: John has disease X."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient",
            "Disease(y) ::: y is a disease",
            "HasDisease(x, y) ::: x has disease y",
            "Treated(x, y) ::: x is treated for y",
            "Suffers(x) ::: x suffers",
            "Doctor(z) ::: z is a doctor"
        ]
    },
    {
        "premises-NL": [
            "All members of a club are interested in the club.",
            "If someone is interested in a club and posts online about it, then they attend meetings.",
            "If someone is a member and attends meetings, then they are active.",
            "John is a member of Club A since 2020.",
            "The president of Club A is John.",
            "John posts online about Club A.",
            "All active members are helpful.",
            "If John is a member of Club A, then he is interested in Club A.",
            "John is a member of Club A."
        ],
        "premises-FOL": [
            "∀x ∀y (Member(x, y) → Interested(x, y)) ::: All members of a club are interested in the club.",
            "∀x ∀y (Interested(x, y) ∧ PostsOnline(x, y) → AttendsMeetings(x, y)) ::: If someone is interested in a club and posts online about it, then they attend meetings.",
            "∀x ∀y (Member(x, y) ∧ AttendsMeetings(x, y) → Active(x, y)) ::: If someone is a member and attends meetings, then they are active.",
            "MemberSince(John, ClubA, 2020) ::: John is a member of Club A since 2020.",
            "President(John, ClubA) ::: The president of Club A is John.",
            "PostsOnline(John, ClubA) ::: John posts online about Club A.",
            "∀x ∀y (Active(x, y) → Helpful(x)) ::: All active members are helpful.",
            "∀x (Member(John, ClubA) → Interested(John, ClubA)) ::: If John is a member of Club A, then he is interested in Club A.",
            "Member(John, ClubA) ::: John is a member of Club A."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Club(y) ::: y is a club",
            "Member(x, y) ::: x is a member of y",
            "AttendsMeetings(x, y) ::: x attends meetings of y",
            "Active(x, y) ::: x is active in y",
            "Interested(x, y) ::: x is interested in y",
            "PostsOnline(x, y) ::: x posts online about y",
            "President(x, y) ::: x is president of y",
            "MemberSince(x, y, z) ::: x is a member of y since z"
        ]
    },
    {
        "premises-NL": [
            "All patients who are diagnosed with a disease are treated.",
            "Some patients are examined.",
            "Every patient that has symptoms is examined.",
            "Some patients are diagnosed.",
            "Any patient that is treated has symptoms."
        ],
        "premises-FOL": [
            "∀x ∀y (Diagnosed(x, y) → IsTreated(x)) ::: All patients who are diagnosed with a disease are treated.",
            "∃x Examined(x) ::: Some patients are examined.",
            "∀x (HasSymptoms(x) → Examined(x)) ::: Every patient that has symptoms is examined.",
            "∃x ∃y Diagnosed(x, y) ::: Some patients are diagnosed.",
            "∀x (IsTreated(x) → HasSymptoms(x)) ::: Any patient that is treated has symptoms."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient.",
            "Disease(y) ::: y is a disease.",
            "Diagnosed(x, y) ::: Patient x is diagnosed with disease y.",
            "HasSymptoms(x) ::: Patient x has symptoms.",
            "Examined(x) ::: Patient x is examined.",
            "IsTreated(x) ::: Patient x is treated."
        ]
    },
    {
        "premises-NL": [
            "All students who study, read books.",
            "Anyone who takes the exam and studies passes the exam.",
            "If someone reads books and is intelligent, they take the exam.",
            "Some students are intelligent.",
            "Some students study.",
            "Every student is a student.",
            "If a student takes an exam, they pass it."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ Studies(x) → ReadsBook(x)) ::: All students who study, read books.",
            "∀x ((TakesExam(x) ∧ Studies(x)) → PassExam(x)) ::: Anyone who takes the exam and studies passes the exam.",
            "∀x (ReadsBook(x) ∧ Intelligent(x) → TakesExam(x)) ::: If someone reads books and is intelligent, they take the exam.",
            "∃x (Student(x) ∧ Intelligent(x)) ::: Some students are intelligent.",
            "∃x (Student(x) ∧ Studies(x)) ::: Some students study.",
            "∀x Student(x) ::: Every student is a student.",
            "∀x (TakesExam(x) → PassExam(x)) ::: If a student takes an exam, they pass it."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Studies(x) ::: Student x studies.",
            "Intelligent(x) ::: Student x is intelligent.",
            "PassExam(x) ::: Student x passes the exam.",
            "TakesExam(x) ::: Student x takes the exam.",
            "ReadsBook(x) ::: Student x reads a book.",
            "Understands(x, y) ::: Student x understands concept y."
        ]
    },
    {
        "premises-NL": [
            "All students take the exam.",
            "Any student who studies will pass the exam.",
            "John is a student.",
            "John studies.",
            "If John takes the exam, he studies.",
            "If someone is a student and studies, they will take the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakesExam(x)) ::: All students take the exam.",
            "∀x (Studies(x) → PassExam(x)) ::: Any student who studies will pass the exam.",
            "Student(John) ::: John is a student.",
            "Studies(John) ::: John studies.",
            "TakesExam(John) ↔ Studies(John) ::: If John takes the exam, he studies.",
            "∀x (Student(x) ∧ Studies(x) → TakesExam(x)) ::: If someone is a student and studies, they will take the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "PassExam(x) ::: x passes the exam",
            "TakesExam(x) ::: x takes the exam"
        ]
    },
    {
        "premises-NL": [
            "All patients who have a fever and a cough are sick.",
            "All sick people have the flu.",
            "If a patient has a fever, they are a patient.",
            "If a patient has a cough and headache, they are a patient.",
            "John has a fever.",
            "John has a cough.",
            "If John has a fever and cough, then he takes medicine.",
            "If someone is sick, they feel weak."
        ],
        "premises-FOL": [
            "∀x ((Patient(x) ∧ Fever(x) ∧ Cough(x)) → IsSick(x)) ::: All patients who have a fever and a cough are sick.",
            "∀x (IsSick(x) → HasFlu(x)) ::: All sick people have the flu.",
            "∀x (Fever(x) → Patient(x)) ::: If a patient has a fever, they are a patient.",
            "∀x ((Cough(x) ∧ Headache(x)) → Patient(x)) ::: If a patient has a cough and headache, they are a patient.",
            "Fever(John) ::: John has a fever.",
            "Cough(John) ::: John has a cough.",
            "Fever(John) ∧ Cough(John) → TakesMedicine(John) ::: If John has a fever and cough, then he takes medicine.",
            "∀x (IsSick(x) → FeelsWeak(x)) ::: If someone is sick, they feel weak."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient",
            "Fever(x) ::: x has a fever",
            "Cough(x) ::: x has a cough",
            "HasFlu(x) ::: x has the flu",
            "IsSick(x) ::: x is sick",
            "TakesMedicine(x) ::: x takes medicine",
            "FeelsWeak(x) ::: x feels weak",
            "HasHeadache(x) ::: x has a headache"
        ]
    },
    {
        "premises-NL": [
            "All doctors work at a hospital.",
            "All researchers publish papers.",
            "Anyone who studies medicine is a person.",
            "If someone studies medicine and knows science, then they are an expert in medicine.",
            "If a person works at a hospital, they treat patients.",
            "If someone treats patients and is a doctor, they study medicine.",
            "John is a doctor.",
            "John is a researcher.",
            "If someone is a doctor, they know science."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → WorksAtHospital(x)) ::: All doctors work at a hospital.",
            "∀x (Researcher(x) → PublishesPapers(x)) ::: All researchers publish papers.",
            "∀x (StudiesMedicine(x) → Person(x)) ::: Anyone who studies medicine is a person.",
            "∀x (StudiesMedicine(x) ∧ KnowsScience(x) → ExpertInMedicine(x)) ::: If someone studies medicine and knows science, then they are an expert in medicine.",
            "∀x (Person(x) ∧ WorksAtHospital(x) → TreatsPatients(x)) ::: If a person works at a hospital, they treat patients.",
            "∀x (TreatsPatients(x) ∧ Doctor(x) → StudiesMedicine(x)) ::: If someone treats patients and is a doctor, they study medicine.",
            "Doctor(John) ::: John is a doctor.",
            "Researcher(John) ::: John is a researcher.",
            "∀x (Doctor(x) → KnowsScience(x)) ::: If someone is a doctor, they know science."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Doctor(x) ::: x is a doctor",
            "Researcher(x) ::: x is a researcher",
            "ExpertInMedicine(x) ::: x is an expert in medicine",
            "StudiesMedicine(x) ::: x studies medicine",
            "PublishesPapers(x) ::: x publishes papers",
            "KnowsScience(x) ::: x knows science",
            "WorksAtHospital(x) ::: x works at a hospital",
            "TreatsPatients(x) ::: x treats patients"
        ]
    },
    {
        "premises-NL": [
            "Alice is enrolled in Course1.",
            "Bob is enrolled in Course1.",
            "If someone is enrolled in a course, and they do not like it, then the course is poorly taught.",
            "Course1 is not poorly taught.",
            "Bob does not like Course1.",
            "If someone does not like a course, they are unhappy."
        ],
        "premises-FOL": [
            "Enrolled(Alice, Course1) ::: Alice is enrolled in Course1",
            "Enrolled(Bob, Course1) ::: Bob is enrolled in Course1",
            "∀x ∀y ((Enrolled(x, y) ∧ ¬Likes(x, y)) → PoorlyTaught(y)) ::: If someone is enrolled in a course and does not like it, then the course is poorly taught",
            "¬PoorlyTaught(Course1) ::: Course1 is not poorly taught",
            "¬Likes(Bob, Course1) ::: Bob does not like Course1",
            "∀x ∀y (¬Likes(x, y) → Unhappy(x)) ::: If someone does not like a course, they are unhappy"
        ],
        "predicates": [
            "Enrolled(x, y) ::: x is enrolled in course y",
            "Likes(x, y) ::: x likes course y"
        ]
    },
    {
        "premises-NL": [
            "John likes Mary.",
            "Mary likes David.",
            "If someone likes someone, they are friends.",
            "If someone is friends with someone, they like them.",
            "John likes Mary, and John is friends with Bob.",
            "If someone likes their friend, they are happy.",
            "If John is happy, then he is smiling.",
            "If John likes Mary and Mary likes David, then John likes David."
        ],
        "premises-FOL": [
            "Likes(John, Mary) ::: John likes Mary",
            "Likes(Mary, David) ::: Mary likes David",
            "∀x ∀y (Likes(x, y) → Friend(x, y)) ::: If someone likes someone, they are friends",
            "∀x ∀y (Friend(x, y) → Likes(x, y)) ::: If someone is friends with someone, they like them",
            "(Likes(John, Mary) ∧ Friend(John, Bob)) ::: John likes Mary and John is friends with Bob",
            "∀x ∀y (Likes(x, y) → Happy(x)) ::: If someone likes their friend, they are happy",
            "∀x (Happy(x) → Smiling(x)) ::: If John is happy, then he is smiling",
            "(Likes(John, Mary) ∧ Likes(Mary, David)) → Likes(John, David) ::: If John likes Mary and Mary likes David, then John likes David"
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Friend(x, y) ::: x is a friend of y",
            "Happy(x) ::: x is happy"
        ]
    },
    {
        "premises-NL": [
            "Every product that is manufactured is available.",
            "If a product is available and advertised, then it's sold.",
            "If a product is in demand, it's manufactured.",
            "If a product is sold, it generates revenue.",
            "Product A is manufactured.",
            "Product B is advertised.",
            "If a product is in demand and advertised, it is sold.",
            "Product B is a product.",
            "Every advertised product is in demand.",
            "Product A is in demand.",
            "If something is manufactured, it's a product.",
            "Product C is manufactured.",
            "Product C is advertised.",
            "Product C is available.",
            "Product B is sold."
        ],
        "premises-FOL": [
            "∀x (Manufactured(x) → Available(x)) ::: Every product that is manufactured is available.",
            "∀x (Available(x) ∧ Advertised(x) → Sold(x)) ::: If a product is available and advertised, then it's sold.",
            "∀x (InDemand(x) → Manufactured(x)) ::: If a product is in demand, it's manufactured.",
            "∀x (Sold(x) → GeneratesRevenue(x)) ::: If a product is sold, it generates revenue.",
            "Manufactured(A) ::: Product A is manufactured.",
            "Advertised(B) ::: Product B is advertised.",
            "∀x (InDemand(x) ∧ Advertised(x) → Sold(x)) ::: If a product is in demand and advertised, it is sold.",
            "Product(B) ::: Product B is a product.",
            "∀x (Advertised(x) → InDemand(x)) ::: Every advertised product is in demand.",
            "InDemand(A) ::: Product A is in demand.",
            "∀x (Manufactured(x) → Product(x)) ::: If something is manufactured, it's a product.",
            "Manufactured(C) ::: Product C is manufactured.",
            "Advertised(C) ::: Product C is advertised.",
            "Available(C) ::: Product C is available.",
            "Sold(B) ::: Product B is sold."
        ],
        "predicates": [
            "Product(x) ::: x is a product.",
            "Manufactured(x) ::: x is manufactured.",
            "Sold(x) ::: x is sold.",
            "Available(x) ::: x is available.",
            "Advertised(x) ::: x is advertised.",
            "GeneratesRevenue(x) ::: x generates revenue.",
            "InDemand(x) ::: x is in demand."
        ]
    },
    {
        "premises-NL": [
            "Every member of the research team has access to the primary dataset.",
            "If someone has access to the primary dataset and uses specialized software, they collaborate on the project.",
            "All researchers are members of the research team.",
            "Anyone who collaborates on a project uses the project's software.",
            "Researcher Alice uses the project software.",
            "Researcher Bob has access to the primary dataset.",
            "The project's software is used on the primary dataset.",
            "Alice is a researcher.",
            "Bob is a member of the research team.",
            "Every member of the research team uses specialized software.",
            "Anyone who has access to the dataset uses the software.",
            "The primary dataset is used on the project.",
            "Bob uses specialized software.",
            "Researcher Charlie is also a member of the research team.",
            "If someone is a member of the research team, then they have access to the primary dataset.",
            "Alice works on the project."
        ],
        "premises-FOL": [
            "∀x (MemberOfTeam(x) → HasAccessToData(x, PrimaryDataset)) ::: Every member of the research team has access to the primary dataset.",
            "∀x (HasAccessToData(x, PrimaryDataset) ∧ UsesSoftware(x, SpecializedSoftware) → CollaboratesOnProject(x)) ::: If someone has access to the primary dataset and uses specialized software, they collaborate on the project.",
            "∀x (IsResearcher(x) → MemberOfTeam(x)) ::: All researchers are members of the research team.",
            "∀x (CollaboratesOnProject(x) → UsesSoftware(x, ProjectSoftware)) ::: Anyone who collaborates on a project uses the project's software.",
            "UsesSoftware(Alice, ProjectSoftware) ::: Researcher Alice uses the project software.",
            "HasAccessToData(Bob, PrimaryDataset) ::: Researcher Bob has access to the primary dataset.",
            "DataIsUsed(PrimaryDataset, Project) ::: The project's software is used on the primary dataset.",
            "IsResearcher(Alice) ::: Alice is a researcher.",
            "MemberOfTeam(Bob) ::: Bob is a member of the research team.",
            "∀x (MemberOfTeam(x) → UsesSoftware(x, SpecializedSoftware)) ::: Every member of the research team uses specialized software.",
            "∀x ∀y (HasAccessToData(x, y) → UsesSoftware(x, ProjectSoftware)) ::: Anyone who has access to the dataset uses the software.",
            "DataIsUsed(PrimaryDataset, Project) ::: The primary dataset is used on the project.",
            "UsesSoftware(Bob, SpecializedSoftware) ::: Bob uses specialized software.",
            "MemberOfTeam(Charlie) ::: Researcher Charlie is also a member of the research team.",
            "∀x (MemberOfTeam(x) → HasAccessToData(x, PrimaryDataset)) ::: If someone is a member of the research team, then they have access to the primary dataset.",
            "WorksOnProject(Alice, Project) ::: Alice works on the project."
        ],
        "predicates": [
            "MemberOfTeam(x) ::: x is a member of the research team.",
            "HasAccessToData(x, y) ::: x has access to data set y.",
            "UsesSoftware(x, y) ::: x uses software y.",
            "CollaboratesOnProject(x) ::: x collaborates on a project.",
            "IsResearcher(x) ::: x is a researcher.",
            "WorksOnProject(x, y) ::: x works on project y.",
            "DataIsUsed(x, y) ::: Dataset x is used by y."
        ]
    },
    {
        "premises-NL": [
            "Every student studies hard.",
            "No lazy student attends classes.",
            "Some students pass exams.",
            "Anyone who studies hard reads books.",
            "If a student reads books, then they get good grades.",
            "Every student who gets good grades enjoys learning.",
            "If someone enjoys learning, they are diligent.",
            "Some diligent students are not lazy.",
            "Anyone who is not lazy does not skip classes.",
            "If a student attends classes, they do not fail exams.",
            "Anyone who is motivated studies hard.",
            "If a student is diligent, they are motivated.",
            "Someone who gets good grades gets an award.",
            "Some people get good grades and are not lazy.",
            "If someone passes exams then they succeeds.",
            "If someone succeeds they offer help.",
            "If someone gets award, they are smart."
        ],
        "premises-FOL": [
            "∀x (Student(x) → StudiesHard(x)) ::: Every student studies hard.",
            "∀x (IsLazy(x) → ¬AttendsClasses(x)) ::: No lazy student attends classes.",
            "∃x PassesExams(x) ::: Some students pass exams.",
            "∀x (StudiesHard(x) → ReadsBooks(x)) ::: Anyone who studies hard reads books.",
            "∀x (ReadsBooks(x) → GetsGoodGrades(x)) ::: If a student reads books, then they get good grades.",
            "∀x (GetsGoodGrades(x) → EnjoysLearning(x)) ::: Every student who gets good grades enjoys learning.",
            "∀x (EnjoysLearning(x) → IsDiligent(x)) ::: If someone enjoys learning, they are diligent.",
            "∃x (IsDiligent(x) ∧ ¬IsLazy(x)) ::: Some diligent students are not lazy.",
            "∀x (¬IsLazy(x) → ¬SkipsClasses(x)) ::: Anyone who is not lazy does not skip classes.",
            "∀x (AttendsClasses(x) → ¬FailsExams(x)) ::: If a student attends classes, they do not fail exams.",
            "∀x (IsMotivated(x) → StudiesHard(x)) ::: Anyone who is motivated studies hard.",
            "∀x (IsDiligent(x) → IsMotivated(x)) ::: If a student is diligent, they are motivated.",
            "∃x (GetsGoodGrades(x) ∧ GetsAward(x)) ::: Someone who gets good grades gets an award.",
            "∃x (GetsGoodGrades(x) ∧ ¬IsLazy(x)) ::: Some people get good grades and are not lazy.",
            "∀x (PassesExams(x) → Succeeds(x)) ::: If someone passes exams then they succeeds.",
            "∀x (Succeeds(x) → OffersHelp(x, x)) ::: If someone succeeds they offer help.",
            "∀x (GetsAward(x) → IsSmart(x)) ::: If someone gets award, they are smart."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "IsLazy(x) ::: x is lazy",
            "Succeeds(x) ::: x succeeds",
            "AttendsClasses(x) ::: x attends classes",
            "PassesExams(x) ::: x passes exams",
            "ReadsBooks(x) ::: x reads books",
            "GetsGoodGrades(x) ::: x gets good grades",
            "EnjoysLearning(x) ::: x enjoys learning",
            "IsDiligent(x) ::: x is diligent",
            "SkipsClasses(x) ::: x skips classes",
            "FailsExams(x) ::: x fails exams",
            "IsMotivated(x) ::: x is motivated",
            "NeedsHelp(x) ::: x needs help",
            "OffersHelp(x, y) ::: x offers help to y",
            "IsSmart(x) ::: x is smart",
            "GetsAward(x) ::: x gets an award"
        ]
    },
    {
        "premises-NL": [
            "Alex is a student.",
            "If Alex studies hard, then Alex will pass the exam.",
            "If someone has a disease, they take medicine.",
            "Alex studies hard.",
            "If Alex takes medicine, then Alex recovers.",
            "Alex has a disease.",
            "Cats are animals.",
            "Dogs are mammals.",
            "All dogs are friendly.",
            "All friendly animals are cute.",
            "Alex likes cats.",
            "If someone likes cats, then they are animal lovers.",
            "Alex is a dog."
        ],
        "premises-FOL": [
            "Student(alex) ::: Alex is a student",
            "StudiesHard(alex) → PassExam(alex) ::: If Alex studies hard, then Alex will pass the exam",
            "∀x (HasDisease(x) → TakesMedicine(x)) ::: If someone has a disease, they take medicine",
            "StudiesHard(alex) ::: Alex studies hard",
            "TakesMedicine(alex) → Recovers(alex) ::: If Alex takes medicine, then Alex recovers",
            "HasDisease(alex) ::: Alex has a disease",
            "∀x (IsCat(x) → IsAnimal(x)) ::: Cats are animals",
            "∀x (IsDog(x) → IsMammal(x)) ::: Dogs are mammals",
            "∀x (IsDog(x) → IsFriendly(x)) ::: All dogs are friendly",
            "∀x (IsFriendly(x) ∧ IsAnimal(x) → IsCute(x)) ::: All friendly animals are cute",
            "Likes(alex, cat) ::: Alex likes cats",
            "∀x (Likes(x, cat) → AnimalLover(x)) ::: If someone likes cats, then they are animal lovers",
            "IsDog(alex) ::: Alex is a dog"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x will pass the exam",
            "HasDisease(x) ::: x has a disease",
            "TakesMedicine(x) ::: x takes medicine",
            "Recovers(x) ::: x recovers",
            "Likes(x, y) ::: x likes y",
            "IsCat(x) ::: x is a cat",
            "IsAnimal(x) ::: x is an animal",
            "IsMammal(x) ::: x is a mammal",
            "IsDog(x) ::: x is a dog",
            "IsFriendly(x) ::: x is friendly",
            "IsCute(x) ::: x is cute"
        ]
    },
    {
        "premises-NL": [
            "Sarah is a student.",
            "If Sarah studies hard, then Sarah will pass the exam.",
            "Everyone who is a student and studies hard will pass the exam.",
            "If someone has a disease, they take medicine.",
            "Sarah studies hard.",
            "If Sarah takes medicine, then Sarah recovers.",
            "Sarah has a disease.",
            "Cats are animals.",
            "Dogs are mammals.",
            "All dogs are friendly.",
            "All friendly animals are cute.",
            "Sarah likes cats.",
            "If someone likes cats, then they are animal lovers.",
            "Sarah is a dog."
        ],
        "premises-FOL": [
            "Student(sarah) ::: Sarah is a student",
            "StudiesHard(sarah) → PassExam(sarah) ::: If Sarah studies hard, then Sarah will pass the exam",
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: Everyone who is a student and studies hard will pass the exam",
            "∀x (HasDisease(x) → TakesMedicine(x)) ::: If someone has a disease, they take medicine",
            "StudiesHard(sarah) ::: Sarah studies hard",
            "TakesMedicine(sarah) → Recovers(sarah) ::: If Sarah takes medicine, then Sarah recovers",
            "HasDisease(sarah) ::: Sarah has a disease",
            "∀x (IsCat(x) → IsAnimal(x)) ::: Cats are animals",
            "∀x (IsDog(x) → IsMammal(x)) ::: Dogs are mammals",
            "∀x (IsDog(x) → IsFriendly(x)) ::: All dogs are friendly",
            "∀x (IsFriendly(x) ∧ IsAnimal(x) → IsCute(x)) ::: All friendly animals are cute",
            "Likes(sarah, cat) ::: Sarah likes cats",
            "∀x (Likes(x, cat) → AnimalLover(x)) ::: If someone likes cats, then they are animal lovers",
            "IsDog(sarah) ::: Sarah is a dog"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x will pass the exam",
            "HasDisease(x) ::: x has a disease",
            "TakesMedicine(x) ::: x takes medicine",
            "Recovers(x) ::: x recovers",
            "Likes(x, y) ::: x likes y",
            "IsCat(x) ::: x is a cat",
            "IsAnimal(x) ::: x is an animal",
            "IsMammal(x) ::: x is a mammal",
            "IsDog(x) ::: x is a dog",
            "IsFriendly(x) ::: x is friendly",
            "IsCute(x) ::: x is cute",
            "Eats(x, y) ::: x eats y"
        ]
    },
    {
        "premises-NL": [
            "Alex is a student.",
            "If Alex studies hard, then Alex will pass the exam.",
            "Everyone who is a student and studies hard will pass the exam.",
            "If someone has a disease, they take medicine.",
            "Alex studies hard.",
            "If Alex takes medicine, then Alex recovers.",
            "Alex has a disease.",
            "Cats are animals.",
            "Dogs are mammals.",
            "All dogs are friendly.",
            "All friendly animals are cute.",
            "Alex likes cats.",
            "If someone likes cats, then they are animal lovers.",
            "Alex is a dog.",
            "Alex is white."
        ],
        "premises-FOL": [
            "Student(alex) ::: Alex is a student",
            "StudiesHard(alex) → PassExam(alex) ::: If Alex studies hard, then Alex will pass the exam",
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: Everyone who is a student and studies hard will pass the exam",
            "∀x (HasDisease(x) → TakesMedicine(x)) ::: If someone has a disease, they take medicine",
            "StudiesHard(alex) ::: Alex studies hard",
            "TakesMedicine(alex) → Recovers(alex) ::: If Alex takes medicine, then Alex recovers",
            "HasDisease(alex) ::: Alex has a disease",
            "∀x (IsCat(x) → IsAnimal(x)) ::: Cats are animals",
            "∀x (IsDog(x) → IsMammal(x)) ::: Dogs are mammals",
            "∀x (IsDog(x) → IsFriendly(x)) ::: All dogs are friendly",
            "∀x (IsFriendly(x) ∧ IsAnimal(x) → IsCute(x)) ::: All friendly animals are cute",
            "Likes(alex, cat) ::: Alex likes cats",
            "∀x (Likes(x, cat) → AnimalLover(x)) ::: If someone likes cats, then they are animal lovers",
            "IsDog(alex) ::: Alex is a dog",
            "IsWhite(alex) ::: Alex is white"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x will pass the exam",
            "HasDisease(x) ::: x has a disease",
            "TakesMedicine(x) ::: x takes medicine",
            "Recovers(x) ::: x recovers",
            "Likes(x, y) ::: x likes y",
            "IsCat(x) ::: x is a cat",
            "IsAnimal(x) ::: x is an animal",
            "IsMammal(x) ::: x is a mammal",
            "IsDog(x) ::: x is a dog",
            "IsFriendly(x) ::: x is friendly",
            "IsCute(x) ::: x is cute",
            "Eats(x, y) ::: x eats y",
            "IsWhite(x) ::: x is white"
        ]
    },
    {
        "premises-NL": [
            "Alex is a student.",
            "If Alex studies hard, then Alex will pass the exam.",
            "Everyone who is a student and studies hard will pass the exam.",
            "If someone has a disease, they take medicine.",
            "Alex studies hard.",
            "If Alex takes medicine, then Alex recovers.",
            "Alex has a disease.",
            "Cats are animals.",
            "Dogs are mammals.",
            "All dogs are friendly.",
            "All friendly animals are cute.",
            "Alex likes cats.",
            "If someone likes cats, then they are animal lovers.",
            "Alex is a dog.",
            "Alex is white.",
            "If Alex is white then Alex is not black."
        ],
        "premises-FOL": [
            "Student(alex) ::: Alex is a student",
            "StudiesHard(alex) → PassExam(alex) ::: If Alex studies hard, then Alex will pass the exam",
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: Everyone who is a student and studies hard will pass the exam",
            "∀x (HasDisease(x) → TakesMedicine(x)) ::: If someone has a disease, they take medicine",
            "StudiesHard(alex) ::: Alex studies hard",
            "TakesMedicine(alex) → Recovers(alex) ::: If Alex takes medicine, then Alex recovers",
            "HasDisease(alex) ::: Alex has a disease",
            "∀x (IsCat(x) → IsAnimal(x)) ::: Cats are animals",
            "∀x (IsDog(x) → IsMammal(x)) ::: Dogs are mammals",
            "∀x (IsDog(x) → IsFriendly(x)) ::: All dogs are friendly",
            "∀x (IsFriendly(x) ∧ IsAnimal(x) → IsCute(x)) ::: All friendly animals are cute",
            "Likes(alex, cat) ::: Alex likes cats",
            "∀x (Likes(x, cat) → AnimalLover(x)) ::: If someone likes cats, then they are animal lovers",
            "IsDog(alex) ::: Alex is a dog",
            "IsWhite(alex) ::: Alex is white",
            "IsWhite(alex) → ¬IsBlack(alex) ::: If Alex is white then Alex is not black"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x will pass the exam",
            "HasDisease(x) ::: x has a disease",
            "TakesMedicine(x) ::: x takes medicine",
            "Recovers(x) ::: x recovers",
            "Likes(x, y) ::: x likes y",
            "IsCat(x) ::: x is a cat",
            "IsAnimal(x) ::: x is an animal",
            "IsMammal(x) ::: x is a mammal",
            "IsDog(x) ::: x is a dog",
            "IsFriendly(x) ::: x is friendly",
            "IsCute(x) ::: x is cute",
            "Eats(x, y) ::: x eats y",
            "IsWhite(x) ::: x is white",
            "IsBlack(x) ::: x is black"
        ]
    },
    {
        "premises-NL": [
            "Alex is a student.",
            "If Alex studies hard, then Alex will pass the exam.",
            "Everyone who is a student and studies hard will pass the exam.",
            "If someone has a disease, they take medicine.",
            "Alex studies hard.",
            "If Alex takes medicine, then Alex recovers.",
            "Alex has a disease.",
            "Cats are animals.",
            "Dogs are mammals.",
            "All dogs are friendly.",
            "All friendly animals are cute.",
            "Alex likes cats.",
            "If someone likes cats, then they are animal lovers.",
            "Alex is a dog.",
            "Alex is white.",
            "If Alex is white then Alex is not black.",
            "Alex is tired."
        ],
        "premises-FOL": [
            "Student(alex) ::: Alex is a student",
            "StudiesHard(alex) → PassExam(alex) ::: If Alex studies hard, then Alex will pass the exam",
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: Everyone who is a student and studies hard will pass the exam",
            "∀x (HasDisease(x) → TakesMedicine(x)) ::: If someone has a disease, they take medicine",
            "StudiesHard(alex) ::: Alex studies hard",
            "TakesMedicine(alex) → Recovers(alex) ::: If Alex takes medicine, then Alex recovers",
            "HasDisease(alex) ::: Alex has a disease",
            "∀x (IsCat(x) → IsAnimal(x)) ::: Cats are animals",
            "∀x (IsDog(x) → IsMammal(x)) ::: Dogs are mammals",
            "∀x (IsDog(x) → IsFriendly(x)) ::: All dogs are friendly",
            "∀x (IsFriendly(x) ∧ IsAnimal(x) → IsCute(x)) ::: All friendly animals are cute",
            "Likes(alex, cat) ::: Alex likes cats",
            "∀x (Likes(x, cat) → AnimalLover(x)) ::: If someone likes cats, then they are animal lovers",
            "IsDog(alex) ::: Alex is a dog",
            "IsWhite(alex) ::: Alex is white",
            "IsWhite(alex) → ¬IsBlack(alex) ::: If Alex is white then Alex is not black",
            "IsTired(alex) ::: Alex is tired"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x will pass the exam",
            "HasDisease(x) ::: x has a disease",
            "TakesMedicine(x) ::: x takes medicine",
            "Recovers(x) ::: x recovers",
            "Likes(x, y) ::: x likes y",
            "IsCat(x) ::: x is a cat",
            "IsAnimal(x) ::: x is an animal",
            "IsMammal(x) ::: x is a mammal",
            "IsDog(x) ::: x is a dog",
            "IsFriendly(x) ::: x is friendly",
            "IsCute(x) ::: x is cute",
            "Eats(x, y) ::: x eats y",
            "IsWhite(x) ::: x is white",
            "IsBlack(x) ::: x is black",
            "IsTired(x) ::: x is tired"
        ]
    },
    {
        "premises-NL": [
            "Alex attends class.",
            "If Alex attends class, Alex studies hard.",
            "If Alex is smart, Alex will pass the exam.",
            "Alex is smart.",
            "If Alex studies hard and Alex is smart then Alex will pass the exam.",
            "If Alex attends class and Alex is smart then Alex will pass the exam."
        ],
        "premises-FOL": [
            "AttendsClass(alex) ::: Alex attends class.",
            "AttendsClass(x) → StudyHard(x) ::: If x attends class, x studies hard.",
            "Smart(x) → PassExam(x) ::: If x is smart, x will pass the exam.",
            "Smart(alex) ::: Alex is smart.",
            "StudyHard(x) ∧ Smart(x) → PassExam(x) ::: If x studies hard and x is smart then x will pass the exam.",
            "AttendsClass(x) ∧ Smart(x) → PassExam(x) ::: If x attends class and x is smart then x will pass the exam."
        ],
        "predicates": [
            "StudyHard(x) ::: x studies hard",
            "PassExam(x) ::: x will pass the exam",
            "AttendsClass(x) ::: x attends class",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "Sarah is enrolled in Calculus.",
            "Sarah takes Calculus.",
            "Professor Miller teaches Calculus.",
            "If someone is enrolled in a course and takes that course, and the course is taught by a professor, then they study hard.",
            "If Sarah is smart and attends class, then she will not be late.",
            "If Sarah is enrolled in Calculus, then she attends class.",
            "If Sarah is not late, she passes the exam.",
            "If Sarah studies hard, then she is smart.",
            "If someone is enrolled in a course, then they attend class.",
            "If someone attends class, they are not late.",
            "If Sarah is enrolled in Calculus and takes Calculus, then she studies hard.",
            "Sarah is smart.",
            "Sarah is taking Calculus and attended the class.",
            "Sarah is not late.",
            "Sarah attends class."
        ],
        "premises-FOL": [
            "Enrolled(sarah, calculus) ::: Sarah is enrolled in Calculus.",
            "TakesCourse(sarah, calculus) ::: Sarah takes Calculus.",
            "Professor(miller) ∧ Teaches(miller, calculus) ::: Professor Miller teaches Calculus.",
            "∀x ∀y ∀z (Enrolled(x, y) ∧ TakesCourse(x, y) ∧ Teaches(z, y) → StudyHard(x)) ::: If someone is enrolled in a course and takes that course, and the course is taught by a professor, then they study hard.",
            "Smart(sarah) ∧ AttendsClass(sarah) → ¬Late(sarah) ::: If Sarah is smart and attends class, then she will not be late.",
            "Enrolled(sarah, calculus) → AttendsClass(sarah) ::: If Sarah is enrolled in Calculus, then she attends class.",
            "¬Late(sarah) → PassExam(sarah) ::: If Sarah is not late, she passes the exam.",
            "StudyHard(sarah) → Smart(sarah) ::: If Sarah studies hard, then she is smart.",
            "∀x ∀y (Enrolled(x, y) → AttendsClass(x)) ::: If someone is enrolled in a course, then they attend class.",
            "∀x (AttendsClass(x) → ¬Late(x)) ::: If someone attends class, they are not late.",
            "Enrolled(sarah, calculus) ∧ TakesCourse(sarah, calculus) → StudyHard(sarah) ::: If Sarah is enrolled in Calculus and takes Calculus, then she studies hard.",
            "Smart(sarah) ::: Sarah is smart.",
            "TakesCourse(sarah, calculus) ∧ AttendsClass(sarah) ::: Sarah is taking Calculus and attended the class.",
            "¬Late(sarah) ::: Sarah is not late.",
            "AttendsClass(sarah) ::: Sarah attends class."
        ],
        "predicates": [
            "StudyHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "Enrolled(x, y) ::: x is enrolled in y",
            "TakesCourse(x, y) ::: x takes course y",
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches course y",
            "Smart(x) ::: x is smart",
            "AttendsClass(x) ::: x attends class",
            "Late(x) ::: x is late"
        ]
    },
    {
        "premises-NL": [
            "John has a high IQ.",
            "John is enrolled in Biology.",
            "John takes Biology.",
            "Professor Smith teaches Biology.",
            "If someone is enrolled in a course and takes that course, and the course is taught by a professor, then they study hard.",
            "If someone has a high IQ and studies hard, they become a doctor.",
            "If John is smart and attends class, then he is not late.",
            "If John is enrolled in Biology, then he attends class.",
            "If John is not late, he passes the exam.",
            "If John studies hard, he is smart.",
            "If someone is enrolled in a course, then they attend class.",
            "If someone attends class, they are not late.",
            "If John is enrolled in Biology and takes Biology, then he studies hard.",
            "John is smart.",
            "John is taking Biology and attended the class.",
            "John studies hard.",
            "John is not late."
        ],
        "premises-FOL": [
            "HighIQ(john) ::: John has a high IQ.",
            "Enrolled(john, biology) ::: John is enrolled in Biology.",
            "TakesCourse(john, biology) ::: John takes Biology.",
            "Professor(smith) ∧ Teaches(smith, biology) ::: Professor Smith teaches Biology.",
            "∀x ∀y ∀z (Enrolled(x, y) ∧ TakesCourse(x, y) ∧ Teaches(z, y) → StudyHard(x)) ::: If someone is enrolled in a course and takes that course, and the course is taught by a professor, then they study hard.",
            "∀x (HighIQ(x) ∧ StudyHard(x) → BecomeDoctor(x)) ::: If someone has a high IQ and studies hard, they become a doctor.",
            "Smart(john) ∧ AttendsClass(john) → ¬Late(john) ::: If John is smart and attends class, then he is not late.",
            "Enrolled(john, biology) → AttendsClass(john) ::: If John is enrolled in Biology, then he attends class.",
            "¬Late(john) → PassExam(john) ::: If John is not late, he passes the exam.",
            "StudyHard(john) → Smart(john) ::: If John studies hard, he is smart.",
            "∀x ∀y (Enrolled(x, y) → AttendsClass(x)) ::: If someone is enrolled in a course, then they attend class.",
            "∀x (AttendsClass(x) → ¬Late(x)) ::: If someone attends class, they are not late.",
            "Enrolled(john, biology) ∧ TakesCourse(john, biology) → StudyHard(john) ::: If John is enrolled in Biology and takes Biology, then he studies hard.",
            "Smart(john) ::: John is smart.",
            "TakesCourse(john, biology) ∧ AttendsClass(john) ::: John is taking Biology and attended the class.",
            "StudyHard(john) ::: John studies hard.",
            "¬Late(john) ::: John is not late."
        ],
        "predicates": [
            "HighIQ(x) ::: x has a high IQ",
            "StudyHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "BecomeDoctor(x) ::: x becomes a doctor",
            "Smart(x) ::: x is smart",
            "Enrolled(x, y) ::: x is enrolled in y",
            "TakesCourse(x, y) ::: x takes course y",
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches course y",
            "AttendsClass(x) ::: x attends class",
            "Late(x) ::: x is late"
        ]
    },
    {
        "premises-NL": [
            "If someone loves cats, then they are happy.",
            "If someone loves dogs, then they are happy.",
            "John loves cats.",
            "John loves dogs.",
            "If someone loves something, they have it as a pet.",
            "If someone loves cats and dogs, then they have pets.",
            "If John loves something and has a pet, he is happy.",
            "Everyone who has a cat is happy.",
            "John is happy.",
            "Cats are pets.",
            "Dogs are pets.",
            "If someone has a pet, then they love it.",
            "John has a cat and a dog.",
            "If someone is happy and has a cat, then they love cats."
        ],
        "premises-FOL": [
            "∀x (Loves(x, cats) → Happy(x)) ::: If someone loves cats, then they are happy.",
            "∀x (Loves(x, dogs) → Happy(x)) ::: If someone loves dogs, then they are happy.",
            "Loves(john, cats) ::: John loves cats.",
            "Loves(john, dogs) ::: John loves dogs.",
            "∀x ∀y (Loves(x, y) → HasPet(x, y)) ::: If someone loves something, they have it as a pet.",
            "∀x (Loves(x, cats) ∧ Loves(x, dogs) → HasPet(x, y)) ::: If someone loves cats and dogs, then they have pets.",
            "∀x (Loves(john, x) ∧ HasPet(john, x) → Happy(john)) ::: If John loves something and has a pet, he is happy.",
            "∀x (HasPet(x, cats) → Happy(x)) ::: Everyone who has a cat is happy.",
            "Happy(john) ::: John is happy.",
            "HasPet(cats, x) ::: Cats are pets.",
            "HasPet(dogs, x) ::: Dogs are pets.",
            "∀x ∀y (HasPet(x, y) → Loves(x, y)) ::: If someone has a pet, then they love it.",
            "HasPet(john, cats) ∧ HasPet(john, dogs) ::: John has a cat and a dog.",
            "∀x (Happy(x) ∧ HasPet(x, cats) → Loves(x, cats)) ::: If someone is happy and has a cat, then they love cats."
        ],
        "predicates": [
            "Loves(x, y) ::: x loves y",
            "Cat(x) ::: x is a cat",
            "Dog(x) ::: x is a dog",
            "Happy(x) ::: x is happy",
            "HasPet(x, y) ::: x has pet y"
        ]
    },
    {
        "premises-NL": [
            "Alex studies.",
            "If Alex studies, Alex prepares well.",
            "If Alex prepares well, Alex will pass the exam.",
            "Alex takes the exam.",
            "If someone is smart and takes the exam, they will pass the exam.",
            "Alex is smart.",
            "Someone who prepares well takes the exam.",
            "Alex prepares well.",
            "Everyone who takes the exam gets a grade.",
            "If someone does not pass the exam, they fail.",
            "Alex does not fail the exam."
        ],
        "premises-FOL": [
            "Study(alex) ::: Alex studies.",
            "Study(alex) → PreparesWell(alex) ::: If Alex studies, Alex prepares well.",
            "PreparesWell(alex) → Pass(alex) ::: If Alex prepares well, Alex will pass the exam.",
            "TakesExam(alex) ::: Alex takes the exam.",
            "Smart(x) ∧ TakesExam(x) → Pass(x) ::: If someone is smart and takes the exam, they will pass the exam.",
            "Smart(alex) ::: Alex is smart.",
            "PreparesWell(x) → TakesExam(x) ::: Someone who prepares well takes the exam.",
            "PreparesWell(alex) ::: Alex prepares well.",
            "∀x(TakesExam(x) → HasGrade(x)) ::: Everyone who takes the exam gets a grade.",
            "¬Pass(x) → Fail(x) ::: If someone does not pass the exam, they fail.",
            "¬Fail(alex) ::: Alex does not fail the exam."
        ],
        "predicates": [
            "Study(x) ::: x studies",
            "Pass(x) ::: x passes the exam",
            "TakesExam(x) ::: x takes the exam",
            "Smart(x) ::: x is smart",
            "PreparesWell(x) ::: x prepares well"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "Anyone who treats someone, helps them.",
            "Some humans are patients.",
            "Some humans have a disease.",
            "If someone has a disease, then they are sick.",
            "If someone is a patient, they are human.",
            "Anyone who is a doctor is a human.",
            "John is a doctor.",
            "If John treats someone, then John helps them.",
            "Everyone who is sick is a patient.",
            "John treats Mary.",
            "Mary is sick.",
            "John is a human.",
            "Mary is a human."
        ],
        "premises-FOL": [
            "∀x∀y(Doctor(x) ∧ Patient(y) → Treats(x, y)) ::: All doctors treat patients.",
            "∀x∀y(Treats(x, y) → Helps(x, y)) ::: Anyone who treats someone, helps them.",
            "∃x(Patient(x) ∧ IsHuman(x)) ::: Some humans are patients.",
            "∃x∃y(IsHuman(x) ∧ HasDisease(x, y)) ::: Some humans have a disease.",
            "∀x∀y(HasDisease(x, y) → IsSick(x)) ::: If someone has a disease, then they are sick.",
            "∀x(Patient(x) → IsHuman(x)) ::: If someone is a patient, they are human.",
            "∀x(Doctor(x) → IsHuman(x)) ::: Anyone who is a doctor is a human.",
            "Doctor(john) ::: John is a doctor.",
            "Treats(john, x) → Helps(john, x) ::: If John treats someone, then John helps them.",
            "∀x(IsSick(x) → Patient(x)) ::: Everyone who is sick is a patient.",
            "Treats(john, mary) ::: John treats Mary.",
            "IsSick(mary) ::: Mary is sick.",
            "IsHuman(john) ::: John is a human.",
            "IsHuman(mary) ::: Mary is a human."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Patient(x) ::: x is a patient",
            "Helps(x, y) ::: x helps y",
            "Treats(x, y) ::: x treats y",
            "HasDisease(x, y) ::: x has disease y",
            "IsSick(x) ::: x is sick",
            "IsHuman(x) ::: x is a human"
        ]
    },
    {
        "premises-NL": [
            "If someone loves someone, they are friendly.",
            "John loves Mary.",
            "Mary is friendly.",
            "Anyone who loves someone is friendly.",
            "If John loves Mary, then Mary loves John.",
            "Mary loves John.",
            "If someone hates John, John does not love them.",
            "Everyone is a person.",
            "No one hates John.",
            "Anyone who is friendly loves John.",
            "John is a person.",
            "Mary is a person.",
            "If someone does not love John, they hate him."
        ],
        "premises-FOL": [
            "∀x ∀y (Loves(x, y) → Friendly(x)) ::: If someone loves someone, they are friendly.",
            "Loves(John, Mary) ::: John loves Mary.",
            "Friendly(Mary) ::: Mary is friendly.",
            "∀x ∀y (Loves(x, y) → Friendly(x)) ::: Anyone who loves someone is friendly.",
            "Loves(John, Mary) → Loves(Mary, John) ::: If John loves Mary, then Mary loves John.",
            "Loves(Mary, John) ::: Mary loves John.",
            "∀x (Hates(x, John) → ¬Loves(John, x)) ::: If someone hates John, John does not love them.",
            "∀x Person(x) ::: Everyone is a person.",
            "¬∃x Hates(x, John) ::: No one hates John.",
            "∀x (Friendly(x) → Loves(x, John)) ::: Anyone who is friendly loves John.",
            "Person(John) ::: John is a person.",
            "Person(Mary) ::: Mary is a person.",
            "∀x (¬Loves(x, John) → Hates(x, John)) ::: If someone does not love John, they hate him."
        ],
        "predicates": [
            "Loves(x, y) ::: x loves y.",
            "Hates(x, y) ::: x hates y.",
            "Friendly(x) ::: x is friendly.",
            "Person(x) ::: x is a person."
        ]
    },
    {
        "premises-NL": [
            "John is a professor.",
            "John teaches.",
            "All professors are smart.",
            "All smart people are happy.",
            "John is smart.",
            "If someone studies a course, they are enrolled in it.",
            "If someone is enrolled in a course, they will pass its exam.",
            "If someone passes the exam, they are enrolled.",
            "If someone has a degree they have passed exams in relevant courses.",
            "Everyone that works at a university is happy.",
            "John works at a university.",
            "If someone likes coffee and is a morning person, they will sleep well.",
            "John likes coffee.",
            "John is a morning person.",
            "If someone sleeps well, they are happy."
        ],
        "premises-FOL": [
            "Professor(john) ::: John is a professor.",
            "Teaches(john) ::: John teaches.",
            "∀x (Professor(x) → Smart(x)) ::: All professors are smart.",
            "∀x (Smart(x) → Happy(x)) ::: All smart people are happy.",
            "Smart(john) ::: John is smart.",
            "∀x ∀y (Studies(x, y) → Enrolled(x, y)) ::: If someone studies a course, they are enrolled in it.",
            "∀x ∀y (Enrolled(x, y) → PassesExam(x, y)) ::: If someone is enrolled in a course, they will pass its exam.",
            "∀x ∀y (PassesExam(x, y) → Enrolled(x, y)) ::: If someone passes the exam, they are enrolled.",
            "∀x ∀y (HasDegree(x, y) → PassesExam(x, y)) ::: If someone has a degree they have passed exams in relevant courses.",
            "∀x ∀y (WorksAt(x, y) → Happy(x)) ::: Everyone that works at a university is happy.",
            "WorksAt(john, university) ::: John works at a university.",
            "∀x (CoffeeDrinker(x) ∧ MorningPerson(x) → SleepsWell(x)) ::: If someone likes coffee and is a morning person, they will sleep well.",
            "CoffeeDrinker(john) ::: John likes coffee.",
            "MorningPerson(john) ::: John is a morning person.",
            "∀x (SleepsWell(x) → Happy(x)) ::: If someone sleeps well, they are happy."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor.",
            "Teaches(x) ::: x teaches.",
            "Happy(x) ::: x is happy.",
            "Smart(x) ::: x is smart.",
            "Studies(x, y) ::: x studies y.",
            "Course(y) ::: y is a course.",
            "PassesExam(x, y) ::: x passes exam for y.",
            "Enrolled(x, y) ::: x is enrolled in y.",
            "HasDegree(x, y) ::: x has a degree in y.",
            "WorksAt(x, y) ::: x works at y.",
            "University(y) ::: y is a university.",
            "Likes(x, y) ::: x likes y.",
            "CoffeeDrinker(x) ::: x is a coffee drinker.",
            "MorningPerson(x) ::: x is a morning person.",
            "SleepsWell(x) ::: x sleeps well."
        ]
    },
    {
        "premises-NL": [
            "If John studies, he takes the exam.",
            "If John takes the exam, he must know the material.",
            "If John knows the material, he will pass.",
            "If John attends class, he studies.",
            "If John reads the textbook, he studies.",
            "If John attends class and reads the textbook, he understands the material.",
            "If John understands the material, he passes the exam.",
            "John always studies or he will not pass the exam.",
            "If John doesn't read the textbook, he does not work hard.",
            "If John works hard, he studies.",
            "If John studies, he will pass the exam or attend class.",
            "If John attends class and reads the textbook, then he must know the material.",
            "If John attends class and reads the textbook, he will pass.",
            "If John takes the exam and knows the material, then John passes.",
            "John works hard or he does not study.",
            "If John studies, he will read the textbook or attend class.",
            "John understands the material or he will not pass."
        ],
        "premises-FOL": [
            "Studies(john) → TakesExam(john) ::: If John studies, he takes the exam.",
            "TakesExam(john) → KnowsMaterial(john) ::: If John takes the exam, he must know the material.",
            "KnowsMaterial(john) → PassExam(john) ::: If John knows the material, he will pass.",
            "AttendsClass(john) → Studies(john) ::: If John attends class, he studies.",
            "ReadsTextbook(john) → Studies(john) ::: If John reads the textbook, he studies.",
            "(AttendsClass(john) ∧ ReadsTextbook(john)) → Understands(john, material) ::: If John attends class and reads the textbook, he understands the material.",
            "Understands(john, material) → PassExam(john) ::: If John understands the material, he passes the exam.",
            "Studies(john) ∨ ¬PassExam(john) ::: John always studies or he will not pass the exam.",
            "¬ReadsTextbook(john) → ¬WorksHard(john) ::: If John doesn't read the textbook, he does not work hard.",
            "WorksHard(john) → Studies(john) ::: If John works hard, he studies.",
            "Studies(john) → PassExam(john) ∨ AttendsClass(john) ::: If John studies, he will pass the exam or attend class.",
            "(AttendsClass(john) ∧ ReadsTextbook(john)) → KnowsMaterial(john) ::: If John attends class and reads the textbook, then he must know the material.",
            "(AttendsClass(john) ∧ ReadsTextbook(john)) → PassExam(john) ::: If John attends class and reads the textbook, he will pass.",
            "(TakesExam(john) ∧ KnowsMaterial(john)) → PassExam(john) ::: If John takes the exam and knows the material, then John passes.",
            "WorksHard(john) ∨ ¬Studies(john) ::: John works hard or he does not study.",
            "Studies(john) → ReadsTextbook(john) ∨ AttendsClass(john) ::: If John studies, he will read the textbook or attend class.",
            "Understands(john, material) ∨ ¬PassExam(john) ::: John understands the material or he will not pass."
        ],
        "predicates": [
            "Studies(x) ::: x studies",
            "PassExam(x) ::: x passes the exam",
            "TakesExam(x) ::: x takes the exam",
            "KnowsMaterial(x) ::: x knows the material",
            "AttendsClass(x) ::: x attends class",
            "ReadsTextbook(x) ::: x reads the textbook",
            "Understands(x, y) ::: x understands y",
            "WorksHard(x) ::: x works hard"
        ]
    },
    {
        "premises-NL": [
            "All birds have feathers.",
            "If something is a penguin, then it is a bird.",
            "All penguins live in Antarctica.",
            "Anything that lives in Antarctica cannot fly.",
            "If something is a penguin, then it cannot fly.",
            "If something has wings, it is a bird.",
            "All birds have wings.",
            "If something cannot fly, then it is a bird.",
            "If something is a penguin, then it has feathers.",
            "If something has feathers and is a bird, then it can fly.",
            "If something is a bird and cannot fly, then it is a penguin.",
            "Some birds do not fly.",
            "Penguins are birds.",
            "All things that cannot fly are not birds.",
            "If something cannot fly, it is a bird.",
            "Tweety is a penguin.",
            "Tweety lives in Antarctica."
        ],
        "premises-FOL": [
            "∀x (Bird(x) → HasFeathers(x)) ::: All birds have feathers.",
            "∀x (Penguin(x) → Bird(x)) ::: If something is a penguin, then it is a bird.",
            "∀x (Penguin(x) → LivesIn(x, antarctica)) ::: All penguins live in Antarctica.",
            "∀x (LivesIn(x, antarctica) → CannotFly(x)) ::: Anything that lives in Antarctica cannot fly.",
            "∀x (Penguin(x) → CannotFly(x)) ::: If something is a penguin, then it cannot fly.",
            "∀x (Wings(x) → Bird(x)) ::: If something has wings, it is a bird.",
            "∀x (Bird(x) → Wings(x)) ::: All birds have wings.",
            "∀x (CannotFly(x) → Bird(x)) ::: If something cannot fly, then it is a bird.",
            "∀x (Penguin(x) → HasFeathers(x)) ::: If something is a penguin, then it has feathers.",
            "∀x (HasFeathers(x) ∧ Bird(x) → Flies(x)) ::: If something has feathers and is a bird, then it can fly.",
            "∀x (Bird(x) ∧ CannotFly(x) → Penguin(x)) ::: If something is a bird and cannot fly, then it is a penguin.",
            "∃x (Bird(x) ∧ ¬Flies(x)) ::: Some birds do not fly.",
            "∀x (Penguin(x) → Bird(x)) ::: Penguins are birds.",
            "∀x (CannotFly(x) → ¬Bird(x)) ::: All things that cannot fly are not birds.",
            "∀x (CannotFly(x) → Bird(x)) ::: If something cannot fly, it is a bird.",
            "Penguin(tweety) ::: Tweety is a penguin.",
            "LivesIn(tweety, antarctica) ::: Tweety lives in Antarctica."
        ],
        "predicates": [
            "Bird(x) ::: x is a bird",
            "Flies(x) ::: x can fly",
            "Wings(x) ::: x has wings",
            "Penguin(x) ::: x is a penguin",
            "HasFeathers(x) ::: x has feathers",
            "LivesIn(x, y) ::: x lives in y",
            "Antarctic(x) ::: x is in Antarctica",
            "CannotFly(x) ::: x cannot fly"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "Doctors specialized in cardiology are doctors.",
            "All doctors are healthcare professionals.",
            "Some doctors work at a hospital.",
            "If someone is a surgeon, then they are a doctor.",
            "If someone is a doctor and works at a hospital, then they are a healthcare professional.",
            "If someone is a doctor and specialized in cardiology, then they are a healthcare professional."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (SpecializedIn(x, Cardiology) ∧ Doctor(x) → Doctor(x)) ::: Doctors specialized in cardiology are doctors.",
            "∀x (Doctor(x) → HealthcareProfessional(x)) ::: All doctors are healthcare professionals.",
            "∃x ∃y (Doctor(x) ∧ WorksAtHospital(x, y)) ::: Some doctors work at a hospital.",
            "∀x (Surgeon(x) → Doctor(x)) ::: If someone is a surgeon, then they are a doctor.",
            "∀x ∀y ((Doctor(x) ∧ WorksAtHospital(x, y)) → HealthcareProfessional(x)) ::: If someone is a doctor and works at a hospital, then they are a healthcare professional.",
            "∀x (SpecializedIn(x, Cardiology) ∧ Doctor(x) → HealthcareProfessional(x)) ::: If someone is a doctor and specialized in cardiology, then they are a healthcare professional."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Surgeon(x) ::: x is a surgeon.",
            "HealthcareProfessional(x) ::: x is a healthcare professional.",
            "SpecializedIn(x, y) ::: Doctor x is specialized in y.",
            "Cardiology(x) ::: x is in cardiology.",
            "WorksAtHospital(x, y) ::: x works at hospital y.",
            "Hospital(y) ::: y is a hospital."
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled.",
            "Alice is a student.",
            "If someone is enrolled, then they study.",
            "If someone studies, then they have a book.",
            "If someone has a book, then they are intelligent.",
            "If someone is intelligent, then they are enrolled.",
            "If a student does not study, they are not enrolled.",
            "If someone is not a student, then they are a professor.",
            "If someone is a professor and they are not a student, then they study.",
            "If someone studies and is not a student, they have a book.",
            "If someone has a book, they are not a student.",
            "If someone is enrolled, then they are a student.",
            "If Alice is enrolled, then Alice is enrolled.",
            "If someone studies, then Alice is enrolled.",
            "If Alice is a student, then Alice studies.",
            "If someone is not a professor, then Alice studies."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x)) ::: All students are enrolled",
            "Student(Alice) ::: Alice is a student",
            "∀x (Enrolled(x) → Studies(x)) ::: If someone is enrolled, then they study",
            "∀x (Studies(x) → HasBook(x,y)) ::: If someone studies, then they have a book",
            "∀x (HasBook(x, y) → Intelligent(x)) ::: If someone has a book, then they are intelligent",
            "∀x (Intelligent(x) → Enrolled(x)) ::: If someone is intelligent, then they are enrolled",
            "∀x (Student(x) ∧ ¬Studies(x) → ¬Enrolled(x)) ::: If a student does not study, they are not enrolled",
            "∀x (¬Student(x) → Professor(x)) ::: If someone is not a student, then they are a professor",
            "∀x (Professor(x) ∧ ¬Student(x) → Studies(x)) ::: If someone is a professor and they are not a student, then they study",
            "∀x (Studies(x) ∧ ¬Student(x) → HasBook(x, y)) ::: If someone studies and is not a student, they have a book",
            "∀x (HasBook(x, y) → ¬Student(x)) ::: If someone has a book, they are not a student",
            "∀x (Enrolled(x) → Student(x)) ::: If someone is enrolled, then they are a student",
            "Enrolled(Alice) → Enrolled(Alice) ::: If Alice is enrolled, then Alice is enrolled",
            "Studies(x) → Enrolled(Alice) ::: If someone studies, then Alice is enrolled",
            "Student(Alice) → Studies(Alice) ::: If Alice is a student, then Alice studies",
            "¬Professor(x) → Studies(Alice) ::: If someone is not a professor, then Alice studies"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x) ::: x is enrolled",
            "Studies(x) ::: x studies",
            "HasBook(x, y) ::: x has y",
            "Professor(x) ::: x is a professor"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard will pass the exam.",
            "John is a student.",
            "John studies hard.",
            "All smart students pass the exam.",
            "John is enrolled in the Biology course.",
            "If someone is a student, and studies hard, then they are smart.",
            "Students in Biology study hard.",
            "If John is enrolled in a course, he is a student.",
            "Every student is smart or studies hard.",
            "John does not have to study hard to pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ HardStudy(x) → PassExam(x)) ::: All students who study hard will pass the exam.",
            "Student(john) ::: John is a student.",
            "HardStudy(john) ::: John studies hard.",
            "∀x (Smart(x) → PassExam(x)) ::: All smart students pass the exam.",
            "Enrolled(john, biology) ::: John is enrolled in the Biology course.",
            "∀x (Student(x) ∧ HardStudy(x) → Smart(x)) ::: If someone is a student, and studies hard, then they are smart.",
            "∀x (Student(x) ∧ Enrolled(x, biology) → HardStudy(x)) ::: Students in Biology study hard.",
            "∀x (Enrolled(x, y) → Student(x)) ::: If John is enrolled in a course, he is a student.",
            "∀x (Student(x) → Smart(x) ∨ HardStudy(x)) ::: Every student is smart or studies hard.",
            "¬HardStudy(john) → PassExam(john) ::: John does not have to study hard to pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "HardStudy(x) ::: x studies hard.",
            "PassExam(x) ::: x passes the exam.",
            "Smart(x) ::: x is smart.",
            "Enrolled(x, y) ::: x is enrolled in course y."
        ]
    },
    {
        "premises-NL": [
            "All doctors who know about the outbreak are treating patients.",
            "Some doctors know about the outbreak.",
            "All specialists are doctors.",
            "Some specialists know about the outbreak.",
            "Some doctors are specialists.",
            "All infected people live in the affected area.",
            "All doctors are from the same country.",
            "All doctors attend the conference.",
            "All conference attendees are experts on the outbreak.",
            "Some doctors are researchers.",
            "Patient is infected."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) ∧ KnowsAboutOutbreak(x) → TreatsPatients(x)) ::: All doctors who know about the outbreak are treating patients.",
            "∃x (Doctor(x) ∧ KnowsAboutOutbreak(x)) ::: Some doctors know about the outbreak.",
            "∀x (Specialist(x) → Doctor(x)) ::: All specialists are doctors.",
            "∃x (Specialist(x) ∧ KnowsAboutOutbreak(x)) ::: Some specialists know about the outbreak.",
            "∃x (Doctor(x) ∧ Specialist(x)) ::: Some doctors are specialists.",
            "∀x (Infected(x) → LivesIn(x, affected_area)) ::: All infected people live in the affected area.",
            "∀x ∃y (Doctor(x) → From(x, y)) ::: All doctors are from the same country.",
            "∀x (Doctor(x) → AttendsConference(x)) ::: All doctors attend the conference.",
            "∀x (AttendsConference(x) → Expert(x, outbreak)) ::: All conference attendees are experts on the outbreak.",
            "∃x (Doctor(x) ∧ Researcher(x)) ::: Some doctors are researchers.",
            "Infected(patient) ::: Patient is infected."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "KnowsAboutOutbreak(x) ::: x knows about the outbreak.",
            "TreatsPatients(x) ::: x treats patients.",
            "Infected(x) ::: x is infected.",
            "Specialist(x) ::: x is a specialist.",
            "LivesIn(x, y) ::: x lives in y.",
            "From(x, y) ::: x is from y.",
            "AttendsConference(x) ::: x attends conference.",
            "Expert(x,y) ::: x is expert in y.",
            "Researcher(x) ::: x is a researcher.",
            "Infected(patient) ::: patient is infected."
        ]
    },
    {
        "premises-NL": [
            "All teachers are tall.",
            "Some teachers like sports.",
            "All who are tall are not students.",
            "If someone likes sports, they have a pet.",
            "If someone has a pet, they are old.",
            "All old people do not study.",
            "Anyone who studies lives in a city.",
            "Anyone who lives in a city is not employed.",
            "Anyone who is employed is a teacher.",
            "If someone makes friends, they are happy.",
            "If someone is happy, they are not a student.",
            "All teachers make friends.",
            "All the teachers like sports."
        ],
        "premises-FOL": [
            "∀x (Teacher(x) → IsTall(x)) ::: All teachers are tall.",
            "∃x (Teacher(x) ∧ PlaysSport(x)) ::: Some teachers like sports.",
            "∀x (IsTall(x) → ¬Student(x)) ::: All who are tall are not students.",
            "∀x (PlaysSport(x) → HasPet(x)) ::: If someone likes sports, they have a pet.",
            "∀x (HasPet(x) → IsOld(x)) ::: If someone has a pet, they are old.",
            "∀x (IsOld(x) → ¬Studies(x, y)) ::: All old people do not study.",
            "∀x (Studies(x, y) → LivesIn(x, city)) ::: Anyone who studies lives in a city.",
            "∀x (LivesIn(x, city) → ¬IsEmployed(x)) ::: Anyone who lives in a city is not employed.",
            "∀x (IsEmployed(x) → Teacher(x)) ::: Anyone who is employed is a teacher.",
            "∀x (MakesFriend(x, y) → IsHappy(x)) ::: If someone makes friends, they are happy.",
            "∀x (IsHappy(x) → ¬Student(x)) ::: If someone is happy, they are not a student.",
            "∀x (Teacher(x) → MakesFriend(x, y)) ::: All teachers make friends.",
            "∀x (Teacher(x) → PlaysSport(x)) ::: All the teachers like sports."
        ],
        "predicates": [
            "Teacher(x) ::: x is a teacher.",
            "Student(x) ::: x is a student.",
            "Teaches(x, y) ::: x teaches y.",
            "Likes(x, y) ::: x likes y.",
            "IsTall(x) ::: x is tall.",
            "PlaysSport(x) ::: x plays a sport.",
            "HasPet(x) ::: x has a pet.",
            "IsOld(x) ::: x is old.",
            "Studies(x,y) ::: x studies subject y.",
            "LivesIn(x, y) ::: x lives in y.",
            "IsEmployed(x) ::: x is employed.",
            "MakesFriend(x, y) ::: x makes friend with y.",
            "IsHappy(x) ::: x is happy."
        ]
    },
    {
        "premises-NL": [
            "All doctors are scientists or researchers.",
            "All scientists are doctors.",
            "Anyone who researches a disease knows the cure.",
            "If someone cures a disease, they know the cure.",
            "Anyone who publishes a paper on a disease knows the cure.",
            "All doctors works at hospital.",
            "Anyone who is at a conference is an expert.",
            "Anyone who is a scientist graduated from a good university.",
            "Anyone who works at a lab develops medicine.",
            "Anyone who develops medicine is a scientist.",
            "All doctors attends the meeting.",
            "All the experts works at the lab.",
            "Anyone who researches a disease attends the meeting.",
            "All the doctors believe that the cure exists."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Scientist(x) ∨ Researches(x, y)) ::: All doctors are scientists or researchers.",
            "∀x (Scientist(x) → Doctor(x)) ::: All scientists are doctors.",
            "∀x (Researches(x, y) → KnowsCure(x)) ::: Anyone who researches a disease knows the cure.",
            "∀x (CuresDisease(x, y) → KnowsCure(x)) ::: If someone cures a disease, they know the cure.",
            "∀x (PublishesPaper(x, y) → KnowsCure(x)) ::: Anyone who publishes a paper on a disease knows the cure.",
            "∀x (Doctor(x) → WorksAtHospital(x)) ::: All doctors works at hospital.",
            "∀x (AtConference(x) → IsExpertIn(x, y)) ::: Anyone who is at a conference is an expert.",
            "∀x (Scientist(x) → GraduatedFrom(x, good_university)) ::: Anyone who is a scientist graduated from a good university.",
            "∀x (WorksAtLab(x) → DevelopsMedicine(x)) ::: Anyone who works at a lab develops medicine.",
            "∀x (DevelopsMedicine(x) → Scientist(x)) ::: Anyone who develops medicine is a scientist.",
            "∀x (Doctor(x) → AttendsMeeting(x)) ::: All doctors attends the meeting.",
            "∀x (IsExpertIn(x, y) → WorksAtLab(x)) ::: All the experts works at the lab.",
            "∀x (Researches(x, y) → AttendsMeeting(x)) ::: Anyone who researches a disease attends the meeting.",
            "∀x (Doctor(x) → Believes(x, cure_exists)) ::: All the doctors believe that the cure exists."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Scientist(x) ::: x is a scientist.",
            "KnowsCure(x) ::: x knows the cure.",
            "Researches(x, y) ::: x researches y.",
            "CuresDisease(x, y) ::: x cures disease y.",
            "PublishesPaper(x, y) ::: x publishes paper on y.",
            "WorksAtHospital(x) ::: x works at a hospital.",
            "AtConference(x) ::: x is at a conference.",
            "IsExpertIn(x, y) ::: x is expert in y.",
            "GraduatedFrom(x, y) ::: x graduated from university y.",
            "WorksAtLab(x) ::: x works at lab.",
            "DevelopsMedicine(x) ::: x develops medicine.",
            "AttendsMeeting(x) ::: x attends meeting.",
            "Believes(x,y) ::: x believes y."
        ]
    },
    {
        "premises-NL": [
            "All students who study hard attend classes.",
            "Anyone who attends classes understands the material.",
            "If a student understands the material, they will pass their exams.",
            "No one who studies hard fails their exams.",
            "Alice is a student.",
            "Alice studies hard.",
            "Bob is a student.",
            "Bob does not fail his exams.",
            "All students who attend classes study hard.",
            "If Bob attends classes, then he studies hard.",
            "If Bob does not fail his exams, then he attends classes."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) → AttendsClasses(x)) ::: All students who study hard attend classes.",
            "∀x (AttendsClasses(x) → UnderstandsMaterial(x)) ::: Anyone who attends classes understands the material.",
            "∀x (UnderstandsMaterial(x) → PassesExams(x)) ::: If a student understands the material, they will pass their exams.",
            "∀x (StudiesHard(x) → ¬FailsExam(x)) ::: No one who studies hard fails their exams.",
            "Student(alice) ::: Alice is a student.",
            "StudiesHard(alice) ::: Alice studies hard.",
            "Student(bob) ::: Bob is a student.",
            "¬FailsExam(bob) ::: Bob does not fail his exams.",
            "∀x (Student(x) ∧ AttendsClasses(x) → StudiesHard(x)) ::: All students who attend classes study hard.",
            "AttendsClasses(bob) → StudiesHard(bob) ::: If Bob attends classes, then he studies hard.",
            "¬FailsExam(bob) → AttendsClasses(bob) ::: If Bob does not fail his exams, then he attends classes."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "FailsExam(x) ::: x fails exam",
            "PassesExams(x) ::: x passes exams",
            "AttendsClasses(x) ::: x attends classes",
            "UnderstandsMaterial(x) ::: x understands the material"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "All researchers publish papers.",
            "Anyone who treats patients works at the hospital.",
            "Anyone who publishes papers works at the university.",
            "If someone is a doctor, and a researcher, then they are respected.",
            "If someone is respected, then they treat patients or publish papers.",
            "Doctor John is a doctor.",
            "Researcher John is a researcher.",
            "John is respected.",
            "All respected people treat patients or publish papers.",
            "If John treats patients, then he works at the hospital.",
            "If John publishes papers, then he works at the university.",
            "If someone is a doctor and a researcher, they are respected."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → TreatsPatients(x)) ::: All doctors treat patients.",
            "∀x (Researcher(x) → PublishesPapers(x)) ::: All researchers publish papers.",
            "∀x (TreatsPatients(x) → WorksAtHospital(x)) ::: Anyone who treats patients works at the hospital.",
            "∀x (PublishesPapers(x) → WorksAtUniversity(x)) ::: Anyone who publishes papers works at the university.",
            "∀x ((Doctor(x) ∧ Researcher(x)) → Respected(x)) ::: If someone is a doctor, and a researcher, then they are respected.",
            "∀x (Respected(x) → (TreatsPatients(x) ∨ PublishesPapers(x))) ::: If someone is respected, then they treat patients or publish papers.",
            "Doctor(john) ::: Doctor John is a doctor.",
            "Researcher(john) ::: Researcher John is a researcher.",
            "Respected(john) ::: John is respected.",
            "∀x (Respected(x) → (TreatsPatients(x) ∨ PublishesPapers(x))) ::: All respected people treat patients or publish papers.",
            "TreatsPatients(john) → WorksAtHospital(john) ::: If John treats patients, then he works at the hospital.",
            "PublishesPapers(john) → WorksAtUniversity(john) ::: If John publishes papers, then he works at the university.",
            "∀x ((Doctor(x) ∧ Researcher(x)) → Respected(x)) ::: If someone is a doctor and a researcher, they are respected."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Researcher(x) ::: x is a researcher",
            "Respected(x) ::: x is respected",
            "WorksAtHospital(x) ::: x works at the hospital",
            "WorksAtUniversity(x) ::: x works at the university",
            "PublishesPapers(x) ::: x publishes papers",
            "TreatsPatients(x) ::: x treats patients"
        ]
    },
    {
        "premises-NL": [
            "All plants either receive sunlight or need sunlight.",
            "All plants either receive water or need water.",
            "If a plant needs sunlight, it also needs water.",
            "If a plant needs water, it does not grow.",
            "Cacti are plants.",
            "Cacti do not need water.",
            "Any plant that receives sunlight grows.",
            "Any plant that receives water grows.",
            "Plants that need sunlight, also need water.",
            "A plant that doesn't receive water is a cactus.",
            "A plant either receives sunlight or water.",
            "A plant receives water if it is not a cactus.",
            "No cactus receives water."
        ],
        "premises-FOL": [
            "∀x (Plant(x) → (Sunlight(x) ∨ NeedsSunlight(x))) ::: All plants either receive sunlight or need sunlight.",
            "∀x (Plant(x) → (Water(x) ∨ NeedsWater(x))) ::: All plants either receive water or need water.",
            "∀x (NeedsSunlight(x) → NeedsWater(x)) ::: If a plant needs sunlight, it also needs water.",
            "∀x (NeedsWater(x) → ¬Grows(x)) ::: If a plant needs water, it does not grow.",
            "∀x (Cactus(x) → Plant(x)) ::: Cacti are plants.",
            "∀x (Cactus(x) → ¬NeedsWater(x)) ::: Cacti do not need water.",
            "∀x (Sunlight(x) → Grows(x)) ::: Any plant that receives sunlight grows.",
            "∀x (Water(x) → Grows(x)) ::: Any plant that receives water grows.",
            "∀x (NeedsSunlight(x) → NeedsWater(x)) ::: Plants that need sunlight, also need water.",
            "∀x (¬Water(x) → Cactus(x)) ::: A plant that doesn't receive water is a cactus.",
            "∀x (Plant(x) → (Sunlight(x) ∨ Water(x))) ::: A plant either receives sunlight or water.",
            "∀x (Plant(x) ∧ ¬Cactus(x) → Water(x)) ::: A plant receives water if it is not a cactus.",
            "∀x (Cactus(x) → ¬Water(x)) ::: No cactus receives water."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "Sunlight(x) ::: x receives sunlight",
            "Water(x) ::: x receives water",
            "Grows(x) ::: x grows",
            "Cactus(x) ::: x is a cactus",
            "NeedsSunlight(x) ::: x needs sunlight",
            "NeedsWater(x) ::: x needs water"
        ]
    },
    {
        "premises-NL": [
            "All good employees work hard.",
            "Anyone who works hard is efficient.",
            "If an employee is efficient, they will get a promotion.",
            "If an employee has skills, they are a good employee.",
            "Everyone who works hard, meets deadlines.",
            "If someone is a good employee, and is efficient, they get promoted.",
            "All good employees have skills.",
            "If an employee is efficient, then they works hard.",
            "Every good employee is an employee.",
            "If an employee works hard and has skills, they are good.",
            "Every good employee is efficient.",
            "If an employee meets deadlines, then they work hard.",
            "Every efficient employee works hard.",
            "If they work hard, and are a good employee, then they get a promotion."
        ],
        "premises-FOL": [
            "∀x (GoodEmployee(x) → WorksHard(x)) ::: All good employees work hard.",
            "∀x (WorksHard(x) → Efficient(x)) ::: Anyone who works hard is efficient.",
            "∀x (Efficient(x) → GetsPromotion(x)) ::: If an employee is efficient, they will get a promotion.",
            "∀x (HasSkills(x) → GoodEmployee(x)) ::: If an employee has skills, they are a good employee.",
            "∀x (WorksHard(x) → MeetsDeadlines(x)) ::: Everyone who works hard, meets deadlines.",
            "∀x ((GoodEmployee(x) ∧ Efficient(x)) → GetsPromotion(x)) ::: If someone is a good employee, and is efficient, they get promoted.",
            "∀x (GoodEmployee(x) → HasSkills(x)) ::: All good employees have skills.",
            "∀x (Efficient(x) → WorksHard(x)) ::: If an employee is efficient, then they works hard.",
            "∀x (GoodEmployee(x) → Employee(x)) ::: Every good employee is an employee.",
            "∀x ((WorksHard(x) ∧ HasSkills(x)) → GoodEmployee(x)) ::: If an employee works hard and has skills, they are good.",
            "∀x (GoodEmployee(x) → Efficient(x)) ::: Every good employee is efficient.",
            "∀x (MeetsDeadlines(x) → WorksHard(x)) ::: If an employee meets deadlines, then they work hard.",
            "∀x (Efficient(x) → WorksHard(x)) ::: Every efficient employee works hard.",
            "∀x ((WorksHard(x) ∧ GoodEmployee(x)) → GetsPromotion(x)) ::: If they work hard, and are a good employee, then they get a promotion."
        ],
        "predicates": [
            "Employee(x) ::: x is an employee",
            "GoodEmployee(x) ::: x is a good employee",
            "Efficient(x) ::: x is efficient",
            "GetsPromotion(x) ::: x gets a promotion",
            "WorksHard(x) ::: x works hard",
            "MeetsDeadlines(x) ::: x meets deadlines",
            "HasSkills(x) ::: x has skills"
        ]
    },
    {
        "premises-NL": [
            "All species that can swim have fins.",
            "Any species with fins can live in water.",
            "If a species is aquatic, then it can swim and has gills.",
            "If a species has gills, it can live in water.",
            "Species A can swim.",
            "Species A has fins.",
            "Species A eats plants.",
            "All species that have fins can swim.",
            "If a species can swim, it is aquatic.",
            "If a species eats plants, it is aquatic.",
            "Species A is aquatic.",
            "If something has gills, it is aquatic.",
            "If it can swim and has fins, then it can live in water.",
            "If a species is aquatic, then it has fins or eats plants.",
            "If a species has fins and eats plants, then it is aquatic."
        ],
        "premises-FOL": [
            "∀x (CanSwim(x) → HasFins(x)) ::: All species that can swim have fins.",
            "∀x (HasFins(x) → CanLiveInWater(x)) ::: Any species with fins can live in water.",
            "∀x (IsAquatic(x) → (CanSwim(x) ∧ HasGills(x))) ::: If a species is aquatic, then it can swim and has gills.",
            "∀x (HasGills(x) → CanLiveInWater(x)) ::: If a species has gills, it can live in water.",
            "CanSwim(a) ::: Species A can swim.",
            "HasFins(a) ::: Species A has fins.",
            "EatsPlants(a) ::: Species A eats plants.",
            "∀x (HasFins(x) → CanSwim(x)) ::: All species that have fins can swim.",
            "∀x (CanSwim(x) → IsAquatic(x)) ::: If a species can swim, it is aquatic.",
            "∀x (EatsPlants(x) → IsAquatic(x)) ::: If a species eats plants, it is aquatic.",
            "IsAquatic(a) ::: Species A is aquatic.",
            "∀x (HasGills(x) → IsAquatic(x)) ::: If something has gills, it is aquatic.",
            "∀x ((CanSwim(x) ∧ HasFins(x)) → CanLiveInWater(x)) ::: If it can swim and has fins, then it can live in water.",
            "∀x (IsAquatic(x) → (HasFins(x) ∨ EatsPlants(x))) ::: If a species is aquatic, then it has fins or eats plants.",
            "∀x ((HasFins(x) ∧ EatsPlants(x)) → IsAquatic(x)) ::: If a species has fins and eats plants, then it is aquatic."
        ],
        "predicates": [
            "Species(x) ::: x is a species",
            "CanSwim(x) ::: x can swim",
            "HasFins(x) ::: x has fins",
            "CanLiveInWater(x) ::: x can live in water",
            "IsAquatic(x) ::: x is aquatic",
            "HasGills(x) ::: x has gills",
            "EatsPlants(x) ::: x eats plants"
        ]
    },
    {
        "premises-NL": [
            "All students are either smart or not.",
            "Every student who studies hard is either smart or gets help.",
            "A student succeeds if they are smart.",
            "A student succeeds if they have resources.",
            "Someone who gets help has resources.",
            "Anyone who is smart has resources.",
            "John is a student and studies hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (IsSmart(x) ∨ ¬IsSmart(x))) ::: All students are either smart or not.",
            "∀x (Student(x) ∧ StudiesHard(x) → (IsSmart(x) ∨ GetsHelp(x))) ::: Every student who studies hard is either smart or gets help.",
            "∀x (Student(x) ∧ IsSmart(x) → Succeeds(x)) ::: A student succeeds if they are smart.",
            "∀x (Student(x) ∧ HasResources(x) → Succeeds(x)) ::: A student succeeds if they have resources.",
            "∀x (GetsHelp(x) → HasResources(x)) ::: Someone who gets help has resources.",
            "∀x (IsSmart(x) → HasResources(x)) ::: Anyone who is smart has resources.",
            "Student(john) ∧ StudiesHard(john) ::: John is a student and studies hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesHard(x) ::: x studies hard.",
            "Succeeds(x) ::: x succeeds.",
            "GetsHelp(x) ::: x gets help.",
            "HasResources(x) ::: x has resources.",
            "IsSmart(x) ::: x is smart."
        ]
    },
    {
        "premises-NL": [
            "If a company invests in marketing, its strategy is effective.",
            "If a company's market is not competitive, its market is receptive.",
            "If a company has a good product and employs skilled workers, then they invest in marketing.",
            "A company either makes a profit or does not increase revenue.",
            "A company increases revenue if it has an effective strategy.",
            "Every company with a receptive market either makes a profit or doesn't have an effective strategy.",
            "Any company either invests in marketing or has a competitive market.",
            "Company X has a good product and employs skilled workers.",
            "Company X is a company."
        ],
        "premises-FOL": [
            "∀x (Company(x) ∧ InvestsInMarketing(x) → EffectiveStrategy(x)) ::: If a company invests in marketing, its strategy is effective.",
            "∀x (Company(x) ∧ ¬CompetitiveMarket(x) → ReceptiveMarket(x)) ::: If a company's market is not competitive, its market is receptive.",
            "∀x (Company(x) ∧ HasGoodProduct(x) ∧ EmploysSkilledWorkers(x) → InvestsInMarketing(x)) ::: If a company has a good product and employs skilled workers, then they invest in marketing.",
            "∀x (Company(x) → (MakesProfit(x) ∨ ¬IncreasesRevenue(x))) ::: A company either makes a profit or does not increase revenue.",
            "∀x (Company(x) ∧ EffectiveStrategy(x) → IncreasesRevenue(x)) ::: A company increases revenue if it has an effective strategy.",
            "∀x (Company(x) ∧ ReceptiveMarket(x) → (MakesProfit(x) ∨ ¬EffectiveStrategy(x))) ::: Every company with a receptive market either makes a profit or doesn't have an effective strategy.",
            "∀x (Company(x) → (InvestsInMarketing(x) ∨ CompetitiveMarket(x))) ::: Any company either invests in marketing or has a competitive market.",
            "HasGoodProduct(x) ∧ EmploysSkilledWorkers(x) ∧ Company(x)  ::: Company X has a good product and employs skilled workers.",
            "Company(x) ::: Company X is a company."
        ],
        "predicates": [
            "Company(x) ::: x is a company.",
            "EffectiveStrategy(x) ::: x's strategy is effective.",
            "ReceptiveMarket(x) ::: x's market is receptive.",
            "MakesProfit(x) ::: x makes a profit.",
            "InvestsInMarketing(x) ::: x invests in marketing.",
            "CompetitiveMarket(x) ::: x's market is competitive.",
            "HasGoodProduct(x) ::: x has a good product.",
            "EmploysSkilledWorkers(x) ::: x employs skilled workers.",
            "IncreasesRevenue(x) ::: x increases revenue."
        ]
    },
    {
        "premises-NL": [
            "Every person either owns a car or does not.",
            "If a person has a job and is employed in a city, the person owns a car.",
            "If a person owns a car, they have a job.",
            "Anyone who is not employed in a city lives in a city.",
            "Anyone employed in a city lives in a city.",
            "Someone does not have a job.",
            "All people are persons."
        ],
        "premises-FOL": [
            "∀x (Person(x) → (Owns(x, car) ∨ ¬Owns(x, car))) ::: Every person either owns a car or does not.",
            "∀x ∀z ((HasJob(x) ∧ Employed(x, z)) → Owns(x, car)) ::: If a person has a job and is employed in a city, the person owns a car.",
            "∀x (Owns(x, car) → HasJob(x)) ::: If a person owns a car, they have a job.",
            "∀x (¬Employed(x, city) → LivesIn(x, city)) ::: Anyone who is not employed in a city lives in a city.",
            "∀x (Employed(x, city) → LivesIn(x, city)) ::: Anyone employed in a city lives in a city.",
            "∃x ¬HasJob(x) ::: Someone does not have a job.",
            "∀x (Person(x) → Person(x)) ::: All people are persons."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Owns(x, y) ::: x owns y",
            "Car(y) ::: y is a car",
            "LivesIn(x, z) ::: x lives in z",
            "City(z) ::: z is a city",
            "HasJob(x) ::: x has a job",
            "Employed(x, z) ::: x is employed in z"
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "If Alex is a student, then Alex studies.",
            "If someone studies hard, then they are a student.",
            "If Alex studies, then Alex studies hard.",
            "Alex is a student.",
            "If someone studies hard, they pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "Student(alex) → Studies(alex, science) ::: If Alex is a student, then Alex studies.",
            "∀x (HardStudy(x) → Student(x)) ::: If someone studies hard, then they are a student.",
            "Studies(alex, science) → HardStudy(alex) ::: If Alex studies, then Alex studies hard.",
            "Student(alex) ::: Alex is a student.",
            "∀x (HardStudy(x) → PassExam(x)) ::: If someone studies hard, they pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Studies(x, y) ::: x studies y.",
            "HardStudy(x) ::: x studies hard.",
            "PassExam(x) ::: x passes the exam."
        ]
    },
    {
        "premises-NL": [
            "All programmers are experts.",
            "If someone designs software, then they are a programmer.",
            "Every expert creates a software.",
            "If someone is a programmer, then they design software.",
            "Bob is a programmer.",
            "Bob designs software.",
            "Bob is an expert."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → Expert(x)) ::: All programmers are experts.",
            "∀x (Designs(x, software) → Programmer(x)) ::: If someone designs software, then they are a programmer.",
            "∀x (Expert(x) → Creates(x, software)) ::: Every expert creates a software.",
            "∀x (Programmer(x) → Designs(x, software)) ::: If someone is a programmer, then they design software.",
            "Programmer(bob) ::: Bob is a programmer.",
            "Designs(bob, software) ::: Bob designs software.",
            "Expert(bob) ::: Bob is an expert."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer.",
            "Expert(x) ::: x is an expert.",
            "Designs(x, y) ::: x designs y.",
            "Creates(x, y) ::: x creates y.",
            "Software(x) ::: x is a software."
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "If someone is a surgeon, then they operate on patients.",
            "If a doctor treats a patient, then the patient receives care.",
            "If a patient receives care, then they have a chance to recover.",
            "If a patient has a disease and a doctor treats them, then they will recover.",
            "If someone operates on a patient, then they treat the patient.",
            "Some doctors are surgeons.",
            "If someone is a doctor, then they treat patients.",
            "If the doctor cures the disease the patient recovers.",
            "If a doctor treats the patient, the patient has a chance to recover."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x ∀y (Surgeon(x) → OperatesOn(x, y)) ::: If someone is a surgeon, then they operate on patients.",
            "∀x ∀y (Treats(x, y) → ReceivesCare(y)) ::: If a doctor treats a patient, then the patient receives care.",
            "∀x (ReceivesCare(x) → HasChanceToRecover(x)) ::: If a patient receives care, then they have a chance to recover.",
            "∀x ∀y ((HasDisease(y, disease) ∧ Treats(x, y)) → Recovers(y)) ::: If a patient has a disease and a doctor treats them, then they will recover.",
            "∀x ∀y (OperatesOn(x, y) → Treats(x, y)) ::: If someone operates on a patient, then they treat the patient.",
            "∃x (Doctor(x) ∧ Surgeon(x)) ::: Some doctors are surgeons.",
            "∀x ∀y (Doctor(x) → Treats(x, y)) ::: If someone is a doctor, then they treat patients.",
            "∀x ∀y (Cures(x, y) → Recovers(y)) ::: If the doctor cures the disease the patient recovers.",
            "∀x ∀y (Treats(x, y) → HasChanceToRecover(y)) ::: If a doctor treats the patient, the patient has a chance to recover."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Surgeon(x) ::: x is a surgeon.",
            "Patient(x) ::: x is a patient.",
            "Treats(x, y) ::: x treats y.",
            "Recovers(x) ::: x recovers.",
            "OperatesOn(x, y) ::: x operates on y.",
            "HasDisease(x, y) ::: x has disease y.",
            "Cures(x, y) ::: x cures y.",
            "Hospital(x) ::: x is a hospital."
        ]
    },
    {
        "premises-NL": [
            "Companies that invest in green technology are often seen as sustainable.",
            "Companies with a good reputation are likely to attract investors.",
            "If a company invests in green technology and has a good reputation, it is likely to attract investors.",
            "SolarTech invests in green technology.",
            "SolarTech has a good reputation.",
            "SolarTech is a company.",
            "Green tech companies often attract investors.",
            "Reputable companies always attract investors.",
            "If a company uses sustainable practices, it is often considered to have a good reputation.",
            "Companies with strong ethics often have a good reputation.",
            "Companies with a good reputation tend to be profitable.",
            "If a company is profitable, it is also a good investment.",
            "A company with good ethics will attract investors.",
            "Investing in green technology can lead to a good reputation.",
            "Companies with a good reputation attract investors, and often use sustainable practices.",
            "If a company uses sustainable practices and invests in green tech, they will attract more investors."
        ],
        "premises-FOL": [
            "∀x (InvestsInGreenTech(x) → UsesSustainablePractices(x)) ::: Companies that invest in green technology are often seen as sustainable.",
            "∀x (GoodReputation(x) → AttractsInvestors(x)) ::: Companies with a good reputation are likely to attract investors.",
            "∀x (InvestsInGreenTech(x) ∧ GoodReputation(x) → AttractsInvestors(x)) ::: If a company invests in green technology and has a good reputation, it is likely to attract investors.",
            "InvestsInGreenTech(SolarTech) ::: SolarTech invests in green technology.",
            "GoodReputation(SolarTech) ::: SolarTech has a good reputation.",
            "Company(SolarTech) ::: SolarTech is a company.",
            "∀x (InvestsInGreenTech(x) → AttractsInvestors(x)) ::: Green tech companies often attract investors.",
            "∀x (GoodReputation(x) → AttractsInvestors(x)) ::: Reputable companies always attract investors.",
            "∀x (UsesSustainablePractices(x) → GoodReputation(x)) ::: If a company uses sustainable practices, it is often considered to have a good reputation.",
            "∀x (HasStrongEthics(x) → GoodReputation(x)) ::: Companies with strong ethics often have a good reputation.",
            "∀x (GoodReputation(x) → Profitable(x)) ::: Companies with a good reputation tend to be profitable.",
            "∀x (Profitable(x) → AttractsInvestors(x)) ::: If a company is profitable, it is also a good investment.",
            "∀x (HasStrongEthics(x) → AttractsInvestors(x)) ::: A company with good ethics will attract investors.",
            "∀x (InvestsInGreenTech(x) → GoodReputation(x)) ::: Investing in green technology can lead to a good reputation.",
            "∀x (GoodReputation(x) → AttractsInvestors(x) ∧ UsesSustainablePractices(x)) ::: Companies with a good reputation attract investors, and often use sustainable practices.",
            "∀x (UsesSustainablePractices(x) ∧ InvestsInGreenTech(x) → AttractsInvestors(x)) ::: If a company uses sustainable practices and invests in green tech, they will attract more investors."
        ],
        "predicates": [
            "Company(x) ::: x is a company",
            "InvestsInGreenTech(x) ::: x invests in green technology",
            "GoodReputation(x) ::: x has a good reputation",
            "AttractsInvestors(x) ::: x attracts investors",
            "Profitable(x) ::: x is profitable",
            "UsesSustainablePractices(x) ::: x uses sustainable practices",
            "HasStrongEthics(x) ::: x has strong ethics"
        ]
    },
    {
        "premises-NL": [
            "All students are either smart or take exams.",
            "All smart people study.",
            "All who study pass exams.",
            "Some students are smart.",
            "All students who pass exams study.",
            "John is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Smart(x) ∨ TakesExam(x))) ::: All students are either smart or take exams.",
            "∀x (Smart(x) → Studies(x)) ::: All smart people study.",
            "∀x (Studies(x) → PassesExam(x)) ::: All who study pass exams.",
            "∃x (Student(x) ∧ Smart(x)) ::: Some students are smart.",
            "∀x ((Student(x) ∧ PassesExam(x)) → Studies(x)) ::: All students who pass exams study.",
            "Student(john) ::: John is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Smart(x) ::: x is smart",
            "Studies(x) ::: x studies",
            "TakesExam(x) ::: x takes an exam",
            "PassesExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "All researchers write papers.",
            "All researchers who write papers are published.",
            "Every researcher who needs funding has a grant.",
            "All published researchers need funding.",
            "Some researchers need funding.",
            "Alice is a researcher.",
            "If Alice writes a paper, then she is published."
        ],
        "premises-FOL": [
            "∀x (Researcher(x) → WritesPaper(x)) ::: All researchers write papers.",
            "∀x ((Researcher(x) ∧ WritesPaper(x)) → Published(x)) ::: All researchers who write papers are published.",
            "∀x (NeedsFunding(x) → HasGrant(x)) ::: Every researcher who needs funding has a grant.",
            "∀x (Published(x) → NeedsFunding(x)) ::: All published researchers need funding.",
            "∃x (Researcher(x) ∧ NeedsFunding(x)) ::: Some researchers need funding.",
            "Researcher(alice) ::: Alice is a researcher.",
            "WritesPaper(alice) → Published(alice) ::: If Alice writes a paper, then she is published."
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher",
            "WritesPaper(x) ::: x writes a paper",
            "Published(x) ::: x is published",
            "HasGrant(x) ::: x has a grant",
            "NeedsFunding(x) ::: x needs funding"
        ]
    },
    {
        "premises-NL": [
            "All patients with a fever cough.",
            "All patients with a cold have a sore throat.",
            "Anyone who has a fever does not have a sore throat.",
            "Anyone who coughs either has a cold or has medicine.",
            "Anyone who feels sick has either a fever or a cold.",
            "Anyone who has medicine is recovering.",
            "All recovering patients take medicine.",
            "Anyone who takes medicine does not have a fever.",
            "John is a patient."
        ],
        "premises-FOL": [
            "∀x (Fever(x) → Cough(x)) ::: All patients with a fever cough.",
            "∀x (Cold(x) → SoreThroat(x)) ::: All patients with a cold have a sore throat.",
            "∀x (Fever(x) → ¬SoreThroat(x)) ::: Anyone who has a fever does not have a sore throat.",
            "∀x (Cough(x) → (Cold(x) ∨ HasMedicine(x))) ::: Anyone who coughs either has a cold or has medicine.",
            "∀x (FeelsSick(x) → (Fever(x) ∨ Cold(x))) ::: Anyone who feels sick has either a fever or a cold.",
            "∀x (HasMedicine(x) → IsRecovering(x)) ::: Anyone who has medicine is recovering.",
            "∀x (IsRecovering(x) → TakesMedicine(x)) ::: All recovering patients take medicine.",
            "∀x (TakesMedicine(x) → ¬Fever(x)) ::: Anyone who takes medicine does not have a fever.",
            "Patient(john) ::: John is a patient."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient",
            "Fever(x) ::: x has a fever",
            "Cold(x) ::: x has a cold",
            "Cough(x) ::: x coughs",
            "SoreThroat(x) ::: x has a sore throat",
            "HasMedicine(x) ::: x has medicine",
            "FeelsSick(x) ::: x feels sick",
            "IsRecovering(x) ::: x is recovering",
            "TakesMedicine(x) ::: x takes medicine"
        ]
    },
    {
        "premises-NL": [
            "Everyone who is a software engineer writes code.",
            "All software engineers know Java or Python.",
            "Anyone who writes code uses a framework.",
            "Everyone who uses a framework enjoys coding.",
            "Anyone who enjoys coding attends conferences.",
            "Anyone who attends conferences works for a company.",
            "Anyone who knows Java doesn't attend conferences.",
            "Some people are good at algorithms.",
            "All who are good at algorithms are software engineers.",
            "Alice is a person."
        ],
        "premises-FOL": [
            "∀x (SoftwareEngineer(x) → WritesCode(x)) ::: Everyone who is a software engineer writes code.",
            "∀x (SoftwareEngineer(x) → (KnowsJava(x) ∨ KnowsPython(x))) ::: All software engineers know Java or Python.",
            "∀x ∃y (WritesCode(x) → UsesFramework(x, y)) ::: Anyone who writes code uses a framework.",
            "∀x ∃y (UsesFramework(x, y) → EnjoysCoding(x)) ::: Everyone who uses a framework enjoys coding.",
            "∀x (EnjoysCoding(x) → AttendsConferences(x)) ::: Anyone who enjoys coding attends conferences.",
            "∀x ∃y (AttendsConferences(x) → WorksForCompany(x, y)) ::: Anyone who attends conferences works for a company.",
            "∀x (KnowsJava(x) → ¬AttendsConferences(x)) ::: Anyone who knows Java doesn't attend conferences.",
            "∃x GoodAtAlgorithms(x) ::: Some people are good at algorithms.",
            "∀x (GoodAtAlgorithms(x) → SoftwareEngineer(x)) ::: All who are good at algorithms are software engineers.",
            "Person(alice) ::: Alice is a person."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "SoftwareEngineer(x) ::: x is a software engineer",
            "KnowsJava(x) ::: x knows Java",
            "KnowsPython(x) ::: x knows Python",
            "WritesCode(x) ::: x writes code",
            "UsesFramework(x,y) ::: x uses framework y",
            "EnjoysCoding(x) ::: x enjoys coding",
            "AttendsConferences(x) ::: x attends conferences",
            "WorksForCompany(x,y) ::: x works for company y",
            "GoodAtAlgorithms(x) ::: x is good at algorithms"
        ]
    },
    {
        "premises-NL": [
            "Every student studies hard or fails.",
            "Any student who fails does not pass the exam.",
            "All students are smart."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (StudiesHard(x) ∨ ¬PassesExam(x))) ::: Every student studies hard or fails.",
            "∀x (Student(x) ∧ ¬PassesExam(x) → ¬PassesExam(x)) ::: Any student who fails does not pass the exam.",
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "∀x (StudiesHard(x) → PassesExam(x)) ::: If someone studies hard, they pass the exam.",
            "∃x (Student(x)) ::: There is a student.",
            "∀x (Smart(x) → StudiesHard(x)) ::: Smart students study hard.",
            "∀x (PassesExam(x) ∨ ¬StudiesHard(x)) ::: Either someone passes the exam or they don't study hard.",
            "∀x (Student(x) ∧ ¬PassesExam(x) → ¬StudiesHard(x)) ::: If a student does not pass, they do not study hard.",
            "∀x (Student(x) ∧ StudiesHard(x) → PassesExam(x)) ::: All students who study hard will pass the exam.",
            "∀x (Student(x) → (StudiesHard(x) ∨ ¬PassesExam(x))) ::: Every student studies hard or fails."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassesExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "All students either study hard or attend classes.",
            "Some students study hard.",
            "All students who attend classes have good grades.",
            "All students with good grades pass the exam.",
            "There is a student.",
            "If a student studies hard, then they have good grades.",
            "If a student has good grades, then they pass the exam.",
            "Every student is either a programmer or a designer.",
            "No student is both a programmer and a designer.",
            "All programmers study hard.",
            "All designers attend classes.",
            "A student is a programmer.",
            "Another student attends classes."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (StudiesHard(x) ∨ AttendsClasses(x))) ::: All students either study hard or attend classes.",
            "∃x (Student(x) ∧ StudiesHard(x)) ::: Some students study hard.",
            "∀x (AttendsClasses(x) → HasGoodGrades(x)) ::: All students who attend classes have good grades.",
            "∀x (HasGoodGrades(x) → PassesExam(x)) ::: All students with good grades pass the exam.",
            "∃x Student(x) ::: There is a student.",
            "∀x (Student(x) ∧ StudiesHard(x) → HasGoodGrades(x)) ::: If a student studies hard, then they have good grades.",
            "∀x (HasGoodGrades(x) → PassesExam(x)) ::: If a student has good grades, then they pass the exam.",
            "∀x (Student(x) → (Programmer(x) ∨ Designer(x))) ::: Every student is either a programmer or a designer.",
            "∀x ¬(Programmer(x) ∧ Designer(x)) ::: No student is both a programmer and a designer.",
            "∀x (Programmer(x) → StudiesHard(x)) ::: All programmers study hard.",
            "∀x (Designer(x) → AttendsClasses(x)) ::: All designers attend classes.",
            "Student(john) ∧ Programmer(john) ::: A student is a programmer.",
            "Student(mary) ∧ AttendsClasses(mary) ::: Another student attends classes."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "AttendsClasses(x) ::: x attends classes",
            "PassesExam(x) ::: x passes the exam",
            "HasGoodGrades(x) ::: x has good grades"
        ]
    },
    {
        "premises-NL": [
            "All students study hard or attend classes.",
            "All students who attend classes have good grades.",
            "All students with good grades pass the exam.",
            "Some students study hard.",
            "If a student studies hard, then they have good grades.",
            "A student is registered for a course.",
            "If a student is registered for a course and attends classes, then they study hard.",
            "Every student is either a programmer or a designer.",
            "No student is both a programmer and a designer.",
            "All programmers study hard and attend classes.",
            "All designers have good grades.",
            "A student is a programmer.",
            "Another student attends classes.",
            "Some students study hard and attend classes.",
            "All who passes the exam, has good grades."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (StudiesHard(x) ∨ AttendsClasses(x))) ::: All students study hard or attend classes.",
            "∀x (AttendsClasses(x) → HasGoodGrades(x)) ::: All students who attend classes have good grades.",
            "∀x (HasGoodGrades(x) → PassesExam(x)) ::: All students with good grades pass the exam.",
            "∃x (Student(x) ∧ StudiesHard(x)) ::: Some students study hard.",
            "∀x (Student(x) ∧ StudiesHard(x) → HasGoodGrades(x)) ::: If a student studies hard, then they have good grades.",
            "∃x ∃y IsRegistered(x, y) ::: A student is registered for a course.",
            "∀x ∀y (IsRegistered(x, y) ∧ AttendsClasses(x) → StudiesHard(x)) ::: If a student is registered for a course and attends classes, then they study hard.",
            "∀x (Student(x) → (Programmer(x) ∨ Designer(x))) ::: Every student is either a programmer or a designer.",
            "∀x ¬(Programmer(x) ∧ Designer(x)) ::: No student is both a programmer and a designer.",
            "∀x (Programmer(x) → (StudiesHard(x) ∧ AttendsClasses(x))) ::: All programmers study hard and attend classes.",
            "∀x (Designer(x) → HasGoodGrades(x)) ::: All designers have good grades.",
            "∃x (Student(x) ∧ Programmer(x)) ::: A student is a programmer.",
            "∃x (Student(x) ∧ AttendsClasses(x)) ::: Another student attends classes.",
            "∃x (Student(x) ∧ StudiesHard(x) ∧ AttendsClasses(x)) ::: Some students study hard and attend classes.",
            "∀x (PassesExam(x) → HasGoodGrades(x)) ::: All who passes the exam, has good grades."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "AttendsClasses(x) ::: x attends classes",
            "PassesExam(x) ::: x passes the exam",
            "HasGoodGrades(x) ::: x has good grades",
            "IsRegistered(x, y) ::: x is registered for course y"
        ]
    },
    {
        "premises-NL": [
            "All doctors work at the hospital.",
            "All researchers conduct research.",
            "If someone works at the hospital and conducts research, then they are both a doctor and a researcher.",
            "All doctors provide medical care.",
            "All researchers publish papers.",
            "Anyone who has a medical degree is a doctor.",
            "All licensed doctors are qualified to provide medical care.",
            "Doctors who specialize in cardiology treat heart patients.",
            "Researchers who specialize in genetics study DNA.",
            "John is a doctor.",
            "If John is a researcher and licensed, then John publishes papers and provides medical care.",
            "Some doctors and researchers are licensed.",
            "If someone has a degree, then the person is a doctor.",
            "If a person is a doctor, then they provides medical care, and they are licensed.",
            "If someone works at the hospital, they provide medical care."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → WorksAtHospital(x)) ::: All doctors work at the hospital.",
            "∀x (Researcher(x) → ConductsResearch(x)) ::: All researchers conduct research.",
            "∀x (WorksAtHospital(x) ∧ ConductsResearch(x) → (Doctor(x) ∧ Researcher(x))) ::: If someone works at the hospital and conducts research, then they are both a doctor and a researcher.",
            "∀x (Doctor(x) → ProvidesMedicalCare(x)) ::: All doctors provide medical care.",
            "∀x (Researcher(x) → PublishesPapers(x)) ::: All researchers publish papers.",
            "∀x ∀y (HasDegree(x, y) ∧ Medical(y) → Doctor(x)) ::: Anyone who has a medical degree is a doctor.",
            "∀x (IsLicensed(x) ∧ Doctor(x) → ProvidesMedicalCare(x)) ::: All licensed doctors are qualified to provide medical care.",
            "∀x ∀y (Doctor(x) ∧ SpecializesIn(x, y) ∧ Cardiology(y) → TreatsHeartPatients(x)) ::: Doctors who specialize in cardiology treat heart patients.",
            "∀x ∀y (Researcher(x) ∧ SpecializesIn(x, y) ∧ Genetics(y) → StudiesDNA(x)) ::: Researchers who specialize in genetics study DNA.",
            "Doctor(john) ::: John is a doctor.",
            "∀x (Researcher(john) ∧ IsLicensed(john) → (PublishesPapers(john) ∧ ProvidesMedicalCare(john))) ::: If John is a researcher and licensed, then John publishes papers and provides medical care.",
            "∃x (Doctor(x) ∧ Researcher(x) ∧ IsLicensed(x)) ::: Some doctors and researchers are licensed.",
            "∀x ∀y (HasDegree(x, y) → Doctor(x)) ::: If someone has a degree, then the person is a doctor.",
            "∀x (Doctor(x) → (ProvidesMedicalCare(x) ∧ IsLicensed(x))) ::: If a person is a doctor, then they provides medical care, and they are licensed.",
            "∀x (WorksAtHospital(x) → ProvidesMedicalCare(x)) ::: If someone works at the hospital, they provide medical care."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Researcher(x) ::: x is a researcher",
            "ProvidesMedicalCare(x) ::: x provides medical care",
            "PublishesPapers(x) ::: x publishes papers",
            "WorksAtHospital(x) ::: x works at the hospital",
            "ConductsResearch(x) ::: x conducts research",
            "HasDegree(x, y) ::: x has a degree in y",
            "IsLicensed(x) ::: x is licensed",
            "SpecializesIn(x, y) ::: x specializes in y"
        ]
    },
    {
        "premises-NL": [
            "All people either enjoy music or don't.",
            "If a person enjoys music, they attend concerts.",
            "If a person attends concerts, they also enjoy books.",
            "Some people read books.",
            "If a person reads books, they are informed.",
            "If a person is informed and attends concerts, they are cultured.",
            "If a person is cultured, they are appreciated.",
            "Mary is a person and she reads books.",
            "Mary attends concerts.",
            "Everyone who attends concerts is cultured.",
            "If someone is informed and not cultured, they are not appreciated."
        ],
        "premises-FOL": [
            "∀x (Person(x) → (EnjoysMusic(x) ∨ ¬EnjoysMusic(x))) ::: All people either enjoy music or don't.",
            "∀x (EnjoysMusic(x) → AttendsConcerts(x)) ::: If a person enjoys music, they attend concerts.",
            "∀x (AttendsConcerts(x) → ReadsBooks(x)) ::: If a person attends concerts, they also enjoy books.",
            "∃x ReadsBooks(x) ::: Some people read books.",
            "∀x (ReadsBooks(x) → Informed(x)) ::: If a person reads books, they are informed.",
            "∀x ((Informed(x) ∧ AttendsConcerts(x)) → Cultured(x)) ::: If a person is informed and attends concerts, they are cultured.",
            "∀x (Cultured(x) → Appreciated(x)) ::: If a person is cultured, they are appreciated.",
            "Person(mary) ∧ ReadsBooks(mary) ::: Mary is a person and she reads books.",
            "AttendsConcerts(mary) ::: Mary attends concerts.",
            "∀x (AttendsConcerts(x) → Cultured(x)) ::: Everyone who attends concerts is cultured.",
            "∀x ((Informed(x) ∧ ¬Cultured(x)) → ¬Appreciated(x)) ::: If someone is informed and not cultured, they are not appreciated."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "EnjoysMusic(x) ::: x enjoys music",
            "ReadsBooks(x) ::: x reads books",
            "Cultured(x) ::: x is cultured",
            "AttendsConcerts(x) ::: x attends concerts"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "Anyone who treats patients is either helpful or knowledgeable.",
            "Some doctors have medical degrees.",
            "If someone has a medical degree, they are knowledgeable.",
            "If a doctor is helpful, they treat patients.",
            "No doctor is both helpful and knowledgeable.",
            "John is a doctor.",
            "People who treat patients, if not helpful, must be knowledgeable.",
            "People are doctors if and only if they treat patients and are knowledgeable.",
            "Anyone knowledgeable is able to diagnose.",
            "John is not helpful.",
            "If someone has a medical degree, they are helpful."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → TreatsPatients(x)) ::: All doctors treat patients.",
            "∀x (TreatsPatients(x) → (Helpful(x) ∨ Knowledgeable(x))) ::: Anyone who treats patients is either helpful or knowledgeable.",
            "∃x (Doctor(x) ∧ HasMedicalDegree(x)) ::: Some doctors have medical degrees.",
            "∀x (HasMedicalDegree(x) → Knowledgeable(x)) ::: If someone has a medical degree, they are knowledgeable.",
            "∀x (Doctor(x) ∧ Helpful(x) → TreatsPatients(x)) ::: If a doctor is helpful, they treat patients.",
            "∀x ¬(Helpful(x) ∧ Knowledgeable(x)) ::: No doctor is both helpful and knowledgeable.",
            "Doctor(john) ::: John is a doctor.",
            "∀x (TreatsPatients(x) ∧ ¬Helpful(x) → Knowledgeable(x)) ::: People who treat patients, if not helpful, must be knowledgeable.",
            "∀x (Doctor(x) ↔ (TreatsPatients(x) ∧ Knowledgeable(x))) ::: People are doctors if and only if they treat patients and are knowledgeable.",
            "∀x (Knowledgeable(x) → Diagnose(x)) ::: Anyone knowledgeable is able to diagnose.",
            "¬Helpful(john) ::: John is not helpful.",
            "∀x (HasMedicalDegree(x) → Helpful(x)) ::: If someone has a medical degree, they are helpful."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Doctor(x) ::: x is a doctor",
            "Helpful(x) ::: x is helpful",
            "Knowledgeable(x) ::: x is knowledgeable",
            "TreatsPatients(x) ::: x treats patients",
            "HasMedicalDegree(x) ::: x has a medical degree"
        ]
    },
    {
        "premises-NL": [
            "All students either study or don't.",
            "If a student studies, they get good grades.",
            "If a student attends classes, they participate in class.",
            "If a student gets good grades and participates in class, they won't fail the course.",
            "John is a student.",
            "John studies and attends classes.",
            "If someone follows rules, they won't fail.",
            "If someone doesn't study, they fail.",
            "If a student studies, they follow rules.",
            "Students who don't study are always lazy.",
            "John does not follow rules.",
            "Anyone who doesn't participate in class fails.",
            "Anyone who follows rules, if also participates, will not fail"
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Studies(x) ∨ ¬Studies(x))) ::: All students either study or don't.",
            "∀x (Studies(x) → GetsGoodGrades(x)) ::: If a student studies, they get good grades.",
            "∀x (AttendsClasses(x) → Participates(x)) ::: If a student attends classes, they participate in class.",
            "∀x ((GetsGoodGrades(x) ∧ Participates(x)) → ¬FailCourse(x)) ::: If a student gets good grades and participates in class, they won't fail the course.",
            "Student(john) ::: John is a student.",
            "Studies(john) ∧ AttendsClasses(john) ::: John studies and attends classes.",
            "∀x (FollowsRules(x) → ¬FailCourse(x)) ::: If someone follows rules, they won't fail.",
            "∀x (¬Studies(x) → FailCourse(x)) ::: If someone doesn't study, they fail.",
            "∀x (Studies(x) → FollowsRules(x)) ::: If a student studies, they follow rules.",
            "∀x (¬Studies(x) → Lazy(x)) ::: Students who don't study are always lazy.",
            "¬FollowsRules(john) ::: John does not follow rules.",
            "∀x (¬Participates(x) → FailCourse(x)) ::: Anyone who doesn't participate in class fails.",
            "∀x ((FollowsRules(x) ∧ Participates(x)) → ¬FailCourse(x)) ::: Anyone who follows rules, if also participates, will not fail"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "AttendsClasses(x) ::: x attends classes",
            "FailCourse(x) ::: x fails the course",
            "GetsGoodGrades(x) ::: x gets good grades",
            "FollowsRules(x) ::: x follows rules",
            "Participates(x) ::: x participates in class"
        ]
    },
    {
        "premises-NL": [
            "All mammals are warm-blooded.",
            "If something is warm-blooded, it has a high metabolic rate.",
            "If something has a high metabolic rate and it is a mammal, it will likely die early.",
            "Some things eat meat.",
            "If something eats meat, it lives in groups.",
            "If something lives in groups, it is large.",
            "If something is large, then it is a mammal.",
            "If it is a mammal it either has fur or is not.",
            "If something has a high metabolic rate, and has fur, then it's a mammal.",
            "Something either has a high metabolic rate or it does not.",
            "If something does not have a high metabolic rate, then it lives a long life.",
            "If it is not a mammal, it will not likely die early.",
            "Something that eats meat is not likely to die early",
            "If something has fur and is large, it's a mammal."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → WarmBlooded(x)) ::: All mammals are warm-blooded.",
            "∀x (WarmBlooded(x) → HighMetabolicRate(x)) ::: If something is warm-blooded, it has a high metabolic rate.",
            "∀x ((HighMetabolicRate(x) ∧ Mammal(x)) → EarlyDeath(x)) ::: If something has a high metabolic rate and it is a mammal, it will likely die early.",
            "∃x EatsMeat(x) ::: Some things eat meat.",
            "∀x (EatsMeat(x) → LivesInGroups(x)) ::: If something eats meat, it lives in groups.",
            "∀x (LivesInGroups(x) → IsLarge(x)) ::: If something lives in groups, it is large.",
            "∀x (IsLarge(x) → Mammal(x)) ::: If something is large, then it is a mammal.",
            "∀x (Mammal(x) → (HasFur(x) ∨ ¬HasFur(x))) ::: If it is a mammal it either has fur or is not.",
            "∀x ((HighMetabolicRate(x) ∧ HasFur(x)) → Mammal(x)) ::: If something has a high metabolic rate, and has fur, then it's a mammal.",
            "∀x (Thing(x) → (HighMetabolicRate(x) ∨ ¬HighMetabolicRate(x))) ::: Something either has a high metabolic rate or it does not.",
            "∀x (¬HighMetabolicRate(x) → LongLife(x)) ::: If something does not have a high metabolic rate, then it lives a long life.",
            "∀x (¬Mammal(x) → ¬EarlyDeath(x)) ::: If it is not a mammal, it will not likely die early.",
            "∀x (EatsMeat(x) → ¬EarlyDeath(x)) ::: Something that eats meat is not likely to die early",
            "∀x ((HasFur(x) ∧ IsLarge(x)) → Mammal(x)) ::: If something has fur and is large, it's a mammal."
        ],
        "predicates": [
            "Thing(x) ::: x is a thing",
            "HighMetabolicRate(x) ::: x has a high metabolic rate",
            "Mammal(x) ::: x is a mammal",
            "EarlyDeath(x) ::: x will likely die early",
            "EatsMeat(x) ::: x eats meat",
            "LivesInGroups(x) ::: x lives in groups",
            "IsLarge(x) ::: x is large",
            "WarmBlooded(x) ::: x is warm-blooded",
            "HasFur(x) ::: x has fur"
        ]
    },
    {
        "premises-NL": [
            "All doctors are knowledgeable.",
            "Dr. Smith is a doctor.",
            "If someone is a doctor, then they are knowledgeable.",
            "There is at least one doctor.",
            "If someone is not knowledgeable, then they are not a doctor.",
            "Every doctor is not an expert.",
            "No expert is a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Knowledgeable(x)) ::: All doctors are knowledgeable",
            "Doctor(Smith) ::: Dr. Smith is a doctor",
            "∀x (Doctor(x) → Knowledgeable(x)) ::: If someone is a doctor, then they are knowledgeable",
            "∃x Doctor(x) ::: There is at least one doctor",
            "∀x (¬Knowledgeable(x) → ¬Doctor(x)) ::: If someone is not knowledgeable, then they are not a doctor",
            "∀x (Doctor(x) → ¬Expert(x)) ::: Every doctor is not an expert",
            "∀x (Expert(x) → ¬Doctor(x)) ::: No expert is a doctor"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Knowledgeable(x) ::: x is knowledgeable"
        ]
    },
    {
        "premises-NL": [
            "All programmers use computers.",
            "If someone uses a computer, then they understand technology.",
            "Alice is a programmer.",
            "Bob uses a computer.",
            "If Bob uses a computer and understands technology, then Alice is a programmer.",
            "If Alice is a programmer, then she uses a computer.",
            "If something does not use a computer, then they are not a programmer.",
            "If someone doesn't understand technology, they don't use computers.",
            "All people who understand technology also use computers."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → UsesComputer(x)) ::: All programmers use computers",
            "∀x (UsesComputer(x) → UnderstandsTechnology(x)) ::: If someone uses a computer, then they understand technology",
            "Programmer(Alice) ::: Alice is a programmer",
            "UsesComputer(Bob) ::: Bob uses a computer",
            "∀x ((UsesComputer(Bob) ∧ UnderstandsTechnology(Bob)) → Programmer(Alice)) ::: If Bob uses a computer and understands technology, then Alice is a programmer",
            "∀x (Programmer(x) → UsesComputer(x)) ::: If Alice is a programmer, then she uses a computer",
            "∀x (¬UsesComputer(x) → ¬Programmer(x)) ::: If something does not use a computer, then they are not a programmer",
            "∀x (¬UnderstandsTechnology(x) → ¬UsesComputer(x)) ::: If someone doesn't understand technology, they don't use computers",
            "∀x (UnderstandsTechnology(x) → UsesComputer(x)) ::: All people who understand technology also use computers"
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "UsesComputer(x) ::: x uses a computer",
            "UnderstandsTechnology(x) ::: x understands technology"
        ]
    },
    {
        "premises-NL": [
            "All squares are rectangles.",
            "All rectangles are parallelograms.",
            "If something is a square, then it has four sides.",
            "If something is not a rectangle, then it is not a square.",
            "If something is a parallelogram, then it has four sides.",
            "A square is a rectangle.",
            "If something is a rectangle, then it has four sides.",
            "If something is a parallelogram, then it is not a square or a rectangle.",
            "If something is not a parallelogram, then it is not a rectangle or a square.",
            "Something is a square."
        ],
        "premises-FOL": [
            "∀x (Square(x) → Rectangle(x)) ::: All squares are rectangles",
            "∀x (Rectangle(x) → Parallelogram(x)) ::: All rectangles are parallelograms",
            "∀x (Square(x) → HasFourSides(x)) ::: If something is a square, then it has four sides",
            "∀x (¬Rectangle(x) → ¬Square(x)) ::: If something is not a rectangle, then it is not a square",
            "∀x (Parallelogram(x) → HasFourSides(x)) ::: If something is a parallelogram, then it has four sides",
            "Square(x) → Rectangle(x) ::: A square is a rectangle",
            "∀x (Rectangle(x) → HasFourSides(x)) ::: If something is a rectangle, then it has four sides",
            "∀x (Parallelogram(x) → (¬Square(x) ∨ ¬Rectangle(x))) ::: If something is a parallelogram, then it is not a square or a rectangle",
            "∀x (¬Parallelogram(x) → (¬Rectangle(x) ∨ ¬Square(x))) ::: If something is not a parallelogram, then it is not a rectangle or a square",
            "∃x Square(x) ::: Something is a square"
        ],
        "predicates": [
            "Square(x) ::: x is a square",
            "Rectangle(x) ::: x is a rectangle",
            "Parallelogram(x) ::: x is a parallelogram",
            "HasFourSides(x) ::: x has four sides"
        ]
    },
    {
        "premises-NL": [
            "Everyone who is employed has income.",
            "Anyone with income can own a car or a house.",
            "If someone owns a car, they are wealthy.",
            "If someone owns a house, they are wealthy.",
            "John is employed.",
            "If someone saves money and has income, they are wealthy.",
            "Owning a car and a house makes someone wealthy.",
            "If someone is wealthy, they own a luxury item.",
            "If someone has income, they spend on a luxury item.",
            "If someone is wealthy, they have a bank account."
        ],
        "premises-FOL": [
            "∀x (Employed(x) → HasIncome(x)) ::: Everyone who is employed has income.",
            "∀x (HasIncome(x) → (Owns(x, Car) ∨ Owns(x, House))) ::: Anyone with income can own a car or a house.",
            "∀x (Owns(x, Car) → Wealthy(x)) ::: If someone owns a car, they are wealthy.",
            "∀x (Owns(x, House) → Wealthy(x)) ::: If someone owns a house, they are wealthy.",
            "Employed(John) ::: John is employed.",
            "∀x (SavesMoney(x) ∧ HasIncome(x) → Wealthy(x)) ::: If someone saves money and has income, they are wealthy.",
            "∀x (Owns(x, Car) ∧ Owns(x, House) → Wealthy(x)) ::: Owning a car and a house makes someone wealthy.",
            "∀x (Wealthy(x) → Owns(x, LuxuryItem)) ::: If someone is wealthy, they own a luxury item.",
            "∀x (HasIncome(x) → Spends(x, LuxuryItem)) ::: If someone has income, they spend on a luxury item.",
            "∀x (Wealthy(x) → HasBankAccount(x)) ::: If someone is wealthy, they have a bank account."
        ],
        "predicates": [
            "Owns(x, y) ::: x owns y.",
            "Car(x) ::: x is a car.",
            "House(x) ::: x is a house.",
            "Wealthy(x) ::: x is wealthy.",
            "HasIncome(x) ::: x has income.",
            "Employed(x) ::: x is employed.",
            "Spends(x, y) ::: x spends on y.",
            "LuxuryItem(x) ::: x is a luxury item.",
            "SavesMoney(x) ::: x saves money.",
            "BankAccount(x) ::: x is a bank account."
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled in the university.",
            "John is a student.",
            "John attends the university.",
            "If someone is enrolled in the university, they take courses.",
            "If someone takes a course and studies, they gain knowledge.",
            "John studies a subject.",
            "If someone has knowledge, they like to learn.",
            "If someone is smart, they read books.",
            "Professors teach courses.",
            "If John studies, and understands the course, then he passes the exam.",
            "If John attends the university, he takes the course.",
            "If John studies a subject, then he understands the course.",
            "If someone is smart and the student is taking the course, then the student will pass.",
            "If John attends the university and studies, he gains knowledge."
        ],
        "premises-FOL": [
            "∀x (Student(x) → EnrolledIn(x, university)) ::: All students are enrolled in the university.",
            "Student(john) ::: John is a student.",
            "Attends(john, university) ::: John attends the university.",
            "∀x (EnrolledIn(x, university) → TakesCourse(x, course1)) ::: If someone is enrolled in the university, they take courses.",
            "∀x ∀y (TakesCourse(x, y) ∧ Studies(x, y) → HasKnowledge(x, y)) ::: If someone takes a course and studies, they gain knowledge.",
            "Studies(john, subjectX) ::: John studies a subject.",
            "∀x (HasKnowledge(x, subjectX) → LikesToLearn(x)) ::: If someone has knowledge, they like to learn.",
            "∀x (Smart(x) → ReadsBook(x, book1)) ::: If someone is smart, they read books.",
            "∀x ∃y Professor(x) → Teaches(x, y) ::: Professors teach courses.",
            "Studies(john, subjectX) ∧ Understood(john, course1) → PassesExam(john, exam1) ::: If John studies, and understands the course, then he passes the exam.",
            "Attends(john, university) → TakesCourse(john, course1) ::: If John attends the university, he takes the course.",
            "Studies(john, subjectX) → Understood(john, course1) ::: If John studies a subject, then he understands the course.",
            "Smart(john) ∧ TakesCourse(john, course1) → PassesExam(john, exam1) ::: If someone is smart and the student is taking the course, then the student will pass.",
            "Attends(john, university) ∧ Studies(john, subjectX) → HasKnowledge(john, subjectX) ::: If John attends the university and studies, he gains knowledge."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Attends(x, y) ::: x attends y",
            "Studies(x, y) ::: x studies y",
            "LikesToLearn(x) ::: x likes to learn",
            "EnrolledIn(x, y) ::: x is enrolled in y",
            "TakesCourse(x, y) ::: x takes course y",
            "HasKnowledge(x, y) ::: x has knowledge of y",
            "Smart(x) ::: x is smart",
            "ReadsBook(x, y) ::: x reads book y",
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches y",
            "Course(x) ::: x is a course",
            "Understands(x, y) ::: x understands y",
            "PassesExam(x, y) ::: x passes exam y"
        ]
    },
    {
        "premises-NL": [
            "All managers are employees.",
            "Managers assign employees to projects.",
            "If a manager assigns an employee to a project, then the employee works on the project.",
            "Important projects are managed by experienced employees.",
            "If an employee is experienced, they have necessary skills.",
            "If a project has adequate resources, it is in budget.",
            "If the project has the right people and the budget is good, it is a successful project.",
            "If a manager works on a project, then the project is in budget.",
            "If a project is successful, then it is well-managed.",
            "Some managers are experienced.",
            "If a project is important and the resources are adequate, it is successful.",
            "Experienced employees manage important projects.",
            "If a project is in budget, then resources are available.",
            "If the project resources are enough, the project will get done well."
        ],
        "premises-FOL": [
            "∀x (Manager(x) → Employee(x)) ::: All managers are employees.",
            "∀x ∃y ∃z Assigns(x, y, z) ::: Managers assign employees to projects.",
            "∀x ∀y ∀z (Assigns(x, y, z) → WorksOn(y, z)) ::: If a manager assigns an employee to a project, then the employee works on the project.",
            "∀x ∀y (ImportantProject(x) ∧ Manager(y) → Experienced(y)) ::: Important projects are managed by experienced employees.",
            "∀x ∀y (Experienced(x) → HasSkill(x, y)) ::: If an employee is experienced, they have necessary skills.",
            "∀x (AdequateResources(x) → InBudget(x)) ::: If a project has adequate resources, it is in budget.",
            "∀x ∀y (Project(x) ∧ HasSkill(y, x) ∧ InBudget(x) → ProjectSuccessful(x)) ::: If the project has the right people and the budget is good, it is a successful project.",
            "∀x ∀y (Manager(x) ∧ WorksOn(x, y) → InBudget(y)) ::: If a manager works on a project, then the project is in budget.",
            "∀x (ProjectSuccessful(x) → WellManaged(x)) ::: If a project is successful, then it is well-managed.",
            "∃x Experienced(x) ::: Some managers are experienced.",
            "∀x (ImportantProject(x) ∧ AdequateResources(x) → ProjectSuccessful(x)) ::: If a project is important and the resources are adequate, it is successful.",
            "∀x ∀y (Manager(y) ∧ ImportantProject(x) → WorksOn(y,x)) ::: Experienced employees manage important projects.",
            "∀x InBudget(x) → AdequateResources(x) ::: If a project is in budget, then resources are available.",
            "∀x ∀y AdequateResources(y) ∧ ImportantProject(x) → WellManaged(x) ::: If the project resources are enough, the project will get done well."
        ],
        "predicates": [
            "Employee(x) ::: x is an employee",
            "Manager(x) ::: x is a manager",
            "ImportantProject(x) ::: x is an important project",
            "WellManaged(x) ::: x is well-managed",
            "WorksOn(x, y) ::: x works on y",
            "Project(x) ::: x is a project",
            "Assigns(x, y, z) ::: x assigns y to z",
            "Experienced(x) ::: x is experienced",
            "HasSkill(x, y) ::: x has skill y",
            "Skill(x) ::: x is a skill",
            "ProjectSuccessful(x) ::: x is successful",
            "AdequateResources(x) ::: x has adequate resources",
            "InBudget(x) ::: x is in budget"
        ]
    },
    {
        "premises-NL": [
            "All researchers are scientists.",
            "Some researchers have grants.",
            "Anyone who has a grant is not a smoker.",
            "There exists a researcher."
        ],
        "premises-FOL": [
            "∀x (Researcher(x) → Scientist(x)) ::: All researchers are scientists.",
            "∃x (Researcher(x) ∧ HasGrant(x)) ::: Some researchers have grants.",
            "∀x (HasGrant(x) → ¬Smoker(x)) ::: Anyone who has a grant is not a smoker.",
            "∃x Researcher(x) ::: There exists a researcher."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Smoker(x) ::: x is a smoker",
            "Researcher(x) ::: x is a researcher",
            "HasGrant(x) ::: x has a grant"
        ]
    },
    {
        "premises-NL": [
            "All programmers are students.",
            "Some students like logic.",
            "Some students are programmers.",
            "Anyone who takes a logic course likes logic.",
            "All logic courses are interesting.",
            "Bob is a programmer.",
            "Bob takes a logic course."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → Student(x)) ::: All programmers are students.",
            "∃x (Student(x) ∧ LikesLogic(x)) ::: Some students like logic.",
            "∃x (Student(x) ∧ Programmer(x)) ::: Some students are programmers.",
            "∀x ∀y (TakesCourse(x, y) ∧ LogicCourse(y) → LikesLogic(x)) ::: Anyone who takes a logic course likes logic.",
            "∀y (LogicCourse(y) → Interesting(y)) ::: All logic courses are interesting.",
            "Programmer(bob) ::: Bob is a programmer.",
            "TakesCourse(bob, logic101) ::: Bob takes a logic course."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Programmer(x) ::: x is a programmer",
            "LikesLogic(x) ::: x likes logic",
            "TakesCourse(x, y) ::: x takes course y",
            "LogicCourse(y) ::: y is a logic course"
        ]
    },
    {
        "premises-NL": [
            "All athletes are disciplined.",
            "Some disciplined people work out.",
            "Anyone who works out is not lazy.",
            "Some athletes study.",
            "All who study are not lazy.",
            "Some athletes are not disciplined.",
            "Anyone who is lazy, does not work out.",
            "All disciplined people are not lazy."
        ],
        "premises-FOL": [
            "∀x (Athlete(x) → Disciplined(x)) ::: All athletes are disciplined.",
            "∃x (Disciplined(x) ∧ WorksOut(x)) ::: Some disciplined people work out.",
            "∀x (WorksOut(x) → ¬Lazy(x)) ::: Anyone who works out is not lazy.",
            "∃x (Athlete(x) ∧ Studies(x)) ::: Some athletes study.",
            "∀x (Studies(x) → ¬Lazy(x)) ::: All who study are not lazy.",
            "∃x (Athlete(x) ∧ ¬Disciplined(x)) ::: Some athletes are not disciplined.",
            "∀x (Lazy(x) → ¬WorksOut(x)) ::: Anyone who is lazy, does not work out.",
            "∀x (Disciplined(x) → ¬Lazy(x)) ::: All disciplined people are not lazy."
        ],
        "predicates": [
            "Athlete(x) ::: x is an athlete",
            "Lazy(x) ::: x is lazy",
            "Studies(x) ::: x studies",
            "Disciplined(x) ::: x is disciplined",
            "WorksOut(x) ::: x works out"
        ]
    },
    {
        "premises-NL": [
            "All who read books like to read.",
            "Some who like to read are smart.",
            "All smart people are not lazy.",
            "Anyone who studies reads books.",
            "Some who study, work.",
            "All who work, are not lazy.",
            "Some who attend class are smart.",
            "Some who work read books.",
            "All who like to read, attend class.",
            "Anyone who studies, likes to read.",
            "Some smart people, read books.",
            "Anyone who is lazy, does not work."
        ],
        "premises-FOL": [
            "∀x (ReadsBooks(x) → LikesToRead(x)) ::: All who read books like to read.",
            "∃x (LikesToRead(x) ∧ Smart(x)) ::: Some who like to read are smart.",
            "∀x (Smart(x) → ¬Lazy(x)) ::: All smart people are not lazy.",
            "∀x (Studies(x) → ReadsBooks(x)) ::: Anyone who studies reads books.",
            "∃x (Studies(x) ∧ Works(x)) ::: Some who study, work.",
            "∀x (Works(x) → ¬Lazy(x)) ::: All who work, are not lazy.",
            "∃x (AttendsClass(x) ∧ Smart(x)) ::: Some who attend class are smart.",
            "∃x (Works(x) ∧ ReadsBooks(x)) ::: Some who work read books.",
            "∀x (LikesToRead(x) → AttendsClass(x)) ::: All who like to read, attend class.",
            "∀x (Studies(x) → LikesToRead(x)) ::: Anyone who studies, likes to read.",
            "∃x (Smart(x) ∧ ReadsBooks(x)) ::: Some smart people, read books.",
            "∀x (Lazy(x) → ¬Works(x)) ::: Anyone who is lazy, does not work."
        ],
        "predicates": [
            "LikesToRead(x) ::: x likes to read",
            "Lazy(x) ::: x is lazy",
            "ReadsBooks(x) ::: x reads books",
            "Studies(x) ::: x studies",
            "Works(x) ::: x works",
            "Smart(x) ::: x is smart",
            "AttendsClass(x) ::: x attends class"
        ]
    },
    {
        "premises-NL": [
            "All patients who have the flu are sick.",
            "Anyone who has a fever is not sick.",
            "No one who is contagious has a fever.",
            "Some patients have the flu.",
            "Some people with the flu are not contagious."
        ],
        "premises-FOL": [
            "∀x (HasFlu(x) → IsSick(x)) ::: All patients who have the flu are sick.",
            "∀x (HasFever(x) → ¬IsSick(x)) ::: Anyone who has a fever is not sick.",
            "∀x (IsContagious(x) → ¬HasFever(x)) ::: No one who is contagious has a fever.",
            "∃x HasFlu(x) ::: Some patients have the flu.",
            "∃x (HasFlu(x) ∧ ¬IsContagious(x)) ::: Some people with the flu are not contagious."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient",
            "HasFever(x) ::: x has a fever",
            "HasFlu(x) ::: x has the flu",
            "IsSick(x) ::: x is sick",
            "IsContagious(x) ::: x is contagious"
        ]
    },
    {
        "premises-NL": [
            "All professors are researchers.",
            "Some researchers do not write papers.",
            "Everyone who writes a paper publishes the paper.",
            "Anyone who publishes a paper has a grant.",
            "No professor has a grant.",
            "All professors teach.",
            "Some researchers attend conferences.",
            "Anyone who teaches is a professor.",
            "Some researchers do not attend a conference."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Researcher(x)) ::: All professors are researchers.",
            "∃x (Researcher(x) ∧ ¬WritesPaper(x, y)) ::: Some researchers do not write papers.",
            "∀x ∀y (WritesPaper(x, y) → Publishes(x, y)) ::: Everyone who writes a paper publishes the paper.",
            "∀x ∀y (Publishes(x, y) → HasGrant(x)) ::: Anyone who publishes a paper has a grant.",
            "∀x (Professor(x) → ¬HasGrant(x)) ::: No professor has a grant.",
            "∀x (Professor(x) → Teaches(x, y)) ::: All professors teach.",
            "∃x (Researcher(x) ∧ AttendsConference(x, y)) ::: Some researchers attend conferences.",
            "∀x (Teaches(x, y) → Professor(x)) ::: Anyone who teaches is a professor.",
            "∃x (Researcher(x) ∧ ¬AttendsConference(x, y)) ::: Some researchers do not attend a conference."
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher",
            "Professor(x) ::: x is a professor",
            "WritesPaper(x, y) ::: x writes paper y",
            "Publishes(x, y) ::: x publishes y",
            "HasGrant(x) ::: x has grant",
            "Teaches(x, y) ::: x teaches course y",
            "AttendsConference(x, y) ::: x attends conference y"
        ]
    },
    {
        "premises-NL": [
            "All mammals are warm-blooded.",
            "All reptiles are cold-blooded.",
            "If something is warm-blooded, it is not cold-blooded.",
            "If something lays eggs, it is not warm-blooded.",
            "If something lays eggs, then it is a reptile.",
            "If something is a mammal, then it lives on land.",
            "If something is a reptile, it is not aquatic.",
            "If something is a mammal, it is a carnivore.",
            "No reptile is a carnivore."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → WarmBlooded(x)) ::: All mammals are warm-blooded.",
            "∀x (Reptile(x) → ColdBlooded(x)) ::: All reptiles are cold-blooded.",
            "∀x (WarmBlooded(x) → ¬ColdBlooded(x)) ::: If something is warm-blooded, it is not cold-blooded.",
            "∀x (LaysEggs(x) → ¬WarmBlooded(x)) ::: If something lays eggs, it is not warm-blooded.",
            "∀x (LaysEggs(x) → Reptile(x)) ::: If something lays eggs, then it is a reptile.",
            "∀x (Mammal(x) → LivesOnLand(x)) ::: If something is a mammal, then it lives on land.",
            "∀x (Reptile(x) → ¬Aquatic(x)) ::: If something is a reptile, it is not aquatic.",
            "∀x (Mammal(x) → Carnivore(x)) ::: If something is a mammal, it is a carnivore.",
            "∀x (Reptile(x) → ¬Carnivore(x)) ::: No reptile is a carnivore."
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal",
            "LaysEggs(x) ::: x lays eggs",
            "Reptile(x) ::: x is a reptile",
            "WarmBlooded(x) ::: x is warm-blooded",
            "ColdBlooded(x) ::: x is cold-blooded",
            "HasFeathers(x) ::: x has feathers",
            "LivesOnLand(x) ::: x lives on land",
            "Aquatic(x) ::: x is aquatic",
            "Carnivore(x) ::: x is carnivore"
        ]
    },
    {
        "premises-NL": [
            "If a patient takes the medication, the infection should subside.",
            "The patient is taking the medication.",
            "If the infection persists, the patient has a serious condition.",
            "If a patient has a serious condition, the doctor will order tests.",
            "If the infection does not subside and the patient takes the medication, the infection persists.",
            "If the patient takes medication, the infection should subside.",
            "If a patient has a serious condition the doctor will order tests.",
            "The infection persists.",
            "The patient takes the medication and the infection persists.",
            "If the patient takes the medication, the patient has a serious condition.",
            "The patient takes the medication and will have a serious condition.",
            "The infection persists, and the patient is taking medication."
        ],
        "premises-FOL": [
            "∀x (TakeMedication(x) → ¬Persists(infection)) ::: If a patient takes the medication, the infection should subside.",
            "TakeMedication(patient) ::: The patient is taking the medication.",
            "∀x (Persists(x) → SeriousCondition(patient)) ::: If the infection persists, the patient has a serious condition.",
            "∀x (SeriousCondition(x) → OrderTests(doctor)) ::: If a patient has a serious condition, the doctor will order tests.",
            "TakeMedication(patient) ∧ ¬Subside(infection) → Persists(infection) ::: If the infection does not subside and the patient takes the medication, the infection persists.",
            "∀x (TakeMedication(x) → ¬Persists(infection)) ::: If the patient takes medication, the infection should subside.",
            "∀x (SeriousCondition(x) → OrderTests(doctor)) ::: If a patient has a serious condition the doctor will order tests.",
            "Persists(infection) ::: The infection persists.",
            "TakeMedication(patient) ∧ Persists(infection) ::: The patient takes the medication and the infection persists.",
            "TakeMedication(patient) → SeriousCondition(patient) ::: If the patient takes the medication, the patient has a serious condition.",
            "TakeMedication(patient) ∧ SeriousCondition(patient) ::: The patient takes the medication and will have a serious condition.",
            "Persists(infection) ∧ TakeMedication(patient) ::: The infection persists, and the patient is taking medication."
        ],
        "predicates": [
            "TakeMedication(x) ::: x takes the medication",
            "Persists(x) ::: x persists",
            "OrderTests(x) ::: x orders tests"
        ]
    },
    {
        "premises-NL": [
            "If a worker is skilled and works hard, the project will be completed.",
            "Worker X is skilled.",
            "Worker X works hard.",
            "If the worker is skilled, and the worker works hard, the project will be completed.",
            "If the project is not completed then the worker is not skilled.",
            "If the worker is not skilled or works hard the project will not be completed.",
            "If worker X is skilled and works hard, the project will be completed.",
            "If a worker is skilled, and the worker works hard, the project will be completed.",
            "Worker X is skilled and works hard, and the project will be completed.",
            "If the project is completed, then the worker is skilled and works hard.",
            "If worker X works hard, the project will be completed, provided that the worker is skilled.",
            "If a worker works hard, then the project is completed.",
            "Worker X is skilled and works hard.",
            "If a worker is not skilled the project will not be completed."
        ],
        "premises-FOL": [
            "∀x (Skilled(x) ∧ WorksHard(x) → ProjectCompleted(project)) ::: If a worker is skilled and works hard, the project will be completed.",
            "Skilled(worker) ::: Worker X is skilled.",
            "WorksHard(worker) ::: Worker X works hard.",
            "∀x (Skilled(x) ∧ WorksHard(x) → ProjectCompleted(project)) ::: If the worker is skilled, and the worker works hard, the project will be completed.",
            "¬ProjectCompleted(project) → ¬Skilled(worker) ::: If the project is not completed then the worker is not skilled.",
            "¬Skilled(worker) ∨ ¬WorksHard(worker) → ¬ProjectCompleted(project) ::: If the worker is not skilled or works hard the project will not be completed.",
            "Skilled(worker) ∧ WorksHard(worker) → ProjectCompleted(project) ::: If worker X is skilled and works hard, the project will be completed.",
            "∀x (Skilled(x) ∧ WorksHard(x) → ProjectCompleted(project)) ::: If a worker is skilled, and the worker works hard, the project will be completed.",
            "Skilled(worker) ∧ WorksHard(worker) ∧ ProjectCompleted(project) ::: Worker X is skilled and works hard, and the project will be completed.",
            "ProjectCompleted(project) → Skilled(worker) ∧ WorksHard(worker) ::: If the project is completed, then the worker is skilled and works hard.",
            "WorksHard(worker) ∧ Skilled(worker) → ProjectCompleted(project) ::: If worker X works hard, the project will be completed, provided that the worker is skilled.",
            "∀x (WorksHard(x) → ProjectCompleted(project)) ::: If a worker works hard, then the project is completed.",
            "Skilled(worker) ∧ WorksHard(worker) ::: Worker X is skilled and works hard.",
            "¬Skilled(worker) → ¬ProjectCompleted(project) ::: If a worker is not skilled the project will not be completed."
        ],
        "predicates": [
            "Skilled(x) ::: x is skilled",
            "WorksHard(x) ::: x works hard",
            "ProjectCompleted(x) ::: x is completed"
        ]
    },
    {
        "premises-NL": [
            "If a plant receives sunlight and water, it grows.",
            "This plant receives sunlight.",
            "This plant is watered.",
            "If a plant grows, the plant receives sunlight and water.",
            "If a plant does not have sunlight, then it will not grow.",
            "If a plant is watered, then it receives sunlight.",
            "If a plant is watered, then it grows.",
            "If a plant has nutrients and sunlight, then it grows.",
            "This plant does not have sunlight or water.",
            "If a plant receives sunlight, then it is watered.",
            "This plant has nutrients and is watered.",
            "If a plant has nutrients, then it will grow.",
            "If a plant receives sunlight, it grows, but is also watered.",
            "If this plant grows, it is watered and gets nutrients.",
            "If a plant has water and sunlight, it will grow."
        ],
        "premises-FOL": [
            "∀x (Sunlight(x) ∧ Watered(x) → Grows(x)) ::: If a plant receives sunlight and water, it grows.",
            "Sunlight(plant) ::: This plant receives sunlight.",
            "Watered(plant) ::: This plant is watered.",
            "∀x (Grows(x) → Sunlight(x) ∧ Watered(x)) ::: If a plant grows, the plant receives sunlight and water.",
            "¬Sunlight(plant) → ¬Grows(plant) ::: If a plant does not have sunlight, then it will not grow.",
            "Watered(plant) → Sunlight(plant) ::: If a plant is watered, then it receives sunlight.",
            "Watered(plant) → Grows(plant) ::: If a plant is watered, then it grows.",
            "∀x (Nutrients(x) ∧ Sunlight(x) → Grows(x)) ::: If a plant has nutrients and sunlight, then it grows.",
            "¬Sunlight(plant) ∨ ¬Watered(plant) ::: This plant does not have sunlight or water.",
            "Sunlight(plant) → Watered(plant) ::: If a plant receives sunlight, then it is watered.",
            "Nutrients(plant) ∧ Watered(plant) ::: This plant has nutrients and is watered.",
            "∀x (Nutrients(x) → Grows(x)) ::: If a plant has nutrients, then it will grow.",
            "Sunlight(plant) → Grows(plant) ∧ Watered(plant) ::: If a plant receives sunlight, it grows, but is also watered.",
            "Grows(plant) → Watered(plant) ∧ Nutrients(plant) ::: If this plant grows, it is watered and gets nutrients.",
            "∀x (Watered(x) ∧ Sunlight(x) → Grows(x)) ::: If a plant has water and sunlight, it will grow."
        ],
        "predicates": [
            "Sunlight(x) ::: x receives sunlight",
            "Grows(x) ::: x grows",
            "Watered(x) ::: x is watered",
            "Nutrients(x) ::: x has nutrients"
        ]
    },
    {
        "premises-NL": [
            "All athletes are tall or play basketball.",
            "All good shooters are successful.",
            "If someone is injured, then they are not successful.",
            "Some athletes are good shooters.",
            "All who plays basketball are athletes.",
            "If an athlete is tall and does not win a championship, they are not successful.",
            "Some athletes are injured.",
            "Anyone who has potential and is a good shooter is successful.",
            "If an athlete is not a good shooter, then they are not tall.",
            "Winning the championship means they are successful."
        ],
        "premises-FOL": [
            "∀x (Athlete(x) → (Tall(x) ∨ PlaysBasketball(x))) ::: If x is an athlete, then x is tall or plays basketball.",
            "∀x (GoodShooter(x) → Successful(x)) ::: If x is a good shooter, then x is successful.",
            "∀x (Injured(x) → ¬Successful(x)) ::: If x is injured, then x is not successful.",
            "∃x (Athlete(x) ∧ GoodShooter(x)) ::: There exists an athlete who is a good shooter.",
            "∀x (PlaysBasketball(x) → Athlete(x)) ::: If x plays basketball, then x is an athlete.",
            "∀x (Athlete(x) ∧ ¬WinsChampionship(x) → ¬Successful(x)) ::: If x is an athlete and doesn't win championship, then x is not successful.",
            "∃x Injured(x) ::: There exists someone who is injured.",
            "∀x (HasPotential(x) ∧ GoodShooter(x) → Successful(x)) ::: If x has potential and is a good shooter, then x is successful.",
            "∀x (¬GoodShooter(x) → ¬Tall(x)) ::: If x is not a good shooter, then x is not tall.",
            "∀x (WinsChampionship(x) → Successful(x)) ::: If x wins the championship, then x is successful."
        ],
        "predicates": [
            "Athlete(x) ::: x is an athlete",
            "Tall(x) ::: x is tall",
            "Successful(x) ::: x is successful",
            "PlaysBasketball(x) ::: x plays basketball",
            "GoodShooter(x) ::: x is a good shooter",
            "Injured(x) ::: x is injured",
            "HasPotential(x) ::: x has potential",
            "WinsChampionship(x) ::: x wins the championship"
        ]
    },
    {
        "premises-NL": [
            "If a patient has a fever and cough, then they have a flu.",
            "If a patient has the flu, they may have weakness.",
            "If a patient has the flu, they may have a sore throat.",
            "If a patient has the flu, they may have a headache.",
            "A patient has a fever.",
            "A patient is coughing.",
            "If a patient has a fever, they may have a headache.",
            "If a patient is coughing, they might have a sore throat.",
            "If a patient has the flu, they might have weakness or sore throat.",
            "If a patient has a fever and cough, they have the flu.",
            "If the patient has the flu, they might have weakness.",
            "If the patient has the flu, they might have a sore throat.",
            "If the patient has a headache, they are having flu.",
            "If the patient has sore throat and headache, they are having flu.",
            "The patient is coughing."
        ],
        "premises-FOL": [
            "∀x (Fever(x) ∧ Cough(x) → Flu(x)) ::: If a patient has a fever and cough, then they have a flu.",
            "∀x (Flu(x) → Weakness(x)) ::: If a patient has the flu, they may have weakness.",
            "∀x (Flu(x) → SoreThroat(x)) ::: If a patient has the flu, they may have a sore throat.",
            "∀x (Flu(x) → Headache(x)) ::: If a patient has the flu, they may have a headache.",
            "Fever(patient) ::: A patient has a fever.",
            "Cough(patient) ::: A patient is coughing.",
            "∀x (Fever(x) → Headache(x)) ::: If a patient has a fever, they may have a headache.",
            "∀x (Cough(x) → SoreThroat(x)) ::: If a patient is coughing, they might have a sore throat.",
            "∀x (Flu(x) → Weakness(x) ∨ SoreThroat(x)) ::: If a patient has the flu, they might have weakness or sore throat.",
            "∀x (Fever(x) ∧ Cough(x) → Flu(x)) ::: If a patient has a fever and cough, they have the flu.",
            "∀x (Flu(x) → Weakness(x)) ::: If the patient has the flu, they might have weakness.",
            "∀x (Flu(x) → SoreThroat(x)) ::: If the patient has the flu, they might have a sore throat.",
            "∀x (Headache(x) → Flu(x)) ::: If the patient has a headache, they are having flu.",
            "∀x (SoreThroat(x) ∧ Headache(x) → Flu(x)) ::: If the patient has sore throat and headache, they are having flu.",
            "Cough(patient) ::: The patient is coughing."
        ],
        "predicates": [
            "Fever(x) ::: x has a fever",
            "Cough(x) ::: x is coughing",
            "Flu(x) ::: x has the flu",
            "Weakness(x) ::: x has weakness",
            "SoreThroat(x) ::: x has a sore throat",
            "Headache(x) ::: x has a headache"
        ]
    },
    {
        "premises-NL": [
            "All students attend class.",
            "Anyone who attends class and likes lectures studies hard.",
            "Anyone who gets good grades and is prepared passes the exam.",
            "Some students get good grades.",
            "Anyone who likes lectures studies hard.",
            "All students are prepared.",
            "Anyone who is prepared and gets good grades.",
            "Most students study hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClass(x)) ::: All students attend class.",
            "∀x (AttendsClass(x) ∧ LikesLectures(x) → StudiesHard(x)) ::: If someone attends class and likes lectures, they study hard.",
            "∀x (GetsGoodGrades(x) ∧ IsPrepared(x) → PassesExam(x)) ::: If someone gets good grades and is prepared, they pass the exam.",
            "∃x (Student(x) ∧ GetsGoodGrades(x)) ::: Some students get good grades.",
            "∀x (LikesLectures(x) → StudiesHard(x)) ::: Anyone who likes lectures studies hard.",
            "∀x (Student(x) → IsPrepared(x)) ::: All students are prepared.",
            "∀x (IsPrepared(x) ∧ GetsGoodGrades(x) → PassesExam(x)) ::: If someone is prepared and gets good grades they pass the exam.",
            "∀x (Student(x) → StudiesHard(x)) ::: Most students study hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassesExam(x) ::: x passes the exam",
            "AttendsClass(x) ::: x attends class",
            "GetsGoodGrades(x) ::: x gets good grades",
            "IsPrepared(x) ::: x is prepared",
            "LikesLectures(x) ::: x likes lectures"
        ]
    },
    {
        "premises-NL": [
            "All patients with the disease receive treatment.",
            "If a patient receives treatment and takes the medication, their condition improves.",
            "Some patients avoid risks.",
            "Any patient who avoids risks is healthy.",
            "Any patient that is healthy recovers.",
            "Some patients have the disease and follow instructions.",
            "Every patient who takes medication receives treatment.",
            "All patients follow instructions.",
            "If someone is recovering, their condition improves."
        ],
        "premises-FOL": [
            "∀x (HasDisease(x) → ReceivesTreatment(x)) ::: All patients with the disease receive treatment.",
            "∀x (ReceivesTreatment(x) ∧ TakesMedication(x) → ImprovesCondition(x)) ::: If a patient receives treatment and takes the medication, their condition improves.",
            "∃x AvoidsRisks(x) ::: Some patients avoid risks.",
            "∀x (AvoidsRisks(x) → IsHealthy(x)) ::: Any patient who avoids risks is healthy.",
            "∀x (IsHealthy(x) → IsRecovering(x)) ::: Any patient that is healthy recovers.",
            "∃x (HasDisease(x) ∧ FollowsInstructions(x)) ::: Some patients have the disease and follow instructions.",
            "∀x (TakesMedication(x) → ReceivesTreatment(x)) ::: Every patient who takes medication receives treatment.",
            "∀x (Patient(x) → FollowsInstructions(x)) ::: All patients follow instructions.",
            "∀x (IsRecovering(x) → ImprovesCondition(x)) ::: If someone is recovering, their condition improves."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient",
            "HasDisease(x) ::: x has the disease",
            "TakesMedication(x) ::: x takes the medication",
            "ImprovesCondition(x) ::: x's condition improves",
            "ReceivesTreatment(x) ::: x receives treatment",
            "IsHealthy(x) ::: x is healthy",
            "AvoidsRisks(x) ::: x avoids risks",
            "IsRecovering(x) ::: x is recovering",
            "FollowsInstructions(x) ::: x follows instructions"
        ]
    },
    {
        "premises-NL": [
            "All doctors study medicine.",
            "Any person who studies medicine has a license.",
            "Any person who has a license can treat a patient.",
            "If a doctor is experienced, then they diagnose the patient.",
            "If a doctor diagnoses the patient, then they prescribe medicine for the patient.",
            "Any patient has a disease.",
            "All doctors see patients.",
            "Some doctors are experienced.",
            "Any doctor with a license can treat a patient.",
            "If someone sees a patient, they are treating them.",
            "Doctor Alice is a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → StudiesMedicine(x)) ::: All doctors study medicine.",
            "∀x (StudiesMedicine(x) → HasLicense(x)) ::: Any person who studies medicine has a license.",
            "∀x ∀y (HasLicense(x) ∧ Patient(y) → CanTreat(x, y)) ::: Any person who has a license can treat a patient.",
            "∀x ∀y (Doctor(x) ∧ IsExperienced(x) ∧ Patient(y) → Diagnoses(x, y)) ::: If a doctor is experienced, then they diagnose the patient.",
            "∀x ∀y (Doctor(x) ∧ Diagnoses(x, y) → PrescribesMedicine(x, y)) ::: If a doctor diagnoses the patient, then they prescribe medicine for the patient.",
            "∀x (Patient(x) → HasDisease(x)) ::: Any patient has a disease.",
            "∀x ∀y (Doctor(x) ∧ Patient(y) → SeesPatient(x, y)) ::: All doctors see patients.",
            "∃x IsExperienced(x) ::: Some doctors are experienced.",
            "∀x ∀y (Doctor(x) ∧ HasLicense(x) ∧ Patient(y) → CanTreat(x, y)) ::: Any doctor with a license can treat a patient.",
            "∀x ∀y (SeesPatient(x, y) → CanTreat(x, y)) ::: If someone sees a patient, they are treating them.",
            "Doctor(Alice) ::: Doctor Alice is a doctor."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Doctor(x) ::: x is a doctor",
            "StudiesMedicine(x) ::: x studies medicine",
            "Patient(x) ::: x is a patient",
            "CanTreat(x, y) ::: x can treat y",
            "HasLicense(x) ::: x has a license",
            "IsExperienced(x) ::: x is experienced",
            "Diagnoses(x, y) ::: x diagnoses y",
            "PrescribesMedicine(x, y) ::: x prescribes medicine for y",
            "HasDisease(x) ::: x has a disease",
            "SeesPatient(x, y) ::: x sees patient y"
        ]
    },
    {
        "premises-NL": [
            "Anyone who follows rules is disciplined.",
            "Anyone who is disciplined and studies is focused.",
            "Anyone who is focused and has a mentor completes tasks.",
            "Some people study.",
            "If someone completes tasks, then they achieve goals.",
            "If someone achieves goals, then they succeed.",
            "Anyone who seeks advice from someone who gives advice is motivated.",
            "If a person has a mentor, they seek advice.",
            "Any person is a person.",
            "Everyone who is motivated follows the rules.",
            "Anyone who studies and is focused achieves goals.",
            "Alex has a mentor."
        ],
        "premises-FOL": [
            "∀x (FollowsRules(x) → IsDisciplined(x)) ::: Anyone who follows rules is disciplined.",
            "∀x (IsDisciplined(x) ∧ Studies(x) → IsFocused(x)) ::: Anyone who is disciplined and studies is focused.",
            "∀x (IsFocused(x) ∧ HasMentor(x) → CompletesTasks(x)) ::: Anyone who is focused and has a mentor completes tasks.",
            "∃x Studies(x) ::: Some people study.",
            "∀x (CompletesTasks(x) → AchievesGoals(x)) ::: If someone completes tasks, then they achieve goals.",
            "∀x (AchievesGoals(x) → Succeeds(x)) ::: If someone achieves goals, then they succeed.",
            "∀x ∀y (SeeksAdvice(x, y) ∧ GivesAdvice(y, x) → IsMotivated(x)) ::: Anyone who seeks advice from someone who gives advice is motivated.",
            "∀x (HasMentor(x) → SeeksAdvice(x, y)) ::: If a person has a mentor, they seek advice.",
            "∀x Person(x) ::: Any person is a person.",
            "∀x (IsMotivated(x) → FollowsRules(x)) ::: Everyone who is motivated follows the rules.",
            "∀x (Studies(x) ∧ IsFocused(x) → AchievesGoals(x)) ::: Anyone who studies and is focused achieves goals.",
            "HasMentor(Alex) ::: Alex has a mentor."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "FollowsRules(x) ::: x follows rules",
            "Studies(x) ::: x studies",
            "HasMentor(x) ::: x has a mentor",
            "Succeeds(x) ::: x succeeds",
            "IsDisciplined(x) ::: x is disciplined",
            "SeeksAdvice(x, y) ::: x seeks advice from y",
            "GivesAdvice(x, y) ::: x gives advice to y",
            "IsFocused(x) ::: x is focused",
            "CompletesTasks(x) ::: x completes tasks",
            "IsMotivated(x) ::: x is motivated",
            "AchievesGoals(x) ::: x achieves goals"
        ]
    },
    {
        "premises-NL": [
            "All advertised products are popular.",
            "Some expensive products are advertised.",
            "If a product is popular, it is advertised or of high quality.",
            "Some products are expensive.",
            "All high-quality products are expensive.",
            "Some products are not advertised.",
            "If a product is advertised, it's popular.",
            "If a product is expensive, it is a product.",
            "If a product is popular, it is a product.",
            "If a product is not popular, it is not advertised.",
            "If a product is high quality, then it is a product.",
            "Some expensive products are not popular."
        ],
        "premises-FOL": [
            "∀x (Advertised(x) → Popular(x)) ::: For all x, if x is advertised, then x is popular.",
            "∃x (Expensive(x) ∧ Advertised(x)) ::: There exists an x such that x is expensive and advertised.",
            "∀x (Popular(x) → (Advertised(x) ∨ HighQuality(x))) ::: For all x, if x is popular, then x is advertised or of high quality.",
            "∃x Expensive(x) ::: There exists an x such that x is expensive.",
            "∀x (HighQuality(x) → Expensive(x)) ::: For all x, if x is of high quality, then x is expensive.",
            "∃x ¬Advertised(x) ::: There exists an x that is not advertised.",
            "∀x (Advertised(x) → Popular(x)) ::: For all x, if x is advertised, then x is popular.",
            "∀x (Expensive(x) → Product(x)) ::: For all x, if x is expensive, then it is a product.",
            "∀x (Popular(x) → Product(x)) ::: For all x, if x is popular, then it is a product.",
            "∀x (¬Popular(x) → ¬Advertised(x)) ::: For all x, if x is not popular, then it is not advertised.",
            "∀x (HighQuality(x) → Product(x)) ::: For all x, if x is of high quality, then it is a product.",
            "∃x (Expensive(x) ∧ ¬Popular(x)) ::: There exists an x that is expensive and not popular."
        ],
        "predicates": [
            "Product(x) ::: x is a product",
            "Expensive(x) ::: x is expensive",
            "Popular(x) ::: x is popular",
            "Advertised(x) ::: x is advertised",
            "HighQuality(x) ::: x is of high quality"
        ]
    },
    {
        "premises-NL": [
            "All students either attend the lecture or like coffee.",
            "Some students like coffee.",
            "All students who like coffee pass the exam.",
            "All students who attend the lecture are students.",
            "Some students do not like coffee.",
            "All students who like coffee are students."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (AttendsLecture(x) ∨ LikesCoffee(x))) ::: All students either attend the lecture or like coffee.",
            "∃x (Student(x) ∧ LikesCoffee(x)) ::: Some students like coffee.",
            "∀x (LikesCoffee(x) → PassesExam(x)) ::: All students who like coffee pass the exam.",
            "∀x (AttendsLecture(x) → Student(x)) ::: All students who attend the lecture are students.",
            "∃x (Student(x) ∧ ¬LikesCoffee(x)) ::: Some students do not like coffee.",
            "∀x (LikesCoffee(x) → Student(x)) ::: All students who like coffee are students."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsLecture(x) ::: x attends the lecture",
            "PassesExam(x) ::: x passes the exam",
            "LikesCoffee(x) ::: x likes coffee"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All surgeons are specialists.",
            "All specialists practice medicine.",
            "Some doctors practice medicine.",
            "All doctors practice medicine.",
            "Some doctors are surgeons.",
            "Some doctors are not surgeons."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Surgeon(x) → Specialist(x)) ::: All surgeons are specialists.",
            "∀x (Specialist(x) → PracticesMedicine(x)) ::: All specialists practice medicine.",
            "∃x (Doctor(x) ∧ PracticesMedicine(x)) ::: Some doctors practice medicine.",
            "∀x (Doctor(x) → PracticesMedicine(x)) ::: All doctors practice medicine.",
            "∃x (Doctor(x) ∧ Surgeon(x)) ::: Some doctors are surgeons.",
            "∃x (Doctor(x) ∧ ¬Surgeon(x)) ::: Some doctors are not surgeons."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "Specialist(x) ::: x is a specialist",
            "PracticesMedicine(x) ::: x practices medicine"
        ]
    },
    {
        "premises-NL": [
            "All students either study or attend the lecture.",
            "Every student studies if they do not attend the lecture.",
            "Anyone who studies will not pass the exam.",
            "All students are taking the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Studies(x) ∨ AttendsLecture(x))) ::: All students either study or attend the lecture.",
            "∀x (Student(x) ∧ ¬AttendsLecture(x) → Studies(x)) ::: Every student studies if they do not attend the lecture.",
            "∀x (Studies(x) → ¬PassesExam(x)) ::: Anyone who studies will not pass the exam.",
            "∀x (Student(x) → TakesExam(x)) ::: All students are taking the exam.",
            "Student(Alice) ::: Alice is a student.",
            "AttendsLecture(Alice) ::: Alice attends the lecture.",
            "¬Studies(Alice) ::: Alice does not study.",
            "Student(Bob) ::: Bob is a student.",
            "AttendsLecture(Bob) ::: Bob attends the lecture.",
            "TakesExam(Bob) ::: Bob is taking the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsLecture(x) ::: x attends the lecture",
            "PassesExam(x) ::: x passes the exam",
            "Studies(x) ::: x studies"
        ]
    },
    {
        "premises-NL": [
            "All chess club members like chess.",
            "Anyone who likes chess is good at chess.",
            "Everyone who is good at chess is smart.",
            "Alice is a member of the chess club.",
            "Bob is Alice's friend.",
            "Alice likes chess.",
            "If someone is good at chess and friends, they are smart.",
            "Alice is good at chess.",
            "All friends of chess club members are smart.",
            "Bob is a member of chess club",
            "All smart people are good at chess."
        ],
        "premises-FOL": [
            "∀x (ChessClubMember(x) → LikesChess(x)) ::: All chess club members like chess.",
            "∀x (LikesChess(x) → GoodAtChess(x)) ::: Anyone who likes chess is good at chess.",
            "∀x (GoodAtChess(x) → Smart(x)) ::: Everyone who is good at chess is smart.",
            "ChessClubMember(Alice) ::: Alice is a member of the chess club.",
            "Friend(Bob, Alice) ::: Bob is Alice's friend.",
            "LikesChess(Alice) ::: Alice likes chess.",
            "∀x ∀y (GoodAtChess(x) ∧ Friend(x, y) → Smart(x)) ::: If someone is good at chess and friends, they are smart.",
            "GoodAtChess(Alice) ::: Alice is good at chess.",
            "∀x ∀y (ChessClubMember(x) ∧ Friend(y, x) → Smart(y)) ::: All friends of chess club members are smart.",
            "ChessClubMember(Bob) ::: Bob is a member of chess club",
            "∀x (Smart(x) → GoodAtChess(x)) ::: All smart people are good at chess."
        ],
        "predicates": [
            "ChessClubMember(x) ::: x is a member of the chess club",
            "Friend(x, y) ::: x is a friend of y",
            "Smart(x) ::: x is smart",
            "LikesChess(x) ::: x likes chess",
            "GoodAtChess(x) ::: x is good at chess"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "Anyone who treats patients is helpful.",
            "All doctors have knowledge.",
            "Anyone who has knowledge cares about patients.",
            "Doctors care about patients.",
            "Alice is a doctor.",
            "Alice treats patients.",
            "Alice is helpful.",
            "Bob is a doctor.",
            "Bob cares about patients.",
            "Doctors always care.",
            "Anyone who is a doctor and is helpful is knowledge.",
            "Bob has knowledge."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → TreatsPatients(x)) ::: All doctors treat patients.",
            "∀x (TreatsPatients(x) → Helpful(x)) ::: Anyone who treats patients is helpful.",
            "∀x (Doctor(x) → HasKnowledge(x)) ::: All doctors have knowledge.",
            "∀x (HasKnowledge(x) → CaresAboutPatients(x)) ::: Anyone who has knowledge cares about patients.",
            "∀x (Doctor(x) → CaresAboutPatients(x)) ::: Doctors care about patients.",
            "Doctor(Alice) ::: Alice is a doctor.",
            "TreatsPatients(Alice) ::: Alice treats patients.",
            "Helpful(Alice) ::: Alice is helpful.",
            "Doctor(Bob) ::: Bob is a doctor.",
            "CaresAboutPatients(Bob) ::: Bob cares about patients.",
            "∀x (Doctor(x) → CaresAboutPatients(x)) ::: Doctors always care.",
            "∀x (Doctor(x) ∧ Helpful(x) → HasKnowledge(x)) ::: Anyone who is a doctor and is helpful is knowledge.",
            "HasKnowledge(Bob) ::: Bob has knowledge."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "TreatsPatients(x) ::: x treats patients",
            "Helpful(x) ::: x is helpful",
            "HasKnowledge(x) ::: x has knowledge",
            "CaresAboutPatients(x) ::: x cares about patients"
        ]
    },
    {
        "premises-NL": [
            "All students are either doctors or not doctors.",
            "Some students are doctors.",
            "All doctors are either students or not students.",
            "Some doctors are students.",
            "If someone is a student and a doctor, then they study medicine.",
            "All people either study medicine or not medicine.",
            "There exists a student who is a doctor.",
            "If a student is a doctor, then they study medicine.",
            "All students who are also doctors study medicine.",
            "If someone is a student and studies medicine, they are a doctor.",
            "There exists a student.",
            "If someone studies medicine, then they are a doctor.",
            "Some students are not doctors."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Doctor(x) ∨ ¬Doctor(x))) ::: All students are either doctors or not doctors",
            "∃x (Student(x) ∧ Doctor(x)) ::: Some students are doctors",
            "∀x (Doctor(x) → (Student(x) ∨ ¬Student(x))) ::: All doctors are either students or not students",
            "∃x (Doctor(x) ∧ Student(x)) ::: Some doctors are students",
            "∀x ((Student(x) ∧ Doctor(x)) → StudiesMedicine(x)) ::: If someone is a student and a doctor, then they study medicine",
            "∀x (StudiesMedicine(x) ∨ ¬StudiesMedicine(x)) ::: All people either study medicine or not medicine",
            "∃x (Student(x) ∧ Doctor(x)) ::: There exists a student who is a doctor",
            "∀x ((Student(x) ∧ Doctor(x)) → StudiesMedicine(x)) ::: If a student is a doctor, then they study medicine",
            "∀x ((Student(x) ∧ Doctor(x)) → StudiesMedicine(x)) ::: All students who are also doctors study medicine",
            "∀x ((Student(x) ∧ StudiesMedicine(x)) → Doctor(x)) ::: If someone is a student and studies medicine, they are a doctor",
            "∃x Student(x) ::: There exists a student",
            "∀x (StudiesMedicine(x) → Doctor(x)) ::: If someone studies medicine, then they are a doctor",
            "∃x (Student(x) ∧ ¬Doctor(x)) ::: Some students are not doctors"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Doctor(x) ::: x is a doctor",
            "StudiesMedicine(x) ::: x studies medicine"
        ]
    },
    {
        "premises-NL": [
            "All cats chase mice.",
            "Garfield is a cat.",
            "Cats either chase mice or do not chase mice.",
            "Garfield either chases mice or does not chase mice.",
            "If something chases mice, then it is a cat.",
            "If something is a cat, it likes lasagna.",
            "Garfield likes lasagna.",
            "All things that chase mice are cats.",
            "Some cats like lasagna.",
            "If something likes lasagna, then it is a cat.",
            "All cats are either orange or not orange.",
            "Garfield is orange.",
            "If something is a cat, it is orange.",
            "Some cats chase mice."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → ChasesMice(x)) ::: All cats chase mice",
            "Cat(garfield) ::: Garfield is a cat",
            "∀x (ChasesMice(x) ∨ ¬ChasesMice(x)) ::: Cats either chase mice or do not chase mice",
            "ChasesMice(garfield) ∨ ¬ChasesMice(garfield) ::: Garfield either chases mice or does not chase mice",
            "∀x (ChasesMice(x) → Cat(x)) ::: If something chases mice, then it is a cat",
            "∀x (Cat(x) → LikesLasagna(x)) ::: If something is a cat, it likes lasagna",
            "LikesLasagna(garfield) ::: Garfield likes lasagna",
            "∀x (ChasesMice(x) → Cat(x)) ::: All things that chase mice are cats",
            "∃x (Cat(x) ∧ LikesLasagna(x)) ::: Some cats like lasagna",
            "∀x (LikesLasagna(x) → Cat(x)) ::: If something likes lasagna, then it is a cat",
            "∀x (Cat(x) → (Orange(x) ∨ ¬Orange(x))) ::: All cats are either orange or not orange",
            "Orange(garfield) ::: Garfield is orange",
            "∀x (Cat(x) → Orange(x)) ::: If something is a cat, it is orange",
            "∃x (Cat(x) ∧ ChasesMice(x)) ::: Some cats chase mice"
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "ChasesMice(x) ::: x chases mice",
            "LikesLasagna(x) ::: x likes lasagna"
        ]
    },
    {
        "premises-NL": [
            "All programmers are smart.",
            "All people who work at Google are well-paid.",
            "If someone is smart and works at Google, then they are well-paid.",
            "Some programmers work at Google.",
            "If someone is a programmer, they are smart.",
            "If someone is well-paid, then they work at Google.",
            "All programmers are either well-paid or not well-paid.",
            "If someone is a programmer and works at Google, then they are well-paid.",
            "All people who work at Google are either well-paid or not well-paid.",
            "Programmers at Google are smart.",
            "If someone is smart, then they are a programmer.",
            "If someone is a programmer and smart, then they work at Google.",
            "Not all programmers are well-paid.",
            "Some people are programmers.",
            "All programmers are well-paid."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → IsSmart(x)) ::: All programmers are smart",
            "∀x (WorksAt(x, google) → WellPaid(x)) ::: All people who work at Google are well-paid",
            "∀x ((IsSmart(x) ∧ WorksAt(x, google)) → WellPaid(x)) ::: If someone is smart and works at Google, then they are well-paid",
            "∃x (Programmer(x) ∧ WorksAt(x, google)) ::: Some programmers work at Google",
            "∀x (Programmer(x) → IsSmart(x)) ::: If someone is a programmer, they are smart",
            "∀x (WellPaid(x) → WorksAt(x, google)) ::: If someone is well-paid, then they work at Google",
            "∀x (Programmer(x) → (WellPaid(x) ∨ ¬WellPaid(x))) ::: All programmers are either well-paid or not well-paid",
            "∀x ((Programmer(x) ∧ WorksAt(x, google)) → WellPaid(x)) ::: If someone is a programmer and works at Google, then they are well-paid",
            "∀x (WorksAt(x, google) → (WellPaid(x) ∨ ¬WellPaid(x))) ::: All people who work at Google are either well-paid or not well-paid",
            "∀x ((Programmer(x) ∧ WorksAt(x, google)) → IsSmart(x)) ::: Programmers at Google are smart",
            "∀x (IsSmart(x) → Programmer(x)) ::: If someone is smart, then they are a programmer",
            "∀x ((Programmer(x) ∧ IsSmart(x)) → WorksAt(x, google)) ::: If someone is a programmer and smart, then they work at Google",
            "¬∀x (Programmer(x) → WellPaid(x)) ::: Not all programmers are well-paid",
            "∃x Programmer(x) ::: Some people are programmers",
            "∀x (Programmer(x) → WellPaid(x)) ::: All programmers are well-paid"
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "WorksAt(x, y) ::: x works at y",
            "WellPaid(x) ::: x is well-paid",
            "IsSmart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All students either study computer science or do not study computer science.",
            "Some students study computer science.",
            "All doctors either study computer science or do not study computer science.",
            "If someone studies computer science, they are not a doctor.",
            "If someone is a student and studies computer science, they like programming.",
            "Some students are not doctors.",
            "All students like programming.",
            "If someone likes programming, they study computer science.",
            "Some students study computer science and are not doctors.",
            "If someone is a doctor, they are not a student.",
            "All students are either doctors or not doctors.",
            "If a student does not study computer science, then they are a doctor.",
            "If someone likes programming, they are a student.",
            "Some students like programming.",
            "If a student studies computer science, they are a doctor.",
            "No student is a doctor."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Studies(x, computerScience) ∨ ¬Studies(x, computerScience))) ::: All students either study computer science or do not study computer science",
            "∃x (Student(x) ∧ Studies(x, computerScience)) ::: Some students study computer science",
            "∀x (Doctor(x) → (Studies(x, computerScience) ∨ ¬Studies(x, computerScience))) ::: All doctors either study computer science or do not study computer science",
            "∀x (Studies(x, computerScience) → ¬Doctor(x)) ::: If someone studies computer science, they are not a doctor",
            "∀x ((Student(x) ∧ Studies(x, computerScience)) → Likes(x, programming)) ::: If someone is a student and studies computer science, they like programming",
            "∃x (Student(x) ∧ ¬Doctor(x)) ::: Some students are not doctors",
            "∀x (Student(x) → Likes(x, programming)) ::: All students like programming",
            "∀x (Likes(x, programming) → Studies(x, computerScience)) ::: If someone likes programming, they study computer science",
            "∃x (Student(x) ∧ Studies(x, computerScience) ∧ ¬Doctor(x)) ::: Some students study computer science and are not doctors",
            "∀x (Doctor(x) → ¬Student(x)) ::: If someone is a doctor, they are not a student",
            "∀x (Student(x) → (Doctor(x) ∨ ¬Doctor(x))) ::: All students are either doctors or not doctors",
            "∀x ((Student(x) ∧ ¬Studies(x, computerScience)) → Doctor(x)) ::: If a student does not study computer science, then they are a doctor",
            "∀x (Likes(x, programming) → Student(x)) ::: If someone likes programming, they are a student",
            "∃x (Student(x) ∧ Likes(x, programming)) ::: Some students like programming",
            "∀x ((Student(x) ∧ Studies(x, computerScience)) → Doctor(x)) ::: If a student studies computer science, they are a doctor",
            "∀x (Student(x) → ¬Doctor(x)) ::: No student is a doctor"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x, y) ::: x studies y",
            "Doctor(x) ::: x is a doctor",
            "Likes(x, y) ::: x likes y"
        ]
    },
    {
        "premises-NL": [
            "All doctors have a degree.",
            "Everyone who has a degree is an expert.",
            "Every doctor has studied medicine.",
            "All doctors trained at a hospital.",
            "Every doctor is a surgeon.",
            "All surgeons are experts.",
            "Anyone who studied medicine is a doctor.",
            "Someone studied medicine.",
            "Doctors and surgeons are the same.",
            "Everyone who has a degree is a researcher.",
            "All doctors are experts.",
            "Anyone who trained at a hospital has a degree.",
            "If someone has a degree and studied medicine, then the person is an expert."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HasDegree(x)) ::: All doctors have a degree.",
            "∀x (HasDegree(x) → Expert(x)) ::: Everyone who has a degree is an expert.",
            "∀x (Doctor(x) → StudiedMedicine(x)) ::: Every doctor has studied medicine.",
            "∀x (Doctor(x) → TrainedAtHospital(x)) ::: All doctors trained at a hospital.",
            "∀x (Doctor(x) → Surgeon(x)) ::: Every doctor is a surgeon.",
            "∀x (Surgeon(x) → Expert(x)) ::: All surgeons are experts.",
            "∀x (StudiedMedicine(x) → Doctor(x)) ::: Anyone who studied medicine is a doctor.",
            "∃x StudiedMedicine(x) ::: Someone studied medicine.",
            "∀x (Doctor(x) ↔ Surgeon(x)) ::: Doctors and surgeons are the same.",
            "∀x (HasDegree(x) → Researcher(x)) ::: Everyone who has a degree is a researcher.",
            "∀x (Doctor(x) → Expert(x)) ::: All doctors are experts.",
            "∀x (TrainedAtHospital(x) → HasDegree(x)) ::: Anyone who trained at a hospital has a degree.",
            "∀x ((HasDegree(x) ∧ StudiedMedicine(x)) → Expert(x)) ::: If someone has a degree and studied medicine, then the person is an expert."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Expert(x) ::: x is an expert",
            "StudiedMedicine(x) ::: x has studied medicine",
            "HasDegree(x) ::: x has a degree",
            "TrainedAtHospital(x) ::: x trained at a hospital",
            "Surgeon(x) ::: x is a surgeon",
            "Researcher(x) ::: x is a researcher"
        ]
    },
    {
        "premises-NL": [
            "All programmers know Java or Python.",
            "Anyone who knows Java is a skilled developer.",
            "All skilled developers have worked on a project.",
            "If someone knows Python, then they use version control.",
            "All programmers use version control.",
            "Everyone who uses version control is a skilled developer.",
            "If someone is a programmer, they have a certification.",
            "All programmers are skilled developers.",
            "Someone is a programmer.",
            "Anyone who knows Python has a certification.",
            "Anyone who knows Java and Python is a skilled developer.",
            "Some programmers know Java.",
            "Programmers know Python.",
            "If someone uses version control and has worked on a project, then they are a skilled developer."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → (KnowsJava(x) ∨ KnowsPython(x))) ::: All programmers know Java or Python.",
            "∀x (KnowsJava(x) → SkilledDeveloper(x)) ::: Anyone who knows Java is a skilled developer.",
            "∀x (SkilledDeveloper(x) → HasWorkedOnProject(x)) ::: All skilled developers have worked on a project.",
            "∀x (KnowsPython(x) → UsesVersionControl(x)) ::: If someone knows Python, then they use version control.",
            "∀x (Programmer(x) → UsesVersionControl(x)) ::: All programmers use version control.",
            "∀x (UsesVersionControl(x) → SkilledDeveloper(x)) ::: Everyone who uses version control is a skilled developer.",
            "∀x (Programmer(x) → HasCertification(x)) ::: If someone is a programmer, they have a certification.",
            "∀x (Programmer(x) → SkilledDeveloper(x)) ::: All programmers are skilled developers.",
            "∃x Programmer(x) ::: Someone is a programmer.",
            "∀x (KnowsPython(x) → HasCertification(x)) ::: Anyone who knows Python has a certification.",
            "∀x ((KnowsJava(x) ∧ KnowsPython(x)) → SkilledDeveloper(x)) ::: Anyone who knows Java and Python is a skilled developer.",
            "∃x (Programmer(x) ∧ KnowsJava(x)) ::: Some programmers know Java.",
            "∀x (Programmer(x) → KnowsPython(x)) ::: Programmers know Python.",
            "∀x ((UsesVersionControl(x) ∧ HasWorkedOnProject(x)) → SkilledDeveloper(x)) ::: If someone uses version control and has worked on a project, then they are a skilled developer."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "KnowsPython(x) ::: x knows Python",
            "SkilledDeveloper(x) ::: x is a skilled developer",
            "KnowsJava(x) ::: x knows Java",
            "HasWorkedOnProject(x) ::: x has worked on a project",
            "UsesVersionControl(x) ::: x uses version control",
            "HasCertification(x) ::: x has a certification"
        ]
    },
    {
        "premises-NL": [
            "All diseases caused by viruses are contagious.",
            "Everything contagious requires medical attention.",
            "Anything transmitted by air is contagious.",
            "All diseases caused by viruses affect humans.",
            "Diseases with severe symptoms require medical attention.",
            "Any disease affecting humans is contagious.",
            "Some diseases are treatable with medication.",
            "Any disease caused by a virus is transmitted by air.",
            "Some diseases cause severe symptoms.",
            "Contagious diseases require medical attention.",
            "Every disease caused by virus is treatable with medication.",
            "If something is a disease caused by a virus, then it has severe symptoms.",
            "Some diseases caused by a virus are transmitted by air.",
            "Anything contagious causes severe symptoms.",
            "Diseases that are treatable with medication are caused by a virus."
        ],
        "premises-FOL": [
            "∀x (DiseaseCausedByVirus(x) → Contagious(x)) ::: All diseases caused by viruses are contagious.",
            "∀x (Contagious(x) → RequiresMedicalAttention(x)) ::: Everything contagious requires medical attention.",
            "∀x (TransmittedByAir(x) → Contagious(x)) ::: Anything transmitted by air is contagious.",
            "∀x (DiseaseCausedByVirus(x) → AffectsHumans(x)) ::: All diseases caused by viruses affect humans.",
            "∀x (SevereSymptoms(x) → RequiresMedicalAttention(x)) ::: Diseases with severe symptoms require medical attention.",
            "∀x (AffectsHumans(x) → Contagious(x)) ::: Any disease affecting humans is contagious.",
            "∃x TreatableWithMedication(x) ::: Some diseases are treatable with medication.",
            "∀x (DiseaseCausedByVirus(x) → TransmittedByAir(x)) ::: Any disease caused by a virus is transmitted by air.",
            "∃x SevereSymptoms(x) ::: Some diseases cause severe symptoms.",
            "∀x (Contagious(x) → RequiresMedicalAttention(x)) ::: Contagious diseases require medical attention.",
            "∀x (DiseaseCausedByVirus(x) → TreatableWithMedication(x)) ::: Every disease caused by virus is treatable with medication.",
            "∀x (DiseaseCausedByVirus(x) → SevereSymptoms(x)) ::: If something is a disease caused by a virus, then it has severe symptoms.",
            "∃x (DiseaseCausedByVirus(x) ∧ TransmittedByAir(x)) ::: Some diseases caused by a virus are transmitted by air.",
            "∀x (Contagious(x) → SevereSymptoms(x)) ::: Anything contagious causes severe symptoms.",
            "∀x (TreatableWithMedication(x) → DiseaseCausedByVirus(x)) ::: Diseases that are treatable with medication are caused by a virus."
        ],
        "predicates": [
            "DiseaseCausedByVirus(x) ::: x is a disease caused by a virus",
            "Contagious(x) ::: x is contagious",
            "RequiresMedicalAttention(x) ::: x requires medical attention",
            "TransmittedByAir(x) ::: x is transmitted by air",
            "AffectsHumans(x) ::: x affects humans",
            "SevereSymptoms(x) ::: x causes severe symptoms",
            "TreatableWithMedication(x) ::: x is treatable with medication"
        ]
    },
    {
        "premises-NL": [
            "All members of the marketing team are experienced.",
            "Experienced employees have project management experience.",
            "Anyone who has project management experience is eligible to lead.",
            "Senior employees are members of the marketing team.",
            "Anyone who has led a team has project management experience.",
            "Some employees are senior employees.",
            "Employees in the marketing team have communication skills.",
            "All experienced employees have led a team.",
            "Someone has project management experience.",
            "Anyone eligible to lead has communication skills.",
            "Anyone who is experienced is eligible to lead.",
            "If someone has communication skills and is a senior employee, then they are eligible to lead.",
            "All senior employees have project management experience.",
            "If a person is experienced and has led a team, then this person is eligible to lead.",
            "Some people in the marketing team have project management experience.",
            "Anyone who has communication skills is eligible to lead."
        ],
        "premises-FOL": [
            "∀x (MarketingTeam(x) → Experienced(x)) ::: All members of the marketing team are experienced.",
            "∀x (Experienced(x) → ProjectManagementExperience(x)) ::: Experienced employees have project management experience.",
            "∀x (ProjectManagementExperience(x) → EligibleToLead(x)) ::: Anyone who has project management experience is eligible to lead.",
            "∀x (SeniorEmployee(x) → MarketingTeam(x)) ::: Senior employees are members of the marketing team.",
            "∀x (HasLedTeam(x) → ProjectManagementExperience(x)) ::: Anyone who has led a team has project management experience.",
            "∃x SeniorEmployee(x) ::: Some employees are senior employees.",
            "∀x (MarketingTeam(x) → CommunicationSkills(x)) ::: Employees in the marketing team have communication skills.",
            "∀x (Experienced(x) → HasLedTeam(x)) ::: All experienced employees have led a team.",
            "∃x ProjectManagementExperience(x) ::: Someone has project management experience.",
            "∀x (EligibleToLead(x) → CommunicationSkills(x)) ::: Anyone eligible to lead has communication skills.",
            "∀x (Experienced(x) → EligibleToLead(x)) ::: Anyone who is experienced is eligible to lead.",
            "∀x ((CommunicationSkills(x) ∧ SeniorEmployee(x)) → EligibleToLead(x)) ::: If someone has communication skills and is a senior employee, then they are eligible to lead.",
            "∀x (SeniorEmployee(x) → ProjectManagementExperience(x)) ::: All senior employees have project management experience.",
            "∀x ((Experienced(x) ∧ HasLedTeam(x)) → EligibleToLead(x)) ::: If a person is experienced and has led a team, then this person is eligible to lead.",
            "∃x (MarketingTeam(x) ∧ ProjectManagementExperience(x)) ::: Some people in the marketing team have project management experience.",
            "∀x (CommunicationSkills(x) → EligibleToLead(x)) ::: Anyone who has communication skills is eligible to lead."
        ],
        "predicates": [
            "MarketingTeam(x) ::: x is a member of the marketing team",
            "ProjectManagementExperience(x) ::: x has project management experience",
            "EligibleToLead(x) ::: x is eligible to lead",
            "Experienced(x) ::: x is experienced",
            "HasLedTeam(x) ::: x has led a team",
            "SeniorEmployee(x) ::: x is a senior employee",
            "CommunicationSkills(x) ::: x has communication skills"
        ]
    },
    {
        "premises-NL": [
            "Sarah is smart.",
            "Smart people pass exams.",
            "If someone is smart and studies hard, they will pass the exam.",
            "If someone studies hard, they will work hard.",
            "Sarah is studying hard.",
            "If someone works hard and is smart, they pass.",
            "If someone does not pass the exam then they fail the exam.",
            "Sarah does not fail the exam.",
            "Someone either passes or fails the exam.",
            "Either Sarah is smart, or Sarah is studying hard.",
            "If someone works hard and is not smart, they will fail the exam.",
            "If someone fails the exam they are not smart.",
            "If someone is smart and studies, they will pass."
        ],
        "premises-FOL": [
            "Smart(sarah) ::: Sarah is smart.",
            "∀x (Smart(x) → PassExam(x)) ::: Smart people pass exams.",
            "∀x (Smart(x) ∧ StudyHard(x) → PassExam(x)) ::: If someone is smart and studies hard, they will pass the exam.",
            "∀x (StudyHard(x) → WorksHard(x)) ::: If someone studies hard, they will work hard.",
            "StudyHard(sarah) ::: Sarah is studying hard.",
            "∀x (WorksHard(x) ∧ Smart(x) → PassExam(x)) ::: If someone works hard and is smart, they pass.",
            "∀x (¬PassExam(x) → FailsExam(x)) ::: If someone does not pass the exam then they fail the exam.",
            "¬FailsExam(sarah) ::: Sarah does not fail the exam.",
            "∀x (PassExam(x) ∨ FailsExam(x)) ::: Someone either passes or fails the exam.",
            "Smart(sarah) ∨ StudyHard(sarah) ::: Either Sarah is smart, or Sarah is studying hard.",
            "∀x (WorksHard(x) ∧ ¬Smart(x) → FailsExam(x)) ::: If someone works hard and is not smart, they will fail the exam.",
            "∀x (FailsExam(x) → ¬Smart(x)) ::: If someone fails the exam they are not smart.",
            "∀x (Smart(x) ∧ StudyHard(x) → PassExam(x)) ::: If someone is smart and studies, they will pass."
        ],
        "predicates": [
            "StudyHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "Smart(x) ::: x is smart",
            "WorksHard(x) ::: x works hard",
            "FailsExam(x) ::: x fails the exam"
        ]
    },
    {
        "premises-NL": [
            "John invests.",
            "If an investment is risky, it either gains money or loses money.",
            "If an investment is profitable, it gains money.",
            "If an investment is safe, it does not lose money.",
            "John's investment is either risky or safe.",
            "John is either rich or invests",
            "If John is rich, then John gains money.",
            "If an investment is not profitable, it will lose money.",
            "If John invests in something that is not profitable, then he loses money.",
            "If John invests in something that is safe, he gains money.",
            "If John invests and gains money, he will become rich.",
            "If John loses money, he will not become rich.",
            "John's investment is profitable.",
            "If something is not safe, it will be risky."
        ],
        "premises-FOL": [
            "Invests(john) ::: John invests.",
            "∀x (RiskyInvestment(x) → (GainsMoney(x) ∨ LosesMoney(x))) ::: If an investment is risky, it either gains money or loses money.",
            "∀x (Profitable(x) → GainsMoney(x)) ::: If an investment is profitable, it gains money.",
            "∀x (SafeInvestment(x) → ¬LosesMoney(x)) ::: If an investment is safe, it does not lose money.",
            "RiskyInvestment(john) ∨ SafeInvestment(john) ::: John's investment is either risky or safe.",
            "IsRich(john) ∨ Invests(john) ::: John is either rich or invests",
            "∀x (IsRich(x) → GainsMoney(x)) ::: If John is rich, then John gains money.",
            "∀x (¬Profitable(x) → LosesMoney(x)) ::: If an investment is not profitable, it will lose money.",
            "∀x (Invests(x) ∧ ¬Profitable(x) → LosesMoney(x)) ::: If John invests in something that is not profitable, then he loses money.",
            "∀x (Invests(x) ∧ SafeInvestment(x) → GainsMoney(x)) ::: If John invests in something that is safe, he gains money.",
            "∀x (Invests(x) ∧ GainsMoney(x) → IsRich(x)) ::: If John invests and gains money, he will become rich.",
            "∀x (LosesMoney(x) → ¬IsRich(x)) ::: If John loses money, he will not become rich.",
            "Profitable(john) ::: John's investment is profitable.",
            "∀x (¬SafeInvestment(x) → RiskyInvestment(x)) ::: If something is not safe, it will be risky."
        ],
        "predicates": [
            "Invests(x) ::: x invests",
            "GainsMoney(x) ::: x gains money",
            "RiskyInvestment(x) ::: x is a risky investment",
            "Profitable(x) ::: x is profitable",
            "SafeInvestment(x) ::: x is a safe investment",
            "LosesMoney(x) ::: x loses money",
            "IsRich(x) ::: x is rich"
        ]
    },
    {
        "premises-NL": [
            "All students either attend all lectures or skip some lectures.",
            "If a student attends all lectures and studies hard, they will pass the course.",
            "Students who attend lectures are students.",
            "If a student fails the course, they didn't attend all lectures.",
            "If a student doesn't attend lectures, they are skipping lectures.",
            "Any student that doesn't pass the course will fail it.",
            "Any student who gets a good grade will pass the course.",
            "If a student studies hard, they will pass the course.",
            "If someone skips lectures, they don't attend lectures.",
            "If someone attends lectures and studies, they will pass the course.",
            "Students who don't get a good grade fail.",
            "John is a student who attends lectures.",
            "Students pass if they study hard and attend all lectures.",
            "If a student doesn't pass they skip lectures.",
            "Some student is taking the course."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (AttendsLectures(x) ∨ SkipsLectures(x))) ::: All students either attend all lectures or skip some lectures.",
            "∀x (Student(x) ∧ AttendsLectures(x) ∧ StudiesHard(x) → PassCourse(x)) ::: If a student attends all lectures and studies hard, they will pass the course.",
            "∀x (AttendsLectures(x) → Student(x)) ::: Students who attend lectures are students.",
            "∀x (FailsCourse(x) → ¬AttendsLectures(x)) ::: If a student fails the course, they didn't attend all lectures.",
            "∀x (¬AttendsLectures(x) → SkipsLectures(x)) ::: If a student doesn't attend lectures, they are skipping lectures.",
            "∀x (¬PassCourse(x) → FailsCourse(x)) ::: Any student that doesn't pass the course will fail it.",
            "∀x (GoodGrade(x) → PassCourse(x)) ::: Any student who gets a good grade will pass the course.",
            "∀x (Student(x) ∧ StudiesHard(x) → PassCourse(x)) ::: If a student studies hard, they will pass the course.",
            "∀x (SkipsLectures(x) → ¬AttendsLectures(x)) ::: If someone skips lectures, they don't attend lectures.",
            "∀x (Student(x) ∧ AttendsLectures(x) ∧ StudiesHard(x) → PassCourse(x)) ::: If someone attends lectures and studies, they will pass the course.",
            "∀x (¬GoodGrade(x) → FailsCourse(x)) ::: Students who don't get a good grade fail.",
            "Student(john) ∧ AttendsLectures(john) ::: John is a student who attends lectures.",
            "∀x (Student(x) ∧ AttendsLectures(x) ∧ StudiesHard(x) → PassCourse(x)) ::: Students pass if they study hard and attend all lectures.",
            "∀x (¬PassCourse(x) → SkipsLectures(x)) ::: If a student doesn't pass they skip lectures.",
            "∃x Student(x) ::: Some student is taking the course."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsLectures(x) ::: x attends all lectures",
            "PassCourse(x) ::: x passes the course",
            "StudiesHard(x) ::: x studies hard",
            "FailsCourse(x) ::: x fails the course",
            "SkipsLectures(x) ::: x skips lectures",
            "GoodGrade(x) ::: x gets a good grade"
        ]
    },
    {
        "premises-NL": [
            "Any company either faces competition or does not face competition.",
            "If a company invests in research and development and is innovative, it increases profits.",
            "If a company faces competition, it either increases profits or loses market share.",
            "A company becomes a leader if and only if it is innovative and provides good service.",
            "A company is innovative if it invests in research and development.",
            "Any company either invests in research and development or does not invest in research and development.",
            "If a company loses market share, it does not increase profits.",
            "If a company provides good service and doesn't face competition, then it increases profits.",
            "If a company does not face competition, then it provides good service.",
            "If a company increases its profits, then it provides good service.",
            "If a company loses market share, it faces competition.",
            "If a company invests in research and development and does not increase its profits, then it becomes a leader.",
            "Company A invests in R&D.",
            "A company faces competition if it does not provide good service.",
            "Company A doesn't lose market share.",
            "Company A doesn't face competition.",
            "If a company is a leader, it provides good service."
        ],
        "premises-FOL": [
            "∀x (Company(x) → (FacesCompetition(x) ∨ ¬FacesCompetition(x))) ::: Any company either faces competition or does not face competition.",
            "∀x (Company(x) ∧ InvestsInRAndD(x) ∧ Innovative(x) → IncreasesProfits(x)) ::: If a company invests in research and development and is innovative, it increases profits.",
            "∀x (Company(x) ∧ FacesCompetition(x) → (IncreasesProfits(x) ∨ LosesMarketShare(x))) ::: If a company faces competition, it either increases profits or loses market share.",
            "∀x (Company(x) ∧ BecomesLeader(x) ↔ (Innovative(x) ∧ ProvidesGoodService(x))) ::: A company becomes a leader if and only if it is innovative and provides good service.",
            "∀x (Company(x) ∧ InvestsInRAndD(x) → Innovative(x)) ::: A company is innovative if it invests in research and development.",
            "∀x (Company(x) → (InvestsInRAndD(x) ∨ ¬InvestsInRAndD(x))) ::: Any company either invests in research and development or does not invest in research and development.",
            "∀x (LosesMarketShare(x) → ¬IncreasesProfits(x)) ::: If a company loses market share, it does not increase profits.",
            "∀x (Company(x) ∧ ProvidesGoodService(x) ∧ ¬FacesCompetition(x) → IncreasesProfits(x)) ::: If a company provides good service and doesn't face competition, then it increases profits.",
            "∀x (Company(x) ∧ ¬FacesCompetition(x) → ProvidesGoodService(x)) ::: If a company does not face competition, then it provides good service.",
            "∀x (IncreasesProfits(x) → ProvidesGoodService(x)) ::: If a company increases its profits, then it provides good service.",
            "∀x (LosesMarketShare(x) → FacesCompetition(x)) ::: If a company loses market share, it faces competition.",
            "∀x (Company(x) ∧ InvestsInRAndD(x) ∧ ¬IncreasesProfits(x) → BecomesLeader(x)) ::: If a company invests in research and development and does not increase its profits, then it becomes a leader.",
            "Company(a) ∧ InvestsInRAndD(a) ::: Company A invests in R&D.",
            "∀x (FacesCompetition(x) → ¬ProvidesGoodService(x)) ::: A company faces competition if it does not provide good service.",
            "¬LosesMarketShare(a) ::: Company A doesn't lose market share.",
            "¬FacesCompetition(a) ::: Company A doesn't face competition.",
            "∀x (BecomesLeader(x) → ProvidesGoodService(x)) ::: If a company is a leader, it provides good service."
        ],
        "predicates": [
            "Company(x) ::: x is a company",
            "InvestsInRAndD(x) ::: x invests in research and development",
            "IncreasesProfits(x) ::: x increases profits",
            "BecomesLeader(x) ::: x becomes a leader",
            "FacesCompetition(x) ::: x faces competition",
            "Innovative(x) ::: x is innovative",
            "LosesMarketShare(x) ::: x loses market share",
            "ProvidesGoodService(x) ::: x provides good service"
        ]
    },
    {
        "premises-NL": [
            "All smart people study hard.",
            "John is smart.",
            "If someone studies hard, they will pass the exam.",
            "John likes coffee.",
            "John has friends.",
            "If someone likes coffee and has friends, they study hard.",
            "If John is smart, then he likes coffee.",
            "Not all smart people like coffee.",
            "If someone is smart they have friends.",
            "John is smart and has friends.",
            "Someone who likes coffee studies hard and passes the exam.",
            "John is smart"
        ],
        "premises-FOL": [
            "∀x (Smart(x) → StudyHard(x)) ::: All smart people study hard",
            "Smart(john) ::: John is smart",
            "∀x (StudyHard(x) → PassExam(x)) ::: If someone studies hard, they will pass the exam",
            "LikesCoffee(john) ::: John likes coffee",
            "HasFriends(john) ::: John has friends",
            "(LikesCoffee(x) ∧ HasFriends(x)) → StudyHard(x) ::: If someone likes coffee and has friends, they study hard",
            "Smart(john) → LikesCoffee(john) ::: If John is smart, then he likes coffee",
            "¬∀x (Smart(x) → LikesCoffee(x)) ::: Not all smart people like coffee",
            "∀x (Smart(x) → HasFriends(x)) ::: If someone is smart they have friends",
            "(Smart(john) ∧ HasFriends(john)) ::: John is smart and has friends",
            "∃x (LikesCoffee(x) ∧ StudyHard(x) ∧ PassExam(x)) ::: Someone who likes coffee studies hard and passes the exam",
            "Smart(john) ::: John is smart"
        ],
        "predicates": [
            "Smart(x) ::: x is smart",
            "StudyHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "LikesCoffee(x) ::: x likes coffee",
            "HasFriends(x) ::: x has friends"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "All researchers publish papers.",
            "Some doctors attend conferences.",
            "If someone treats patients and attends conferences, they are dedicated to medicine.",
            "Some researchers are doctors.",
            "If someone publishes papers and is dedicated, then they are researchers",
            "If someone is a doctor, they are smart.",
            "If someone is a researcher, then they are smart.",
            "If someone is a doctor and researcher then they have to attend conferences.",
            "If a doctor and researcher, they publish papers.",
            "If someone attends conferences, they are a doctor.",
            "If someone is a doctor they will dedicate their lives to medicine",
            "If someone researches and is dedicated to medicine then they attend conferences.",
            "Not all doctors are researchers."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → TreatsPatients(x)) ::: All doctors treat patients",
            "∀x (Researcher(x) → PublishesPapers(x)) ::: All researchers publish papers",
            "∃x (Doctor(x) ∧ AttendsConferences(x)) ::: Some doctors attend conferences",
            "∀x ((TreatsPatients(x) ∧ AttendsConferences(x)) → DedicatedToMedicine(x)) ::: If someone treats patients and attends conferences, they are dedicated to medicine",
            "∃x (Researcher(x) ∧ Doctor(x)) ::: Some researchers are doctors",
            "∀x ((PublishesPapers(x) ∧ DedicatedToMedicine(x)) → Researcher(x)) ::: If someone publishes papers and is dedicated, then they are researchers",
            "∀x (Doctor(x) → IsSmart(x)) ::: If someone is a doctor, they are smart",
            "∀x (Researcher(x) → IsSmart(x)) ::: If someone is a researcher, then they are smart",
            "∀x ((Doctor(x) ∧ Researcher(x)) → AttendsConferences(x)) ::: If someone is a doctor and researcher then they have to attend conferences",
            "∀x ((Doctor(x) ∧ Researcher(x)) → PublishesPapers(x)) ::: If a doctor and researcher, they publish papers",
            "∀x (AttendsConferences(x) → Doctor(x)) ::: If someone attends conferences, they are a doctor",
            "∀x (Doctor(x) → DedicatedToMedicine(x)) ::: If someone is a doctor they will dedicate their lives to medicine",
            "∀x ((Researcher(x) ∧ DedicatedToMedicine(x)) → AttendsConferences(x)) ::: If someone researches and is dedicated to medicine then they attend conferences",
            "¬∀x (Doctor(x) → Researcher(x)) ::: Not all doctors are researchers"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Researcher(x) ::: x is a researcher",
            "DedicatedToMedicine(x) ::: x is dedicated to medicine",
            "PublishesPapers(x) ::: x publishes papers",
            "TreatsPatients(x) ::: x treats patients",
            "AttendsConferences(x) ::: x attends conferences",
            "IsSmart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All professors teach students.",
            "All authors write books.",
            "Some professors are authors.",
            "If someone teaches students, they like to read books.",
            "If someone writes books, they read books.",
            "If someone reads books, they are educated.",
            "If someone is a professor, they are educated.",
            "If someone is educated, they have to read books.",
            "Some authors are professors.",
            "Some educated people are authors.",
            "Some people who teach students are also authors.",
            "If someone is a professor, they write books.",
            "If someone likes to read books they are educated.",
            "Some educated people are professors.",
            "Not all professors are authors."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → TeachesStudents(x)) ::: All professors teach students",
            "∀x (Author(x) → WritesBooks(x)) ::: All authors write books",
            "∃x (Professor(x) ∧ Author(x)) ::: Some professors are authors",
            "∀x (TeachesStudents(x) → LikesToRead(x)) ::: If someone teaches students, they like to read books",
            "∀x (WritesBooks(x) → ReadsBooks(x)) ::: If someone writes books, they read books",
            "∀x (ReadsBooks(x) → IsEducated(x)) ::: If someone reads books, they are educated",
            "∀x (Professor(x) → IsEducated(x)) ::: If someone is a professor, they are educated",
            "∀x (IsEducated(x) → ReadsBooks(x)) ::: If someone is educated, they have to read books",
            "∃x (Author(x) ∧ Professor(x)) ::: Some authors are professors",
            "∃x (IsEducated(x) ∧ Author(x)) ::: Some educated people are authors",
            "∃x (TeachesStudents(x) ∧ Author(x)) ::: Some people who teach students are also authors",
            "∀x (Professor(x) → WritesBooks(x)) ::: If someone is a professor, they write books",
            "∀x (LikesToRead(x) → IsEducated(x)) ::: If someone likes to read books they are educated",
            "∃x (IsEducated(x) ∧ Professor(x)) ::: Some educated people are professors",
            "¬∀x (Professor(x) → Author(x)) ::: Not all professors are authors"
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "Author(x) ::: x is an author",
            "LikesToRead(x) ::: x likes to read books",
            "WritesBooks(x) ::: x writes books",
            "TeachesStudents(x) ::: x teaches students",
            "ReadsBooks(x) ::: x reads books",
            "IsEducated(x) ::: x is educated"
        ]
    },
    {
        "premises-NL": [
            "All programmers write code.",
            "All gamers play games.",
            "Some programmers are gamers.",
            "If someone writes code, they use a computer a lot.",
            "If someone plays games, they use a computer a lot.",
            "If someone uses a computer a lot, they are online.",
            "If someone is a programmer, they enjoy technology.",
            "If someone is a gamer, they enjoy technology.",
            "If someone enjoys technology, they have to be online.",
            "If someone is online and enjoys technology, they use a computer a lot.",
            "If someone is a programmer, they are online.",
            "If someone is a gamer, they are online.",
            "Some online people write code.",
            "Some programmers enjoy technology and use a computer.",
            "Some people that enjoy technology are also programmers.",
            "Not all programmers are gamers."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → WritesCode(x)) ::: All programmers write code",
            "∀x (Gamer(x) → PlaysGames(x)) ::: All gamers play games",
            "∃x (Programmer(x) ∧ Gamer(x)) ::: Some programmers are gamers",
            "∀x (WritesCode(x) → UsesComputerALot(x)) ::: If someone writes code, they use a computer a lot",
            "∀x (PlaysGames(x) → UsesComputerALot(x)) ::: If someone plays games, they use a computer a lot",
            "∀x (UsesComputerALot(x) → IsOnline(x)) ::: If someone uses a computer a lot, they are online",
            "∀x (Programmer(x) → EnjoysTechnology(x)) ::: If someone is a programmer, they enjoy technology",
            "∀x (Gamer(x) → EnjoysTechnology(x)) ::: If someone is a gamer, they enjoy technology",
            "∀x (EnjoysTechnology(x) → IsOnline(x)) ::: If someone enjoys technology, they have to be online",
            "∀x ((IsOnline(x) ∧ EnjoysTechnology(x)) → UsesComputerALot(x)) ::: If someone is online and enjoys technology, they use a computer a lot",
            "∀x (Programmer(x) → IsOnline(x)) ::: If someone is a programmer, they are online",
            "∀x (Gamer(x) → IsOnline(x)) ::: If someone is a gamer, they are online",
            "∃x (IsOnline(x) ∧ WritesCode(x)) ::: Some online people write code",
            "∃x (Programmer(x) ∧ EnjoysTechnology(x) ∧ UsesComputerALot(x)) ::: Some programmers enjoy technology and use a computer",
            "∃x (EnjoysTechnology(x) ∧ Programmer(x)) ::: Some people that enjoy technology are also programmers",
            "¬∀x (Programmer(x) → Gamer(x)) ::: Not all programmers are gamers"
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "Gamer(x) ::: x is a gamer",
            "UsesComputerALot(x) ::: x uses a computer a lot",
            "WritesCode(x) ::: x writes code",
            "PlaysGames(x) ::: x plays games",
            "EnjoysTechnology(x) ::: x enjoys technology",
            "IsOnline(x) ::: x is online"
        ]
    },
    {
        "premises-NL": [
            "All students who study finance are studying finance.",
            "Anyone who works in finance is involved with money.",
            "All students who are employed are involved with money.",
            "If someone works in finance, they are employed.",
            "If someone is a student, they either study finance or are not working.",
            "Anyone who works in finance studies economics.",
            "Anyone who is a student, is studying something.",
            "If someone studies economics, they are involved with money.",
            "If someone studies finance, they are a student or employed.",
            "Some students study finance."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesFinance(x) → StudiesFinance(x)) ::: All students who study finance are studying finance.",
            "∀x (WorksFinance(x) → InvolvedMoney(x)) ::: Anyone who works in finance is involved with money.",
            "∀x (Student(x) ∧ Employed(x) → InvolvedMoney(x)) ::: All students who are employed are involved with money.",
            "∀x (WorksFinance(x) → Employed(x)) ::: If someone works in finance, they are employed.",
            "∀x (Student(x) → (StudiesFinance(x) ∨ ¬Employed(x))) ::: If someone is a student, they either study finance or are not working.",
            "∀x (WorksFinance(x) → StudiesEconomics(x)) ::: Anyone who works in finance studies economics.",
            "∀x (Student(x) → StudiesSomething(x)) ::: Anyone who is a student, is studying something.",
            "∀x (StudiesEconomics(x) → InvolvedMoney(x)) ::: If someone studies economics, they are involved with money.",
            "∀x (StudiesFinance(x) → (Student(x) ∨ Employed(x))) ::: If someone studies finance, they are a student or employed.",
            "∃x (Student(x) ∧ StudiesFinance(x)) ::: Some students study finance."
        ],
        "predicates": [
            "StudiesFinance(x) ::: x studies finance",
            "WorksFinance(x) ::: x works in finance",
            "InvolvedMoney(x) ::: x is involved with money",
            "Student(x) ::: x is a student",
            "Employed(x) ::: x is employed"
        ]
    },
    {
        "premises-NL": [
            "All patients with a fever and cough either have the flu or a cold.",
            "Patients with the flu do not have a rash.",
            "If a patient has a cold, they may have a headache.",
            "Anyone who has contact with an infected person is a patient.",
            "Patients with a cold do not have a fever.",
            "Anyone who has a rash, does not have a fever.",
            "Some patients have a fever.",
            "Some patients have a cough.",
            "Anyone with the flu has a cough.",
            "If a patient has the flu, they have contact with an infected person.",
            "Anyone that has a cold and a headache is not a patient.",
            "If a patient has contact with an infected person and no fever, then they have the cold."
        ],
        "premises-FOL": [
            "∀x ((Fever(x) ∧ Cough(x)) → (HasFlu(x) ∨ HasCold(x))) ::: All patients with a fever and cough either have the flu or a cold.",
            "∀x (HasFlu(x) → ¬Rash(x)) ::: Patients with the flu do not have a rash.",
            "∀x (HasCold(x) → Headache(x)) ::: If a patient has a cold, they may have a headache.",
            "∀x (ContactWithInfected(x) → Patient(x)) ::: Anyone who has contact with an infected person is a patient.",
            "∀x (HasCold(x) → ¬Fever(x)) ::: Patients with a cold do not have a fever.",
            "∀x (Rash(x) → ¬Fever(x)) ::: Anyone who has a rash, does not have a fever.",
            "∃x Fever(x) ::: Some patients have a fever.",
            "∃x Cough(x) ::: Some patients have a cough.",
            "∀x (HasFlu(x) → Cough(x)) ::: Anyone with the flu has a cough.",
            "∀x (HasFlu(x) → ContactWithInfected(x)) ::: If a patient has the flu, they have contact with an infected person.",
            "∀x ((HasCold(x) ∧ Headache(x)) → ¬Patient(x)) ::: Anyone that has a cold and a headache is not a patient.",
            "∀x ((ContactWithInfected(x) ∧ ¬Fever(x)) → HasCold(x)) ::: If a patient has contact with an infected person and no fever, then they have the cold."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient",
            "Fever(x) ::: x has a fever",
            "Cough(x) ::: x has a cough",
            "Rash(x) ::: x has a rash",
            "HasFlu(x) ::: x has the flu",
            "HasCold(x) ::: x has a cold",
            "ContactWithInfected(x) ::: x has contact with someone infected",
            "Headache(x) ::: x has a headache"
        ]
    },
    {
        "premises-NL": [
            "All students who attend classes and study hard pass their exams.",
            "If a student has an excuse, they are not failing.",
            "If a student fails, they do not pass the exam.",
            "Any student who does not attend classes has the chance to fail.",
            "If a student passes the exam, they have good grades.",
            "Students who study hard and have good grades receive a scholarship.",
            "Students who don't have good grades are not eligible for a scholarship.",
            "Any student who does not have a valid excuse and doesn't attend classes will fail.",
            "Students who study hard take the exam.",
            "If a student takes the exam, they have a chance to pass.",
            "Students with a scholarship, have good grades",
            "If a student fails, they are not a student.",
            "If a student has an excuse, they attend classes."
        ],
        "premises-FOL": [
            "∀x ((Student(x) ∧ AttendsClasses(x) ∧ StudiesHard(x)) → PassesExam(x)) ::: All students who attend classes and study hard pass their exams.",
            "∀x (HasExcuse(x) → ¬Fails(x)) ::: If a student has an excuse, they are not failing.",
            "∀x (Fails(x) → ¬PassesExam(x)) ::: If a student fails, they do not pass the exam.",
            "∀x ((Student(x) ∧ ¬AttendsClasses(x)) → Fails(x)) ::: Any student who does not attend classes has the chance to fail.",
            "∀x (PassesExam(x) → HasGoodGrades(x)) ::: If a student passes the exam, they have good grades.",
            "∀x ((Student(x) ∧ StudiesHard(x) ∧ HasGoodGrades(x)) → ReceivesScholarship(x)) ::: Students who study hard and have good grades receive a scholarship.",
            "∀x (¬HasGoodGrades(x) → ¬ReceivesScholarship(x)) ::: Students who don't have good grades are not eligible for a scholarship.",
            "∀x ((Student(x) ∧ ¬HasExcuse(x) ∧ ¬AttendsClasses(x)) → Fails(x)) ::: Any student who does not have a valid excuse and doesn't attend classes will fail.",
            "∀x (StudiesHard(x) → TakesExam(x)) ::: Students who study hard take the exam.",
            "∀x (TakesExam(x) → PassesExam(x)) ::: If a student takes the exam, they have a chance to pass.",
            "∀x (ReceivesScholarship(x) → HasGoodGrades(x)) ::: Students with a scholarship, have good grades.",
            "∀x (Fails(x) → ¬Student(x)) ::: If a student fails, they are not a student.",
            "∀x (HasExcuse(x) → AttendsClasses(x)) ::: If a student has an excuse, they attend classes."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsClasses(x) ::: x attends classes",
            "Fails(x) ::: x fails",
            "HasExcuse(x) ::: x has a valid excuse",
            "TakesExam(x) ::: x takes an exam",
            "PassesExam(x) ::: x passes an exam",
            "StudiesHard(x) ::: x studies hard",
            "ReceivesScholarship(x) ::: x receives a scholarship",
            "HasGoodGrades(x) ::: x has good grades"
        ]
    },
    {
        "premises-NL": [
            "All students study hard or they will fail.",
            "Alice is a student.",
            "If a student is tutored, they will not fail.",
            "Bob is Alice's tutor.",
            "Students who don't study hard will fail."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (StudiesHard(x) ∨ Fail(x))) ::: All students study hard or they will fail.",
            "Student(Alice) ::: Alice is a student.",
            "∀x ∀y ((Student(y) ∧ TutorOf(x, y)) → ¬Fail(y)) ::: If a student is tutored, they will not fail.",
            "TutorOf(Bob, Alice) ::: Bob is Alice's tutor.",
            "∀x (¬StudiesHard(x) → Fail(x)) ::: Students who don't study hard will fail.",
            "∀x (Fail(x) → ¬PassExam(x)) ::: Those who fail will not pass.",
            "Student(Bob) ::: Bob is a student.",
            "∀x (TutorOf(x, y) → Student(y)) ::: If x is a tutor of y then y is a student.",
            "¬Fail(Alice) ::: Alice does not fail.",
            "StudiesHard(Alice) ∨ Fail(Alice) ::: Alice studies hard or Alice fails.",
            "∀x (PassExam(x) ∨ Fail(x)) ::: Everyone either passes or fails.",
            "∀x (Student(x) → (PassExam(x) ∨ Fail(x))) ::: All students either pass or fail."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "TutorOf(x, y) ::: x is a tutor of y",
            "PassExam(x) ::: x will pass the exam"
        ]
    },
    {
        "premises-NL": [
            "All musicians either play guitar or play the piano.",
            "David is a musician.",
            "Musicians who play the piano don't like Jazz.",
            "David likes Jazz.",
            "If someone doesn't play guitar, then they play piano.",
            "Anyone who plays piano, does not like Jazz",
            "All musicians like Jazz or they dislike Jazz.",
            "If someone dislikes Jazz, they don't play guitar.",
            "Anyone who doesn't play guitar, plays piano.",
            "Musicians who don't like Jazz play the piano.",
            "David plays piano or guitar.",
            "If David is a musician and plays piano, then he does not like Jazz.",
            "If someone is a musician and likes Jazz, then they don't play piano."
        ],
        "premises-FOL": [
            "∀x (Musician(x) → (PlaysGuitar(x) ∨ PlaysPiano(x))) ::: All musicians either play guitar or play the piano.",
            "Musician(David) ::: David is a musician.",
            "∀x ((Musician(x) ∧ PlaysPiano(x)) → ¬Likes(x, Jazz)) ::: Musicians who play the piano don't like Jazz.",
            "Likes(David, Jazz) ::: David likes Jazz.",
            "∀x (¬PlaysGuitar(x) → PlaysPiano(x)) ::: If someone doesn't play guitar, then they play piano.",
            "∀x (PlaysPiano(x) → ¬Likes(x, Jazz)) ::: Anyone who plays piano, does not like Jazz",
            "∀x (Musician(x) → (Likes(x, Jazz) ∨ ¬Likes(x, Jazz))) ::: All musicians like Jazz or they dislike Jazz.",
            "∀x (¬PlaysGuitar(x) → ¬Likes(x, Jazz)) ::: If someone dislikes Jazz, they don't play guitar.",
            "∀x (¬PlaysGuitar(x) → PlaysPiano(x)) ::: Anyone who doesn't play guitar, plays piano.",
            "∀x ((Musician(x) ∧ ¬Likes(x, Jazz)) → PlaysPiano(x)) ::: Musicians who don't like Jazz play the piano.",
            "PlaysPiano(David) ∨ PlaysGuitar(David) ::: David plays piano or guitar.",
            "(Musician(David) ∧ PlaysPiano(David)) → ¬Likes(David, Jazz) ::: If David is a musician and plays piano, then he does not like Jazz.",
            "(Musician(x) ∧ Likes(x, Jazz)) → ¬PlaysPiano(x) ::: If someone is a musician and likes Jazz, then they don't play piano."
        ],
        "predicates": [
            "Musician(x) ::: x is a musician",
            "PlaysGuitar(x) ::: x plays guitar",
            "Likes(x, y) ::: x likes y",
            "Jazz(x) ::: x is Jazz music"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All specialists are doctors.",
            "Some doctors are wealthy.",
            "All surgeons are rich.",
            "All specialists are famous.",
            "If someone is wealthy or famous, they have a high social status.",
            "John is a surgeon."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Specialist(x) → Doctor(x)) ::: All specialists are doctors.",
            "∃x (Doctor(x) ∧ Wealthy(x)) ::: Some doctors are wealthy.",
            "∀x (Surgeon(x) → Rich(x)) ::: All surgeons are rich.",
            "∀x (Specialist(x) → Famous(x)) ::: All specialists are famous.",
            "∀x ((Wealthy(x) ∨ Famous(x)) → HighSocialStatus(x)) ::: If someone is wealthy or famous, they have a high social status.",
            "Surgeon(John) ::: John is a surgeon."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Wealthy(x) ::: x is wealthy",
            "HighSocialStatus(x) ::: x has a high social status",
            "Surgeon(x) ::: x is a surgeon",
            "Specialist(x) ::: x is a specialist",
            "Rich(x) ::: x is rich",
            "Famous(x) ::: x is famous"
        ]
    },
    {
        "premises-NL": [
            "All mammals are not fish.",
            "All mammals are land animals or aquatic.",
            "Echidnas are mammals.",
            "Echidnas do not live in water.",
            "Platypuses are mammals.",
            "Platypuses live in water.",
            "If an animal lives in water, it is aquatic.",
            "If an animal has wings, it is not a mammal.",
            "Echidnas lay eggs."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → ¬Fish(x)) ::: All mammals are not fish.",
            "∀x (Mammal(x) → (LandAnimal(x) ∨ Aquatic(x))) ::: All mammals are land animals or aquatic.",
            "Echidna(x) → Mammal(x) ::: Echidnas are mammals.",
            "∀x (Echidna(x) → ¬LivesInWater(x)) ::: Echidnas do not live in water.",
            "Platypus(x) → Mammal(x) ::: Platypuses are mammals.",
            "Platypus(x) → LivesInWater(x) ::: Platypuses live in water.",
            "∀x (LivesInWater(x) → Aquatic(x)) ::: If an animal lives in water, it is aquatic.",
            "∀x (Wings(x) → ¬Mammal(x)) ::: If an animal has wings, it is not a mammal.",
            "∀x (Echidna(x) → LaysEggs(x)) ::: Echidnas lay eggs."
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal",
            "Fish(x) ::: x is a fish",
            "Aquatic(x) ::: x is an aquatic animal",
            "LaysEggs(x) ::: x lays eggs",
            "Echidna(x) ::: x is an echidna",
            "Platypus(x) ::: x is a platypus",
            "LivesInWater(x) ::: x lives in water",
            "LandAnimal(x) ::: x is a land animal",
            "Wings(x) ::: x has wings"
        ]
    },
    {
        "premises-NL": [
            "John is a member of the Red Society.",
            "Mary is a member of the Red Society.",
            "John and Mary are members of the same club.",
            "The Red Society is a club.",
            "Mary attends meetings.",
            "If someone is a member of a club and attends meetings, and knows someone else, then that someone else also attends meetings.",
            "Mary knows John.",
            "If someone is a member of a club, and that club has meetings, then that person attends meetings.",
            "All members of Red Society attends meetings.",
            "Anyone who is a member of a club that holds meetings, and Mary attends, and Mary is a member, John will also attend.",
            "If the same club has meetings, and Mary attends the meeting then John will attend the meeting.",
            "If someone is a member of a club, they know other members of that club.",
            "If Mary attends meetings, and John and Mary is the same club, then John will attend meetings"
        ],
        "premises-FOL": [
            "MemberOf(john, redSociety) ::: John is a member of the Red Society.",
            "MemberOf(mary, redSociety) ::: Mary is a member of the Red Society.",
            "SameClub(john, mary, redSociety) ::: John and Mary are members of the same club.",
            "Club(redSociety) ::: The Red Society is a club.",
            "AttendsMeetings(mary) ::: Mary attends meetings.",
            "∀x ∀y ∀z (MemberOf(x, z) ∧ AttendsMeetings(x) ∧ Knows(x, y) → AttendsMeetings(y)) ::: If someone is a member of a club and attends meetings, and knows someone else, then that someone else also attends meetings.",
            "Knows(mary, john) ::: Mary knows John.",
            "∀x ∀y (MemberOf(x, y) ∧ HasMeetings(y) → AttendsMeetings(x)) ::: If someone is a member of a club, and that club has meetings, then that person attends meetings.",
            "∀x (MemberOf(x, redSociety) → AttendsMeetings(x)) ::: All members of Red Society attends meetings.",
            "∀x ∀y (MemberOf(x,y) ∧ AttendsMeetings(mary) ∧ MemberOf(mary,y) → AttendsMeetings(john)) ::: Anyone who is a member of a club that holds meetings, and Mary attends, and Mary is a member, John will also attend.",
            "∀x (HasMeetings(x) ∧ AttendsMeetings(mary) ∧ SameClub(john, mary, x) → AttendsMeetings(john)) ::: If the same club has meetings, and Mary attends the meeting then John will attend the meeting.",
            "∀x ∀y (MemberOf(x, y) → Knows(x, y)) ::: If someone is a member of a club, they know other members of that club.",
            "SameClub(john, mary, z) ∧ AttendsMeetings(mary) → AttendsMeetings(john) ::: If Mary attends meetings, and John and Mary is the same club, then John will attend meetings"
        ],
        "predicates": [
            "MemberOf(x, y) ::: x is a member of club y",
            "AttendsMeetings(x) ::: x attends meetings",
            "SameClub(x, y, z) ::: x and y are in the same club z",
            "Knows(x, y) ::: x knows y"
        ]
    },
    {
        "premises-NL": [
            "Everyone who studies hard, attends classes, and reads books, gets good grades.",
            "If someone is intelligent and attends classes, they also read books.",
            "Someone studies hard.",
            "Someone is intelligent.",
            "If someone gets good grades, they succeed in the exam.",
            "Anyone who reads books and studies hard, will have good grades.",
            "Someone attends classes.",
            "Anyone who reads a lot will study hard.",
            "If someone is intelligent, they can get good grades.",
            "If someone gets good grades and attends classes, they will succeed.",
            "If someone studies hard and is intelligent, they will read books and attends classes.",
            "Those who attend classes and read books, gets good grades.",
            "If someone studies hard, attends classes, and is intelligent, then they will succeed in the exam.",
            "Everyone who is intelligent and studies hard attends classes, then they will succeed in the exam.",
            "Someone who is intelligent will get good grades."
        ],
        "premises-FOL": [
            "∀x (StudiesHard(x) ∧ AttendsClasses(x) ∧ ReadsBooks(x) → GetsGoodGrades(x)) ::: Everyone who studies hard, attends classes, and reads books, gets good grades.",
            "∀x (IsIntelligent(x) ∧ AttendsClasses(x) → ReadsBooks(x)) ::: If someone is intelligent and attends classes, they also read books.",
            "StudiesHard(someone) ::: Someone studies hard.",
            "IsIntelligent(someone) ::: Someone is intelligent.",
            "∀x (GetsGoodGrades(x) → SucceedsInExam(x)) ::: If someone gets good grades, they succeed in the exam.",
            "∀x (ReadsBooks(x) ∧ StudiesHard(x) → GetsGoodGrades(x)) ::: Anyone who reads books and studies hard, will have good grades.",
            "AttendsClasses(someone) ::: Someone attends classes.",
            "∀x (ReadsALot(x) → StudiesHard(x)) ::: Anyone who reads a lot will study hard.",
            "∀x (IsIntelligent(x) → GetsGoodGrades(x)) ::: If someone is intelligent, they can get good grades.",
            "∀x (GetsGoodGrades(x) ∧ AttendsClasses(x) → SucceedsInExam(x)) ::: If someone gets good grades and attends classes, they will succeed.",
            "∀x (StudiesHard(x) ∧ IsIntelligent(x) → ReadsBooks(x) ∧ AttendsClasses(x)) ::: If someone studies hard and is intelligent, they will read books and attends classes.",
            "∀x (AttendsClasses(x) ∧ ReadsBooks(x) → GetsGoodGrades(x)) ::: Those who attend classes and read books, gets good grades.",
            "∀x (StudiesHard(x) ∧ AttendsClasses(x) ∧ IsIntelligent(x) → SucceedsInExam(x)) ::: If someone studies hard, attends classes, and is intelligent, then they will succeed in the exam.",
            "∀x (IsIntelligent(x) ∧ StudiesHard(x) ∧ AttendsClasses(x) → SucceedsInExam(x)) ::: Everyone who is intelligent and studies hard attends classes, then they will succeed in the exam.",
            "∀x (IsIntelligent(x) → GetsGoodGrades(x)) ::: Someone who is intelligent will get good grades."
        ],
        "predicates": [
            "StudiesHard(x) ::: x studies hard",
            "IsIntelligent(x) ::: x is intelligent",
            "SucceedsInExam(x) ::: x succeeds in the exam",
            "AttendsClasses(x) ::: x attends classes",
            "ReadsBooks(x) ::: x reads books",
            "GetsGoodGrades(x) ::: x gets good grades"
        ]
    },
    {
        "premises-NL": [
            "Everyone likes either apples or bananas.",
            "If someone likes apples, then they are a person.",
            "If someone likes bananas, then they are a person.",
            "There exists someone who likes apples.",
            "There exists someone who likes bananas.",
            "There is someone who likes both apples and bananas."
        ],
        "premises-FOL": [
            "∀x (Person(x) → (Likes(x, apples) ∨ Likes(x, bananas))) ::: Everyone likes either apples or bananas.",
            "∀x (Likes(x, apples) → Person(x)) ::: If someone likes apples, then they are a person.",
            "∀x (Likes(x, bananas) → Person(x)) ::: If someone likes bananas, then they are a person.",
            "∃x Likes(x, apples) ::: There exists someone who likes apples.",
            "∃x Likes(x, bananas) ::: There exists someone who likes bananas.",
            "∃x (Likes(x, apples) ∧ Likes(x, bananas)) ::: There is someone who likes both apples and bananas."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Person(x) ::: x is a person",
            "Apples(x) ::: x is an apple",
            "Bananas(x) ::: x is a banana"
        ]
    },
    {
        "premises-NL": [
            "All researchers study either plants or animals or both.",
            "John is a researcher.",
            "If John studies plants, then he is related to ecology.",
            "If John studies animals, then he is related to ecology.",
            "If someone is related to ecology, they study ecology.",
            "If a researcher studies ecology, then they study plants or animals.",
            "John studies ecology."
        ],
        "premises-FOL": [
            "∀x (Researcher(x) → (Studies(x, plants) ∨ Studies(x, animals))) ::: All researchers study either plants or animals or both.",
            "Researcher(john) ::: John is a researcher.",
            "Studies(john, plants) → IsRelated(john, ecology) ::: If John studies plants, then he is related to ecology.",
            "Studies(john, animals) → IsRelated(john, ecology) ::: If John studies animals, then he is related to ecology.",
            "∀x (IsRelated(x, ecology) → Studies(x, ecology)) ::: If someone is related to ecology, they study ecology.",
            "∀x (Researcher(x) ∧ Studies(x, ecology) → (Studies(x, plants) ∨ Studies(x, animals))) ::: If a researcher studies ecology, then they study plants or animals.",
            "Studies(john, ecology) ::: John studies ecology."
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher",
            "Studies(x, y) ::: x studies y",
            "Plants(x) ::: x is a plant",
            "Animals(x) ::: x is an animal",
            "Ecology(x) ::: x is ecology",
            "IsRelated(x, y) ::: x is related to y"
        ]
    },
    {
        "premises-NL": [
            "All students are either enrolled in CS101 or Math200.",
            "If a student studies hard, they will pass both courses.",
            "Some students study hard.",
            "Students enrolled in Math200 do not pass CS101.",
            "No student is enrolled in both CS101 and Math200.",
            "If a student is enrolled in CS101, then they are a student.",
            "If a student is enrolled in Math200, they are a student.",
            "If a student is enrolled in a course, they are a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Enrolled(x, CS101) ∨ Enrolled(x, Math200))) ::: All students are enrolled in CS101 or Math200",
            "∀x (StudyHard(x) → (Pass(x, CS101) ∧ Pass(x, Math200))) ::: Students who study hard pass both courses",
            "∃x StudyHard(x) ::: Some students study hard",
            "∀x (Enrolled(x, Math200) → ¬Pass(x, CS101)) ::: Students enrolled in Math200 do not pass CS101",
            "∀x ¬(Enrolled(x, CS101) ∧ Enrolled(x, Math200)) ::: No student is enrolled in both courses",
            "∀x (Enrolled(x, CS101) → Student(x)) ::: If a student is enrolled in CS101, they are a student",
            "∀x (Enrolled(x, Math200) → Student(x)) ::: If a student is enrolled in Math200, they are a student",
            "∀x ∀y (Enrolled(x, y) → Student(x)) ::: If a student is enrolled in a course, then they are a student"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "Pass(x, y) ::: x passes course y",
            "CS101(x) ::: x is the CS101 course",
            "Math200(x) ::: x is the Math200 course",
            "StudyHard(x) ::: x studies hard"
        ]
    },
    {
        "premises-NL": [
            "All teachers teach a subject.",
            "If a person is a teacher, then they are not an athlete.",
            "Some students are athletes.",
            "All coaches are teachers.",
            "No teacher plays a sport unless they are a coach.",
            "If a teacher is a coach, they know a sport.",
            "Teachers either teach or coach.",
            "If someone is a coach, then they are a teacher.",
            "All coaches practice a sport.",
            "Some teachers are athletes and coaches."
        ],
        "premises-FOL": [
            "∀x ∃y (Teacher(x) → Teaches(x, y)) ::: All teachers teach a subject",
            "∀x (Teacher(x) → ¬Athlete(x)) ::: If a person is a teacher, then they are not an athlete",
            "∃x Athlete(x) ::: Some students are athletes",
            "∀x (Coach(x) → Teacher(x)) ::: All coaches are teachers",
            "∀x ∀y (Teacher(x) ∧ PlaysSport(x, y) → Coach(x)) ::: No teacher plays a sport unless they are a coach",
            "∀x ∀y (Coach(x) → Knows(x, y)) ::: If a teacher is a coach, they know a sport",
            "∀x (Teacher(x) → (Teaches(x, y) ∨ Coach(x))) ::: Teachers either teach or coach",
            "∀x (Coach(x) → Teacher(x)) ::: If someone is a coach, they are a teacher",
            "∀x ∃y (Coach(x) → Practices(x, y)) ::: All coaches practice a sport",
            "∃x (Teacher(x) ∧ Athlete(x) ∧ Coach(x)) ::: Some teachers are athletes and coaches"
        ],
        "predicates": [
            "Teacher(x) ::: x is a teacher",
            "Athlete(x) ::: x is an athlete",
            "Coach(x) ::: x is a coach",
            "Student(x) ::: x is a student",
            "Teaches(x, y) ::: x teaches subject y",
            "Subject(x) ::: x is a subject",
            "PlaysSport(x, y) ::: x plays sport y",
            "Sport(x) ::: x is a sport",
            "Knows(x, y) ::: x knows y",
            "Practices(x, y) ::: x practices sport y"
        ]
    },
    {
        "premises-NL": [
            "All birds fly.",
            "All bats are mammals.",
            "If something flies, it has wings.",
            "Birds lay eggs.",
            "If something is a bat, then it is warm-blooded.",
            "If something is a mammal and has wings, it is a bat.",
            "All bats are nocturnal.",
            "If something is a bird, then it has wings.",
            "Some bats eat insects.",
            "If something is warm-blooded and has fur, then it is a mammal.",
            "Some bats live in caves."
        ],
        "premises-FOL": [
            "∀x (Bird(x) → Flies(x)) ::: All birds fly",
            "∀x (Bat(x) → Mammal(x)) ::: All bats are mammals",
            "∀x (Flies(x) → HasWings(x)) ::: If something flies, it has wings",
            "∀x (Bird(x) → LaysEggs(x)) ::: Birds lay eggs",
            "∀x (Bat(x) → IsWarmBlooded(x)) ::: If something is a bat, then it is warm-blooded",
            "∀x (Mammal(x) ∧ HasWings(x) → Bat(x)) ::: If something is a mammal and has wings, it is a bat",
            "∀x (Bat(x) → Nocturnal(x)) ::: All bats are nocturnal",
            "∀x (Bird(x) → HasWings(x)) ::: If something is a bird, then it has wings",
            "∃x (Bat(x) ∧ EatsInsects(x)) ::: Some bats eat insects",
            "∀x (IsWarmBlooded(x) ∧ HasFur(x) → Mammal(x)) ::: If something is warm-blooded and has fur, then it is a mammal",
            "∃x (Bat(x) ∧ LivesInCave(x)) ::: Some bats live in caves"
        ],
        "predicates": [
            "HasWings(x) ::: x has wings",
            "Bird(x) ::: x is a bird",
            "Bat(x) ::: x is a bat",
            "Mammal(x) ::: x is a mammal",
            "Flies(x) ::: x flies",
            "EatsInsects(x) ::: x eats insects",
            "Nocturnal(x) ::: x is nocturnal",
            "LivesInCave(x) ::: x lives in a cave",
            "IsWarmBlooded(x) ::: x is warm-blooded",
            "LaysEggs(x) ::: x lays eggs",
            "HasFur(x) ::: x has fur"
        ]
    },
    {
        "premises-NL": [
            "All students attend class.",
            "If someone attends class and studies hard, they will have good grades.",
            "If a student has good grades they will pass the exam.",
            "Sarah is a student.",
            "Sarah studies hard.",
            "John is a student.",
            "John attends class."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClass(x)) ::: All students attend class.",
            "∀x (AttendsClass(x) ∧ StudiesHard(x) → GoodGrades(x)) ::: If someone attends class and studies hard, they will have good grades.",
            "∀x (GoodGrades(x) → PassesExam(x)) ::: If a student has good grades they will pass the exam.",
            "Student(Sarah) ::: Sarah is a student.",
            "StudiesHard(Sarah) ::: Sarah studies hard.",
            "Student(John) ::: John is a student.",
            "AttendsClass(John) ::: John attends class."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesHard(x) ::: x studies hard.",
            "PassesExam(x) ::: x passes the exam.",
            "AttendsClass(x) ::: x attends the class.",
            "GoodGrades(x) ::: x has good grades."
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All specialists are doctors.",
            "If a doctor is a surgeon or a specialist and has a patient, then they take care of their patient.",
            "Dr. Smith is a surgeon.",
            "Dr. Smith has a patient named John.",
            "Dr. Jones is a specialist.",
            "If a doctor treats a patient, they provide good healthcare.",
            "Dr. Jones has a patient named Mary."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Specialist(x) → Doctor(x)) ::: All specialists are doctors.",
            "∀x ∀y ((Surgeon(x) ∨ Specialist(x)) ∧ HasPatient(x, y) → TakesCareOf(x, y)) ::: If a doctor is a surgeon or a specialist and has a patient, then they take care of their patient.",
            "Surgeon(Smith) ::: Dr. Smith is a surgeon.",
            "HasPatient(Smith, John) ::: Dr. Smith has a patient named John.",
            "Specialist(Jones) ::: Dr. Jones is a specialist.",
            "∀x ∀y (Doctor(x) ∧ Treats(x, y) → GoodHealthcare(x)) ::: If a doctor treats a patient, they provide good healthcare.",
            "HasPatient(Jones, Mary) ::: Dr. Jones has a patient named Mary."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "HasPatient(x, y) ::: x has y as a patient.",
            "TakesCareOf(x, y) ::: x takes care of y.",
            "Surgeon(x) ::: x is a surgeon.",
            "Specialist(x) ::: x is a specialist.",
            "Patient(y) ::: y is a patient.",
            "Treats(x, y) ::: x treats y.",
            "GoodHealthcare(x) ::: x provides good healthcare."
        ]
    },
    {
        "premises-NL": [
            "If x and y are friends, then x trusts y.",
            "If x trusts y, then y knows x.",
            "If x hates y, then x does not trust y.",
            "John is friends with Mary.",
            "Mary likes John.",
            "If John knows Mary and Mary likes John, then they are friends.",
            "If John is tall, he plays sports.",
            "If John is kind and plays sports, he studies.",
            "If someone hates someone, then they are not friends with them.",
            "John is kind."
        ],
        "premises-FOL": [
            "∀x ∀y (Friends(x, y) → Trusts(x, y)) ::: If x and y are friends, then x trusts y.",
            "∀x ∀y (Trusts(x, y) → Knows(y, x)) ::: If x trusts y, then y knows x.",
            "∀x ∀y (Hates(x, y) → ¬Trusts(x, y)) ::: If x hates y, then x does not trust y.",
            "Friends(John, Mary) ::: John is friends with Mary.",
            "Likes(Mary, John) ::: Mary likes John.",
            "∀x ∀y (Knows(x, y) ∧ Likes(y, x) → Friends(x, y)) ::: If John knows Mary and Mary likes John, then they are friends.",
            "∀x (IsTall(John) → PlaysSports(John)) ::: If John is tall, he plays sports.",
            "∀x (IsKind(John) ∧ PlaysSports(John) → Studies(John)) ::: If John is kind and plays sports, he studies.",
            "∀x ∀y (Hates(x, y) → ¬Friends(x, y)) ::: If someone hates someone, then they are not friends with them.",
            "IsKind(John) ::: John is kind."
        ],
        "predicates": [
            "Friends(x, y) ::: x and y are friends.",
            "Likes(x, y) ::: x likes y.",
            "Trusts(x, y) ::: x trusts y.",
            "Knows(x, y) ::: x knows y.",
            "Hates(x, y) ::: x hates y.",
            "IsTall(x) ::: x is tall.",
            "IsKind(x) ::: x is kind.",
            "PlaysSports(x) ::: x plays sports.",
            "Studies(x) ::: x studies.",
            "HasPet(x) ::: x has a pet."
        ]
    },
    {
        "premises-NL": [
            "All specialists are doctors.",
            "All specialists who study diseases are researchers.",
            "If someone is a doctor and studies diseases, then they are either treating patients or publishing papers.",
            "Dr. Smith is a specialist and studies a disease.",
            "If someone is a doctor, then they have a degree.",
            "Anyone who has a degree and reads articles attends conferences.",
            "Anyone who attends conferences and studies diseases is good at research.",
            "Anyone who is good at research writes reports.",
            "If a specialist is good at research then they are publishing papers.",
            "If someone is both a doctor and a researcher, then they read articles.",
            "Dr. Smith is a doctor."
        ],
        "premises-FOL": [
            "∀x (Specialist(x) → Doctor(x)) ::: All specialists are doctors.",
            "∀x (Specialist(x) ∧ StudiesDisease(x) → Researcher(x)) ::: All specialists who study diseases are researchers.",
            "∀x (Doctor(x) ∧ StudiesDisease(x) → (TreatingPatients(x) ∨ PublishingPapers(x))) ::: If someone is a doctor and studies diseases, then they are either treating patients or publishing papers.",
            "Specialist(Smith) ∧ StudiesDisease(Smith) ::: Dr. Smith is a specialist and studies a disease.",
            "∀x (Doctor(x) → HasDegree(x)) ::: If someone is a doctor, then they have a degree.",
            "∀x (HasDegree(x) ∧ ReadsArticles(x) → AttendsConferences(x)) ::: Anyone who has a degree and reads articles attends conferences.",
            "∀x (AttendsConferences(x) ∧ StudiesDisease(x) → GoodAtResearch(x)) ::: Anyone who attends conferences and studies diseases is good at research.",
            "∀x (GoodAtResearch(x) → WritesReports(x)) ::: Anyone who is good at research writes reports.",
            "∀x (Specialist(x) ∧ GoodAtResearch(x) → PublishingPapers(x)) ::: If a specialist is good at research then they are publishing papers.",
            "∀x (Doctor(x) ∧ Researcher(x) → ReadsArticles(x)) ::: If someone is both a doctor and a researcher, then they read articles.",
            "Doctor(Smith) ::: Dr. Smith is a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Researcher(x) ::: x is a researcher.",
            "TreatingPatients(x) ::: x is treating patients.",
            "PublishingPapers(x) ::: x is publishing papers.",
            "Specialist(x) ::: x is a specialist.",
            "StudiesDisease(x) ::: x studies a disease.",
            "HasDegree(x) ::: x has a degree.",
            "ReadsArticles(x) ::: x reads articles.",
            "WritesReports(x) ::: x writes reports.",
            "AttendsConferences(x) ::: x attends conferences.",
            "GoodAtResearch(x) ::: x is good at research."
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "If someone is smart, they study.",
            "Some people are students.",
            "If someone studies, they pass the exam.",
            "Alice is a student.",
            "Alice studies."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: For all x, if x is a student, then x is smart",
            "∀x (Smart(x) → Studies(x)) ::: For all x, if x is smart, then x studies",
            "∃x Student(x) ::: There exists an x such that x is a student",
            "∀x (Studies(x) → PassesExam(x)) ::: For all x, if x studies, then x passes the exam",
            "Student(alice) ::: Alice is a student",
            "Studies(alice) ::: Alice studies"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "Smart(x) ::: x is smart",
            "PassesExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All doctors treat patients.",
            "All surgeons treat patients.",
            "If someone treats patients, they are a healthcare worker.",
            "Bob is a surgeon.",
            "Alice is a doctor.",
            "Charlie is a healthcare worker."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: For all x, if x is a surgeon, then x is a doctor",
            "∀x (Doctor(x) → TreatsPatients(x)) ::: For all x, if x is a doctor, then x treats patients",
            "∀x (Surgeon(x) → TreatsPatients(x)) ::: For all x, if x is a surgeon, then x treats patients",
            "∀x (TreatsPatients(x) → HealthcareWorker(x)) ::: For all x, if x treats patients, then x is a healthcare worker",
            "Surgeon(bob) ::: Bob is a surgeon",
            "Doctor(alice) ::: Alice is a doctor",
            "HealthcareWorker(charlie) ::: Charlie is a healthcare worker"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "HealthcareWorker(x) ::: x is a healthcare worker",
            "TreatsPatients(x) ::: x treats patients"
        ]
    },
    {
        "premises-NL": [
            "All mammals are animals.",
            "All mammals breathe air.",
            "Some animals are aquatic.",
            "No aquatic animal breathes air.",
            "If an animal lives in water, it is aquatic.",
            "Dolphins are mammals.",
            "Whales are mammals.",
            "Sharks are aquatic."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → Animal(x)) ::: For all x, if x is a mammal, then x is an animal",
            "∀x (Mammal(x) → BreathesAir(x)) ::: For all x, if x is a mammal, then x breathes air",
            "∃x (Animal(x) ∧ Aquatic(x)) ::: There exists an x such that x is an animal and x is aquatic",
            "∀x (Aquatic(x) → ¬BreathesAir(x)) ::: For all x, if x is aquatic, then x does not breathe air",
            "∀x (LivesInWater(x) → Aquatic(x)) ::: For all x, if x lives in water, then x is aquatic",
            "Mammal(dolphin) ::: Dolphins are mammals",
            "Mammal(whale) ::: Whales are mammals",
            "Aquatic(shark) ::: Sharks are aquatic"
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal",
            "Animal(x) ::: x is an animal",
            "BreathesAir(x) ::: x breathes air",
            "Aquatic(x) ::: x is aquatic",
            "HasGills(x) ::: x has gills",
            "LivesInWater(x) ::: x lives in water"
        ]
    },
    {
        "premises-NL": [
            "All students attend a university.",
            "Anyone who attends a university can be a volunteer.",
            "If someone works for a charity, then that person is a volunteer.",
            "John is a student",
            "John attends a university",
            "John works for a charity",
            "A student works for a charity",
            "Only volunteers are involved"
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsUniversity(x, y)) ::: All students attend a university.",
            "∀x ∀y (AttendsUniversity(x, y) → Volunteer(x)) ::: Anyone who attends a university can be a volunteer.",
            "∀x ∀y (WorksFor(x, y) → Volunteer(x)) ::: If someone works for a charity, then that person is a volunteer.",
            "Student(john) ::: John is a student.",
            "AttendsUniversity(john, university) ::: John attends a university.",
            "WorksFor(john, charity) ::: John works for a charity.",
            "∃x (Student(x) ∧ WorksFor(x, charity)) ::: A student works for a charity.",
            "∀x (InvolvedInCommunity(x) → Volunteer(x)) ::: Only volunteers are involved."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Volunteer(x) ::: x is a volunteer",
            "InvolvedInCommunity(x) ::: x is involved in the community",
            "AttendsUniversity(x, y) ::: x attends university y",
            "WorksFor(x, y) ::: x works for y"
        ]
    },
    {
        "premises-NL": [
            "All students are happy.",
            "Some musicians play the guitar.",
            "No student plays the guitar.",
            "Everyone is either a musician or a student.",
            "If someone plays the guitar, then they are not happy.",
            "Alice is a musician.",
            "Bob is a student.",
            "Alice plays the guitar.",
            "Bob is happy.",
            "Carol is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Happy(x)) ::: All students are happy.",
            "∃x (Musician(x) ∧ PlaysInstrument(x, guitar)) ::: Some musicians play the guitar.",
            "¬∃x (Student(x) ∧ PlaysInstrument(x, guitar)) ::: No student plays the guitar.",
            "∀x (Musician(x) ∨ Student(x)) ::: Everyone is either a musician or a student.",
            "∀x (PlaysInstrument(x, guitar) → ¬Happy(x)) ::: If someone plays the guitar, then they are not happy.",
            "Musician(alice) ::: Alice is a musician.",
            "Student(bob) ::: Bob is a student.",
            "PlaysInstrument(alice, guitar) ::: Alice plays the guitar.",
            "Happy(bob) ::: Bob is happy.",
            "Student(carol) ::: Carol is a student."
        ],
        "predicates": [
            "Musician(x) ::: x is a musician",
            "PlaysInstrument(x, y) ::: x plays instrument y",
            "Happy(x) ::: x is happy",
            "Student(x) ::: x is a student"
        ]
    },
    {
        "premises-NL": [
            "All basketball players are athletes.",
            "Every athlete is either tall or a fast runner.",
            "Someone is both a fast runner and likes pizza.",
            "If someone likes pizza, then they don't play basketball.",
            "All tall people are athletes.",
            "David is a fast runner.",
            "David likes pizza.",
            "David is an athlete.",
            "Someone is tall.",
            "All athletes either play basketball or are fast runners.",
            "Eve is tall."
        ],
        "premises-FOL": [
            "∀x (PlaysBasketball(x) → Athlete(x)) ::: All basketball players are athletes.",
            "∀x (Athlete(x) → (Tall(x) ∨ FastRunner(x))) ::: Every athlete is either tall or a fast runner.",
            "∃x (FastRunner(x) ∧ Likes(x, pizza)) ::: Someone is both a fast runner and likes pizza.",
            "∀x (Likes(x, pizza) → ¬PlaysBasketball(x)) ::: If someone likes pizza, then they don't play basketball.",
            "∀x (Tall(x) → Athlete(x)) ::: All tall people are athletes.",
            "FastRunner(david) ::: David is a fast runner.",
            "Likes(david, pizza) ::: David likes pizza.",
            "Athlete(david) ::: David is an athlete.",
            "∃x Tall(x) ::: Someone is tall.",
            "∀x (Athlete(x) → (PlaysBasketball(x) ∨ FastRunner(x))) ::: All athletes either play basketball or are fast runners.",
            "Tall(eve) ::: Eve is tall."
        ],
        "predicates": [
            "Tall(x) ::: x is tall",
            "PlaysBasketball(x) ::: x plays basketball",
            "Athlete(x) ::: x is an athlete",
            "Likes(x, y) ::: x likes y",
            "FastRunner(x) ::: x is a fast runner"
        ]
    },
    {
        "premises-NL": [
            "All cats chase mice.",
            "If something chases mice, then it is not friendly.",
            "All cats like cream or play with wool.",
            "Anything that likes cream is a cat.",
            "Something does not like cream.",
            "If something plays with wool, then it is not friendly.",
            "Fluffy is a cat.",
            "Whiskers chases mice.",
            "Garfield likes cream.",
            "Milo plays with wool.",
            "All cats either chase mice or play with wool.",
            "Mittens is a cat."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → ChasesMice(x)) ::: All cats chase mice.",
            "∀x (ChasesMice(x) → ¬Friendly(x)) ::: If something chases mice, then it is not friendly.",
            "∀x (Cat(x) → (LikesCream(x) ∨ PlaysWithWool(x))) ::: All cats like cream or play with wool.",
            "∀x (LikesCream(x) → Cat(x)) ::: Anything that likes cream is a cat.",
            "∃x ¬LikesCream(x) ::: Something does not like cream.",
            "∀x (PlaysWithWool(x) → ¬Friendly(x)) ::: If something plays with wool, then it is not friendly.",
            "Cat(fluffy) ::: Fluffy is a cat.",
            "ChasesMice(whiskers) ::: Whiskers chases mice.",
            "LikesCream(garfield) ::: Garfield likes cream.",
            "PlaysWithWool(milo) ::: Milo plays with wool.",
            "∀x (Cat(x) → (ChasesMice(x) ∨ PlaysWithWool(x))) ::: All cats either chase mice or play with wool.",
            "Cat(mittens) ::: Mittens is a cat."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Friendly(x) ::: x is friendly",
            "ChasesMice(x) ::: x chases mice",
            "LikesCream(x) ::: x likes cream",
            "PlaysWithWool(x) ::: x plays with wool"
        ]
    },
    {
        "premises-NL": [
            "All who read books know history or understand politics.",
            "Anyone who knows history is not happy.",
            "Someone who understands politics works at the library.",
            "Anyone who works at the library is not happy.",
            "David reads books.",
            "If someone reads books, then they either know history or understand politics.",
            "If someone knows history, they are not happy.",
            "If someone understands politics, they work at the library.",
            "David knows history.",
            "Bob understands politics.",
            "All who work at the library are not happy.",
            "David reads books and knows history.",
            "Carol works at the library."
        ],
        "premises-FOL": [
            "∀x (ReadsBooks(x) → (KnowsHistory(x) ∨ UnderstandsPolitics(x))) ::: All who read books know history or understand politics.",
            "∀x (KnowsHistory(x) → ¬Happy(x)) ::: Anyone who knows history is not happy.",
            "∃x (UnderstandsPolitics(x) ∧ WorksAt(x, library)) ::: Someone who understands politics works at the library.",
            "∀x (WorksAt(x, library) → ¬Happy(x)) ::: Anyone who works at the library is not happy.",
            "ReadsBooks(david) ::: David reads books.",
            "∀x (ReadsBooks(x) → (KnowsHistory(x) ∨ UnderstandsPolitics(x))) ::: If someone reads books, then they either know history or understand politics.",
            "∀x (KnowsHistory(x) → ¬Happy(x)) ::: If someone knows history, they are not happy.",
            "∀x (UnderstandsPolitics(x) → WorksAt(x, library)) ::: If someone understands politics, they work at the library.",
            "KnowsHistory(david) ::: David knows history.",
            "UnderstandsPolitics(bob) ::: Bob understands politics.",
            "∀x (WorksAt(x, library) → ¬Happy(x)) ::: All who work at the library are not happy.",
            "ReadsBooks(david) ∧ KnowsHistory(david) ::: David reads books and knows history.",
            "WorksAt(carol, library) ::: Carol works at the library."
        ],
        "predicates": [
            "ReadsBooks(x) ::: x reads books",
            "Happy(x) ::: x is happy",
            "KnowsHistory(x) ::: x knows history",
            "UnderstandsPolitics(x) ::: x understands politics",
            "WorksAt(x, y) ::: x works at y"
        ]
    },
    {
        "premises-NL": [
            "All students take the exam.",
            "Alex is a student.",
            "If someone studies hard, then they need help.",
            "If someone needs help, they will take the exam.",
            "Alex studies hard.",
            "Anyone smart will pass the exam.",
            "Alex is smart.",
            "Every student is enrolled in a course.",
            "Alex likes pizza.",
            "Pizza is food.",
            "Food is delicious.",
            "Alex is helpful.",
            "If someone is helpful, they like pizza."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakesExam(x)) ::: All students take the exam",
            "Student(Alex) ::: Alex is a student",
            "∀x (StudiesHard(x) → NeedsHelp(x)) ::: If someone studies hard, then they need help",
            "∀x (NeedsHelp(x) → TakesExam(x)) ::: If someone needs help, they will take the exam",
            "StudiesHard(Alex) ::: Alex studies hard",
            "∀x (Smart(x) → PassExam(x)) ::: Anyone smart will pass the exam",
            "Smart(Alex) ::: Alex is smart",
            "∀x ∃y Enrolled(x, y) ::: Every student is enrolled in a course",
            "Likes(Alex, pizza) ::: Alex likes pizza",
            "Food(pizza) ::: Pizza is food",
            "∀x (Food(x) → Delicious(x)) ::: Food is delicious",
            "Helpful(Alex) ::: Alex is helpful",
            "∀x (Helpful(x) → Likes(x, pizza)) ::: If someone is helpful, they like pizza"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "TakesExam(x) ::: x takes the exam",
            "NeedsHelp(x) ::: x needs help",
            "Smart(x) ::: x is smart",
            "Enrolled(x, y) ::: x is enrolled in y",
            "Likes(x, y) ::: x likes y",
            "Helpful(x) ::: x is helpful"
        ]
    },
    {
        "premises-NL": [
            "All black cats are cats.",
            "All cats hunt mice.",
            "If a cat is friendly, it eats meat.",
            "If a cat eats meat and likes to play, it is a fast runner.",
            "Some cats chase birds.",
            "All fast runners hunt mice.",
            "Some cats are black.",
            "All mammals are friendly.",
            "Alex is a mammal.",
            "Alex is a cat.",
            "Alex likes to play.",
            "Alex eats meat.",
            "Alex chases birds.",
            "Alex is a fast runner."
        ],
        "premises-FOL": [
            "∀x (BlackCat(x) → IsCat(x)) ::: All black cats are cats",
            "∀x (IsCat(x) → HuntsMice(x)) ::: All cats hunt mice",
            "∀x (IsCat(x) ∧ Friendly(x) → EatsMeat(x)) ::: If a cat is friendly, it eats meat",
            "∀x (IsCat(x) ∧ EatsMeat(x) ∧ LikesToPlay(x) → FastRunner(x)) ::: If a cat eats meat and likes to play, it is a fast runner",
            "∃x (IsCat(x) ∧ ChasesBirds(x)) ::: Some cats chase birds",
            "∀x (FastRunner(x) → HuntsMice(x)) ::: All fast runners hunt mice",
            "∃x BlackCat(x) ::: Some cats are black",
            "∀x (IsMammal(x) → Friendly(x)) ::: All mammals are friendly",
            "IsMammal(Alex) ::: Alex is a mammal",
            "IsCat(Alex) ::: Alex is a cat",
            "LikesToPlay(Alex) ::: Alex likes to play",
            "EatsMeat(Alex) ::: Alex eats meat",
            "ChasesBirds(Alex) ::: Alex chases birds",
            "FastRunner(Alex) ::: Alex is a fast runner"
        ],
        "predicates": [
            "BlackCat(x) ::: x is a black cat",
            "HuntsMice(x) ::: x hunts mice",
            "IsCat(x) ::: x is a cat",
            "Friendly(x) ::: x is friendly",
            "EatsMeat(x) ::: x eats meat",
            "LikesToPlay(x) ::: x likes to play",
            "FastRunner(x) ::: x is a fast runner",
            "ChasesBirds(x) ::: x chases birds",
            "IsMammal(x) ::: x is a mammal"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "If someone is a patient, they are human.",
            "John is a doctor.",
            "If a doctor treats a patient, the patient is helped.",
            "John has Mary as a patient.",
            "Mary is sick.",
            "Mary has a disease.",
            "If someone has a disease, they need medicine.",
            "If a doctor has a patient, that patient is helped.",
            "John treats Mary.",
            "All humans need medicine.",
            "Doctors administer medicine.",
            "John administers medicine to Mary.",
            "Mary is human.",
            "If someone is a doctor, they administer medicine."
        ],
        "premises-FOL": [
            "∀x ∀y (Doctor(x) ∧ HasPatient(x, y) → Treats(x, y)) ::: All doctors treat patients",
            "∀x (HasPatient(x, y) → IsHuman(y)) ::: If someone is a patient, they are human",
            "Doctor(John) ::: John is a doctor",
            "∀x ∀y (Treats(x, y) → Helped(y)) ::: If a doctor treats a patient, the patient is helped",
            "HasPatient(John, Mary) ::: John has Mary as a patient",
            "Sick(Mary) ::: Mary is sick",
            "HasDisease(Mary) ::: Mary has a disease",
            "∀x (HasDisease(x) → NeedsMedicine(x)) ::: If someone has a disease, they need medicine",
            "∀x ∀y (Doctor(x) ∧ HasPatient(x, y) → Helped(y)) ::: If a doctor has a patient, that patient is helped",
            "Treats(John, Mary) ::: John treats Mary",
            "∀x (IsHuman(x) → NeedsMedicine(x)) ::: All humans need medicine",
            "∀x ∃y AdministersMedicine(x, y) ::: Doctors administer medicine",
            "AdministersMedicine(John, Mary) ::: John administers medicine to Mary",
            "IsHuman(Mary) ::: Mary is human",
            "∀x (Doctor(x) → AdministersMedicine(x,y)) ::: If someone is a doctor, they administer medicine"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "HasPatient(x, y) ::: x has y as a patient",
            "Helped(x) ::: x is helped",
            "Sick(x) ::: x is sick",
            "Treats(x, y) ::: x treats y",
            "IsHuman(x) ::: x is human",
            "NeedsMedicine(x) ::: x needs medicine",
            "AdministersMedicine(x, y) ::: x administers medicine to y",
            "HasDisease(x) ::: x has a disease"
        ]
    },
    {
        "premises-NL": [
            "All scientists are researchers.",
            "All researchers study biology.",
            "If someone studies biology, they are smart.",
            "If a person is a scientist, they will publish a paper.",
            "John is a scientist.",
            "If a person works at a university and has funding, then they will publish a paper.",
            "John studies biology.",
            "All professors are scientists.",
            "Researchers read papers.",
            "Scientists write papers.",
            "John works at a university.",
            "If someone is a professor, then they teach.",
            "John has funding.",
            "John likes pizza.",
            "If someone reads papers, they like science.",
            "If someone writes papers, they are a researcher."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Researcher(x)) ::: All scientists are researchers",
            "∀x (Researcher(x) → StudiesBiology(x)) ::: All researchers study biology",
            "∀x (StudiesBiology(x) → IsSmart(x)) ::: If someone studies biology, they are smart",
            "∀x (Scientist(x) → PublishPaper(x)) ::: If a person is a scientist, they will publish a paper",
            "Scientist(John) ::: John is a scientist",
            "∀x ∀y (WorksAt(x, y) ∧ HasFunding(x) → PublishPaper(x)) ::: If a person works at a university and has funding, then they will publish a paper",
            "StudiesBiology(John) ::: John studies biology",
            "∀x (IsProfessor(x) → Scientist(x)) ::: All professors are scientists",
            "∀x (Researcher(x) → ReadsPapers(x)) ::: Researchers read papers",
            "∀x (Scientist(x) → WritesPapers(x)) ::: Scientists write papers",
            "WorksAt(John, university) ::: John works at a university",
            "∀x (IsProfessor(x) → Teaches(x, y)) ::: If someone is a professor, then they teach",
            "HasFunding(John) ::: John has funding",
            "Likes(John, pizza) ::: John likes pizza",
            "∀x (ReadsPapers(x) → Likes(x, science)) ::: If someone reads papers, they like science",
            "∀x (WritesPapers(x) → Researcher(x)) ::: If someone writes papers, they are a researcher"
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "StudiesBiology(x) ::: x studies biology",
            "PublishPaper(x) ::: x publishes a paper",
            "Researcher(x) ::: x is a researcher",
            "WorksAt(x, y) ::: x works at y",
            "HasFunding(x) ::: x has funding",
            "IsSmart(x) ::: x is smart",
            "ReadsPapers(x) ::: x reads papers",
            "WritesPapers(x) ::: x writes papers",
            "IsProfessor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches y",
            "Likes(x, y) ::: x likes y"
        ]
    },
    {
        "premises-NL": [
            "All students are smart or they study.",
            "John is a student.",
            "John is not smart.",
            "If John studies, then he will pass the exam.",
            "John studies or he does not pass the exam.",
            "If someone is smart, then they will pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Smart(x) ∨ Studies(x))) ::: All students are smart or they study",
            "Student(john) ::: John is a student",
            "¬Smart(john) ::: John is not smart",
            "Studies(john) → PassExam(john) ::: If John studies, then he will pass the exam",
            "Studies(john) ∨ ¬PassExam(john) ::: John studies or he does not pass the exam",
            "∀x (Smart(x) → PassExam(x)) ::: If someone is smart, then they will pass the exam"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "Smart(x) ::: x is smart",
            "PassExam(x) ::: x will pass the exam"
        ]
    },
    {
        "premises-NL": [
            "All cats like either fish or toys.",
            "No dogs like toys.",
            "Some animals are cats.",
            "All dogs are animals.",
            "Some animals do not like toys.",
            "If something is a cat, then it likes fish or toys.",
            "Not all cats like toys.",
            "If an animal does not like toys, it likes fish."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → (Likes(x, fish) ∨ Likes(x, toys))) ::: All cats like either fish or toys",
            "∀x (Dog(x) → ¬Likes(x, toys)) ::: No dogs like toys",
            "∃x (Cat(x)) ::: Some animals are cats",
            "∀x (Dog(x) → Animal(x)) ::: All dogs are animals",
            "∃x (Animal(x) ∧ ¬Likes(x, toys)) ::: Some animals do not like toys",
            "∀x (Cat(x) → (Likes(x, fish) ∨ Likes(x, toys))) ::: If something is a cat, then it likes fish or toys",
            "¬∀x (Cat(x) → Likes(x, toys)) ::: Not all cats like toys",
            "∀x (Animal(x) ∧ ¬Likes(x, toys) → Likes(x, fish)) ::: If an animal does not like toys, it likes fish"
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Dog(x) ::: x is a dog",
            "Likes(x, y) ::: x likes y",
            "Fish(x) ::: x is a fish"
        ]
    },
    {
        "premises-NL": [
            "All students are either smart or work hard.",
            "All employed people receive a salary.",
            "If someone is smart, then they study.",
            "If someone works hard, then they are employed.",
            "If someone receives a salary, then they are not a student.",
            "Some students do not work hard.",
            "Everyone who is rich, has a degree.",
            "If someone has a degree, they will graduate.",
            "If someone is employed, they are successful.",
            "Some students are not employed."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Smart(x) ∨ WorksHard(x))) ::: All students are either smart or work hard",
            "∀x (Employed(x) → ReceivesSalary(x)) ::: All employed people receive a salary",
            "∀x (Smart(x) → Studies(x)) ::: If someone is smart, then they study",
            "∀x (WorksHard(x) → Employed(x)) ::: If someone works hard, then they are employed",
            "∀x (ReceivesSalary(x) → ¬Student(x)) ::: If someone receives a salary, then they are not a student",
            "∃x (Student(x) ∧ ¬WorksHard(x)) ::: Some students do not work hard",
            "∀x (IsRich(x) → HasDegree(x)) ::: Everyone who is rich, has a degree",
            "∀x (HasDegree(x) → Graduates(x)) ::: If someone has a degree, they will graduate",
            "∀x (Employed(x) → Successful(x)) ::: If someone is employed, they are successful",
            "∃x (Student(x) ∧ ¬Employed(x)) ::: Some students are not employed"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Employed(x) ::: x is employed",
            "Smart(x) ::: x is smart",
            "WorksHard(x) ::: x works hard",
            "ReceivesSalary(x) ::: x receives a salary",
            "Studies(x) ::: x studies",
            "IsRich(x) ::: x is rich",
            "HasDegree(x) ::: x has a degree",
            "Graduates(x) ::: x graduates",
            "Successful(x) ::: x is successful"
        ]
    },
    {
        "premises-NL": [
            "All students who attend the lecture read books.",
            "Some students attend the lecture.",
            "All students who read books study.",
            "Smart students are always good students",
            "Every good student studies.",
            "All students are people."
        ],
        "premises-FOL": [
            "∀x ((Student(x) ∧ AttendsLecture(x)) → ReadsBooks(x)) ::: If a student attends the lecture, they read books.",
            "∃x (Student(x) ∧ AttendsLecture(x)) ::: There is a student who attends the lecture.",
            "∀x (ReadsBooks(x) → Study(x)) ::: If someone reads books, they study.",
            "∀x (IsSmart(x) → Study(x)) ::: If a student is smart, they study.",
            "∀x (Student(x) → Study(x)) ::: All students study.",
            "∀x (Student(x) → Person(x)) ::: Every student is a person."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsLecture(x) ::: x attends the lecture",
            "Study(x) ::: x studies",
            "ReadsBooks(x) ::: x reads books",
            "IsSmart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All cats chase mice.",
            "Some mice are near holes.",
            "If a cat chases a mouse and the mouse is near the hole, the cat catches the mouse.",
            "Every cat is a mammal.",
            "All mammals are animals",
            "If a cat chases a mouse, the mouse will run."
        ],
        "premises-FOL": [
            "∀x ∀y ((Cat(x) ∧ Mouse(y)) → Chases(x, y)) ::: All cats chase mice.",
            "∃x (Mouse(x) ∧ NearHole(x)) ::: Some mice are near holes.",
            "∀x ∀y ((Cat(x) ∧ Chases(x, y) ∧ NearHole(y)) → Catches(x, y)) ::: If a cat chases a mouse that is near a hole, then the cat catches the mouse.",
            "∀x (Cat(x) → Mammal(x)) ::: Every cat is a mammal.",
            "∀x (Mammal(x) → Animal(x)) ::: All mammals are animals.",
            "∀x ∀y ((Cat(x) ∧ Chases(x, y)) → Run(y)) ::: If a cat chases a mouse, the mouse will run."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Mouse(x) ::: x is a mouse",
            "Chases(x, y) ::: x chases y",
            "NearHole(x) ::: x is near a hole",
            "Catches(x, y) ::: x catches y",
            "IsFast(x) ::: x is fast",
            "IsSmall(x) ::: x is small"
        ]
    },
    {
        "premises-NL": [
            "Alex is a student.",
            "All students who study will pass the exam.",
            "Alex is studying.",
            "Everyone who studies is a student.",
            "Anyone who is not studying will fail the exam.",
            "Alex did not fail the exam.",
            "If a student is studying, then they will pass the exam.",
            "If a student fails the exam, then they did not study.",
            "If Alex studies, he will not fail.",
            "If Alex is a student, then he studies or fails.",
            "Alex is studying if and only if he is a student.",
            "Either Alex studies or Alex doesn't study."
        ],
        "premises-FOL": [
            "Student(Alex) ::: Alex is a student",
            "∀x (Student(x) ∧ Studies(x) → PassExam(x)) ::: All students who study will pass the exam",
            "Studies(Alex) ::: Alex is studying",
            "∀x (Studies(x) → Student(x)) ::: Everyone who studies is a student",
            "∀x (¬Studies(x) → ¬PassExam(x)) ::: Anyone who is not studying will fail the exam",
            "¬PassExam(Alex) → ¬Studies(Alex) ::: Alex did not fail the exam",
            "∀x (Student(x) ∧ Studies(x) → PassExam(x)) ::: If a student is studying, then they will pass the exam",
            "∀x (Student(x) ∧ ¬PassExam(x) → ¬Studies(x)) ::: If a student fails the exam, then they did not study",
            "Studies(Alex) → ¬FailExam(Alex) ::: If Alex studies, he will not fail",
            "Student(Alex) → (Studies(Alex) ∨ ¬PassExam(Alex)) ::: If Alex is a student, then he studies or fails",
            "Studies(Alex) ↔ Student(Alex) ::: Alex is studying if and only if he is a student",
            "Studies(Alex) ⊕ ¬Studies(Alex) ::: Either Alex studies or Alex doesn't study."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "PassExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "All smart people study hard.",
            "Alice is smart.",
            "If someone is smart, they pass the exam.",
            "Bob helps Alice.",
            "If Bob helps Alice, then Alice studies hard.",
            "Alice is a student.",
            "All students have a chance to pass the exam.",
            "If a person passes the exam then they become smart.",
            "If a person is not smart then they fail the exam.",
            "Everyone who studies hard helps bob.",
            "If Alice studies hard, then Bob passes the exam.",
            "Bob does not help Alice.",
            "Bob is not a student."
        ],
        "premises-FOL": [
            "∀x (Smart(x) → StudyHard(x)) ::: All smart people study hard",
            "Smart(alice) ::: Alice is smart",
            "∀x (Smart(x) → PassExam(x)) ::: If someone is smart, they pass the exam",
            "Help(bob, alice) ::: Bob helps Alice",
            "Help(bob, alice) → StudyHard(alice) ::: If Bob helps Alice, then Alice studies hard",
            "Student(alice) ::: Alice is a student",
            "∀x (Student(x) → PassExam(x)) ::: All students have a chance to pass the exam",
            "PassExam(x) → Smart(x) ::: If a person passes the exam then they become smart",
            "¬Smart(x) → ¬PassExam(x) ::: If a person is not smart then they fail the exam",
            "∀x (StudyHard(x) → Help(x, bob)) ::: Everyone who studies hard helps bob",
            "StudyHard(alice) → PassExam(bob) ::: If Alice studies hard, then Bob passes the exam",
            "¬Help(bob, alice) ::: Bob does not help Alice",
            "¬Student(bob) ::: Bob is not a student"
        ],
        "predicates": [
            "Smart(x) ::: x is smart",
            "StudyHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "Help(x, y) ::: x helps y"
        ]
    },
    {
        "premises-NL": [
            "All biologists are researchers.",
            "All researchers who work at a university are interested in genetics.",
            "All researchers who publish papers are good researchers.",
            "If someone is interested in genetics, they study genetics.",
            "If someone is a good researcher, they understand the function of DNA.",
            "Alice is a biologist.",
            "Alice works at a university.",
            "Alice publishes papers."
        ],
        "premises-FOL": [
            "∀x (Biologist(x) → Researcher(x)) ::: All biologists are researchers.",
            "∀x ((Researcher(x) ∧ WorksAtUniversity(x)) → InterestedInGenetics(x)) ::: All researchers who work at a university are interested in genetics.",
            "∀x (PublishesPapers(x) → GoodResearcher(x)) ::: All researchers who publish papers are good researchers.",
            "∀x (InterestedInGenetics(x) → StudiesGenetics(x)) ::: If someone is interested in genetics, they study genetics.",
            "∀x (GoodResearcher(x) → UnderstandsDNAFunction(x)) ::: If someone is a good researcher, they understand the function of DNA.",
            "Biologist(alice) ::: Alice is a biologist.",
            "WorksAtUniversity(alice) ::: Alice works at a university.",
            "PublishesPapers(alice) ::: Alice publishes papers."
        ],
        "predicates": [
            "Biologist(x) ::: x is a biologist",
            "StudiesGenetics(x) ::: x studies genetics",
            "UnderstandsDNAFunction(x) ::: x understands the function of DNA",
            "Researcher(x) ::: x is a researcher",
            "WorksAtUniversity(x) ::: x works at a university",
            "PublishesPapers(x) ::: x publishes papers",
            "InterestedInGenetics(x) ::: x is interested in genetics",
            "GoodResearcher(x) ::: x is a good researcher"
        ]
    },
    {
        "premises-NL": [
            "All tech companies have high revenue.",
            "All companies that are profitable invest in the stock market.",
            "If a company sells products and has high revenue, then it is profitable.",
            "If a company doesn't invest in the stock market, it risks losing capital.",
            "All tech companies sell products.",
            "Company A is a tech company.",
            "Company A employs many people.",
            "Company B has high revenue.",
            "Company A has innovation."
        ],
        "premises-FOL": [
            "∀x (IsTechCompany(x) → HighRevenue(x)) ::: All tech companies have high revenue.",
            "∀x (Profitable(x) → InvestsInStockMarket(x)) ::: All companies that are profitable invest in the stock market.",
            "∀x ((SellsProducts(x) ∧ HighRevenue(x)) → Profitable(x)) ::: If a company sells products and has high revenue, then it is profitable.",
            "∀x (¬InvestsInStockMarket(x) → RisksLosingCapital(x)) ::: If a company doesn't invest in the stock market, it risks losing capital.",
            "∀x (IsTechCompany(x) → SellsProducts(x)) ::: All tech companies sell products.",
            "IsTechCompany(companyA) ::: Company A is a tech company.",
            "EmploysManyPeople(companyA) ::: Company A employs many people.",
            "HighRevenue(companyB) ::: Company B has high revenue.",
            "HasInnovation(companyA) ::: Company A has innovation."
        ],
        "predicates": [
            "Company(x) ::: x is a company",
            "HighRevenue(x) ::: x has high revenue",
            "InvestsInStockMarket(x) ::: x invests in the stock market",
            "RisksLosingCapital(x) ::: x risks losing capital",
            "Profitable(x) ::: x is profitable",
            "EmploysManyPeople(x) ::: x employs many people",
            "IsTechCompany(x) ::: x is a tech company",
            "HasInnovation(x) ::: x has innovation",
            "SellsProducts(x) ::: x sells products"
        ]
    },
    {
        "premises-NL": [
            "All premium members have profiles.",
            "If a user shares content, then they post it.",
            "If a user posts content and is a premium member, then that content is visible to friends.",
            "Alice is a premium member.",
            "Alice shares content C1.",
            "Bob is a user.",
            "Bob is a friend of Alice.",
            "Content C1 is liked by Bob.",
            "Alice has commented on C1.",
            "Content C1 is content."
        ],
        "premises-FOL": [
            "∀x (PremiumMember(x) → HasProfile(x)) ::: All premium members have profiles.",
            "∀x ∀y (SharesContent(x, y) → Posts(x, y)) ::: If a user shares content, then they post it.",
            "∀x ∀y ((Posts(x, y) ∧ PremiumMember(x)) → VisibleToFriends(y)) ::: If a user posts content and is a premium member, then that content is visible to friends.",
            "PremiumMember(alice) ::: Alice is a premium member.",
            "SharesContent(alice, c1) ::: Alice shares content C1.",
            "User(bob) ::: Bob is a user.",
            "IsFriendOf(bob, alice) ::: Bob is a friend of Alice.",
            "LikesContent(bob, c1) ::: Content C1 is liked by Bob.",
            "HasCommented(alice, c1) ::: Alice has commented on C1.",
            "Content(c1) ::: Content C1 is content."
        ],
        "predicates": [
            "User(x) ::: x is a user",
            "PremiumMember(x) ::: x is a premium member",
            "SharesContent(x, y) ::: x shares content y",
            "Content(y) ::: y is content",
            "VisibleToFriends(y) ::: y is visible to friends",
            "HasProfile(x) ::: x has a profile",
            "Posts(x, y) ::: x posts y",
            "IsFriendOf(x, y) ::: x is a friend of y",
            "LikesContent(x, y) ::: x likes content y",
            "HasCommented(x, y) ::: x has commented on y"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard attend classes.",
            "All students who attend classes and read books submit assignments.",
            "All students who submit assignments receive good grades.",
            "If a student studies hard and is not lazy, they will pass the exam.",
            "Anyone who skips classes is lazy.",
            "If someone enjoys learning they study hard.",
            "Alice is a student.",
            "Alice studies hard.",
            "Alice is not lazy.",
            "Alice reads books.",
            "Alice does not skip classes."
        ],
        "premises-FOL": [
            "∀x ((Student(x) ∧ StudiesHard(x)) → AttendsClasses(x)) ::: All students who study hard attend classes.",
            "∀x ((AttendsClasses(x) ∧ ReadsBooks(x)) → SubmitsAssignments(x)) ::: All students who attend classes and read books submit assignments.",
            "∀x (SubmitsAssignments(x) → ReceivesGoodGrades(x)) ::: All students who submit assignments receive good grades.",
            "∀x (StudiesHard(x) ∧ ¬Lazy(x) → PassesExam(x)) ::: If a student studies hard and is not lazy, they will pass the exam.",
            "∀x (SkipsClasses(x) → Lazy(x)) ::: Anyone who skips classes is lazy.",
            "∀x (EnjoysLearning(x) → StudiesHard(x)) ::: If someone enjoys learning they study hard.",
            "Student(alice) ::: Alice is a student.",
            "StudiesHard(alice) ::: Alice studies hard.",
            "¬Lazy(alice) ::: Alice is not lazy.",
            "ReadsBooks(alice) ::: Alice reads books.",
            "¬SkipsClasses(alice) ::: Alice does not skip classes."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "Lazy(x) ::: x is lazy",
            "PassesExam(x) ::: x passes the exam",
            "AttendsClasses(x) ::: x attends classes",
            "ReadsBooks(x) ::: x reads books",
            "SubmitsAssignments(x) ::: x submits assignments",
            "ReceivesGoodGrades(x) ::: x receives good grades",
            "EnjoysLearning(x) ::: x enjoys learning",
            "IsDiligent(x) ::: x is diligent",
            "SkipsClasses(x) ::: x skips classes"
        ]
    },
    {
        "premises-NL": [
            "All students study.",
            "John is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Studies(x)) ::: Every student studies.",
            "Student(john) ::: John is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies"
        ]
    },
    {
        "premises-NL": [
            "All cats chase mice.",
            "Mittens is a cat.",
            "There exists a mouse."
        ],
        "premises-FOL": [
            "∀x ∀y (Cat(x) ∧ Mouse(y) → Chases(x, y)) ::: Every cat chases every mouse.",
            "Cat(mittens) ::: Mittens is a cat.",
            "∃y Mouse(y) ::: There exists a mouse."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Mouse(y) ::: y is a mouse",
            "Chases(x, y) ::: x chases y"
        ]
    },
    {
        "premises-NL": [
            "All doctors have degrees.",
            "Every doctor treats patients.",
            "There is a patient."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HasDegree(x)) ::: Every doctor has a degree.",
            "∀x ∀y (Doctor(x) ∧ Patient(y) → Treats(x, y)) ::: Every doctor treats patients.",
            "∃y Patient(y) ::: There is a patient."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "HasDegree(x) ::: x has a degree",
            "Treats(x, y) ::: x treats y",
            "Patient(y) ::: y is a patient"
        ]
    },
    {
        "premises-NL": [
            "David is a student.",
            "All students who study hard are likely to succeed.",
            "David studies hard.",
            "If someone studies hard and is intelligent, they get a good grade.",
            "David is intelligent.",
            "Anyone who plays sports is a student.",
            "If someone has friends and is a student, they are likely to be happy.",
            "David plays sports.",
            "If someone is intelligent, they can solve problems.",
            "David has friends."
        ],
        "premises-FOL": [
            "Student(david) ::: David is a student.",
            "∀x (Student(x) ∧ StudiesHard(x) → Succeeds(x)) ::: All students who study hard are likely to succeed.",
            "StudiesHard(david) ::: David studies hard.",
            "∀x (StudiesHard(x) ∧ Intelligent(x) → GoodGrade(x)) ::: If someone studies hard and is intelligent, they get a good grade.",
            "Intelligent(david) ::: David is intelligent.",
            "∀x (PlaysSports(x) → Student(x)) ::: Anyone who plays sports is a student.",
            "∀x (HasFriends(x) ∧ Student(x) → Happy(x)) ::: If someone has friends and is a student, they are likely to be happy.",
            "PlaysSports(david) ::: David plays sports.",
            "∀x (Intelligent(x) → SolvesProblems(x)) ::: If someone is intelligent, they can solve problems.",
            "HasFriends(david) ::: David has friends."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "Intelligent(x) ::: x is intelligent",
            "PlaysSports(x) ::: x plays sports",
            "HasFriends(x) ::: x has friends",
            "GoodGrade(x) ::: x gets a good grade"
        ]
    },
    {
        "premises-NL": [
            "John is invited to the party.",
            "Sarah is invited to the party.",
            "If John and Sarah attend the party, Mary also attends.",
            "John is friends with Sarah.",
            "Mary is friends with Sarah.",
            "If someone is invited to a party and likes the party, they attend the party.",
            "Mary likes parties.",
            "If John attends the party, then Mary will be happy.",
            "Sarah is friends with John.",
            "Everyone is invited to the party.",
            "If Sarah attends the party, then John also attends."
        ],
        "premises-FOL": [
            "Invited(john, party) ::: John is invited to the party.",
            "Invited(sarah, party) ::: Sarah is invited to the party.",
            "∀x ∀y (Attends(john, y) ∧ Attends(sarah, y) → Attends(mary, y)) ::: If John and Sarah attend the party, Mary also attends.",
            "FriendsWith(john, sarah) ::: John is friends with Sarah.",
            "FriendsWith(mary, sarah) ::: Mary is friends with Sarah.",
            "∀x ∀y (Invited(x, y) ∧ Likes(x, y) → Attends(x, y)) ::: If someone is invited to a party and likes the party, they attend the party.",
            "Likes(mary, party) ::: Mary likes parties.",
            "Attends(john, party) → Happy(mary) ::: If John attends the party, then Mary will be happy.",
            "FriendsWith(sarah, john) ::: Sarah is friends with John.",
            "∀x Invited(x, party) ::: Everyone is invited to the party.",
            "Attends(sarah, party) → Attends(john, party) ::: If Sarah attends the party, then John also attends."
        ],
        "predicates": [
            "Attends(x, y) ::: x attends event y",
            "FriendsWith(x, y) ::: x is friends with y",
            "Invited(x, y) ::: x is invited to y",
            "Likes(x, y) ::: x likes y",
            "Happy(x) ::: x is happy"
        ]
    },
    {
        "premises-NL": [
            "All students are human.",
            "Some students are smart.",
            "All smart students study.",
            "If someone studies, then they will pass the exam.",
            "Every student likes coffee.",
            "Alex is a student and is smart.",
            "Alex attends the lecture about logic.",
            "Lectures about logic are boring.",
            "If someone attends a boring lecture, then they are tired."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Human(x)) ::: All students are human.",
            "∃x (Student(x) ∧ Smart(x)) ::: Some students are smart.",
            "∀x (Smart(x) → Studies(x)) ::: All smart students study.",
            "∀x (Studies(x) → PassesExam(x)) ::: If someone studies, then they will pass the exam.",
            "∀x (Student(x) → LikesCoffee(x)) ::: Every student likes coffee.",
            "Student(alex) ∧ Smart(alex) ::: Alex is a student and is smart.",
            "AttendsLecture(alex, logicLecture) ::: Alex attends the lecture about logic.",
            "Lecture(logicLecture) ∧ Boring(logicLecture) ::: Lectures about logic are boring.",
            "∀x ∀y (AttendsLecture(x, y) ∧ Boring(y) → IsTired(x)) ::: If someone attends a boring lecture, then they are tired."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Smart(x) ::: x is smart",
            "Studies(x) ::: x studies",
            "PassesExam(x) ::: x passes the exam",
            "LikesCoffee(x) ::: x likes coffee",
            "AttendsLecture(x, y) ::: x attends lecture y",
            "Lecture(y) ::: y is a lecture",
            "IsTired(x) ::: x is tired",
            "HasBook(x, y) ::: x has book y"
        ]
    },
    {
        "premises-NL": [
            "All doctors help people.",
            "All nurses help people.",
            "Everyone who helps people works in a hospital.",
            "Some doctors treat patients.",
            "All patients are sick.",
            "Some nurses administer medicine.",
            "All medicine is for sick people.",
            "Every doctor has a medical license.",
            "Doctors and nurses are healthcare professionals",
            "A doctor can specialize in a field.",
            "If someone helps people, they are caring."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HelpsPeople(x)) ::: All doctors help people.",
            "∀x (Nurse(x) → HelpsPeople(x)) ::: All nurses help people.",
            "∀x (HelpsPeople(x) → WorksInHospital(x)) ::: Everyone who helps people works in a hospital.",
            "∃x ∃y (Doctor(x) ∧ TreatsPatient(x, y)) ::: Some doctors treat patients.",
            "∀y (Patient(y) → IsSick(y)) ::: All patients are sick.",
            "∃x ∃y (Nurse(x) ∧ AdministersMedicine(x, y)) ::: Some nurses administer medicine.",
            "∀y (IsMedicine(y) → IsForSickPeople(y)) ::: All medicine is for sick people.",
            "∀x (Doctor(x) → HasMedicalLicense(x)) ::: Every doctor has a medical license.",
            "∀x ((Doctor(x) ∨ Nurse(x)) → HealthcareProfessional(x)) ::: Doctors and nurses are healthcare professionals.",
            "∀x ∃y (Doctor(x) → SpecializesIn(x, y)) ::: A doctor can specialize in a field.",
            "∀x (HelpsPeople(x) → Caring(x)) ::: If someone helps people, they are caring."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Nurse(x) ::: x is a nurse",
            "HelpsPeople(x) ::: x helps people",
            "WorksInHospital(x) ::: x works in a hospital",
            "TreatsPatient(x, y) ::: x treats patient y",
            "Patient(y) ::: y is a patient",
            "IsSick(y) ::: y is sick",
            "AdministersMedicine(x, y) ::: x administers medicine to y",
            "IsMedicine(y) ::: y is medicine",
            "HasMedicalLicense(x) ::: x has a medical license",
            "SpecializesIn(x, y) ::: x specializes in y"
        ]
    },
    {
        "premises-NL": [
            "All plants have leaves.",
            "If something is a plant, it needs water.",
            "Plants that are watered grow.",
            "Everything that grows has a stem.",
            "All plants are exposed to sunlight.",
            "If something is a plant, it is green.",
            "Something that is a plant and is watered is alive.",
            "All plants are organic.",
            "This is a plant.",
            "This plant is watered.",
            "A plant is always a living thing.",
            "If it has leaves and is exposed to sunlight, then it grows."
        ],
        "premises-FOL": [
            "∀x (Plant(x) → HasLeaves(x)) ::: All plants have leaves.",
            "∀x (Plant(x) → NeedsWater(x)) ::: If something is a plant, it needs water.",
            "∀x (Plant(x) ∧ IsWatered(x) → Grows(x)) ::: Plants that are watered grow.",
            "∀x (Grows(x) → HasStem(x)) ::: Everything that grows has a stem.",
            "∀x (Plant(x) → ExposedToSunlight(x)) ::: All plants are exposed to sunlight.",
            "∀x (Plant(x) → IsGreen(x)) ::: If something is a plant, it is green.",
            "∀x (Plant(x) ∧ IsWatered(x) → IsAlive(x)) ::: Something that is a plant and is watered is alive.",
            "∀x (Plant(x) → IsOrganic(x)) ::: All plants are organic.",
            "Plant(thisPlant) ::: This is a plant.",
            "IsWatered(thisPlant) ::: This plant is watered.",
            "∀x (Plant(x) → IsA(x, LivingThing)) ::: A plant is always a living thing.",
            "∀x (HasLeaves(x) ∧ ExposedToSunlight(x) → Grows(x)) ::: If it has leaves and is exposed to sunlight, then it grows."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "HasLeaves(x) ::: x has leaves",
            "ExposedToSunlight(x) ::: x is exposed to sunlight",
            "Grows(x) ::: x grows",
            "HasStem(x) ::: x has a stem",
            "IsWatered(x) ::: x is watered",
            "NeedsWater(x) ::: x needs water",
            "IsGreen(x) ::: x is green",
            "IsAlive(x) ::: x is alive",
            "IsA(x, y) ::: x is a y",
            "IsOrganic(x) ::: x is organic"
        ]
    },
    {
        "premises-NL": [
            "All students are educated.",
            "Some people study a subject.",
            "Anyone who studies a subject works at a company.",
            "A company employs its workers.",
            "John is a student.",
            "John studies a subject."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Educated(x)) ::: All students are educated.",
            "∃x ∃y Studies(x, y) ::: Someone studies something.",
            "∀x ∀y (Studies(x, y) → WorksAt(x, y)) ::: If someone studies something, they work at it.",
            "∀x ∀y (WorksAt(x, y) → Employed(x)) ::: If someone works at something, they are employed.",
            "Student(john) ::: John is a student.",
            "Studies(john, science) ::: John studies science."
        ],
        "predicates": [
            "Educated(x) ::: x is educated",
            "Employed(x) ::: x is employed",
            "Studies(x, y) ::: x studies y",
            "WorksAt(x, y) ::: x works at y"
        ]
    },
    {
        "premises-NL": [
            "All defective products have a warranty.",
            "If a product has a warranty and is complained about, it will be returned.",
            "If a product is returned, then it will be refunded.",
            "If a product is defective, it is complained about.",
            "If a product has a warranty and is returned, it is refunded.",
            "A product is defective or it is not returned.",
            "If a product is not returned then it is not defective.",
            "If a product is not defective, then it is not complained about.",
            "If a product is complained about, then it will be returned.",
            "A product has a warranty if it is not returned.",
            "A product either has a warranty or is defective.",
            "If a product is returned, then it is defective or has a warranty.",
            "All products are a product.",
            "If a product is defective it is complained about.",
            "If a product has a warranty, then it is not defective.",
            "If a product is returned, then it is complained about."
        ],
        "premises-FOL": [
            "∀x (Defective(x) → HasWarranty(x)) ::: All defective products have a warranty.",
            "∀x (HasWarranty(x) ∧ Complained(x) → Returned(x)) ::: If a product has a warranty and is complained about, it will be returned.",
            "∀x (Returned(x) → Refunded(x)) ::: If a product is returned, then it will be refunded.",
            "∀x (Defective(x) → Complained(x)) ::: If a product is defective, it is complained about.",
            "∀x (HasWarranty(x) ∧ Returned(x) → Refunded(x)) ::: If a product has a warranty and is returned, it is refunded.",
            "Defective(x) ∨ ¬Returned(x) ::: A product is defective or it is not returned.",
            "∀x (¬Returned(x) → ¬Defective(x)) ::: If a product is not returned then it is not defective.",
            "∀x (¬Defective(x) → ¬Complained(x)) ::: If a product is not defective, then it is not complained about.",
            "∀x (Complained(x) → Returned(x)) ::: If a product is complained about, then it will be returned.",
            "∀x (¬Returned(x) → HasWarranty(x)) ::: A product has a warranty if it is not returned.",
            "∀x (HasWarranty(x) ∨ Defective(x)) ::: A product either has a warranty or is defective.",
            "∀x (Returned(x) → Defective(x) ∨ HasWarranty(x)) ::: If a product is returned, then it is defective or has a warranty.",
            "∀x Product(x) ::: All products are a product.",
            "∀x (Defective(x) → Complained(x)) ::: If a product is defective it is complained about.",
            "∀x (HasWarranty(x) → ¬Defective(x)) ::: If a product has a warranty, then it is not defective.",
            "∀x (Returned(x) → Complained(x)) ::: If a product is returned, then it is complained about."
        ],
        "predicates": [
            "Product(x) ::: x is a product",
            "Defective(x) ::: x is defective",
            "Returned(x) ::: x is returned",
            "Complained(x) ::: x is complained about",
            "HasWarranty(x) ::: x has a warranty",
            "Refunded(x) ::: x is refunded"
        ]
    },
    {
        "premises-NL": [
            "Everyone who owns a cat likes cats.",
            "Everyone who owns a dog likes dogs.",
            "Some people own cats.",
            "Some people own dogs.",
            "Cats and dogs are pets.",
            "No one likes both cats and dogs.",
            "If someone owns a pet, they are friendly with it.",
            "If someone likes a pet, they are friendly with it.",
            "John owns a cat.",
            "John does not own a dog.",
            "If x is friendly with y, then y is friendly with x.",
            "If John likes cats, John is friendly with all cats."
        ],
        "premises-FOL": [
            "∀x ∀y ((OwnsPet(x, y) ∧ IsCat(y)) → LikesCats(x)) ::: Everyone who owns a cat likes cats.",
            "∀x ∀y ((OwnsPet(x, y) ∧ IsDog(y)) → LikesDogs(x)) ::: Everyone who owns a dog likes dogs.",
            "∃x ∃y (OwnsPet(x, y) ∧ IsCat(y)) ::: Some people own cats.",
            "∃x ∃y (OwnsPet(x, y) ∧ IsDog(y)) ::: Some people own dogs.",
            "∀y (IsCat(y) ∨ IsDog(y)) ::: Cats and dogs are pets.",
            "¬∃x (LikesCats(x) ∧ LikesDogs(x)) ::: No one likes both cats and dogs.",
            "∀x ∀y (OwnsPet(x, y) → FriendlyWith(x, y)) ::: If someone owns a pet, they are friendly with it.",
            "∀x ∀y ((LikesCats(x) ∨ LikesDogs(x)) → FriendlyWith(x, y)) ::: If someone likes a pet, they are friendly with it.",
            "∃y (OwnsPet(john, y) ∧ IsCat(y)) ::: John owns a cat.",
            "¬∃y (OwnsPet(john, y) ∧ IsDog(y)) ::: John does not own a dog.",
            "∀x ∀y (FriendlyWith(x, y) → FriendlyWith(y, x)) ::: If x is friendly with y, then y is friendly with x.",
            "∀y (LikesCats(john) → FriendlyWith(john, y)) ::: If John likes cats, John is friendly with all cats.",
            "¬∃x (LikesCats(john) ∧ LikesDogs(john)) ::: John likes either cats or dogs, but not both."
        ],
        "predicates": [
            "LikesCats(x) ::: x likes cats",
            "LikesDogs(x) ::: x likes dogs",
            "OwnsPet(x, y) ::: x owns pet y",
            "IsCat(y) ::: y is a cat",
            "IsDog(y) ::: y is a dog",
            "FriendlyWith(x, y) ::: x is friendly with y"
        ]
    },
    {
        "premises-NL": [
            "All doctors work in a hospital.",
            "If someone is a doctor, they are either a surgeon or a specialist.",
            "All surgeons are doctors.",
            "If someone is a specialist and works in a hospital, then they have a high workload.",
            "Dr. Smith is a surgeon.",
            "If Dr. Smith is a surgeon and works in a hospital, then he is tired.",
            "Dr. Smith works in a hospital.",
            "If someone is a doctor, they have a high workload if and only if they work in a hospital.",
            "Dr. Jones is a doctor.",
            "Dr. Jones is a specialist.",
            "Dr. Jones works in a hospital.",
            "If a doctor works in a hospital, then the workload is high.",
            "Dr. Smith is a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → WorksIn(x, hospital)) ::: All doctors work in a hospital.",
            "∀x (Doctor(x) → Surgeon(x) ∨ Specialist(x)) ::: If someone is a doctor, they are either a surgeon or a specialist.",
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Specialist(x) ∧ WorksIn(x, hospital) → HighWorkload(x)) ::: If someone is a specialist and works in a hospital, then they have a high workload.",
            "Surgeon(smith) ::: Dr. Smith is a surgeon.",
            "Surgeon(smith) ∧ WorksIn(smith, hospital) → IsTired(smith) ::: If Dr. Smith is a surgeon and works in a hospital, then he is tired.",
            "WorksIn(smith, hospital) ::: Dr. Smith works in a hospital.",
            "∀x (Doctor(x) → (HighWorkload(x) ↔ WorksIn(x, hospital))) ::: If someone is a doctor, they have a high workload if and only if they work in a hospital.",
            "Doctor(jones) ::: Dr. Jones is a doctor.",
            "Specialist(jones) ::: Dr. Jones is a specialist.",
            "WorksIn(jones, hospital) ::: Dr. Jones works in a hospital.",
            "∀x (Doctor(x) ∧ WorksIn(x, hospital) → HighWorkload(x)) ::: If a doctor works in a hospital, then the workload is high.",
            "Doctor(smith) ::: Dr. Smith is a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "WorksIn(x, y) ::: x works in y",
            "Hospital(x) ::: x is a hospital",
            "Specialist(x) ::: x is a specialist",
            "Surgeon(x) ::: x is a surgeon",
            "IsTired(x) ::: x is tired"
        ]
    },
    {
        "premises-NL": [
            "All athletes play a sport.",
            "Anyone who plays a sport is enrolled in a training program.",
            "All who are enrolled in a training program are healthy.",
            "Someone is an athlete.",
            "All athletes are strong.",
            "No one who is not enrolled in a training program is healthy.",
            "Some people are athletes and enrolled in training programs."
        ],
        "premises-FOL": [
            "∀x (Athlete(x) → PlaysSport(x)) ::: For all x, if x is an athlete, then x plays a sport.",
            "∀x (PlaysSport(x) → EnrolledIn(x, y)) ::: For all x, if x plays a sport, then x is enrolled in a training program.",
            "∀x (EnrolledIn(x, y) → Healthy(x)) ::: For all x, if x is enrolled in a training program, then x is healthy.",
            "∃x Athlete(x) ::: There exists someone who is an athlete.",
            "∀x (Athlete(x) → Strong(x)) ::: For all x, if x is an athlete, then x is strong.",
            "∀x (¬EnrolledIn(x, y) → ¬Healthy(x)) ::: For all x, if x is not enrolled in a training program, then x is not healthy.",
            "∃x (Athlete(x) ∧ EnrolledIn(x, y)) ::: There exists someone who is an athlete and enrolled in a training program."
        ],
        "predicates": [
            "Athlete(x) ::: x is an athlete",
            "Healthy(x) ::: x is healthy",
            "Strong(x) ::: x is strong",
            "EnrolledIn(x, y) ::: x is enrolled in y",
            "PlaysSport(x) ::: x plays a sport"
        ]
    },
    {
        "premises-NL": [
            "All scientists are researchers.",
            "All researchers are either published or unemployed.",
            "Some scientists have grants.",
            "Anyone with a grant is a researcher.",
            "Anyone who is published has not lost a grant.",
            "Some scientists are not unemployed.",
            "All scientists are published or unemployed.",
            "All researchers are published if they have a grant."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Researcher(x)) ::: For all x, if x is a scientist, then x is a researcher.",
            "∀x (Researcher(x) → (Published(x) ∨ Unemployed(x))) ::: For all x, if x is a researcher, then x is published or unemployed.",
            "∃x (Scientist(x) ∧ HasGrant(x)) ::: There exists a scientist who has a grant.",
            "∀x (HasGrant(x) → Researcher(x)) ::: For all x, if x has a grant, then x is a researcher.",
            "∀x (Published(x) → ¬HasGrant(x)) ::: For all x, if x is published, then they don't have grants.",
            "∃x (Scientist(x) ∧ ¬Unemployed(x)) ::: There exists a scientist who is not unemployed.",
            "∀x (Scientist(x) → (Published(x) ∨ Unemployed(x))) ::: For all x, if x is a scientist, then x is published or unemployed.",
            "∀x ((Researcher(x) ∧ HasGrant(x)) → Published(x)) ::: For all x, if x is a researcher and has a grant, then x is published."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Published(x) ::: x is published",
            "Unemployed(x) ::: x is unemployed",
            "HasGrant(x) ::: x has a grant",
            "Researcher(x) ::: x is a researcher"
        ]
    },
    {
        "premises-NL": [
            "All fruits are edible.",
            "Apples are fruits.",
            "Apples are red.",
            "If something is red, it grows on a tree.",
            "If something grows on a tree it has seeds.",
            "Oranges are fruits.",
            "Oranges are yellow.",
            "If something is yellow, it contains Vitamin C.",
            "If something contains Vitamin C, it is a citrus fruit."
        ],
        "premises-FOL": [
            "∀x (Fruit(x) → Edible(x)) ::: All fruits are edible.",
            "Fruit(apple) ::: Apples are fruits.",
            "IsRed(apple) ::: Apples are red.",
            "∀x (IsRed(x) → GrowsOnTree(x)) ::: If something is red, it grows on a tree.",
            "∀x (GrowsOnTree(x) → HasSeeds(x)) ::: If something grows on a tree it has seeds.",
            "Fruit(orange) ::: Oranges are fruits.",
            "IsYellow(orange) ::: Oranges are yellow.",
            "∀x (IsYellow(x) → ContainsVitaminC(x)) ::: If something is yellow, it contains Vitamin C.",
            "∀x (ContainsVitaminC(x) → IsCitrus(x)) ::: If something contains Vitamin C, it is a citrus fruit."
        ],
        "predicates": [
            "Fruit(x) ::: x is a fruit.",
            "IsRed(x) ::: x is red.",
            "GrowsOnTree(x) ::: x grows on a tree.",
            "Edible(x) ::: x is edible.",
            "IsSweet(x) ::: x is sweet.",
            "HasSeeds(x) ::: x has seeds.",
            "IsYellow(x) ::: x is yellow.",
            "ContainsVitaminC(x) ::: x contains vitamin C.",
            "IsCitrus(x) ::: x is a citrus fruit."
        ]
    },
    {
        "premises-NL": [
            "All fish live in water and have gills.",
            "All fish are cold-blooded.",
            "Everything that lives in water either has gills or lungs.",
            "Everything that lives in water can breathe.",
            "If something has lungs, it can breathe.",
            "If something has fur, it is a mammal.",
            "If something is warm-blooded and lives in water, it is a mammal.",
            "Fish do not have fur.",
            "Mammals are warm-blooded.",
            "Something with lungs does not have gills.",
            "Mammals do not lay eggs.",
            "Fish eat meat.",
            "If something has fins, it is aquatic."
        ],
        "premises-FOL": [
            "∀x (IsFish(x) → (LivesInWater(x) ∧ HasGills(x))) ::: All fish live in water and have gills.",
            "∀x (IsFish(x) → IsColdBlooded(x)) ::: All fish are cold-blooded.",
            "∀x (LivesInWater(x) → (HasGills(x) ∨ HasLungs(x))) ::: Everything that lives in water either has gills or lungs.",
            "∀x (LivesInWater(x) → CanBreathe(x)) ::: Everything that lives in water can breathe.",
            "∀x (HasLungs(x) → CanBreathe(x)) ::: If something has lungs, it can breathe.",
            "∀x (HasFur(x) → Mammal(x)) ::: If something has fur, it is a mammal.",
            "∀x (IsWarmBlooded(x) ∧ LivesInWater(x) → Mammal(x)) ::: If something is warm-blooded and lives in water, it is a mammal.",
            "∀x (IsFish(x) → ¬HasFur(x)) ::: Fish do not have fur.",
            "∀x (Mammal(x) → IsWarmBlooded(x)) ::: Mammals are warm-blooded.",
            "∀x (HasLungs(x) → ¬HasGills(x)) ::: Something with lungs does not have gills.",
            "∀x (Mammal(x) → ¬LaysEggs(x)) ::: Mammals do not lay eggs.",
            "∀x (IsFish(x) → EatsMeat(x)) ::: Fish eat meat.",
            "∀x (HasFins(x) → IsAquatic(x)) ::: If something has fins, it is aquatic."
        ],
        "predicates": [
            "LivesInWater(x) ::: x lives in water",
            "CanBreathe(x) ::: x can breathe",
            "HasGills(x) ::: x has gills",
            "Mammal(x) ::: x is a mammal",
            "IsFish(x) ::: x is a fish",
            "HasLungs(x) ::: x has lungs",
            "HasFins(x) ::: x has fins",
            "HasFur(x) ::: x has fur",
            "IsColdBlooded(x) ::: x is cold-blooded",
            "EatsMeat(x) ::: x eats meat",
            "IsAquatic(x) ::: x is aquatic",
            "IsWarmBlooded(x) ::: x is warm-blooded",
            "LaysEggs(x) ::: x lays eggs"
        ]
    },
    {
        "premises-NL": [
            "All doctors are employed.",
            "Dr. Smith is a doctor.",
            "If x is a doctor, then x is smart.",
            "Dr. Smith is an expert.",
            "Anyone who is an expert is employable.",
            "Anyone who is employable has a job.",
            "If someone is a doctor and they are employable, they are smart.",
            "If someone is not a doctor, they are still kind.",
            "If x is kind, then x has friends.",
            "Anyone who is kind and has friends, they have a life.",
            "If they have a life, then they are happy.",
            "If someone is a doctor or is happy, then they can travel.",
            "Someone is a doctor if they have a degree.",
            "If they are happy or sad, they are alive."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Employed(x)) ::: All doctors are employed",
            "Doctor(smith) ::: Dr. Smith is a doctor",
            "∀x (Doctor(x) → Smart(x)) ::: If x is a doctor, then x is smart",
            "Expert(smith) ::: Dr. Smith is an expert",
            "∀x (Expert(x) → Employable(x)) ::: Anyone who is an expert is employable",
            "∀x (Employable(x) → HasJob(x)) ::: Anyone who is employable has a job",
            "∀x ((Doctor(x) ∧ Employable(x)) → Smart(x)) ::: If someone is a doctor and they are employable, they are smart",
            "∀x (¬Doctor(x) → Kind(x)) ::: If someone is not a doctor, they are still kind",
            "∀x (Kind(x) → HasFriends(x)) ::: If x is kind, then x has friends",
            "∀x ((Kind(x) ∧ HasFriends(x)) → HasLife(x)) ::: Anyone who is kind and has friends, they have a life",
            "∀x (HasLife(x) → Happy(x)) ::: If they have a life, then they are happy",
            "∀x ((Doctor(x) ∨ Happy(x)) → CanTravel(x)) ::: If someone is a doctor or is happy, then they can travel",
            "∀x (HasDegree(x) → Doctor(x)) ::: Someone is a doctor if they have a degree",
            "∀x ((Happy(x) ∨ Sad(x)) → Alive(x)) ::: If they are happy or sad, they are alive"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Employed(x) ::: x is employed"
        ]
    },
    {
        "premises-NL": [
            "All mammals are warm-blooded.",
            "Fido is a mammal.",
            "If something is a mammal, it has fur.",
            "If something has fur, it is not a reptile.",
            "If something is a reptile, it will be cold-blooded.",
            "If something is not a mammal, it's a bird.",
            "If something is a bird, it can fly.",
            "If it can fly, it lives a long life.",
            "If it lives a long life, it's generally happy.",
            "If something is warm-blooded, it eats meat.",
            "If it eats meat, it has good vision.",
            "If it has good vision, it can spot predators.",
            "If it can spot predators, it has defense systems.",
            "If something has defense systems, it will be in danger.",
            "If something is in danger or happy, it travels the world.",
            "If something travels the world, then it will find love."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → WarmBlooded(x)) ::: All mammals are warm-blooded",
            "Mammal(fido) ::: Fido is a mammal",
            "∀x (Mammal(x) → HasFur(x)) ::: If something is a mammal, it has fur",
            "∀x (HasFur(x) → ¬Reptile(x)) ::: If something has fur, it is not a reptile",
            "∀x (Reptile(x) → ColdBlooded(x)) ::: If something is a reptile, it will be cold-blooded",
            "∀x (¬Mammal(x) → Bird(x)) ::: If something is not a mammal, it's a bird",
            "∀x (Bird(x) → CanFly(x)) ::: If something is a bird, it can fly",
            "∀x (CanFly(x) → LivesLong(x)) ::: If it can fly, it lives a long life",
            "∀x (LivesLong(x) → Happy(x)) ::: If it lives a long life, it's generally happy",
            "∀x (WarmBlooded(x) → EatsMeat(x)) ::: If something is warm-blooded, it eats meat",
            "∀x (EatsMeat(x) → GoodVision(x)) ::: If it eats meat, it has good vision",
            "∀x (GoodVision(x) → SpotsPredators(x)) ::: If it has good vision, it can spot predators",
            "∀x (SpotsPredators(x) → HasDefense(x)) ::: If it can spot predators, it has defense systems",
            "∀x (HasDefense(x) → InDanger(x)) ::: If something has defense systems, it will be in danger",
            "∀x ((InDanger(x) ∨ Happy(x)) → TravelsWorld(x)) ::: If something is in danger or happy, it travels the world",
            "∀x (TravelsWorld(x) → FindsLove(x)) ::: If something travels the world, then it will find love"
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal",
            "WarmBlooded(x) ::: x is warm-blooded",
            "HasFur(x) ::: x has fur"
        ]
    },
    {
        "premises-NL": [
            "All squares are rectangles.",
            "This shape is a square.",
            "If something is a square, it has four sides.",
            "If something has four sides, it can be drawn.",
            "If something is drawn, it will be beautiful.",
            "If something is not a square, it is a circle.",
            "If something is a circle, it will be blue.",
            "If something is blue, it is not a triangle.",
            "If something is a rectangle, it will be useful.",
            "If something is useful, it is valuable.",
            "If something is valuable or beautiful, it is a treasure.",
            "If something is a square and a treasure, it's dangerous.",
            "If something is not valuable, it's useless.",
            "If something is useless, then it is not desired.",
            "If something is desired and a circle, it's also in danger.",
            "If something is in danger, it is sad."
        ],
        "premises-FOL": [
            "∀x (Square(x) → Rectangle(x)) ::: All squares are rectangles",
            "Square(shape) ::: This shape is a square",
            "∀x (Square(x) → HasSides(x, 4)) ::: If something is a square, it has four sides",
            "∀x (HasSides(x, 4) → CanBeDrawn(x)) ::: If something has four sides, it can be drawn",
            "∀x (CanBeDrawn(x) → Beautiful(x)) ::: If something is drawn, it will be beautiful",
            "∀x (¬Square(x) → Circle(x)) ::: If something is not a square, it is a circle",
            "∀x (Circle(x) → IsBlue(x)) ::: If something is a circle, it will be blue",
            "∀x (IsBlue(x) → ¬Triangle(x)) ::: If something is blue, it is not a triangle",
            "∀x (Rectangle(x) → Useful(x)) ::: If something is a rectangle, it will be useful",
            "∀x (Useful(x) → Valuable(x)) ::: If something is useful, it is valuable",
            "∀x ((Valuable(x) ∨ Beautiful(x)) → Treasure(x)) ::: If something is valuable or beautiful, it is a treasure",
            "∀x ((Square(x) ∧ Treasure(x)) → Dangerous(x)) ::: If something is a square and a treasure, it's dangerous",
            "∀x (¬Valuable(x) → Useless(x)) ::: If something is not valuable, it's useless",
            "∀x (Useless(x) → ¬Desired(x)) ::: If something is useless, then it is not desired",
            "∀x ((Desired(x) ∧ Circle(x)) → InDanger(x)) ::: If something is desired and a circle, it's also in danger",
            "∀x (InDanger(x) → Sad(x)) ::: If something is in danger, it is sad"
        ],
        "predicates": [
            "Square(x) ::: x is a square",
            "Rectangle(x) ::: x is a rectangle",
            "HasSides(x, y) ::: x has y sides",
            "IsBlue(x) ::: x is blue"
        ]
    },
    {
        "premises-NL": [
            "All artists are creative.",
            "Some creative people are eccentric.",
            "John is an artist.",
            "John is creative.",
            "Mary is creative.",
            "Mary is eccentric.",
            "If someone is an artist, they are creative"
        ],
        "premises-FOL": [
            "∀x (Artist(x) → Creative(x)) ::: All artists are creative.",
            "∃x (Creative(x) ∧ Eccentric(x)) ::: Some creative people are eccentric.",
            "Artist(John) ::: John is an artist.",
            "Creative(John) ::: John is creative.",
            "Creative(Mary) ::: Mary is creative.",
            "Eccentric(Mary) ::: Mary is eccentric.",
            "∀x (Artist(x) → Creative(x)) ::: If someone is an artist, they are creative."
        ],
        "predicates": [
            "Artist(x) ::: x is an artist.",
            "Creative(x) ::: x is creative.",
            "Eccentric(x) ::: x is eccentric."
        ]
    },
    {
        "premises-NL": [
            "All doctors have medical degrees.",
            "Some researchers are doctors.",
            "All doctors are employed.",
            "Alice is a researcher.",
            "Alice is a doctor.",
            "Alice is employed.",
            "Alice has a medical degree.",
            "Bob is a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HasMedicalDegree(x)) ::: All doctors have medical degrees.",
            "∃x (Researcher(x) ∧ Doctor(x)) ::: Some researchers are doctors.",
            "∀x (Doctor(x) → Employed(x)) ::: All doctors are employed.",
            "Researcher(Alice) ::: Alice is a researcher.",
            "Doctor(Alice) ::: Alice is a doctor.",
            "Employed(Alice) ::: Alice is employed.",
            "HasMedicalDegree(Alice) ::: Alice has a medical degree.",
            "Doctor(Bob) ::: Bob is a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "HasMedicalDegree(x) ::: x has a medical degree.",
            "Researcher(x) ::: x is a researcher.",
            "Employed(x) ::: x is employed."
        ]
    },
    {
        "premises-NL": [
            "All students are either athletes or lazy.",
            "All athletes are smart.",
            "No one is both smart and lazy.",
            "Some students are athletes.",
            "Alex is a student.",
            "Alex is smart.",
            "Alex is not lazy.",
            "Bob is an athlete.",
            "Bob is smart.",
            "There exist a student who is also an athlete."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Athlete(x) ∨ Lazy(x))) ::: All students are either athletes or lazy.",
            "∀x (Athlete(x) → Smart(x)) ::: All athletes are smart.",
            "¬∃x (Smart(x) ∧ Lazy(x)) ::: No one is both smart and lazy.",
            "∃x (Student(x) ∧ Athlete(x)) ::: Some students are athletes.",
            "Student(Alex) ::: Alex is a student.",
            "Smart(Alex) ::: Alex is smart.",
            "¬Lazy(Alex) ::: Alex is not lazy.",
            "Athlete(Bob) ::: Bob is an athlete.",
            "Smart(Bob) ::: Bob is smart.",
            "∃x (Student(x) ∧ Athlete(x)) ::: There exist a student who is also an athlete."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Athlete(x) ::: x is an athlete.",
            "Lazy(x) ::: x is lazy.",
            "Smart(x) ::: x is smart."
        ]
    },
    {
        "premises-NL": [
            "All scientists are researchers.",
            "Some researchers are not ethical.",
            "All ethical people are good.",
            "No good person is wealthy.",
            "Alex is a scientist.",
            "Alex researches physics.",
            "Alex is not ethical.",
            "If someone researches physics then they are ethical.",
            "Bob is a scientist.",
            "Bob is good.",
            "There is a scientist who is not wealthy."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Researches(x, Physics)) ::: All scientists are researchers.",
            "∃x (Researches(x, Physics) ∧ ¬Ethical(x)) ::: Some researchers are not ethical.",
            "∀x (Ethical(x) → Good(x)) ::: All ethical people are good.",
            "¬∃x (Good(x) ∧ Wealthy(x)) ::: No good person is wealthy.",
            "Scientist(Alex) ::: Alex is a scientist.",
            "Researches(Alex, Physics) ::: Alex researches physics.",
            "¬Ethical(Alex) ::: Alex is not ethical.",
            "∀x (Researches(x, Physics) → Ethical(x)) ::: If someone researches physics then they are ethical.",
            "Scientist(Bob) ::: Bob is a scientist.",
            "Good(Bob) ::: Bob is good.",
            "∃x (Scientist(x) ∧ ¬Wealthy(x)) ::: There is a scientist who is not wealthy."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist.",
            "Ethical(x) ::: x is ethical.",
            "Wealthy(x) ::: x is wealthy.",
            "Good(x) ::: x is good.",
            "Researches(x, y) ::: x researches y."
        ]
    },
    {
        "premises-NL": [
            "All students attend the lecture.",
            "Emily is a student.",
            "If someone is a student and studies hard, they will understand the material.",
            "If someone attends the lecture, they study hard.",
            "If someone understands the material, they will pass the exam.",
            "No one studies hard if they don't attend the lecture.",
            "Emily attends the lecture.",
            "Someone passes the exam if they study hard and understand the material.",
            "Every student either studies hard or does not attend the lecture.",
            "If someone is a student, they either study hard or not.",
            "There exists a student who understands the material."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsLecture(x)) ::: All students attend the lecture",
            "Student(emily) ::: Emily is a student",
            "∀x ((Student(x) ∧ StudiesHard(x)) → UnderstandsMaterial(x)) ::: If someone is a student and studies hard, they will understand the material",
            "∀x (AttendsLecture(x) → StudiesHard(x)) ::: If someone attends the lecture, they study hard",
            "∀x (UnderstandsMaterial(x) → PassesExam(x)) ::: If someone understands the material, they will pass the exam",
            "¬∃x (StudiesHard(x) ∧ ¬AttendsLecture(x)) ::: No one studies hard if they don't attend the lecture",
            "AttendsLecture(emily) ::: Emily attends the lecture",
            "∀x ((StudiesHard(x) ∧ UnderstandsMaterial(x)) → PassesExam(x)) ::: Someone passes the exam if they study hard and understand the material",
            "∀x (Student(x) → (StudiesHard(x) ∨ ¬AttendsLecture(x))) ::: Every student either studies hard or does not attend the lecture",
            "∀x (Student(x) → (StudiesHard(x) ∨ ¬StudiesHard(x))) ::: If someone is a student, they either study hard or not",
            "∃x (Student(x) ∧ UnderstandsMaterial(x)) ::: There exists a student who understands the material"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "AttendsLecture(x) ::: x attends the lecture",
            "UnderstandsMaterial(x) ::: x understands the material",
            "PassesExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "Every employee either receives a bonus or has a high salary.",
            "Some employees do not have a high salary.",
            "John is an employee.",
            "All managers receive bonuses.",
            "No manager has a low salary.",
            "All employees work at the same company.",
            "There exists an employee.",
            "If someone works at a company and is an employee then they receive a salary.",
            "Some employees do not receive bonuses.",
            "Mary is a manager.",
            "Mary is an employee.",
            "Mary works at the company.",
            "If someone is a manager then they work at the company.",
            "If someone receives a bonus then they are an employee.",
            "Some employees have a low salary.",
            "If someone is a manager then they receive a high salary."
        ],
        "premises-FOL": [
            "∀x (Employee(x) → (ReceivesBonus(x) ∨ HighSalary(x))) ::: For all x, if x is an employee, then x receives a bonus or has a high salary.",
            "∃x (Employee(x) ∧ ¬HighSalary(x)) ::: There exists an x such that x is an employee and does not have a high salary.",
            "Employee(john) ::: John is an employee.",
            "∀x (Manager(x) → ReceivesBonus(x)) ::: For all x, if x is a manager, then x receives a bonus.",
            "∀x (Manager(x) → HighSalary(x)) ::: For all x, if x is a manager, then x has a high salary.",
            "∀x ∀y (Employee(x) → WorksAt(x, y)) ::: For all x and y, if x is an employee, then x works at y.",
            "∃x Employee(x) ::: There exists an x such that x is an employee.",
            "∀x ∀y (WorksAt(x, y) ∧ Employee(x) → ReceivesSalary(x)) ::: For all x and y, if x works at y and x is an employee, then x receives a salary.",
            "∃x (Employee(x) ∧ ¬ReceivesBonus(x)) ::: There exists an x such that x is an employee and does not receive a bonus.",
            "Manager(mary) ::: Mary is a manager.",
            "Employee(mary) ::: Mary is an employee.",
            "WorksAt(mary, company) ::: Mary works at the company.",
            "∀x (Manager(x) → WorksAt(x, company)) ::: For all x, if x is a manager, then x works at the company.",
            "∀x (ReceivesBonus(x) → Employee(x)) ::: For all x, if x receives a bonus, then x is an employee.",
            "∃x (Employee(x) ∧ LowSalary(x)) ::: There exists an x such that x is an employee and has a low salary.",
            "∀x (Manager(x) → HighSalary(x)) ::: For all x, if x is a manager, then x has a high salary."
        ],
        "predicates": [
            "Employee(x) ::: x is an employee.",
            "ReceivesBonus(x) ::: x receives a bonus.",
            "HighSalary(x) ::: x has a high salary.",
            "WorksAt(x, y) ::: x works at y.",
            "Manager(x) ::: x is a manager."
        ]
    },
    {
        "premises-NL": [
            "All apples are fruits.",
            "All apples are sweet.",
            "All apples are red.",
            "There is an apple."
        ],
        "premises-FOL": [
            "∀x (Apple(x) → Fruit(x)) ::: All apples are fruits.",
            "∀x (Apple(x) → Sweet(x)) ::: All apples are sweet.",
            "∀x (Apple(x) → Red(x)) ::: All apples are red.",
            "∃x Apple(x) ::: There is an apple."
        ],
        "predicates": [
            "Fruit(x) ::: x is a fruit.",
            "Apple(x) ::: x is an apple.",
            "Sweet(x) ::: x is sweet.",
            "Red(x) ::: x is red."
        ]
    },
    {
        "premises-NL": [
            "All good doctors are doctors.",
            "All good doctors are skilled.",
            "All good doctors are tall.",
            "Some doctors are good doctors.",
            "Every patient likes a doctor.",
            "Every doctor treats a patient.",
            "Every doctor likes themselves.",
            "A good doctor is also tall.",
            "A good doctor is also skilled.",
            "Some doctors are good."
        ],
        "premises-FOL": [
            "∀x (GoodDoctor(x) → Doctor(x)) ::: All good doctors are doctors.",
            "∀x (GoodDoctor(x) → Skilled(x)) ::: All good doctors are skilled.",
            "∀x (GoodDoctor(x) → Tall(x)) ::: All good doctors are tall.",
            "∃x GoodDoctor(x) ::: Some doctors are good doctors.",
            "∀x ∃y (Patient(y) → Likes(y, x)) ::: Every patient likes a doctor.",
            "∀x ∃y (Doctor(x) → Treats(x, y)) ::: Every doctor treats a patient.",
            "∀x (Doctor(x) → Likes(x, x)) ::: Every doctor likes themselves.",
            "∀x (GoodDoctor(x) → Tall(x)) ::: A good doctor is also tall.",
            "∀x (GoodDoctor(x) → Skilled(x)) ::: A good doctor is also skilled.",
            "∃x GoodDoctor(x) ::: Some doctors are good."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Patient(x) ::: x is a patient.",
            "Tall(x) ::: x is tall.",
            "Skilled(x) ::: x is skilled.",
            "Treats(x, y) ::: x treats y.",
            "Likes(x, y) ::: x likes y.",
            "GoodDoctor(x) ::: x is a good doctor."
        ]
    },
    {
        "premises-NL": [
            "All employed people have jobs.",
            "All employed people are qualified.",
            "All qualified people have degrees.",
            "Some students study hard.",
            "Some people are students.",
            "All students get degrees.",
            "All people who work at a company are employed.",
            "Anyone who has a job, is employed.",
            "Someone has a job.",
            "Someone is qualified.",
            "Some people work in tech companies.",
            "Someone studies computer science.",
            "Someone who has a degree has a job.",
            "Some people have jobs at a tech company.",
            "All the employed have a degree and a job.",
            "Someone is employed."
        ],
        "premises-FOL": [
            "∀x (Employed(x) → HasJob(x)) ::: All employed people have jobs.",
            "∀x (Employed(x) → Qualified(x)) ::: All employed people are qualified.",
            "∀x (Qualified(x) → HasDegree(x)) ::: All qualified people have degrees.",
            "∃x ∃y (Student(x) ∧ Studies(x, y)) ::: Some students study hard.",
            "∃x Student(x) ::: Some people are students.",
            "∀x (Student(x) → HasDegree(x)) ::: All students get degrees.",
            "∀x ∀y (WorksAt(x, y) → Employed(x)) ::: All people who work at a company are employed.",
            "∀x (HasJob(x) → Employed(x)) ::: Anyone who has a job, is employed.",
            "∃x HasJob(x) ::: Someone has a job.",
            "∃x Qualified(x) ::: Someone is qualified.",
            "∃x ∃y (WorksAt(x, y) ∧ JobType(y, tech)) ::: Some people work in tech companies.",
            "∃x ∃y (Studies(x, computerScience)) ::: Someone studies computer science.",
            "∀x (HasDegree(x) → HasJob(x)) ::: Someone who has a degree has a job.",
            "∃x ∃y (HasJob(x) ∧ WorksAt(x, y)) ::: Some people have jobs at a tech company.",
            "∀x (Employed(x) → (HasDegree(x) ∧ HasJob(x))) ::: All the employed have a degree and a job.",
            "∃x Employed(x) ::: Someone is employed."
        ],
        "predicates": [
            "HasDegree(x) ::: x has a degree.",
            "HasJob(x) ::: x has a job.",
            "Employed(x) ::: x is employed.",
            "Studies(x, y) ::: x studies y.",
            "WorksAt(x, y) ::: x works at y.",
            "Qualified(x) ::: x is qualified.",
            "JobType(x, y) ::: x is a job of type y.",
            "Student(x) ::: x is a student."
        ]
    },
    {
        "premises-NL": [
            "John has a driver's license.",
            "John is not drunk.",
            "If a person has a driver's license and is not drunk, then the person can drive a car.",
            "John has a car.",
            "If John has a car and can drive, John can go anywhere.",
            "John passed the driving test.",
            "John attends driving school.",
            "If someone passed the driving test, then they can get a license.",
            "If someone is a student and passed the driving test, they get a license.",
            "John is a student.",
            "If John is a student, he is attending driving school.",
            "If John can drive and has a car, then he can go anywhere.",
            "John has the keys to the car."
        ],
        "premises-FOL": [
            "HasLicense(john) ::: John has a driver's license",
            "¬Drunk(john) ::: John is not drunk",
            "(HasLicense(x) ∧ ¬Drunk(x)) → DrivesCar(x) ::: If a person has a driver's license and is not drunk, then the person can drive a car",
            "HasCar(john) ::: John has a car",
            "(HasCar(x) ∧ DrivesCar(x)) → CanGoAnywhere(x) ::: If x has a car and can drive, x can go anywhere",
            "PassedTest(john) ::: John passed the driving test",
            "AttendsSchool(john) ::: John attends driving school",
            "PassedTest(x) → HasLicense(x) ::: If x passed the driving test, then they can get a license",
            "(IsStudent(x) ∧ PassedTest(x)) → HasLicense(x) ::: If someone is a student and passed the driving test, they get a license",
            "IsStudent(john) ::: John is a student",
            "IsStudent(x) → AttendsSchool(x) ::: If x is a student, he is attending driving school",
            "(DrivesCar(x) ∧ HasCar(x)) → CanGoAnywhere(x) ::: If x can drive and has a car, then he can go anywhere",
            "HasKeys(john, car) ::: John has the keys to the car"
        ],
        "predicates": [
            "HasLicense(x) ::: x has a driver's license",
            "Drunk(x) ::: x is drunk",
            "DrivesCar(x) ::: x drives a car",
            "HasCar(x) ::: x has a car",
            "PassedTest(x) ::: x passed the test",
            "AttendsSchool(x) ::: x attends school",
            "IsStudent(x) ::: x is a student",
            "HasKeys(x, y) ::: x has the keys to y",
            "IsCar(x) ::: x is a car",
            "CarAvailable(x) ::: x car is available",
            "CanDrive(x) ::: x can drive"
        ]
    },
    {
        "premises-NL": [
            "All students take either Calculus or Physics.",
            "If a student takes Calculus, they are a student.",
            "If a student takes Physics, they are a student.",
            "If a student is struggling, then they do not have good grades.",
            "If a student has good grades, they do not struggle."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Calculus(x) ∨ Physics(x))) ::: All students take either Calculus or Physics.",
            "∀x (Calculus(x) → Student(x)) ::: If a student takes Calculus, they are a student.",
            "∀x (Physics(x) → Student(x)) ::: If a student takes Physics, they are a student.",
            "∀x (Struggle(x) → ¬GoodGrades(x)) ::: If a student is struggling, then they do not have good grades.",
            "∀x (GoodGrades(x) → ¬Struggle(x)) ::: If a student has good grades, they do not struggle."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Calculus(x) ::: x is taking Calculus",
            "Physics(x) ::: x is taking Physics",
            "Struggle(x) ::: x will struggle"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "Doctors help patients.",
            "All patients are sick.",
            "If someone is a surgeon, then they operate on patients.",
            "If someone operates on patients, then they are doctors.",
            "If someone is a doctor, then they help sick people."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x ∀y (Doctor(x) ∧ Patient(y) → Helps(x, y)) ::: Doctors help patients.",
            "∀y (Patient(y) → Sick(y)) ::: All patients are sick.",
            "∀x ∀y (Surgeon(x) ∧ Patient(y) → Operates(x, y)) ::: If someone is a surgeon, then they operate on patients.",
            "∀x ∀y (Operates(x, y) → Doctor(x)) ::: If someone operates on patients, then they are doctors.",
            "∀x ∀y (Doctor(x) ∧ Sick(y) → Helps(x, y)) ::: If someone is a doctor, then they help sick people."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "Sick(y) ::: y is sick",
            "Helps(x, y) ::: x helps y",
            "Patient(y) ::: y is a patient",
            "Operates(x, y) ::: x operates on y"
        ]
    },
    {
        "premises-NL": [
            "All professors research.",
            "All professors teach.",
            "If someone researches, they publish papers.",
            "If someone teaches, they are a good teacher.",
            "If someone is a good teacher, they do not get fired.",
            "If someone researches and is a good teacher, then they get promoted.",
            "If someone is a professor and researches, they will get promoted."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Researches(x)) ::: All professors research.",
            "∀x (Professor(x) → Teaches(x)) ::: All professors teach.",
            "∀x (Researches(x) → Publishes(x)) ::: If someone researches, they publish papers.",
            "∀x (Teaches(x) → GoodTeacher(x)) ::: If someone teaches, they are a good teacher.",
            "∀x (GoodTeacher(x) → ¬Fired(x)) ::: If someone is a good teacher, they do not get fired.",
            "∀x (Researches(x) ∧ GoodTeacher(x) → Promoted(x)) ::: If someone researches and is a good teacher, then they get promoted.",
            "∀x (Professor(x) ∧ Researches(x) → Promoted(x)) ::: If someone is a professor and researches, they will get promoted."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "Publishes(x) ::: x publishes papers",
            "Researches(x) ::: x researches",
            "Teaches(x) ::: x teaches",
            "Promoted(x) ::: x is promoted",
            "GoodTeacher(x) ::: x is a good teacher",
            "Researcher(x) ::: x is a researcher"
        ]
    },
    {
        "premises-NL": [
            "All patients admitted to the hospital receive care.",
            "If a patient has a serious condition, then they are an emergency.",
            "If a patient is an emergency, they need immediate treatment.",
            "If a patient has a serious condition and has insurance, then they are admitted.",
            "If a patient is an emergency, then they will receive care.",
            "If a patient is admitted to the hospital, they are a patient.",
            "If a patient needs medication, they will receive care.",
            "If a patient has surgery, they need medication."
        ],
        "premises-FOL": [
            "∀x (Admitted(x) → ReceivesCare(x)) ::: All patients admitted to the hospital receive care.",
            "∀x (SeriousCondition(x) → Emergency(x)) ::: If a patient has a serious condition, then they are an emergency.",
            "∀x (Emergency(x) → ImmediateTreatment(x)) ::: If a patient is an emergency, they need immediate treatment.",
            "∀x (SeriousCondition(x) ∧ HasInsurance(x) → Admitted(x)) ::: If a patient has a serious condition and has insurance, then they are admitted.",
            "∀x (Emergency(x) → ReceivesCare(x)) ::: If a patient is an emergency, then they will receive care.",
            "∀x (Admitted(x) → Patient(x)) ::: If a patient is admitted to the hospital, they are a patient.",
            "∀x (NeedsMedication(x) → ReceivesCare(x)) ::: If a patient needs medication, they will receive care.",
            "∀x (HasSurgery(x) → NeedsMedication(x)) ::: If a patient has surgery, they need medication."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient",
            "Admitted(x) ::: x is admitted to the hospital",
            "SeriousCondition(x) ::: x has a serious condition",
            "NeedsMedication(x) ::: x needs medication",
            "ReceivesCare(x) ::: x receives care",
            "HasSurgery(x) ::: x has surgery",
            "Emergency(x) ::: x is an emergency",
            "ImmediateTreatment(x) ::: x receives immediate treatment",
            "HasInsurance(x) ::: x has insurance"
        ]
    },
    {
        "premises-NL": [
            "Every student either studies hard or is lazy.",
            "If a student is lazy, they will not succeed.",
            "John is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (StudiesHard(x) ∨ Lazy(x))) ::: Every student either studies hard or is lazy.",
            "∀x (Lazy(x) → ¬Succeeds(x)) ::: If anyone is lazy, they will not succeed.",
            "Student(john) ::: John is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "Succeeds(x) ::: x succeeds"
        ]
    },
    {
        "premises-NL": [
            "Every doctor attends a conference.",
            "Every researcher attends a conference.",
            "Anyone who attends a conference is either a doctor or a researcher.",
            "If a person is a doctor, they are skilled.",
            "If a person is a researcher, they are skilled.",
            "Alice is both a doctor and a researcher.",
            "Bob is a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → AttendsConference(x)) ::: Every doctor attends a conference.",
            "∀x (Researcher(x) → AttendsConference(x)) ::: Every researcher attends a conference.",
            "∀x (AttendsConference(x) → (Doctor(x) ∨ Researcher(x))) ::: Anyone who attends a conference is either a doctor or a researcher.",
            "∀x (Doctor(x) → Skilled(x)) ::: If a person is a doctor, they are skilled.",
            "∀x (Researcher(x) → Skilled(x)) ::: If a person is a researcher, they are skilled.",
            "Doctor(alice) ∧ Researcher(alice) ::: Alice is both a doctor and a researcher.",
            "Doctor(bob) ::: Bob is a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Researcher(x) ::: x is a researcher",
            "Skilled(x) ::: x is skilled",
            "AttendsConference(x) ::: x attends a conference"
        ]
    },
    {
        "premises-NL": [
            "Every member of the chess club plays chess.",
            "Anyone who plays chess studies tactics or enjoys chess.",
            "Anyone who studies tactics improves their skills.",
            "If someone enjoys chess, they are not a member of the chess club.",
            "If someone improves their skills and doesn't enjoy chess, then they study tactics.",
            "David is a member of the chess club.",
            "David plays chess.",
            "David does not enjoy chess.",
            "David studies tactics."
        ],
        "premises-FOL": [
            "∀x (ChessClubMember(x) → PlaysChess(x)) ::: Every member of the chess club plays chess.",
            "∀x (PlaysChess(x) → (StudiesTactics(x) ∨ EnjoysChess(x))) ::: Anyone who plays chess studies tactics or enjoys chess.",
            "∀x (StudiesTactics(x) → ImprovesSkills(x)) ::: Anyone who studies tactics improves their skills.",
            "∀x (EnjoysChess(x) → ¬ChessClubMember(x)) ::: If someone enjoys chess, they are not a member of the chess club.",
            "∀x ((ImprovesSkills(x) ∧ ¬EnjoysChess(x)) → StudiesTactics(x)) ::: If someone improves their skills and doesn't enjoy chess, then they study tactics.",
            "ChessClubMember(david) ::: David is a member of the chess club.",
            "PlaysChess(david) ::: David plays chess.",
            "¬EnjoysChess(david) ::: David does not enjoy chess.",
            "StudiesTactics(david) ::: David studies tactics."
        ],
        "predicates": [
            "ChessClubMember(x) ::: x is a member of the chess club",
            "StudiesTactics(x) ::: x studies tactics",
            "ImprovesSkills(x) ::: x improves their skills",
            "PlaysChess(x) ::: x plays chess",
            "EnjoysChess(x) ::: x enjoys chess"
        ]
    },
    {
        "premises-NL": [
            "If someone invests in stocks, they either save money or spend money.",
            "If someone spends money, they do not save money.",
            "Anyone who saves money is financially responsible.",
            "Anyone who earns income and invests in stocks is not in debt.",
            "Anyone who is not in debt is financially responsible.",
            "If someone invests in stocks, they are not in debt.",
            "If someone buys property, they are financially responsible.",
            "If someone is financially responsible they either save or spend money.",
            "John invests in stocks.",
            "John spends money.",
            "John earns income.",
            "John does not save money.",
            "John does not have debt."
        ],
        "premises-FOL": [
            "∀x (InvestsInStocks(x) → (SavesMoney(x) ∨ SpendsMoney(x))) ::: If someone invests in stocks, they either save money or spend money.",
            "∀x (SpendsMoney(x) → ¬SavesMoney(x)) ::: If someone spends money, they do not save money.",
            "∀x (SavesMoney(x) → FinanciallyResponsible(x)) ::: Anyone who saves money is financially responsible.",
            "∀x ((EarnsIncome(x) ∧ InvestsInStocks(x)) → ¬HasDebt(x)) ::: Anyone who earns income and invests in stocks is not in debt.",
            "∀x (¬HasDebt(x) → FinanciallyResponsible(x)) ::: Anyone who is not in debt is financially responsible.",
            "∀x (InvestsInStocks(x) → ¬HasDebt(x)) ::: If someone invests in stocks, they are not in debt.",
            "∀x (BuysProperty(x) → FinanciallyResponsible(x)) ::: If someone buys property, they are financially responsible.",
            "∀x (FinanciallyResponsible(x) → (SavesMoney(x) ∨ SpendsMoney(x))) ::: If someone is financially responsible they either save or spend money.",
            "InvestsInStocks(john) ::: John invests in stocks.",
            "SpendsMoney(john) ::: John spends money.",
            "EarnsIncome(john) ::: John earns income.",
            "¬SavesMoney(john) ::: John does not save money.",
            "¬HasDebt(john) ::: John does not have debt."
        ],
        "predicates": [
            "InvestsInStocks(x) ::: x invests in stocks",
            "SavesMoney(x) ::: x saves money",
            "FinanciallyResponsible(x) ::: x is financially responsible",
            "EarnsIncome(x) ::: x earns income",
            "SpendsMoney(x) ::: x spends money",
            "HasDebt(x) ::: x has debt",
            "BuysProperty(x) ::: x buys property"
        ]
    },
    {
        "premises-NL": [
            "All entrepreneurs work hard.",
            "Anyone who works hard can be successful.",
            "Some entrepreneurs have a degree.",
            "Anyone with a degree will have a network.",
            "John is an entrepreneur."
        ],
        "premises-FOL": [
            "∀x (Entrepreneur(x) → WorksHard(x)) ::: All entrepreneurs work hard.",
            "∀x (WorksHard(x) → Successful(x)) ::: Anyone who works hard can be successful.",
            "∃x (Entrepreneur(x) ∧ HasDegree(x)) ::: Some entrepreneurs have a degree.",
            "∀x (HasDegree(x) → HasNetwork(x)) ::: Anyone with a degree will have a network.",
            "Entrepreneur(john) ::: John is an entrepreneur."
        ],
        "predicates": [
            "Entrepreneur(x) ::: x is an entrepreneur",
            "Successful(x) ::: x is successful",
            "HasDegree(x) ::: x has a degree",
            "HasNetwork(x) ::: x has a network",
            "WorksHard(x) ::: x works hard"
        ]
    },
    {
        "premises-NL": [
            "All patients with flu symptoms have a fever.",
            "All patients with a fever are contagious.",
            "All contagious patients should isolate.",
            "Some patients have flu symptoms.",
            "John is a patient.",
            "Anyone with flu symptoms has a cough."
        ],
        "premises-FOL": [
            "∀x (HasFluSymptoms(x) → HasFever(x)) ::: All patients with flu symptoms have a fever.",
            "∀x (HasFever(x) → IsContagious(x)) ::: All patients with a fever are contagious.",
            "∀x (IsContagious(x) → ShouldIsolate(x)) ::: All contagious patients should isolate.",
            "∃x (Patient(x) ∧ HasFluSymptoms(x)) ::: Some patients have flu symptoms.",
            "Patient(john) ::: John is a patient.",
            "∀x (HasFluSymptoms(x) → HasCough(x)) ::: Anyone with flu symptoms has a cough."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient",
            "HasFluSymptoms(x) ::: x has flu symptoms",
            "HasFever(x) ::: x has a fever",
            "IsContagious(x) ::: x is contagious",
            "ShouldIsolate(x) ::: x should isolate",
            "HasCough(x) ::: x has a cough"
        ]
    },
    {
        "premises-NL": [
            "All professors conduct research.",
            "Anyone who conducts research publishes papers.",
            "Some professors are experts in their field.",
            "Anyone who is an expert in a field and has a grant teaches advanced courses.",
            "John is a professor.",
            "John has a grant.",
            "John is an expert in computer science."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → ConductsResearch(x)) ::: All professors conduct research.",
            "∀x (ConductsResearch(x) → PublishesPapers(x)) ::: Anyone who conducts research publishes papers.",
            "∃x ∃y (Professor(x) ∧ ExpertInField(x, y)) ::: Some professors are experts in their field.",
            "∀x ∀y (ExpertInField(x, y) ∧ HasGrant(x) → TeachesAdvanced(x)) ::: Anyone who is an expert in a field and has a grant teaches advanced courses.",
            "Professor(john) ::: John is a professor.",
            "HasGrant(john) ::: John has a grant.",
            "ExpertInField(john, computerScience) ::: John is an expert in computer science."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "TeachesAdvanced(x) ::: x teaches advanced courses",
            "PublishesPapers(x) ::: x publishes papers",
            "ConductsResearch(x) ::: x conducts research",
            "ExpertInField(x, y) ::: x is an expert in field y",
            "Field(y) ::: y is a field",
            "HasGrant(x) ::: x has a grant"
        ]
    },
    {
        "premises-NL": [
            "All people with a high income have a good job.",
            "All people with a good job save money.",
            "All people who save money have a high education.",
            "Anyone who is rich and has a high education spends money on vacations.",
            "Anyone who is rich owns a luxury car.",
            "John has a high income.",
            "John is rich.",
            "John has a good job."
        ],
        "premises-FOL": [
            "∀x (HasHighIncome(x) → HasGoodJob(x)) ::: All people with a high income have a good job.",
            "∀x (HasGoodJob(x) → SavesMoney(x)) ::: All people with a good job save money.",
            "∀x (SavesMoney(x) → HasHighEducation(x)) ::: All people who save money have a high education.",
            "∀x (IsRich(x) ∧ HasHighEducation(x) → SpendsMoneyOnVacations(x)) ::: Anyone who is rich and has a high education spends money on vacations.",
            "∀x (IsRich(x) → OwnsLuxuryCar(x)) ::: Anyone who is rich owns a luxury car.",
            "HasHighIncome(john) ::: John has a high income.",
            "IsRich(john) ::: John is rich.",
            "HasGoodJob(john) ::: John has a good job."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "HasHighIncome(x) ::: x has a high income",
            "HasHighEducation(x) ::: x has high education",
            "OwnsLuxuryCar(x) ::: x owns a luxury car",
            "SpendsMoneyOnVacations(x) ::: x spends money on vacations",
            "SavesMoney(x) ::: x saves money",
            "IsRich(x) ::: x is rich",
            "HasGoodJob(x) ::: x has a good job"
        ]
    },
    {
        "premises-NL": [
            "All scientists who study genetics publish papers.",
            "All scientists who publish papers are good researchers.",
            "All good researchers win an award.",
            "All scientists who work at a university receive funding.",
            "Anyone who receives funding conducts experiments.",
            "John is a scientist.",
            "John studies genetics.",
            "John works at the university.",
            "John specializes in genomics."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) ∧ StudiesGenetics(x) → PublishesPapers(x)) ::: All scientists who study genetics publish papers.",
            "∀x (PublishesPapers(x) → GoodResearcher(x)) ::: All scientists who publish papers are good researchers.",
            "∀x (GoodResearcher(x) → WinsAward(x)) ::: All good researchers win an award.",
            "∀x (Scientist(x) ∧ WorksAtUniversity(x) → ReceivesFunding(x)) ::: All scientists who work at a university receive funding.",
            "∀x (ReceivesFunding(x) → ConductsExperiments(x)) ::: Anyone who receives funding conducts experiments.",
            "Scientist(john) ::: John is a scientist.",
            "StudiesGenetics(john) ::: John studies genetics.",
            "WorksAtUniversity(john) ::: John works at the university.",
            "SpecializesIn(john, genomics) ::: John specializes in genomics."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "StudiesGenetics(x) ::: x studies genetics",
            "GoodResearcher(x) ::: x is a good researcher",
            "WinsAward(x) ::: x wins an award",
            "PublishesPapers(x) ::: x publishes papers",
            "WorksAtUniversity(x) ::: x works at a university",
            "ReceivesFunding(x) ::: x receives funding",
            "ConductsExperiments(x) ::: x conducts experiments",
            "SpecializesIn(x, y) ::: x specializes in y"
        ]
    },
    {
        "premises-NL": [
            "All programmers use computers.",
            "Alice is a programmer.",
            "If someone uses a computer, they write code.",
            "If someone is a programmer, they write code.",
            "Alice knows Python.",
            "All programmers know Python.",
            "If someone writes code and knows Python, they are a programmer.",
            "Alice is employed by Google.",
            "If someone is employed by Google, they are a programmer.",
            "If someone uses a computer, they like coffee.",
            "Alice likes coffee.",
            "If someone is employed by Google and uses a computer, they are a programmer.",
            "If a programmer writes code, they are employed.",
            "Programmers write code and use computers.",
            "Alice writes code.",
            "If Alice knows Python, she writes code.",
            "If someone writes code, they are a programmer.",
            "If someone likes coffee and writes code, then they know Python.",
            "Alice is a programmer who uses computer"
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → UsesComputer(x)) ::: All programmers use computers.",
            "Programmer(Alice) ::: Alice is a programmer.",
            "∀x (UsesComputer(x) → WritesCode(x)) ::: If someone uses a computer, they write code.",
            "∀x (Programmer(x) → WritesCode(x)) ::: If someone is a programmer, they write code.",
            "KnowsPython(Alice) ::: Alice knows Python.",
            "∀x (Programmer(x) → KnowsPython(x)) ::: All programmers know Python.",
            "∀x (WritesCode(x) ∧ KnowsPython(x) → Programmer(x)) ::: If someone writes code and knows Python, they are a programmer.",
            "IsEmployedBy(Alice, Google) ::: Alice is employed by Google.",
            "∀x (IsEmployedBy(x, Google) → Programmer(x)) ::: If someone is employed by Google, they are a programmer.",
            "∀x (UsesComputer(x) → LikesCoffee(x)) ::: If someone uses a computer, they like coffee.",
            "LikesCoffee(Alice) ::: Alice likes coffee.",
            "∀x (IsEmployedBy(x, Google) ∧ UsesComputer(x) → Programmer(x)) ::: If someone is employed by Google and uses a computer, they are a programmer.",
            "∀x (Programmer(x) ∧ WritesCode(x) → IsEmployed(x)) ::: If a programmer writes code, they are employed.",
            "∀x (Programmer(x) → WritesCode(x) ∧ UsesComputer(x)) ::: Programmers write code and use computers.",
            "WritesCode(Alice) ::: Alice writes code.",
            "KnowsPython(Alice) → WritesCode(Alice) ::: If Alice knows Python, she writes code.",
            "∀x (WritesCode(x) → Programmer(x)) ::: If someone writes code, they are a programmer.",
            "∀x (LikesCoffee(x) ∧ WritesCode(x) → KnowsPython(x)) ::: If someone likes coffee and writes code, then they know Python.",
            "Programmer(Alice) ∧ UsesComputer(Alice) ::: Alice is a programmer who uses computer"
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer.",
            "UsesComputer(x) ::: x uses a computer.",
            "WritesCode(x) ::: x writes code.",
            "KnowsPython(x) ::: x knows Python.",
            "IsEmployedBy(x, y) ::: x is employed by y.",
            "LikesCoffee(x) ::: x likes coffee."
        ]
    },
    {
        "premises-NL": [
            "All students study.",
            "Some students are intelligent.",
            "Every student likes ice cream.",
            "Alice is a student.",
            "Bob likes ice cream.",
            "Alice is intelligent."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Studies(x)) ::: All students study.",
            "∃x (Student(x) ∧ Intelligent(x)) ::: Some students are intelligent.",
            "∀x (Student(x) → Likes(x, \"ice cream\")) ::: Every student likes ice cream.",
            "Student(\"Alice\") ::: Alice is a student.",
            "Likes(\"Bob\", \"ice cream\") ::: Bob likes ice cream.",
            "Intelligent(\"Alice\") ::: Alice is intelligent."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "Intelligent(x) ::: x is intelligent",
            "Likes(x, y) ::: x likes y"
        ]
    },
    {
        "premises-NL": [
            "All students study.",
            "Everyone who studies attends class.",
            "Anyone who attends class and studies, has a project or fails the project.",
            "If someone attends class and doesn't have a project, they fail the class.",
            "Some students have projects.",
            "If someone has a project and does not fail it, they pass the class.",
            "All students must pass the class to graduate.",
            "Alice is a student.",
            "Bob is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Studies(x)) ::: All students study.",
            "∀x (Studies(x) → AttendsClass(x)) ::: Everyone who studies attends class.",
            "∀x (AttendsClass(x) → (HasProject(x) ∨ FailsProject(x))) ::: Anyone who attends class and studies, has a project or fails the project.",
            "∀x (AttendsClass(x) ∧ ¬HasProject(x) → FailsProject(x)) ::: If someone attends class and doesn't have a project, they fail the class.",
            "∃x (Student(x) ∧ HasProject(x)) ::: Some students have projects.",
            "∀x (HasProject(x) ∧ ¬FailsProject(x) → PassClass(x)) ::: If someone has a project and does not fail it, they pass the class.",
            "∀x (PassClass(x) → Graduate(x)) ::: All students must pass the class to graduate.",
            "Student(\"Alice\") ::: Alice is a student.",
            "Student(\"Bob\") ::: Bob is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "HasProject(x) ::: x has a project",
            "FailsProject(x) ::: x fails the project",
            "PassClass(x) ::: x passes the class",
            "Studies(x) ::: x studies",
            "AttendsClass(x) ::: x attends the class",
            "HasGrade(x, y) ::: x has grade y",
            "GoodGrade(x) ::: x has a good grade"
        ]
    },
    {
        "premises-NL": [
            "All students attend lectures.",
            "Some students pass the exam.",
            "If someone is a student, they attend lectures.",
            "If someone is a student, then they can pass the exam.",
            "Every student is either attending lecture or passes the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsLecture(x)) ::: All students attend lectures.",
            "∃x (Student(x) ∧ PassesExam(x)) ::: Some students pass the exam.",
            "∀x (Student(x) → AttendsLecture(x)) ::: If someone is a student, they attend lectures.",
            "∀x (Student(x) → PassesExam(x)) ::: If someone is a student, then they can pass the exam.",
            "∀x (Student(x) → (AttendsLecture(x) ∨ PassesExam(x))) ::: Every student is either attending lecture or passes the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsLecture(x) ::: x attends lectures",
            "PassesExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "Some doctors are surgeons.",
            "No surgeons are happy.",
            "If someone is a doctor, then they are either a surgeon or not happy.",
            "If x is a surgeon, x is a doctor.",
            "There are some doctors"
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∃x (Doctor(x) ∧ Surgeon(x)) ::: Some doctors are surgeons.",
            "∀x (Surgeon(x) → ¬Happy(x)) ::: No surgeons are happy.",
            "∀x (Doctor(x) → (Surgeon(x) ∨ ¬Happy(x))) ::: If someone is a doctor, then they are either a surgeon or not happy.",
            "∀x (Surgeon(x) → Doctor(x)) ::: If x is a surgeon, x is a doctor.",
            "∃x Doctor(x) ::: There are some doctors."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "Happy(x) ::: x is happy"
        ]
    },
    {
        "premises-NL": [
            "Everyone likes either apples or oranges.",
            "Someone likes apples.",
            "If someone likes apples, they are a person.",
            "If someone likes oranges, they are a person.",
            "If someone is a person, they either like apples or oranges.",
            "Some people like apples, and some like oranges.",
            "There is someone."
        ],
        "premises-FOL": [
            "∀x (Person(x) → (Likes(x, apples) ∨ Likes(x, oranges))) ::: Everyone likes either apples or oranges.",
            "∃x (Likes(x, apples)) ::: Someone likes apples.",
            "∀x (Likes(x, apples) → Person(x)) ::: If someone likes apples, they are a person.",
            "∀x (Likes(x, oranges) → Person(x)) ::: If someone likes oranges, they are a person.",
            "∀x (Person(x) → (Likes(x, apples) ∨ Likes(x, oranges))) ::: If someone is a person, they either like apples or oranges.",
            "∃x (Likes(x, apples) ∧ Likes(x, oranges)) ::: Some people like apples, and some like oranges.",
            "∃x Person(x) ::: There is someone."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Apples(x) ::: x is an apple",
            "Oranges(x) ::: x is an orange",
            "Person(x) ::: x is a person"
        ]
    },
    {
        "premises-NL": [
            "Everyone owns a car or a house.",
            "Some people are happy.",
            "If someone owns a car, then they don't own a house.",
            "If someone owns a house, then they are happy.",
            "If someone is happy, then they don't own a car.",
            "If someone doesn't own a house, then they own a car or are happy.",
            "Everyone either owns a car, a house, or is happy.",
            "Some people own a house.",
            "Everyone is a person."
        ],
        "premises-FOL": [
            "∀x (Person(x) → (Owns(x, car) ∨ Owns(x, house))) ::: Everyone owns a car or a house.",
            "∃x (Person(x) ∧ Happy(x)) ::: Some people are happy.",
            "∀x (Owns(x, car) → ¬Owns(x, house)) ::: If someone owns a car, then they don't own a house.",
            "∀x (Owns(x, house) → Happy(x)) ::: If someone owns a house, then they are happy.",
            "∀x (Happy(x) → ¬Owns(x, car)) ::: If someone is happy, then they don't own a car.",
            "∀x (¬Owns(x, house) → (Owns(x, car) ∨ Happy(x))) ::: If someone doesn't own a house, then they own a car or are happy.",
            "∀x (Person(x) → (Owns(x, car) ∨ Owns(x, house) ∨ Happy(x))) ::: Everyone either owns a car, a house, or is happy.",
            "∃x (Person(x) ∧ Owns(x, house)) ::: Some people own a house.",
            "∀x Person(x) ::: Everyone is a person."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Owns(x, y) ::: x owns y",
            "Happy(x) ::: x is happy"
        ]
    },
    {
        "premises-NL": [
            "Every student takes a course.",
            "Every course is a required course.",
            "If a student takes a required course, then that student takes all required courses.",
            "Adam is a student.",
            "If a student takes all the required courses, they graduate."
        ],
        "premises-FOL": [
            "∀x ∃y TakesCourse(x, y) ::: Every student takes a course.",
            "∀y RequiredCourse(y) ::: Every course is a required course.",
            "∀x ∀y (TakesCourse(x, y) → AllRequiredCourses(x)) ::: If a student takes a required course, then that student takes all required courses.",
            "Student(adam) ::: Adam is a student.",
            "∀x (AllRequiredCourses(x) → Graduates(x)) ::: If a student takes all the required courses, they graduate."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "TakesCourse(x, y) ::: Student x takes course y.",
            "RequiredCourse(y) ::: Course y is a required course.",
            "AllRequiredCourses(x) ::: Student x takes all required courses.",
            "Graduates(x) ::: Student x graduates."
        ]
    },
    {
        "premises-NL": [
            "All members of the coding club attend coding meetings.",
            "Every meeting is either about coding or not about coding.",
            "If a person attends a meeting and the meeting is about coding, then the person knows how to code.",
            "All the meetings about coding are held by the coding club.",
            "The coding club is a club.",
            "Adam is a member of the coding club.",
            "If someone is a member of a club, they attend meetings."
        ],
        "premises-FOL": [
            "∀x ∀y ((CodingClubMember(x) ∧ MeetingAboutCoding(y)) → AttendsMeeting(x, y)) ::: All members of the coding club attend coding meetings.",
            "∀y (Meeting(y) → (MeetingAboutCoding(y) ∨ ¬MeetingAboutCoding(y))) ::: Every meeting is either about coding or not about coding.",
            "∀x ∀y ((AttendsMeeting(x, y) ∧ MeetingAboutCoding(y)) → KnowsHowToCode(x)) ::: If a person attends a meeting and the meeting is about coding, then the person knows how to code.",
            "∀y (MeetingAboutCoding(y) → CodingClubMeeting(y)) ::: All the meetings about coding are held by the coding club.",
            "∃y Club(y) ::: The coding club is a club.",
            "CodingClubMember(adam) ::: Adam is a member of the coding club.",
            "∀x ∀y (MemberOfClub(x, y) → AttendsMeeting(x, y)) ::: If someone is a member of a club, they attend meetings."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "CodingClubMember(x) ::: x is a member of the coding club.",
            "AttendsMeeting(x, y) ::: Person x attends meeting y.",
            "Meeting(y) ::: y is a meeting.",
            "KnowsHowToCode(x) ::: x knows how to code.",
            "MeetingAboutCoding(y) ::: Meeting y is about coding.",
            "MemberOfClub(x, y) ::: Person x is a member of club y"
        ]
    },
    {
        "premises-NL": [
            "Every software engineer writes code.",
            "Every language is either Python or Java.",
            "If a person writes code and the language is Python, then they know Python.",
            "If a person writes code and the language is Java, then they know Java.",
            "Adam is a software engineer.",
            "Python is a language.",
            "Java is a language.",
            "If Adam writes code, then he uses either Python or Java."
        ],
        "premises-FOL": [
            "∀x ∃l (SoftwareEngineer(x) → WritesCode(x, l)) ::: Every software engineer writes code.",
            "∀l (Language(l) → (Python(l) ∨ Java(l))) ::: Every language is either Python or Java.",
            "∀x ∀l ((WritesCode(x, l) ∧ Python(l)) → KnowsPython(x)) ::: If a person writes code and the language is Python, then they know Python.",
            "∀x ∀l ((WritesCode(x, l) ∧ Java(l)) → KnowsJava(x)) ::: If a person writes code and the language is Java, then they know Java.",
            "SoftwareEngineer(adam) ::: Adam is a software engineer.",
            "∃l Python(l) ::: Python is a language.",
            "∃l Java(l) ::: Java is a language.",
            "∀l (WritesCode(adam, l) → (Python(l) ∨ Java(l))) ::: If Adam writes code, then he uses either Python or Java."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "SoftwareEngineer(x) ::: x is a software engineer.",
            "KnowsPython(x) ::: x knows Python.",
            "KnowsJava(x) ::: x knows Java.",
            "WritesCode(x, l) ::: x writes code in language l.",
            "Language(l) ::: l is a programming language.",
            "Python(l) ::: l is Python.",
            "Java(l) ::: l is Java."
        ]
    },
    {
        "premises-NL": [
            "Every patient has either the flu, a cold, or is healthy.",
            "Every patient who has the flu has a fever.",
            "Every patient who has a cold has a fever.",
            "Fever is a symptom.",
            "If a person has a fever, they have a symptom.",
            "If a patient has a symptom, they are sick.",
            "If a patient is sick, they must see a doctor.",
            "John is a patient.",
            "John has a fever."
        ],
        "premises-FOL": [
            "∀x (Patient(x) → (SickWithFlu(x) ∨ SickWithCold(x) ∨ ¬(SickWithFlu(x) ∨ SickWithCold(x)))) ::: Every patient has either the flu, a cold, or is healthy.",
            "∀x (SickWithFlu(x) → HasFever(x)) ::: Every patient who has the flu has a fever.",
            "∀x (SickWithCold(x) → HasFever(x)) ::: Every patient who has a cold has a fever.",
            "∃s Fever(s) ::: Fever is a symptom.",
            "∀x ∀s (HasFever(x) → HasSymptom(x, s)) ::: If a person has a fever, they have a symptom.",
            "∀x (HasSymptom(x, s) → IfHasFever(x)) ::: If a patient has a symptom, they are sick.",
            "∀x (IfHasFever(x) → SeeDoctor(x)) ::: If a patient is sick, they must see a doctor.",
            "Patient(john) ::: John is a patient.",
            "HasFever(john) ::: John has a fever."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient.",
            "SickWithFlu(x) ::: Patient x is sick with the flu.",
            "SickWithCold(x) ::: Patient x is sick with a cold.",
            "HasFever(x) ::: Patient x has a fever.",
            "SeeDoctor(x) ::: Patient x needs to see a doctor.",
            "Symptom(s) ::: s is a symptom.",
            "Fever(s) ::: s is fever.",
            "HasSymptom(x, s) ::: Patient x has symptom s.",
            "IfHasFever(x) ::: Patient x is sick"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "If someone is a surgeon, they perform surgery.",
            "If a doctor performs surgery, they assist.",
            "John is a doctor.",
            "John is not a surgeon.",
            "No one assists unless they're a doctor."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: For all x, if x is a surgeon, then x is a doctor.",
            "∀x (Surgeon(x) → PerformsSurgery(x)) ::: For all x, if x is a surgeon, then x performs surgery.",
            "∀x (PerformsSurgery(x) → Assists(x)) ::: For all x, if x performs surgery, then x assists.",
            "Doctor(john) ::: John is a doctor.",
            "¬Surgeon(john) ::: John is not a surgeon.",
            "∀x (Assists(x) → Doctor(x)) ::: For all x, if x assists, then x is a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "Assists(x) ::: x assists",
            "PerformsSurgery(x) ::: x performs surgery",
            "IsPatientOf(x, y) ::: x is a patient of y",
            "HasSpecialty(x, y) ::: x has specialty y"
        ]
    },
    {
        "premises-NL": [
            "All scientists research something.",
            "Anyone who researches something publishes a paper.",
            "If someone publishes a paper, it is about something.",
            "John is a scientist.",
            "John researches physics.",
            "Physics is a subject.",
            "If something is about physics, it is a physics paper."
        ],
        "premises-FOL": [
            "∀x ∃y Researches(x, y) ::: For all x, there exists a y such that x researches y.",
            "∀x ∀y (Researches(x, y) → PublishesPaper(x)) ::: For all x and y, if x researches y, then x publishes a paper.",
            "∀x ∃y IsAbout(x, y) → PublishesPaper(x) ::: For all x, there exists a y if x publishes a paper it is about y",
            "Scientist(john) ::: John is a scientist.",
            "Researches(john, physics) ::: John researches physics.",
            "Subject(physics) ::: Physics is a subject.",
            "∀x (IsAbout(x, physics) → IsAPhysicsPaper(x)) ::: For all x, if x is about physics, then x is a physics paper."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Researches(x, y) ::: x researches y",
            "PublishesPaper(x) ::: x publishes a paper",
            "IsPaperOn(x, y) ::: x is a paper on y",
            "ExpertIn(x, y) ::: x is an expert in y",
            "IsAbout(x, y) ::: x is about y",
            "FundedBy(x, y) ::: x is funded by y"
        ]
    },
    {
        "premises-NL": [
            "All managers are employees.",
            "All employees attend some meetings.",
            "If an employee is senior, then they are a manager.",
            "Some employees are senior.",
            "If someone is a manager and does not attend all meetings, then they do not always fulfill their duties.",
            "If someone attends all meetings, they fulfill their duties.",
            "John is an employee.",
            "If someone is a manager they have role manager"
        ],
        "premises-FOL": [
            "∀x (Manager(x) → Employee(x)) ::: For all x, if x is a manager, then x is an employee.",
            "∀x ∃y AttendsMeeting(x, y) ::: For all x, there exists a y such that x attends meeting y.",
            "∀x (Senior(x) → Manager(x)) ::: For all x, if x is senior, then x is a manager.",
            "∃x Senior(x) ::: There exists an x such that x is senior.",
            "∀x ((Manager(x) ∧ ¬AttendsAllMeetings(x)) → ¬FulfillsDuties(x)) ::: For all x, if x is a manager and does not attend all meetings, then x does not fulfill their duties.",
            "∀x (AttendsAllMeetings(x) → FulfillsDuties(x)) ::: For all x, if x attends all meetings, then x fulfills their duties.",
            "Employee(john) ::: John is an employee.",
            "∀x (Manager(x) → HasRole(x, \"manager\")) ::: For all x, if x is a manager, then x has role manager."
        ],
        "predicates": [
            "Manager(x) ::: x is a manager",
            "Employee(x) ::: x is an employee",
            "AttendsMeeting(x, y) ::: x attends meeting y",
            "AttendsAllMeetings(x) ::: x attends all meetings",
            "HasRole(x, y) ::: x has role y",
            "IsMeeting(x) ::: x is a meeting",
            "ReportsTo(x, y) ::: x reports to y",
            "IsSenior(x) ::: x is senior"
        ]
    },
    {
        "premises-NL": [
            "David takes all required courses.",
            "If someone takes a course and studies diligently, they will pass the exam.",
            "All courses David takes are required courses.",
            "David studies diligently.",
            "David takes the 'Logic' course.",
            "The 'Logic' course is a required course.",
            "If someone takes the 'Logic' course and studies diligently, they will pass the exam.",
            "If David takes a course and studies diligently, he will pass the exam.",
            "David takes the 'Math' course.",
            "The 'Math' course is a required course."
        ],
        "premises-FOL": [
            "∀x (TakesCourse(david, x) ∧ CourseRequired(x) → PassExam(david)) ::: If someone takes a required course and studies diligently, they will pass the exam",
            "∀x (TakesCourse(david, x) ∧ StudiesDiligently(david) → PassExam(david)) ::: If someone takes a course and studies diligently, they will pass the exam",
            "∀x (TakesCourse(david, x) → CourseRequired(x)) ::: David takes all required courses",
            "StudiesDiligently(david) ::: David studies diligently",
            "TakesCourse(david, 'Logic') ::: David takes the 'Logic' course",
            "CourseRequired('Logic') ::: The 'Logic' course is a required course",
            "∀x (TakesCourse(david, x) ∧ StudiesDiligently(david) → PassExam(david)) ::: If someone takes the 'Logic' course and studies diligently, they will pass the exam",
            "∀x (TakesCourse(david, x) ∧ StudiesDiligently(david) → PassExam(david)) ::: If David takes a course and studies diligently, he will pass the exam",
            "TakesCourse(david, 'Math') ::: David takes the 'Math' course",
            "CourseRequired('Math') ::: The 'Math' course is a required course"
        ],
        "predicates": [
            "StudiesDiligently(x) ::: x studies diligently",
            "PassExam(x) ::: x passes the exam",
            "TakesCourse(x, y) ::: x takes the course y",
            "CourseRequired(y) ::: y is a required course"
        ]
    },
    {
        "premises-NL": [
            "All doctors practice medicine.",
            "Anyone who practices medicine can help patients.",
            "Doctors require a license.",
            "Sarah is a doctor.",
            "If someone is a doctor, then they are qualified.",
            "Doctors have a license.",
            "If someone is qualified, then they can help patients.",
            "If someone practices medicine, they can help patients.",
            "If someone requires a license and has a license, they can practice medicine.",
            "Sarah requires a license.",
            "Sarah has a license."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → PracticesMedicine(x)) ::: All doctors practice medicine",
            "∀x (PracticesMedicine(x) → CanHelpPatients(x)) ::: Anyone who practices medicine can help patients",
            "∀x (Doctor(x) → RequiresLicense(x)) ::: Doctors require a license",
            "Doctor(sarah) ::: Sarah is a doctor",
            "∀x (Doctor(x) → IsQualified(x)) ::: If someone is a doctor, then they are qualified",
            "∀x (Doctor(x) → HasLicense(x)) ::: Doctors have a license",
            "∀x (IsQualified(x) → CanHelpPatients(x)) ::: If someone is qualified, then they can help patients",
            "∀x (PracticesMedicine(x) → CanHelpPatients(x)) ::: If someone practices medicine, they can help patients",
            "∀x (RequiresLicense(x) ∧ HasLicense(x) → PracticesMedicine(x)) ::: If someone requires a license and has a license, they can practice medicine",
            "RequiresLicense(sarah) ::: Sarah requires a license",
            "HasLicense(sarah) ::: Sarah has a license"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "CanHelpPatients(x) ::: x can help patients",
            "PracticesMedicine(x) ::: x practices medicine",
            "RequiresLicense(x) ::: x requires a license",
            "HasLicense(x) ::: x has a license",
            "IsQualified(x) ::: x is qualified"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All surgeons treat patients.",
            "Every doctor either works at a hospital or is a specialist.",
            "Every specialist treats patients.",
            "If someone treats patients, they are at a hospital.",
            "If a surgeon has a license, they practice medicine.",
            "All doctors practice medicine.",
            "If someone practices medicine, then they are at a hospital.",
            "All surgeons have a license.",
            "John is a surgeon.",
            "John works at a hospital.",
            "John is at the hospital.",
            "All doctors are at a hospital."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors",
            "∀x (Surgeon(x) → TreatsPatients(x)) ::: All surgeons treat patients",
            "∀x (Doctor(x) → (WorksAt(x, y) ∨ Specialist(x))) ::: Every doctor either works at a hospital or is a specialist",
            "∀x (Specialist(x) → TreatsPatients(x)) ::: Every specialist treats patients",
            "∀x (TreatsPatients(x) → IsAt(x, y)) ::: If someone treats patients, they are at a hospital",
            "∀x (Surgeon(x) ∧ HasLicense(x) → PracticesMedicine(x)) ::: If a surgeon has a license, they practice medicine",
            "∀x (Doctor(x) → PracticesMedicine(x)) ::: All doctors practice medicine",
            "∀x (PracticesMedicine(x) → IsAt(x, y)) ::: If someone practices medicine, then they are at a hospital",
            "∀x (Surgeon(x) → HasLicense(x)) ::: All surgeons have a license",
            "Surgeon(john) ::: John is a surgeon",
            "WorksAt(john, y) ∧ Hospital(y) ::: John works at a hospital",
            "IsAt(john, y) ∧ Hospital(y) ::: John is at the hospital",
            "∀x (Doctor(x) → IsAt(x, y) ∧ Hospital(y)) ::: All doctors are at a hospital"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "WorksAt(x, y) ::: x works at y",
            "Hospital(y) ::: y is a hospital",
            "Specialist(x) ::: x is a specialist",
            "TreatsPatients(x) ::: x treats patients",
            "IsAt(x, y) ::: x is at y",
            "HasLicense(x) ::: x has a license",
            "PracticesMedicine(x) ::: x practices medicine",
            "InHospital(x, y) ::: x is in hospital y"
        ]
    },
    {
        "premises-NL": [
            "All programmers are developers.",
            "Every developer is a team member.",
            "Someone who is a team member likes coffee.",
            "Someone who likes coffee has a laptop.",
            "Everyone with a laptop attends meetings.",
            "Anyone who attends meetings writes code.",
            "All who write code are active.",
            "Someone active uses Slack.",
            "Those who use Slack have skills.",
            "Someone with skills understands concepts.",
            "All who understand concepts know Python.",
            "Anyone who knows Python is certified.",
            "All certified people are employed.",
            "No one employed works for the company.",
            "There is a programmer."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → Developer(x)) ::: All programmers are developers.",
            "∀x (Developer(x) → IsATeamMember(x)) ::: Every developer is a team member.",
            "∃x (IsATeamMember(x) ∧ LikesCoffee(x)) ::: Someone who is a team member likes coffee.",
            "∃x (LikesCoffee(x) ∧ HasLaptop(x)) ::: Someone who likes coffee has a laptop.",
            "∀x (HasLaptop(x) → AttendsMeetings(x)) ::: Everyone with a laptop attends meetings.",
            "∀x (AttendsMeetings(x) → WritesCode(x)) ::: Anyone who attends meetings writes code.",
            "∀x (WritesCode(x) → IsActive(x)) ::: All who write code are active.",
            "∃x (IsActive(x) ∧ UsesSlack(x)) ::: Someone active uses Slack.",
            "∀x (UsesSlack(x) → HasSkills(x)) ::: Those who use Slack have skills.",
            "∀x (HasSkills(x) → UnderstandsConcepts(x)) ::: Someone with skills understands concepts.",
            "∀x (UnderstandsConcepts(x) → KnowsPython(x)) ::: All who understand concepts know Python.",
            "∀x (KnowsPython(x) → IsCertified(x)) ::: Anyone who knows Python is certified.",
            "∀x (IsCertified(x) → Employed(x)) ::: All certified people are employed.",
            "∀x (Employed(x) → ¬WorksForCompany(x)) ::: No one employed works for the company.",
            "∃x Programmer(x) ::: There is a programmer."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "Employed(x) ::: x is employed",
            "WorksForCompany(x) ::: x works for the company",
            "Developer(x) ::: x is a developer",
            "IsATeamMember(x) ::: x is a team member",
            "LikesCoffee(x) ::: x likes coffee",
            "HasLaptop(x) ::: x has a laptop",
            "AttendsMeetings(x) ::: x attends meetings",
            "WritesCode(x) ::: x writes code",
            "IsActive(x) ::: x is active",
            "UsesSlack(x) ::: x uses slack",
            "HasSkills(x) ::: x has skills",
            "UnderstandsConcepts(x) ::: x understands concepts",
            "KnowsPython(x) ::: x knows Python",
            "IsCertified(x) ::: x is certified"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All specialists are doctors.",
            "Every doctor treats illnesses.",
            "Anyone who treats illnesses uses medical equipment.",
            "Anyone who uses medical equipment prescribes medication.",
            "Everyone who prescribes medication diagnoses.",
            "Anyone who diagnoses sees patients.",
            "All who see patients work in a clinic or a hospital.",
            "Someone who conducts research is a doctor.",
            "Every doctor knows medicine.",
            "Anyone who knows medicine is educated.",
            "Everyone educated has a degree.",
            "All with a degree has a license.",
            "Anyone with a license can be a doctor.",
            "Not everyone works in a clinic.",
            "There are doctors who work in hospitals."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Specialist(x) → Doctor(x)) ::: All specialists are doctors.",
            "∀x (Doctor(x) → TreatsIllness(x)) ::: Every doctor treats illnesses.",
            "∀x (TreatsIllness(x) → UsesMedicalEquipment(x)) ::: Anyone who treats illnesses uses medical equipment.",
            "∀x (UsesMedicalEquipment(x) → PrescribesMedication(x)) ::: Anyone who uses medical equipment prescribes medication.",
            "∀x (PrescribesMedication(x) → Diagnoses(x)) ::: Everyone who prescribes medication diagnoses.",
            "∀x (Diagnoses(x) → SeesPatients(x)) ::: Anyone who diagnoses sees patients.",
            "∀x (SeesPatients(x) → (WorksInClinic(x) ∨ WorksInHospital(x))) ::: All who see patients work in a clinic or a hospital.",
            "∃x (ConductsResearch(x) ∧ Doctor(x)) ::: Someone who conducts research is a doctor.",
            "∀x (Doctor(x) → KnowsMedicine(x)) ::: Every doctor knows medicine.",
            "∀x (KnowsMedicine(x) → IsEducated(x)) ::: Anyone who knows medicine is educated.",
            "∀x (IsEducated(x) → HasDegree(x)) ::: Everyone educated has a degree.",
            "∀x (HasDegree(x) → HasLicense(x)) ::: All with a degree has a license.",
            "∀x (HasLicense(x) → Doctor(x)) ::: Anyone with a license can be a doctor.",
            "¬∀x WorksInClinic(x) ::: Not everyone works in a clinic.",
            "∃x (Doctor(x) ∧ WorksInHospital(x)) ::: There are doctors who work in hospitals."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "WorksInHospital(x) ::: x works in a hospital",
            "HelpsPatients(x) ::: x helps patients",
            "Surgeon(x) ::: x is a surgeon",
            "Specialist(x) ::: x is a specialist",
            "TreatsIllness(x) ::: x treats illness",
            "UsesMedicalEquipment(x) ::: x uses medical equipment",
            "PrescribesMedication(x) ::: x prescribes medication",
            "Diagnoses(x) ::: x diagnoses",
            "SeesPatients(x) ::: x sees patients",
            "WorksInClinic(x) ::: x works in a clinic",
            "ConductsResearch(x) ::: x conducts research",
            "KnowsMedicine(x) ::: x knows medicine",
            "IsEducated(x) ::: x is educated",
            "HasDegree(x) ::: x has a degree",
            "HasLicense(x) ::: x has a license"
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled.",
            "Anyone who is enrolled takes exams.",
            "Anyone who studies computer science attends lectures.",
            "Anyone who attends lectures submits assignments.",
            "Anyone who submits assignments understands concepts.",
            "Anyone who understands concepts passes exams.",
            "Anyone who passes exams gets good grades.",
            "Anyone who gets good grades does well.",
            "Anyone who does well has skills.",
            "Anyone with skills applies for jobs.",
            "Anyone who applies for jobs gets an interview.",
            "Anyone who gets an interview gets an offer.",
            "Anyone who gets an offer gets a job.",
            "Everyone who studies computer science works hard.",
            "Anyone who works hard is dedicated.",
            "Anyone who is dedicated submits assignments.",
            "Someone studies computer science.",
            "There are students."
        ],
        "premises-FOL": [
            "∀x (Student(x) → IsEnrolled(x)) ::: All students are enrolled.",
            "∀x (IsEnrolled(x) → TakesExams(x)) ::: Anyone who is enrolled takes exams.",
            "∀x (StudiesComputerScience(x) → AttendsLectures(x)) ::: Anyone who studies computer science attends lectures.",
            "∀x (AttendsLectures(x) → SubmitsAssignments(x)) ::: Anyone who attends lectures submits assignments.",
            "∀x (SubmitsAssignments(x) → UnderstandsConcepts(x)) ::: Anyone who submits assignments understands concepts.",
            "∀x (UnderstandsConcepts(x) → PassesExams(x)) ::: Anyone who understands concepts passes exams.",
            "∀x (PassesExams(x) → GetsGoodGrades(x)) ::: Anyone who passes exams gets good grades.",
            "∀x (GetsGoodGrades(x) → DoesWell(x)) ::: Anyone who gets good grades does well.",
            "∀x (DoesWell(x) → HasSkills(x)) ::: Anyone who does well has skills.",
            "∀x (HasSkills(x) → AppliesForJobs(x)) ::: Anyone with skills applies for jobs.",
            "∀x (AppliesForJobs(x) → GetsInterview(x)) ::: Anyone who applies for jobs gets an interview.",
            "∀x (GetsInterview(x) → GetsOffer(x)) ::: Anyone who gets an interview gets an offer.",
            "∀x (GetsOffer(x) → GetsJob(x)) ::: Anyone who gets an offer gets a job.",
            "∀x (StudiesComputerScience(x) → WorksHard(x)) ::: Everyone who studies computer science works hard.",
            "∀x (WorksHard(x) → IsDedicated(x)) ::: Anyone who works hard is dedicated.",
            "∀x (IsDedicated(x) → SubmitsAssignments(x)) ::: Anyone who is dedicated submits assignments.",
            "∃x StudiesComputerScience(x) ::: Someone studies computer science.",
            "∃x Student(x) ::: There are students."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesComputerScience(x) ::: x studies computer science",
            "DoesWell(x) ::: x does well",
            "GetsJob(x) ::: x gets a job",
            "IsEnrolled(x) ::: x is enrolled",
            "TakesExams(x) ::: x takes exams",
            "AttendsLectures(x) ::: x attends lectures",
            "SubmitsAssignments(x) ::: x submits assignments",
            "UnderstandsConcepts(x) ::: x understands concepts",
            "PassesExams(x) ::: x passes exams",
            "GetsGoodGrades(x) ::: x gets good grades",
            "HasSkills(x) ::: x has skills",
            "AppliesForJobs(x) ::: x applies for jobs",
            "GetsInterview(x) ::: x gets an interview",
            "GetsOffer(x) ::: x gets an offer",
            "WorksHard(x) ::: x works hard",
            "IsDedicated(x) ::: x is dedicated"
        ]
    },
    {
        "premises-NL": [
            "All scientists conduct experiments.",
            "Anyone who conducts experiments analyzes data.",
            "Anyone who analyzes data generates a report.",
            "Anyone who studies biology or chemistry works in a lab.",
            "Anyone who works in a lab uses lab equipment.",
            "Scientists publish papers.",
            "Anyone who publishes papers needs funding.",
            "Scientists collaborate with others.",
            "Anyone who collaborates presents findings.",
            "Anyone who presents findings attends conferences.",
            "Anyone who attends conferences is a scientist.",
            "All who specialize in biology or chemistry understands principles.",
            "Anyone who understands principles has knowledge.",
            "Anyone who has knowledge is educated.",
            "Anyone who is educated graduates.",
            "Anyone who graduates is a researcher.",
            "All researchers are scientists.",
            "Someone studies biology or chemistry.",
            "There is a scientist."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → ConductsExperiments(x)) ::: All scientists conduct experiments.",
            "∀x (ConductsExperiments(x) → AnalyzesData(x)) ::: Anyone who conducts experiments analyzes data.",
            "∀x (AnalyzesData(x) → GeneratesReport(x)) ::: Anyone who analyzes data generates a report.",
            "∀x ((StudiesBiology(x) ∨ StudiesChemistry(x)) → WorksInLab(x)) ::: Anyone who studies biology or chemistry works in a lab.",
            "∀x (WorksInLab(x) → UsesLabEquipment(x)) ::: Anyone who works in a lab uses lab equipment.",
            "∀x (Scientist(x) → PublishesPapers(x)) ::: Scientists publish papers.",
            "∀x (PublishesPapers(x) → NeedsFunding(x)) ::: Anyone who publishes papers needs funding.",
            "∀x ∃y Collaborates(x, y) ::: Scientists collaborate with others.",
            "∀x (Collaborates(x, y) → PresentsFindings(x)) ::: Anyone who collaborates presents findings.",
            "∀x (PresentsFindings(x) → AttendsConferences(x)) ::: Anyone who presents findings attends conferences.",
            "∀x (AttendsConferences(x) → Scientist(x)) ::: Anyone who attends conferences is a scientist.",
            "∀x ((SpecializesIn(x, \"Biology\") ∨ SpecializesIn(x, \"Chemistry\")) → UnderstandsPrinciples(x)) ::: All who specialize in biology or chemistry understands principles.",
            "∀x (UnderstandsPrinciples(x) → HasKnowledge(x)) ::: Anyone who understands principles has knowledge.",
            "∀x (HasKnowledge(x) → IsEducated(x)) ::: Anyone who has knowledge is educated.",
            "∀x (IsEducated(x) → Graduates(x)) ::: Anyone who is educated graduates.",
            "∀x (Graduates(x) → IsResearcher(x)) ::: Anyone who graduates is a researcher.",
            "∀x (IsResearcher(x) → Scientist(x)) ::: All researchers are scientists.",
            "∃x (StudiesBiology(x) ∨ StudiesChemistry(x)) ::: Someone studies biology or chemistry.",
            "∃x Scientist(x) ::: There is a scientist."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "StudiesBiology(x) ::: x studies biology",
            "StudiesChemistry(x) ::: x studies chemistry",
            "UsesLabEquipment(x) ::: x uses lab equipment",
            "GeneratesReport(x) ::: x generates a report",
            "ConductsExperiments(x) ::: x conducts experiments",
            "AnalyzesData(x) ::: x analyzes data",
            "PublishesPapers(x) ::: x publishes papers",
            "WorksInLab(x) ::: x works in a lab",
            "NeedsFunding(x) ::: x needs funding",
            "Collaborates(x, y) ::: x collaborates with y",
            "PresentsFindings(x) ::: x presents findings",
            "AttendsConferences(x) ::: x attends conferences",
            "SpecializesIn(x, y) ::: x specializes in y",
            "UnderstandsPrinciples(x) ::: x understands principles",
            "HasKnowledge(x) ::: x has knowledge",
            "IsEducated(x) ::: x is educated",
            "Graduates(x) ::: x graduates",
            "IsResearcher(x) ::: x is a researcher"
        ]
    },
    {
        "premises-NL": [
            "All advertised products are popular.",
            "Product X is sold.",
            "If a product is sold and popular, it generates revenue.",
            "Product X is advertised.",
            "If a product is advertised, it is marketed.",
            "If a product is marketed, it is successful.",
            "If a product is successful, it is sold.",
            "Product X is successful.",
            "If a product is sold and advertised, it is successful.",
            "Product X is sold and popular.",
            "Product X is a product.",
            "Product X is advertised and marketed.",
            "Product X is a product and it is sold and advertised.",
            "Product X generates revenue."
        ],
        "premises-FOL": [
            "∀x (Advertised(x) → Popular(x)) ::: All advertised products are popular.",
            "Sold(x) ::: Product X is sold.",
            "∀x ((Sold(x) ∧ Popular(x)) → GeneratesRevenue(x)) ::: If a product is sold and popular, it generates revenue.",
            "Advertised(x) ::: Product X is advertised.",
            "∀x (Advertised(x) → Marketed(x)) ::: If a product is advertised, it is marketed.",
            "∀x (Marketed(x) → Successful(x)) ::: If a product is marketed, it is successful.",
            "∀x (Successful(x) → Sold(x)) ::: If a product is successful, it is sold.",
            "Successful(x) ::: Product X is successful.",
            "∀x ((Sold(x) ∧ Advertised(x)) → Successful(x)) ::: If a product is sold and advertised, it is successful.",
            "(Sold(x) ∧ Popular(x)) ::: Product X is sold and popular.",
            "Product(x) ::: Product X is a product.",
            "(Advertised(x) ∧ Marketed(x)) ::: Product X is advertised and marketed.",
            "(Product(x) ∧ Sold(x) ∧ Advertised(x)) ::: Product X is a product and it is sold and advertised.",
            "GeneratesRevenue(x) ::: Product X generates revenue."
        ],
        "predicates": [
            "Product(x) ::: x is a product",
            "Sold(x) ::: x is sold",
            "Advertised(x) ::: x is advertised",
            "Popular(x) ::: x is popular",
            "GeneratesRevenue(x) ::: x generates revenue"
        ]
    },
    {
        "premises-NL": [
            "All students attend class.",
            "If someone studies hard and attends class, they pass the exam.",
            "If someone passes the exam, they receive good grades.",
            "If someone studies hard and passes the exam, they are happy.",
            "Alice is a student.",
            "Alice studies hard.",
            "If someone is a student, they have books.",
            "Alice attends class.",
            "If someone has books and studies hard, they attend class.",
            "Alice studies hard and attends class.",
            "Alice is a student and studies hard.",
            "Alice passes the exam.",
            "If someone receives good grades, they are happy.",
            "Alice has books.",
            "Alice receives good grades."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClass(x)) ::: All students attend class.",
            "∀x ((StudiesHard(x) ∧ AttendsClass(x)) → PassExam(x)) ::: If someone studies hard and attends class, they pass the exam.",
            "∀x (PassExam(x) → ReceivesGoodGrades(x)) ::: If someone passes the exam, they receive good grades.",
            "∀x ((StudiesHard(x) ∧ PassExam(x)) → Happy(x)) ::: If someone studies hard and passes the exam, they are happy.",
            "Student(alice) ::: Alice is a student.",
            "StudiesHard(alice) ::: Alice studies hard.",
            "∀x (Student(x) → HasBooks(x)) ::: If someone is a student, they have books.",
            "AttendsClass(alice) ::: Alice attends class.",
            "∀x ((HasBooks(x) ∧ StudiesHard(x)) → AttendsClass(x)) ::: If someone has books and studies hard, they attend class.",
            "(StudiesHard(alice) ∧ AttendsClass(alice)) ::: Alice studies hard and attends class.",
            "(Student(alice) ∧ StudiesHard(alice)) ::: Alice is a student and studies hard.",
            "PassExam(alice) ::: Alice passes the exam.",
            "∀x (ReceivesGoodGrades(x) → Happy(x)) ::: If someone receives good grades, they are happy.",
            "HasBooks(alice) ::: Alice has books.",
            "ReceivesGoodGrades(alice) ::: Alice receives good grades."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "Happy(x) ::: x is happy",
            "AttendsClass(x) ::: x attends class",
            "HasBooks(x) ::: x has books",
            "ReceivesGoodGrades(x) ::: x receives good grades"
        ]
    },
    {
        "premises-NL": [
            "All students study hard.",
            "John is a student.",
            "If a student studies hard, then they pass the exam.",
            "All who study hard are students.",
            "If someone is a student and they pass the exam, then they are successful.",
            "If John is a student, then he studies hard.",
            "If someone is a student and studies hard, they pass the exam.",
            "John studies hard.",
            "No one studies hard and fails the exam.",
            "John passes the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → StudyHard(x)) ::: All students study hard.",
            "Student(john) ::: John is a student.",
            "∀x (StudyHard(x) → PassExam(x)) ::: If a student studies hard, then they pass the exam.",
            "∀x (StudyHard(x) → Student(x)) ::: All who study hard are students.",
            "∀x ((Student(x) ∧ PassExam(x)) → Successful(x)) ::: If someone is a student and they pass the exam, then they are successful.",
            "Student(john) → StudyHard(john) ::: If John is a student, then he studies hard.",
            "∀x ((Student(x) ∧ StudyHard(x)) → PassExam(x)) ::: If someone is a student and studies hard, they pass the exam.",
            "StudyHard(john) ::: John studies hard.",
            "¬∃x (StudyHard(x) ∧ ¬PassExam(x)) ::: No one studies hard and fails the exam.",
            "PassExam(john) ::: John passes the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudyHard(x) ::: x studies hard.",
            "PassExam(x) ::: x passes the exam."
        ]
    },
    {
        "premises-NL": [
            "All doctors work at a hospital.",
            "All researchers work at a university.",
            "John is a doctor.",
            "John is a researcher.",
            "All hospitals are institutions.",
            "All universities are institutions.",
            "If someone works at an institution, they are a scientist.",
            "John works at a hospital and a university.",
            "The hospital where John works is the same as the hospital where all doctors work.",
            "The university where John works is the same as the university where all researchers work.",
            "If someone is both a doctor and a researcher, they are a scientist.",
            "Every scientist studies.",
            "Studying implies being informed."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → WorksAt(x, y)) ::: All doctors work at a hospital.",
            "∀x (Researcher(x) → WorksAt(x, z)) ::: All researchers work at a university.",
            "Doctor(john) ::: John is a doctor.",
            "Researcher(john) ::: John is a researcher.",
            "∀x (Hospital(x) → Institution(x)) ::: All hospitals are institutions.",
            "∀x (University(x) → Institution(x)) ::: All universities are institutions.",
            "∀x (WorksAt(x, y) → Scientist(x)) ::: If someone works at an institution, they are a scientist.",
            "WorksAt(john, y) ∧ WorksAt(john, z) ::: John works at a hospital and a university.",
            "∀x (Doctor(x) → WorksAt(x, y)) ↔ WorksAt(john, y) ::: The hospital where John works is the same as the hospital where all doctors work.",
            "∀x (Researcher(x) → WorksAt(x, z)) ↔ WorksAt(john, z) ::: The university where John works is the same as the university where all researchers work.",
            "(Doctor(x) ∧ Researcher(x)) → Scientist(x) ::: If someone is both a doctor and a researcher, they are a scientist.",
            "∀x (Scientist(x) → Studies(x)) ::: Every scientist studies.",
            "∀x (Studies(x) → Informed(x)) ::: Studying implies being informed."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Researcher(x) ::: x is a researcher",
            "Scientist(x) ::: x is a scientist",
            "WorksAt(x, y) ::: x works at y",
            "Hospital(x) ::: x is a hospital",
            "University(x) ::: x is a university"
        ]
    },
    {
        "premises-NL": [
            "Alex likes Jane and Alex likes Bob.",
            "Alex is not friends with anyone who hates Jane.",
            "Anyone who hates Jane hates Bob.",
            "If someone is a friend of Alex, then Alex is a friend of that person.",
            "If Alex loves someone, then Alex is not friends with that person.",
            "Alex studies at the university.",
            "Everyone at the university either likes Jane or hates Bob.",
            "If Alex hates Bob, then Alex is not friends with David.",
            "Alex is not friends with someone who likes Jane.",
            "Jane hates David.",
            "Anyone who hates Jane hates David.",
            "If someone loves Jane, then that person is not happy.",
            "If Alex is rich then Alex is not famous.",
            "Bob knows David.",
            "Alex knows someone who is happy and can sing."
        ],
        "premises-FOL": [
            "Likes(alex, jane) ∧ Likes(alex, bob) ::: Alex likes Jane and Alex likes Bob.",
            "¬FriendOf(alex, x) → ¬Hates(x, jane) ::: Alex is not friends with anyone who hates Jane.",
            "∀x (Hates(x, jane) → Hates(x, bob)) ::: Anyone who hates Jane hates Bob.",
            "∀x (FriendOf(x, alex) → FriendOf(alex, x)) ::: If someone is a friend of Alex, then Alex is a friend of that person.",
            "∀x (Loves(alex, x) → ¬FriendOf(alex, x)) ::: If Alex loves someone, then Alex is not friends with that person.",
            "Studies(alex, university) ::: Alex studies at the university.",
            "∀x (IsStudent(x, university) → Likes(x, jane) ∨ Hates(x, bob)) ::: Everyone at the university either likes Jane or hates Bob.",
            "Hates(alex, bob) → ¬FriendOf(david, alex) ::: If Alex hates Bob, then Alex is not friends with David.",
            "¬FriendOf(alex, x) → ¬Likes(x, jane) ::: Alex is not friends with someone who likes Jane.",
            "Hates(jane, david) ::: Jane hates David.",
            "∀x (Hates(jane, x) → Hates(x, david)) ::: Anyone who hates Jane hates David.",
            "∀x (Loves(x, jane) → ¬IsHappy(x)) ::: If someone loves Jane, then that person is not happy.",
            "IsRich(alex) → ¬IsFamous(alex) ::: If Alex is rich then Alex is not famous.",
            "Knows(bob, david) ::: Bob knows David.",
            "∃x (Knows(alex, x) ∧ IsHappy(x) ∧ CanSing(x)) ::: Alex knows someone who is happy and can sing."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "FriendOf(x, y) ::: x is a friend of y",
            "Loves(x, y) ::: x loves y",
            "Hates(x, y) ::: x hates y",
            "IsStudent(x) ::: x is a student",
            "Studies(x, y) ::: x studies y",
            "IsSmart(x) ::: x is smart",
            "IsTeacher(x) ::: x is a teacher",
            "Teaches(x, y) ::: x teaches y",
            "IsClassmateOf(x, y) ::: x is a classmate of y",
            "Attends(x, y) ::: x attends y",
            "IsHappy(x) ::: x is happy",
            "CanSing(x) ::: x can sing",
            "Knows(x, y) ::: x knows y",
            "IsFamous(x) ::: x is famous",
            "IsRich(x) ::: x is rich"
        ]
    },
    {
        "premises-NL": [
            "Everyone who eats fruits is healthy.",
            "Anyone who eats vegetables is healthy.",
            "Anyone who exercises regularly is healthy.",
            "Some people eat fruits and vegetables.",
            "Some people exercise regularly.",
            "If someone is healthy, they enjoy running.",
            "John eats fruits.",
            "John eats vegetables.",
            "Jane exercises regularly.",
            "Jane is healthy.",
            "Some people are healthy."
        ],
        "premises-FOL": [
            "∀x (EatsFruits(x) → Healthy(x)) ::: Everyone who eats fruits is healthy.",
            "∀x (EatsVegetables(x) → Healthy(x)) ::: Anyone who eats vegetables is healthy.",
            "∀x (ExerciseRegularly(x) → Healthy(x)) ::: Anyone who exercises regularly is healthy.",
            "∃x (EatsFruits(x) ∧ EatsVegetables(x)) ::: Some people eat fruits and vegetables.",
            "∃x ExerciseRegularly(x) ::: Some people exercise regularly.",
            "∀x (Healthy(x) → EnjoysRunning(x)) ::: If someone is healthy, they enjoy running.",
            "EatsFruits(John) ::: John eats fruits.",
            "EatsVegetables(John) ::: John eats vegetables.",
            "ExerciseRegularly(Jane) ::: Jane exercises regularly.",
            "Healthy(Jane) ::: Jane is healthy.",
            "∃x Healthy(x) ::: Some people are healthy."
        ],
        "predicates": [
            "Healthy(x) ::: x is a healthy person",
            "EatsFruits(x) ::: x eats fruits",
            "EnjoysRunning(x) ::: x enjoys running",
            "EatsVegetables(x) ::: x eats vegetables",
            "ExerciseRegularly(x) ::: x exercises regularly"
        ]
    },
    {
        "premises-NL": [
            "All scientists are researchers.",
            "Some researchers work at a university.",
            "Anyone who works at a university can publish a paper.",
            "Some scientists conduct research.",
            "Everyone who conducts research must publish a paper.",
            "John is a scientist.",
            "Jane is a researcher.",
            "Jane works at a university.",
            "Some scientists study biology.",
            "Some people who study biology are scientists.",
            "If someone is a scientist, they must publish a paper.",
            "John conducts research.",
            "Jane has published papers."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Researcher(x)) ::: All scientists are researchers.",
            "∃x (Researcher(x) ∧ WorksAtUniversity(x)) ::: Some researchers work at a university.",
            "∀x (WorksAtUniversity(x) → PublishedPaper(x)) ::: Anyone who works at a university can publish a paper.",
            "∃x (Scientist(x) ∧ ConductsResearch(x)) ::: Some scientists conduct research.",
            "∀x (ConductsResearch(x) → PublishedPaper(x)) ::: Everyone who conducts research must publish a paper.",
            "Scientist(John) ::: John is a scientist.",
            "Researcher(Jane) ::: Jane is a researcher.",
            "WorksAtUniversity(Jane) ::: Jane works at a university.",
            "∃x (Scientist(x) ∧ StudiesBiology(x)) ::: Some scientists study biology.",
            "∃x (StudiesBiology(x) ∧ Scientist(x)) ::: Some people who study biology are scientists.",
            "∀x (Scientist(x) → PublishedPaper(x)) ::: If someone is a scientist, they must publish a paper.",
            "ConductsResearch(John) ::: John conducts research.",
            "PublishedPaper(Jane) ::: Jane has published papers."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Researcher(x) ::: x is a researcher",
            "WorksAtUniversity(x) ::: x works at a university",
            "PublishedPaper(x) ::: x has published a paper",
            "ConductsResearch(x) ::: x conducts research",
            "StudiesBiology(x) ::: x studies biology"
        ]
    },
    {
        "premises-NL": [
            "All students are either lazy or study hard.",
            "Anyone who studies hard passes the exam.",
            "Anyone who passes the exam receives a scholarship.",
            "John studies hard.",
            "John is a student.",
            "Anyone who is lazy doesn't receive a scholarship.",
            "Some students fail the exam.",
            "Anyone who enjoys parties is lazy.",
            "Jane is a student.",
            "Jane enjoys parties.",
            "Jane fails the exam.",
            "Students who do not pass the exam are not lazy.",
            "If someone receives a scholarship, then they are not lazy.",
            "John does not receive a scholarship."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Lazy(x) ∨ StudiesHard(x))) ::: All students are either lazy or study hard.",
            "∀x (StudiesHard(x) → PassesExam(x)) ::: Anyone who studies hard passes the exam.",
            "∀x (PassesExam(x) → ReceivesScholarship(x)) ::: Anyone who passes the exam receives a scholarship.",
            "StudiesHard(John) ::: John studies hard.",
            "Student(John) ::: John is a student.",
            "∀x (Lazy(x) → ¬ReceivesScholarship(x)) ::: Anyone who is lazy doesn't receive a scholarship.",
            "∃x (Student(x) ∧ FailsExam(x)) ::: Some students fail the exam.",
            "∀x (EnjoysParties(x) → Lazy(x)) ::: Anyone who enjoys parties is lazy.",
            "Student(Jane) ::: Jane is a student.",
            "EnjoysParties(Jane) ::: Jane enjoys parties.",
            "FailsExam(Jane) ::: Jane fails the exam.",
            "∀x (¬PassesExam(x) → ¬Lazy(x)) ::: Students who do not pass the exam are not lazy.",
            "∀x (ReceivesScholarship(x) → ¬Lazy(x)) ::: If someone receives a scholarship, then they are not lazy.",
            "¬ReceivesScholarship(John) ::: John does not receive a scholarship."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "Lazy(x) ::: x is lazy",
            "PassesExam(x) ::: x passes the exam",
            "ReceivesScholarship(x) ::: x receives a scholarship",
            "EnjoysParties(x) ::: x enjoys parties",
            "FailsExam(x) ::: x fails the exam"
        ]
    },
    {
        "premises-NL": [
            "All doctors are licensed.",
            "All licensed individuals have a medical degree.",
            "Anyone with a medical degree attended medical school.",
            "Every doctor completed residency.",
            "Anyone who completed residency is a specialist.",
            "Some specialists are surgeons.",
            "All surgeons are doctors.",
            "John is a doctor.",
            "John is licensed.",
            "John has a medical degree.",
            "John attended medical school.",
            "John completed residency.",
            "John is a specialist."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → IsLicensed(x)) ::: For all x, if x is a doctor, then x is licensed.",
            "∀x (IsLicensed(x) → HasMedicalDegree(x)) ::: For all x, if x is licensed, then x has a medical degree.",
            "∀x (HasMedicalDegree(x) → AttendedMedicalSchool(x)) ::: For all x, if x has a medical degree, then x attended medical school.",
            "∀x (Doctor(x) → CompletedResidency(x)) ::: For all x, if x is a doctor, then x completed residency.",
            "∀x (CompletedResidency(x) → IsSpecialist(x)) ::: For all x, if x completed residency, then x is a specialist.",
            "∃x (IsSpecialist(x) ∧ IsSurgeon(x)) ::: There exists x such that x is a specialist and x is a surgeon.",
            "∀x (IsSurgeon(x) → Doctor(x)) ::: For all x, if x is a surgeon, then x is a doctor.",
            "Doctor(john) ::: John is a doctor.",
            "IsLicensed(john) ::: John is licensed.",
            "HasMedicalDegree(john) ::: John has a medical degree.",
            "AttendedMedicalSchool(john) ::: John attended medical school.",
            "CompletedResidency(john) ::: John completed residency.",
            "IsSpecialist(john) ::: John is a specialist."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "HasMedicalDegree(x) ::: x has a medical degree.",
            "IsLicensed(x) ::: x is licensed.",
            "CompletedResidency(x) ::: x completed residency.",
            "AttendedMedicalSchool(x) ::: x attended medical school.",
            "IsSpecialist(x) ::: x is a specialist.",
            "IsSurgeon(x) ::: x is a surgeon."
        ]
    },
    {
        "premises-NL": [
            "All members pay dues.",
            "Anyone who pays dues is a member.",
            "Some members attend meetings.",
            "Anyone who attends a meeting volunteers.",
            "Volunteers are active members.",
            "Some people have access to resources.",
            "Members have access to all resources.",
            "Everyone who has access to any resource is a member.",
            "A specific resource exists"
        ],
        "premises-FOL": [
            "∀x (Member(x) → PaysDues(x)) ::: All members pay dues.",
            "∀x (PaysDues(x) → Member(x)) ::: Anyone who pays dues is a member.",
            "∃x (Member(x) ∧ AttendsMeeting(x)) ::: Some members attend meetings.",
            "∀x (AttendsMeeting(x) → Volunteers(x)) ::: Anyone who attends a meeting volunteers.",
            "∀x (Volunteers(x) → Active(x)) ::: Volunteers are active members.",
            "∃x ∃y HasAccess(x, y) ::: Some people have access to resources.",
            "∀x ∀y (Member(x) ∧ Resource(y) → HasAccess(x, y)) ::: Members have access to all resources.",
            "∀x ∀y (HasAccess(x, y) → Member(x)) ::: Everyone who has access to any resource is a member.",
            "∃x Resource(x) ::: A specific resource exists"
        ],
        "predicates": [
            "Member(x) ::: x is a member",
            "AttendsMeeting(x) ::: x attends a meeting",
            "Active(x) ::: x is active",
            "PaysDues(x) ::: x pays dues",
            "Volunteers(x) ::: x volunteers",
            "HasAccess(x, y) ::: Person x has access to resource y",
            "Resource(x) ::: x is a resource"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard will pass the exam.",
            "Sarah is a student.",
            "Sarah likes coffee.",
            "If Sarah is a student and likes coffee, then she studies hard.",
            "All students like coffee.",
            "Anyone who passes the exam gets a good grade.",
            "Students who get a good grade are happy.",
            "John is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: All students who study hard will pass the exam.",
            "Student(sarah) ::: Sarah is a student.",
            "LikesCoffee(sarah) ::: Sarah likes coffee.",
            "Student(sarah) ∧ LikesCoffee(sarah) → StudiesHard(sarah) ::: If Sarah is a student and likes coffee, then she studies hard.",
            "∀x (Student(x) → LikesCoffee(x)) ::: All students like coffee.",
            "∀x (PassExam(x) → GoodGrade(x)) ::: Anyone who passes the exam gets a good grade.",
            "∀x (GoodGrade(x) → Happy(x)) ::: Students who get a good grade are happy.",
            "Student(john) ::: John is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "LikesCoffee(x) ::: x likes coffee"
        ]
    },
    {
        "premises-NL": [
            "All doctors are busy.",
            "All doctors help people.",
            "Some doctors are smokers.",
            "Anyone who helps people is not a smoker.",
            "If someone is a doctor, they have insurance.",
            "Everyone who has insurance is a patient.",
            "If someone is a patient, they help people.",
            "If someone is a smoker, they don't help people.",
            "Sarah is a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Busy(x)) ::: All doctors are busy.",
            "∀x (Doctor(x) → HelpsPeople(x)) ::: All doctors help people.",
            "∃x (Doctor(x) ∧ Smoker(x)) ::: Some doctors are smokers.",
            "∀x (HelpsPeople(x) → ¬Smoker(x)) ::: Anyone who helps people is not a smoker.",
            "∀x (Doctor(x) → HasInsurance(x)) ::: If someone is a doctor, they have insurance.",
            "∀x (HasInsurance(x) → Patient(x)) ::: Everyone who has insurance is a patient.",
            "∀x (Patient(x) → HelpsPeople(x)) ::: If someone is a patient, they help people.",
            "∀x (Smoker(x) → ¬HelpsPeople(x)) ::: If someone is a smoker, they don't help people.",
            "Doctor(sarah) ::: Sarah is a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Smoker(x) ::: x is a smoker",
            "HelpsPeople(x) ::: x helps people",
            "HasInsurance(x) ::: x has insurance",
            "Patient(x) ::: x is a patient"
        ]
    },
    {
        "premises-NL": [
            "All programmers write code.",
            "Anyone who writes code uses some language.",
            "If someone uses Python, they are a programmer.",
            "If someone likes coding, they are a programmer.",
            "Anyone who writes code in Python is skilled.",
            "Some programmers use Python.",
            "If someone knows Python, they use Python.",
            "All skilled people get good jobs.",
            "If someone likes coding, they know Python.",
            "John is a programmer."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → WritesCode(x, y)) ::: All programmers write code.",
            "∀x ∃y (WritesCode(x, y) → UsesLanguage(x, y)) ::: Anyone who writes code uses some language.",
            "∀x (UsesPython(x) → Programmer(x)) ::: If someone uses Python, they are a programmer.",
            "∀x (LikesCoding(x) → Programmer(x)) ::: If someone likes coding, they are a programmer.",
            "∀x (WritesCode(x, python) → Skilled(x)) ::: Anyone who writes code in Python is skilled.",
            "∃x (Programmer(x) ∧ UsesPython(x)) ::: Some programmers use Python.",
            "∀x (KnowsPython(x) → UsesPython(x)) ::: If someone knows Python, they use Python.",
            "∀x (Skilled(x) → GoodJob(x)) ::: All skilled people get good jobs.",
            "∀x (LikesCoding(x) → KnowsPython(x)) ::: If someone likes coding, they know Python.",
            "Programmer(john) ::: John is a programmer."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "UsesPython(x) ::: x uses Python",
            "Skilled(x) ::: x is skilled",
            "WritesCode(x, y) ::: x writes code in language y",
            "KnowsLanguage(x, y) ::: x knows language y",
            "LikesCoding(x) ::: x likes coding"
        ]
    },
    {
        "premises-NL": [
            "All biologists understand biology.",
            "If someone studies genetics, they are a biologist.",
            "Anyone who does experiments uses a microscope.",
            "If someone uses a microscope, they do research.",
            "If someone studies genetics and does experiments, they write papers.",
            "All biologists do experiments.",
            "Anyone who studies genetics and writes papers does research.",
            "If someone understands biology, they study genetics.",
            "If someone does research, then they write papers.",
            "All people who do research are biologists.",
            "Sarah is a biologist."
        ],
        "premises-FOL": [
            "∀x (Biologist(x) → UnderstandsBiology(x)) ::: All biologists understand biology.",
            "∀x (StudiesGenetics(x) → Biologist(x)) ::: If someone studies genetics, they are a biologist.",
            "∀x (DoesExperiments(x) → UsesMicroscope(x)) ::: Anyone who does experiments uses a microscope.",
            "∀x (UsesMicroscope(x) → DoesResearch(x)) ::: If someone uses a microscope, they do research.",
            "∀x (StudiesGenetics(x) ∧ DoesExperiments(x) → WritesPapers(x)) ::: If someone studies genetics and does experiments, they write papers.",
            "∀x (Biologist(x) → DoesExperiments(x)) ::: All biologists do experiments.",
            "∀x (StudiesGenetics(x) ∧ WritesPapers(x) → DoesResearch(x)) ::: Anyone who studies genetics and writes papers does research.",
            "∀x (UnderstandsBiology(x) → StudiesGenetics(x)) ::: If someone understands biology, they study genetics.",
            "∀x (DoesResearch(x) → WritesPapers(x)) ::: If someone does research, then they write papers.",
            "∀x (DoesResearch(x) → Biologist(x)) ::: All people who do research are biologists.",
            "Biologist(sarah) ::: Sarah is a biologist."
        ],
        "predicates": [
            "Biologist(x) ::: x is a biologist",
            "StudiesGenetics(x) ::: x studies genetics",
            "DoesExperiments(x) ::: x does experiments",
            "DoesResearch(x) ::: x does research",
            "UsesMicroscope(x) ::: x uses a microscope",
            "UnderstandsBiology(x) ::: x understands biology",
            "WritesPapers(x) ::: x writes papers"
        ]
    },
    {
        "premises-NL": [
            "Every student attends lectures.",
            "If someone attends lectures and understands material, they study.",
            "If someone studies, they will pass their exams.",
            "John is a student.",
            "John attends lectures.",
            "John understands material."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsLectures(x)) ::: For all x, if x is a student, then x attends lectures.",
            "∀x (AttendsLectures(x) ∧ UnderstandsMaterial(x) → Studies(x)) ::: For all x, if x attends lectures and understands material, then x studies.",
            "∀x (Studies(x) → PassesExams(x)) ::: For all x, if x studies, then x passes exams.",
            "Student(john) ::: John is a student.",
            "AttendsLectures(john) ::: John attends lectures.",
            "UnderstandsMaterial(john) ::: John understands material."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Studies(x) ::: x studies.",
            "PassesExams(x) ::: x passes exams.",
            "AttendsLectures(x) ::: x attends lectures.",
            "UnderstandsMaterial(x) ::: x understands material.",
            "Smart(x) ::: x is smart."
        ]
    },
    {
        "premises-NL": [
            "All members of the club are invited to the party.",
            "Everyone who is invited to the party will attend it.",
            "If someone is a friend of Bob, Bob likes them.",
            "Bob is a friend of everyone who is a member of the club.",
            "Alice is a member of the club.",
            "Bob likes Alice.",
            "Alice is a friend of Bob."
        ],
        "premises-FOL": [
            "∀x (MemberOfClub(x) → InvitedToParty(x)) ::: For all x, if x is a member of the club, then x is invited to the party.",
            "∀x (InvitedToParty(x) → AttendsParty(x)) ::: For all x, if x is invited to the party, then x attends the party.",
            "∀x (FriendOf(x, bob) → BobLikes(x)) ::: For all x, if x is a friend of Bob, then Bob likes x.",
            "∀x (MemberOfClub(x) → FriendOf(bob, x)) ::: For all x, if x is a member of the club, then Bob is a friend of x.",
            "MemberOfClub(alice) ::: Alice is a member of the club.",
            "BobLikes(alice) ::: Bob likes Alice.",
            "FriendOf(alice, bob) ::: Alice is a friend of Bob."
        ],
        "predicates": [
            "MemberOfClub(x) ::: x is a member of the club.",
            "FriendOf(x, y) ::: x is a friend of y.",
            "AttendsParty(x) ::: x attends the party.",
            "InvitedToParty(x) ::: x is invited to the party.",
            "FriendOf(bob, x) ::: Bob is a friend of x.",
            "Likes(x, y) ::: x likes y.",
            "BobLikes(x) ::: Bob likes x."
        ]
    },
    {
        "premises-NL": [
            "If someone invests in an increasing market, they will likely have profit.",
            "If an investment has a high risk, the market is decreasing.",
            "If an investment has a low risk, the market is increasing.",
            "John invests in both high and low-risk investments.",
            "John is a smart investor.",
            "John invests.",
            "If an investor diversifies, they invest in multiple markets.",
            "If John invests in a low-risk investment, then it's an increasing market."
        ],
        "premises-FOL": [
            "∀x ∀y (Invests(x, y) ∧ IncreasingMarket(y) → LikelyProfit(x)) ::: For all x and y, if x invests in y and y is an increasing market, then x will likely have profit.",
            "∀y (HighRisk(y) → DecreasingMarket(y)) ::: For all y, if y has high risk, then y is a decreasing market.",
            "∀y (LowRisk(y) → IncreasingMarket(y)) ::: For all y, if y has low risk, then y is an increasing market.",
            "∃y ∃z (Invests(john, y) ∧ HighRisk(y) ∧ Invests(john, z) ∧ LowRisk(z)) ::: There exists a y and z, such that John invests in y and y has high risk, and John invests in z and z has low risk.",
            "SmartInvestor(john) ::: John is a smart investor.",
            "∃y Invests(john, y) ::: There exists a y, such that John invests in y.",
            "∀x ∀y (Diversifies(x, y) → Invests(x, y)) ::: For all x and y, if x diversifies in y, then x invests in y.",
            "∀y (Invests(john, y) ∧ LowRisk(y) → IncreasingMarket(y)) ::: For all y, if John invests in y and y has low risk, then y is an increasing market."
        ],
        "predicates": [
            "Invests(x, y) ::: x invests in y.",
            "IncreasingMarket(y) ::: y is an increasing market.",
            "LikelyProfit(x) ::: x will likely have profit.",
            "DecreasingMarket(y) ::: y is a decreasing market.",
            "HighRisk(y) ::: y has high risk.",
            "LowRisk(y) ::: y has low risk.",
            "SmartInvestor(x) ::: x is a smart investor.",
            "Diversifies(x, y) ::: x diversifies investments in y."
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "Dr. Smith is a doctor.",
            "John is a patient of Dr. Smith.",
            "If someone treats a patient, then they are helping people.",
            "Dr. Smith loves helping people.",
            "There is a doctor named Dr. Smith.",
            "Dr. Smith has medicine for everyone.",
            "If someone is allergic to a medicine, then the medicine will not help.",
            "John is allergic to the medicine."
        ],
        "premises-FOL": [
            "∀x ∀y (Doctor(x) ∧ Patient(y) ∧ Treats(x, y) → LovesHelpingPeople(x)) ::: For all x and y, if x is a doctor, y is a patient, and x treats y, then x loves helping people.",
            "Doctor(smith) ::: Dr. Smith is a doctor",
            "Patient(john) ∧ Treats(smith, john) ::: John is a patient of Dr. Smith",
            "∀x ∀y (Treats(x, y) → LovesHelpingPeople(x)) ::: If someone treats a patient, then they are helping people.",
            "LovesHelpingPeople(smith) ::: Dr. Smith loves helping people.",
            "Doctor(smith) ::: There is a doctor named Dr. Smith.",
            "∀x ∃y HasMedicine(smith, y) ::: Dr. Smith has medicine for everyone.",
            "∀x ∀y (AllergicTo(x, y) → ¬Helps(y,x)) ::: If someone is allergic to a medicine, then the medicine will not help.",
            "AllergicTo(john,medicine) ::: John is allergic to the medicine."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Patient(x) ::: x is a patient",
            "Treats(x, y) ::: x treats y",
            "LovesHelpingPeople(x) ::: x loves helping people",
            "AllergicTo(x, y) ::: x is allergic to y",
            "HasMedicine(x, y) ::: x has medicine y"
        ]
    },
    {
        "premises-NL": [
            "All students attend classes.",
            "If someone attends classes and studies hard, they pass the exam.",
            "All students are studying hard.",
            "Alice is a student.",
            "Alice attends classes."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClasses(x)) ::: All students attend classes.",
            "∀x ((AttendsClasses(x) ∧ StudiesHard(x)) → PassesExam(x)) ::: If someone attends classes and studies hard, they pass the exam.",
            "∀x (Student(x) → StudiesHard(x)) ::: All students are studying hard.",
            "Student(alice) ::: Alice is a student.",
            "AttendsClasses(alice) ::: Alice attends classes."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassesExam(x) ::: x passes the exam",
            "AttendsClasses(x) ::: x attends classes"
        ]
    },
    {
        "premises-NL": [
            "All doctors work at a hospital.",
            "Everyone who works at a hospital has a degree.",
            "If someone has a degree, they are highly educated.",
            "Alice is a doctor.",
            "Alice specializes in cardiology.",
            "All cardiologists are doctors."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → WorksAtHospital(x)) ::: All doctors work at a hospital.",
            "∀x (WorksAtHospital(x) → HasDegree(x)) ::: Everyone who works at a hospital has a degree.",
            "∀x (HasDegree(x) → HighlyEducated(x)) ::: If someone has a degree, they are highly educated.",
            "Doctor(alice) ::: Alice is a doctor.",
            "SpecializesIn(alice, cardiology) ::: Alice specializes in cardiology.",
            "∀x (SpecializesIn(x, cardiology) → Doctor(x)) ::: All cardiologists are doctors."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "HighlyEducated(x) ::: x is highly educated",
            "HasDegree(x) ::: x has a degree",
            "WorksAtHospital(x) ::: x works at a hospital",
            "SpecializesIn(x, y) ::: x specializes in y"
        ]
    },
    {
        "premises-NL": [
            "All students attend classes.",
            "If a student studies and attends classes, then they have a tutor.",
            "If a student studies, then they are a good learner.",
            "Some students study.",
            "All students are students.",
            "If a student attends classes, they study.",
            "If a student has a tutor, then they are a student.",
            "If a student is a good learner, then they have a tutor.",
            "A student either studies or is a good learner.",
            "Some students do not study.",
            "Every student attends classes.",
            "If a student does not have a tutor, then they don't study.",
            "If a student is a good learner, then they attend classes.",
            "A student is a good learner or does not study."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClass(x)) ::: All students attend classes.",
            "∀x ((Studies(x) ∧ AttendsClass(x)) → HasTutor(x)) ::: If a student studies and attends classes, then they have a tutor.",
            "∀x (Studies(x) → GoodLearner(x)) ::: If a student studies, then they are a good learner.",
            "∃x Studies(x) ::: Some students study.",
            "∀x Student(x) → Student(x) ::: All students are students.",
            "∀x (AttendsClass(x) → Studies(x)) ::: If a student attends classes, they study.",
            "∀x (HasTutor(x) → Student(x)) ::: If a student has a tutor, then they are a student.",
            "∀x (GoodLearner(x) → HasTutor(x)) ::: If a student is a good learner, then they have a tutor.",
            "∀x (Studies(x) ∨ GoodLearner(x)) ::: A student either studies or is a good learner.",
            "∃x ¬Studies(x) ::: Some students do not study.",
            "∀x AttendsClass(x) ::: Every student attends classes.",
            "∀x (¬HasTutor(x) → ¬Studies(x)) ::: If a student does not have a tutor, then they don't study.",
            "∀x (GoodLearner(x) → AttendsClass(x)) ::: If a student is a good learner, then they attend classes.",
            "∀x (GoodLearner(x) ∨ ¬Studies(x)) ::: A student is a good learner or does not study."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "HasTutor(x) ::: x has a tutor",
            "AttendsClass(x) ::: x attends a class",
            "GoodLearner(x) ::: x is a good learner",
            "Studies(x) ::: x studies"
        ]
    },
    {
        "premises-NL": [
            "Anyone who uses social media reads news.",
            "Everyone who reads news trusts sources.",
            "If someone trusts sources, they are informed.",
            "If a person is informed, they share news or post opinions.",
            "If someone uses social media, they have friends.",
            "If a person posts opinions, they share news.",
            "If someone has friends, they use social media.",
            "If a person is informed, they reads news.",
            "If someone share news, they do not post opinions.",
            "If someone does not read news, they don't share news.",
            "Everyone is informed or does not trust sources.",
            "A person shares news or does not use social media.",
            "Someone trusts sources.",
            "Anyone who shares news has friends.",
            "Anyone that posts opinions shares news."
        ],
        "premises-FOL": [
            "∀x (UsesSocialMedia(x) → ReadsNews(x)) ::: Anyone who uses social media reads news.",
            "∀x (ReadsNews(x) → TrustsSources(x)) ::: Everyone who reads news trusts sources.",
            "∀x (TrustsSources(x) → Informed(x)) ::: If someone trusts sources, they are informed.",
            "∀x (Informed(x) → (SharesNews(x) ∨ PostsOpinions(x))) ::: If a person is informed, they share news or post opinions.",
            "∀x (UsesSocialMedia(x) → HasFriends(x)) ::: If someone uses social media, they have friends.",
            "∀x (PostsOpinions(x) → SharesNews(x)) ::: If a person posts opinions, they share news.",
            "∀x (HasFriends(x) → UsesSocialMedia(x)) ::: If someone has friends, they use social media.",
            "∀x (Informed(x) → ReadsNews(x)) ::: If a person is informed, they reads news.",
            "∀x (SharesNews(x) → ¬PostsOpinions(x)) ::: If someone share news, they do not post opinions.",
            "∀x (¬ReadsNews(x) → ¬SharesNews(x)) ::: If someone does not read news, they don't share news.",
            "∀x (Informed(x) ∨ ¬TrustsSources(x)) ::: Everyone is informed or does not trust sources.",
            "∀x (SharesNews(x) ∨ ¬UsesSocialMedia(x)) ::: A person shares news or does not use social media.",
            "∃x TrustsSources(x) ::: Someone trusts sources.",
            "∀x (SharesNews(x) → HasFriends(x)) ::: Anyone who shares news has friends.",
            "∀x (PostsOpinions(x) → SharesNews(x)) ::: Anyone that posts opinions shares news."
        ],
        "predicates": [
            "UsesSocialMedia(x) ::: x uses social media",
            "Informed(x) ::: x is informed",
            "SharesNews(x) ::: x shares news",
            "ReadsNews(x) ::: x reads news",
            "TrustsSources(x) ::: x trusts sources",
            "PostsOpinions(x) ::: x posts opinions",
            "HasFriends(x) ::: x has friends"
        ]
    },
    {
        "premises-NL": [
            "All patients who are treated take medication.",
            "Anyone who takes medication either improves or is cured.",
            "If a patient follows instructions, they are treated.",
            "If a patient has a disease, they take medication.",
            "If a patient is cured, they are not treated.",
            "Some patients follow instructions.",
            "A patient has a disease or doesn't take medication.",
            "If a patient does not follow instructions, then the person is not treated.",
            "If a patient improves, then they are treated.",
            "A person is a patient.",
            "If a person follows instructions, they improve.",
            "Anyone who has a disease is a patient.",
            "Anyone who improves, follows instructions.",
            "If a patient is treated, then the person follows instructions.",
            "A person either takes medication or is cured.",
            "A person is treated if and only if he follows instructions."
        ],
        "premises-FOL": [
            "∀x (Treated(x) → TakesMedication(x)) ::: All patients who are treated take medication.",
            "∀x (TakesMedication(x) → (Improves(x) ∨ Cured(x))) ::: Anyone who takes medication either improves or is cured.",
            "∀x (FollowsInstructions(x) → Treated(x)) ::: If a patient follows instructions, they are treated.",
            "∀x (HasDisease(x) → TakesMedication(x)) ::: If a patient has a disease, they take medication.",
            "∀x (Cured(x) → ¬Treated(x)) ::: If a patient is cured, they are not treated.",
            "∃x FollowsInstructions(x) ::: Some patients follow instructions.",
            "∀x (HasDisease(x) ∨ ¬TakesMedication(x)) ::: A patient has a disease or doesn't take medication.",
            "∀x (¬FollowsInstructions(x) → ¬Treated(x)) ::: If a patient does not follow instructions, then the person is not treated.",
            "∀x (Improves(x) → Treated(x)) ::: If a patient improves, then they are treated.",
            "∀x Patient(x) ::: A person is a patient.",
            "∀x (FollowsInstructions(x) → Improves(x)) ::: If a person follows instructions, they improve.",
            "∀x (HasDisease(x) → Patient(x)) ::: Anyone who has a disease is a patient.",
            "∀x (Improves(x) → FollowsInstructions(x)) ::: Anyone who improves, follows instructions.",
            "∀x (Treated(x) → FollowsInstructions(x)) ::: If a patient is treated, then the person follows instructions.",
            "∀x (TakesMedication(x) ∨ Cured(x)) ::: A person either takes medication or is cured.",
            "∀x (Treated(x) ↔ FollowsInstructions(x)) ::: A person is treated if and only if he follows instructions."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient",
            "HasDisease(x) ::: x has a disease",
            "Treated(x) ::: x is treated",
            "Improves(x) ::: x improves",
            "Cured(x) ::: x is cured",
            "TakesMedication(x) ::: x takes medication",
            "FollowsInstructions(x) ::: x follows instructions"
        ]
    },
    {
        "premises-NL": [
            "All successful projects are completed or require approval.",
            "If a project has resources and has a team, then the project is completed.",
            "If a project is completed, then it is successful and on time.",
            "Every project has a team.",
            "Some projects have resources.",
            "If a project requires approval, then it is within budget.",
            "If a project is within budget, then it has a team or is successful.",
            "If a project is successful, then it has a team.",
            "If a project is not completed, then it is not successful.",
            "If a project does not require approval, then the project is completed.",
            "If a project has a team and has resources, then it is completed.",
            "Some projects do not have a team or are within budget.",
            "Every project has resources or requires approval.",
            "If a project is on time, then it is successful.",
            "If a project is not within budget, then it is not completed.",
            "A project has a team if and only if it is completed.",
            "If a project has resources, then it is completed."
        ],
        "premises-FOL": [
            "∀x (Successful(x) → (Completed(x) ∨ RequiresApproval(x))) ::: All successful projects are completed or require approval.",
            "∀x ((HasResources(x) ∧ HasTeam(x)) → Completed(x)) ::: If a project has resources and has a team, then the project is completed.",
            "∀x (Completed(x) → (Successful(x) ∧ OnTime(x))) ::: If a project is completed, then it is successful and on time.",
            "∀x HasTeam(x) ::: Every project has a team.",
            "∃x HasResources(x) ::: Some projects have resources.",
            "∀x (RequiresApproval(x) → WithinBudget(x)) ::: If a project requires approval, then it is within budget.",
            "∀x (WithinBudget(x) → (HasTeam(x) ∨ Successful(x))) ::: If a project is within budget, then it has a team or is successful.",
            "∀x (Successful(x) → HasTeam(x)) ::: If a project is successful, then it has a team.",
            "∀x (¬Completed(x) → ¬Successful(x)) ::: If a project is not completed, then it is not successful.",
            "∀x (¬RequiresApproval(x) → Completed(x)) ::: If a project does not require approval, then the project is completed.",
            "∀x ((HasTeam(x) ∧ HasResources(x)) → Completed(x)) ::: If a project has a team and has resources, then it is completed.",
            "∃x (¬HasTeam(x) ∨ WithinBudget(x)) ::: Some projects do not have a team or are within budget.",
            "∀x (HasResources(x) ∨ RequiresApproval(x)) ::: Every project has resources or requires approval.",
            "∀x (OnTime(x) → Successful(x)) ::: If a project is on time, then it is successful.",
            "∀x (¬WithinBudget(x) → ¬Completed(x)) ::: If a project is not within budget, then it is not completed.",
            "∀x (HasTeam(x) ↔ Completed(x)) ::: A project has a team if and only if it is completed.",
            "∀x (HasResources(x) → Completed(x)) ::: If a project has resources, then it is completed."
        ],
        "predicates": [
            "Project(x) ::: x is a project",
            "Successful(x) ::: x is successful",
            "HasResources(x) ::: x has resources",
            "Completed(x) ::: x is completed",
            "HasTeam(x) ::: x has a team",
            "OnTime(x) ::: x is on time",
            "WithinBudget(x) ::: x is within budget",
            "RequiresApproval(x) ::: x requires approval"
        ]
    },
    {
        "premises-NL": [
            "All scientists work at a university.",
            "If someone studies biology, they have a degree in biology.",
            "If someone works at a university and has a degree in biology, they do research.",
            "If someone studies biology, they attend conferences.",
            "If someone attends a conference, they publish papers.",
            "All scientists do research.",
            "If someone does research, they are a researcher.",
            "If someone is a researcher and studies biology, then they do research.",
            "If someone is a scientist and studies biology, then they do research."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → WorksAtUniversity(x)) ::: All scientists work at a university.",
            "∀x (StudiesBiology(x) → HasDegree(x, biology)) ::: If someone studies biology, they have a degree in biology.",
            "∀x (WorksAtUniversity(x) ∧ HasDegree(x, biology) → DoesResearch(x)) ::: If someone works at a university and has a degree in biology, they do research.",
            "∀x (StudiesBiology(x) → AttendsConference(x)) ::: If someone studies biology, they attend conferences.",
            "∀x (AttendsConference(x) → PublishesPapers(x)) ::: If someone attends a conference, they publish papers.",
            "∀x (Scientist(x) → DoesResearch(x)) ::: All scientists do research.",
            "∀x (DoesResearch(x) → IsResearcher(x)) ::: If someone does research, they are a researcher.",
            "∀x (IsResearcher(x) ∧ StudiesBiology(x) → DoesResearch(x)) ::: If someone is a researcher and studies biology, then they do research.",
            "∀x (Scientist(x) ∧ StudiesBiology(x) → DoesResearch(x)) ::: If someone is a scientist and studies biology, then they do research."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "StudiesBiology(x) ::: x studies biology",
            "DoesResearch(x) ::: x does research",
            "WorksAtUniversity(x) ::: x works at a university",
            "HasDegree(x, y) ::: x has a degree in y",
            "Biology(x) ::: x is biology",
            "AttendsConference(x) ::: x attends a conference",
            "PublishesPapers(x) ::: x publishes papers",
            "IsResearcher(x) ::: x is a researcher"
        ]
    },
    {
        "premises-NL": [
            "All products that are advertised are available.",
            "If a product is sold in a store, and is available, it will be bought.",
            "If a product is expensive, it is not in demand.",
            "If a product has a discount, it is on sale.",
            "If a product is on sale, it is bought.",
            "If a product is advertised and has good quality, it is in demand.",
            "If a product is sold in a store and advertised, the product will be bought.",
            "All products are either sold or not in store.",
            "If a product is advertised, it is either in demand or has a discount.",
            "A product is sold in a store if and only if it is bought."
        ],
        "premises-FOL": [
            "∀x (Advertised(x) → Available(x)) ::: All products that are advertised are available.",
            "∀x (SoldInStore(x) ∧ Available(x) → Bought(x)) ::: If a product is sold in a store, and is available, it will be bought.",
            "∀x (Expensive(x) → ¬InDemand(x)) ::: If a product is expensive, it is not in demand.",
            "∀x (HasDiscount(x) → OnSale(x)) ::: If a product has a discount, it is on sale.",
            "∀x (OnSale(x) → Bought(x)) ::: If a product is on sale, it is bought.",
            "∀x (Advertised(x) ∧ GoodQuality(x) → InDemand(x)) ::: If a product is advertised and has good quality, it is in demand.",
            "∀x (Product(x) ∧ SoldInStore(x) ∧ Advertised(x) → Bought(x)) ::: If a product is sold in a store and advertised, the product will be bought.",
            "∀x (SoldInStore(x) ∨ ¬SoldInStore(x)) ::: All products are either sold or not in store.",
            "∀x (Advertised(x) → (InDemand(x) ∨ HasDiscount(x))) ::: If a product is advertised, it is either in demand or has a discount.",
            "∀x (SoldInStore(x) ↔ Bought(x)) ::: A product is sold in a store if and only if it is bought."
        ],
        "predicates": [
            "Product(x) ::: x is a product",
            "SoldInStore(x) ::: x is sold in a store",
            "Advertised(x) ::: x is advertised",
            "Bought(x) ::: x is bought",
            "Expensive(x) ::: x is expensive",
            "Available(x) ::: x is available",
            "HasDiscount(x) ::: x has a discount",
            "InDemand(x) ::: x is in demand",
            "GoodQuality(x) ::: x has good quality",
            "OnSale(x) ::: x is on sale"
        ]
    },
    {
        "premises-NL": [
            "All people with high incomes work hard.",
            "If someone works hard and is employed, they save money.",
            "If someone saves money, they have investments.",
            "If someone has investments, they are financially secure.",
            "If someone is employed, they pay taxes.",
            "If someone has a high income, they are employed and saves money.",
            "If someone owns property and has no debt, they are financially secure.",
            "If someone spends money, they are not financially secure.",
            "If someone has a high income and is employed, they are financially secure.",
            "Anyone who is employed and pays taxes is financially secure.",
            "If someone has a high income, then they are a person."
        ],
        "premises-FOL": [
            "∀x (HasHighIncome(x) → WorksHard(x)) ::: All people with high incomes work hard.",
            "∀x (WorksHard(x) ∧ Employed(x) → SavesMoney(x)) ::: If someone works hard and is employed, they save money.",
            "∀x (SavesMoney(x) → HasInvestments(x)) ::: If someone saves money, they have investments.",
            "∀x (HasInvestments(x) → FinanciallySecure(x)) ::: If someone has investments, they are financially secure.",
            "∀x (Employed(x) → PaysTaxes(x)) ::: If someone is employed, they pay taxes.",
            "∀x (HasHighIncome(x) → (Employed(x) ∧ SavesMoney(x))) ::: If someone has a high income, they are employed and saves money.",
            "∀x (OwnsProperty(x) ∧ ¬HasDebt(x) → FinanciallySecure(x)) ::: If someone owns property and has no debt, they are financially secure.",
            "∀x (SpendsMoney(x) → ¬FinanciallySecure(x)) ::: If someone spends money, they are not financially secure.",
            "∀x (Person(x) ∧ HasHighIncome(x) ∧ Employed(x) → FinanciallySecure(x)) ::: If a person has a high income and is employed, they are financially secure.",
            "∀x (Employed(x) ∧ PaysTaxes(x) → FinanciallySecure(x)) ::: Anyone who is employed and pays taxes is financially secure.",
            "∀x (HasHighIncome(x) → Person(x)) ::: If someone has a high income, then they are a person."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "HasHighIncome(x) ::: x has a high income",
            "Employed(x) ::: x is employed",
            "FinanciallySecure(x) ::: x is financially secure",
            "OwnsProperty(x) ::: x owns property",
            "HasDebt(x) ::: x has debt",
            "SavesMoney(x) ::: x saves money",
            "SpendsMoney(x) ::: x spends money",
            "HasInvestments(x) ::: x has investments",
            "PaysTaxes(x) ::: x pays taxes",
            "WorksHard(x) ::: x works hard"
        ]
    },
    {
        "premises-NL": [
            "All doctors work at a hospital.",
            "All surgeons are doctors.",
            "Some doctors are surgeons.",
            "No patients are doctors.",
            "If someone is a surgeon, then they have a medical degree.",
            "John is a doctor.",
            "If someone is a patient, then they are not a doctor.",
            "Doctors do not deal with patients."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → WorksAtHospital(x)) ::: All doctors work at a hospital.",
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∃x (Doctor(x) ∧ Surgeon(x)) ::: Some doctors are surgeons.",
            "∀x (Patient(x) → ¬Doctor(x)) ::: No patients are doctors.",
            "∀x (Surgeon(x) → HasMedicalDegree(x)) ::: If someone is a surgeon, then they have a medical degree.",
            "Doctor(john) ::: John is a doctor.",
            "∀x (Patient(x) → ¬Doctor(x)) ::: If someone is a patient, then they are not a doctor.",
            "∀x (Doctor(x) → ¬DealsWithPatient(x)) ::: Doctors do not deal with patients."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "HasMedicalDegree(x) ::: x has a medical degree",
            "WorksAtHospital(x) ::: x works at a hospital",
            "Surgeon(x) ::: x is a surgeon",
            "Patient(x) ::: x is a patient"
        ]
    },
    {
        "premises-NL": [
            "All members of the marketing team work for the company.",
            "Anyone who works for the company, if they manage social media, they have a relevant degree.",
            "Some members of the marketing team manage social media.",
            "If someone manages social media, they have good communication skills.",
            "If someone has good communication skills and works for the company, they have marketing experience.",
            "All members of the marketing team have good communication skills.",
            "If someone has marketing experience, they have a relevant degree.",
            "Sarah is a member of the marketing team.",
            "Anyone in marketing has good communication skills."
        ],
        "premises-FOL": [
            "∀x (MemberOfMarketing(x) → WorksForCompany(x)) ::: All members of the marketing team work for the company.",
            "∀x (WorksForCompany(x) ∧ ManagesSocialMedia(x) → HasRelevantDegree(x)) ::: Anyone who works for the company, if they manage social media, they have a relevant degree.",
            "∃x (MemberOfMarketing(x) ∧ ManagesSocialMedia(x)) ::: Some members of the marketing team manage social media.",
            "∀x (ManagesSocialMedia(x) → HasGoodCommunicationSkills(x)) ::: If someone manages social media, they have good communication skills.",
            "∀x (HasGoodCommunicationSkills(x) ∧ WorksForCompany(x) → HasMarketingExperience(x)) ::: If someone has good communication skills and works for the company, they have marketing experience.",
            "∀x (MemberOfMarketing(x) → HasGoodCommunicationSkills(x)) ::: All members of the marketing team have good communication skills.",
            "∀x (HasMarketingExperience(x) → HasRelevantDegree(x)) ::: If someone has marketing experience, they have a relevant degree.",
            "MemberOfMarketing(sarah) ::: Sarah is a member of the marketing team.",
            "∀x (MemberOfMarketing(x) → HasGoodCommunicationSkills(x)) ::: Anyone in marketing has good communication skills."
        ],
        "predicates": [
            "MemberOfMarketing(x) ::: x is a member of the marketing team",
            "HasRelevantDegree(x) ::: x has a relevant degree",
            "WorksForCompany(x) ::: x works for a company",
            "ManagesSocialMedia(x) ::: x manages social media",
            "HasGoodCommunicationSkills(x) ::: x has good communication skills",
            "HasMarketingExperience(x) ::: x has marketing experience"
        ]
    },
    {
        "premises-NL": [
            "All people who invest in stocks and bonds consult a financial advisor.",
            "Anyone who consults a financial advisor has a diversified portfolio.",
            "Some wealthy people invest in stocks.",
            "People with high incomes tend to invest in bonds.",
            "If a person understands risk and invests in real estate, they have a diversified portfolio.",
            "John invests in stocks and bonds.",
            "If a person has a diversified portfolio and is wealthy, they understand risk.",
            "Anyone who invests in real estate has high income.",
            "All wealthy people consult financial advisors.",
            "Some people who consult financial advisors have a diversified portfolio."
        ],
        "premises-FOL": [
            "∀x (InvestsInStocks(x) ∧ InvestsInBonds(x) → ConsultsFinancialAdvisor(x)) ::: All people who invest in stocks and bonds consult a financial advisor.",
            "∀x (ConsultsFinancialAdvisor(x) → HasDiversifiedPortfolio(x)) ::: Anyone who consults a financial advisor has a diversified portfolio.",
            "∃x (IsWealthy(x) ∧ InvestsInStocks(x)) ::: Some wealthy people invest in stocks.",
            "∀x (HasHighIncome(x) → InvestsInBonds(x)) ::: People with high incomes tend to invest in bonds.",
            "∀x (UnderstandsRisk(x) ∧ InvestsInRealEstate(x) → HasDiversifiedPortfolio(x)) ::: If a person understands risk and invests in real estate, they have a diversified portfolio.",
            "InvestsInStocks(john) ∧ InvestsInBonds(john) ::: John invests in stocks and bonds.",
            "∀x (HasDiversifiedPortfolio(x) ∧ IsWealthy(x) → UnderstandsRisk(x)) ::: If a person has a diversified portfolio and is wealthy, they understand risk.",
            "∀x (InvestsInRealEstate(x) → HasHighIncome(x)) ::: Anyone who invests in real estate has high income.",
            "∀x (IsWealthy(x) → ConsultsFinancialAdvisor(x)) ::: All wealthy people consult financial advisors.",
            "∃x (ConsultsFinancialAdvisor(x) ∧ HasDiversifiedPortfolio(x)) ::: Some people who consult financial advisors have a diversified portfolio."
        ],
        "predicates": [
            "InvestsInStocks(x) ::: x invests in stocks",
            "InvestsInBonds(x) ::: x invests in bonds",
            "HasDiversifiedPortfolio(x) ::: x has a diversified portfolio",
            "IsWealthy(x) ::: x is wealthy",
            "ConsultsFinancialAdvisor(x) ::: x consults a financial advisor",
            "UnderstandsRisk(x) ::: x understands risk",
            "HasHighIncome(x) ::: x has a high income",
            "InvestsInRealEstate(x) ::: x invests in real estate"
        ]
    },
    {
        "premises-NL": [
            "People who take vitamins eat healthy.",
            "People who exercise have low stress.",
            "People with low stress have improved health.",
            "Anyone who smokes does not have improved health.",
            "If a person has a chronic disease, they do not have improved health.",
            "John takes vitamins and exercises.",
            "Anyone who drinks alcohol eats processed food.",
            "If someone sleeps well and drinks water, they eat healthy.",
            "Eating healthy and drinking water contributes to improved health.",
            "Some people who eat processed food, smoke."
        ],
        "premises-FOL": [
            "∀x (TakesVitamins(x) → EatsHealthy(x)) ::: People who take vitamins eat healthy.",
            "∀x (Exercises(x) → HasLowStress(x)) ::: People who exercise have low stress.",
            "∀x (HasLowStress(x) → HasImprovedHealth(x)) ::: People with low stress have improved health.",
            "∀x (Smokes(x) → ¬HasImprovedHealth(x)) ::: Anyone who smokes does not have improved health.",
            "∀x (HasChronicDisease(x) → ¬HasImprovedHealth(x)) ::: If a person has a chronic disease, they do not have improved health.",
            "TakesVitamins(john) ∧ Exercises(john) ::: John takes vitamins and exercises.",
            "∀x (DrinksAlcohol(x) → EatsProcessedFood(x)) ::: Anyone who drinks alcohol eats processed food.",
            "∀x (SleepsWell(x) ∧ DrinksWater(x) → EatsHealthy(x)) ::: If someone sleeps well and drinks water, they eat healthy.",
            "∀x (EatsHealthy(x) ∧ DrinksWater(x) → HasImprovedHealth(x)) ::: Eating healthy and drinking water contributes to improved health.",
            "∃x (EatsProcessedFood(x) ∧ Smokes(x)) ::: Some people who eat processed food, smoke."
        ],
        "predicates": [
            "TakesVitamins(x) ::: x takes vitamins",
            "Exercises(x) ::: x exercises",
            "HasImprovedHealth(x) ::: x has improved health",
            "EatsHealthy(x) ::: x eats healthy",
            "HasLowStress(x) ::: x has low stress",
            "Smokes(x) ::: x smokes",
            "HasChronicDisease(x) ::: x has a chronic disease",
            "DrinksAlcohol(x) ::: x drinks alcohol",
            "SleepsWell(x) ::: x sleeps well",
            "DrinksWater(x) ::: x drinks water",
            "EatsProcessedFood(x) ::: x eats processed food"
        ]
    },
    {
        "premises-NL": [
            "All students who study computer science attend university.",
            "Anyone who takes a programming course studies computer science.",
            "Students who read textbooks and are diligent have good grades.",
            "Those who participate in projects and study mathematics will be prepared for a tech career.",
            "If a student has good grades and uses online resources, they will be prepared for a tech career.",
            "John studies computer science and mathematics.",
            "If someone attends lectures, they read textbooks.",
            "Anyone who submits assignments is diligent.",
            "Taking programming courses implies reading textbooks.",
            "Some students who read textbooks attend university.",
            "If a student studies mathematics and submits assignments, they participate in projects."
        ],
        "premises-FOL": [
            "∀x (StudiesComputerScience(x) → AttendsUniversity(x)) ::: All students who study computer science attend university.",
            "∀x (TakesProgrammingCourse(x) → StudiesComputerScience(x)) ::: Anyone who takes a programming course studies computer science.",
            "∀x (ReadsTextbooks(x) ∧ IsDiligent(x) → HasGoodGrades(x)) ::: Students who read textbooks and are diligent have good grades.",
            "∀x (ParticipatesInProjects(x) ∧ StudiesMathematics(x) → WillBePreparedForTechCareer(x)) ::: Those who participate in projects and study mathematics will be prepared for a tech career.",
            "∀x (HasGoodGrades(x) ∧ UsesOnlineResources(x) → WillBePreparedForTechCareer(x)) ::: If a student has good grades and uses online resources, they will be prepared for a tech career.",
            "StudiesComputerScience(john) ∧ StudiesMathematics(john) ::: John studies computer science and mathematics.",
            "∀x (AttendsLectures(x) → ReadsTextbooks(x)) ::: If someone attends lectures, they read textbooks.",
            "∀x (SubmitsAssignments(x) → IsDiligent(x)) ::: Anyone who submits assignments is diligent.",
            "∀x (TakesProgrammingCourse(x) → ReadsTextbooks(x)) ::: Taking programming courses implies reading textbooks.",
            "∃x (ReadsTextbooks(x) ∧ AttendsUniversity(x)) ::: Some students who read textbooks attend university.",
            "∀x (StudiesMathematics(x) ∧ SubmitsAssignments(x) → ParticipatesInProjects(x)) ::: If a student studies mathematics and submits assignments, they participate in projects."
        ],
        "predicates": [
            "StudiesComputerScience(x) ::: x studies computer science",
            "StudiesMathematics(x) ::: x studies mathematics",
            "WillBePreparedForTechCareer(x) ::: x will be prepared for a tech career",
            "AttendsUniversity(x) ::: x attends university",
            "TakesProgrammingCourse(x) ::: x takes a programming course",
            "ReadsTextbooks(x) ::: x reads textbooks",
            "IsDiligent(x) ::: x is diligent",
            "ParticipatesInProjects(x) ::: x participates in projects",
            "HasGoodGrades(x) ::: x has good grades",
            "UsesOnlineResources(x) ::: x uses online resources",
            "AttendsLectures(x) ::: x attends lectures",
            "SubmitsAssignments(x) ::: x submits assignments"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "Some specialists are surgeons.",
            "All surgeons treat patients.",
            "Anyone who works at the hospital is a hospital employee.",
            "Alex is a hospital employee",
            "Alex is a specialist.",
            "Some doctors are specialists.",
            "A surgeon is always a doctor.",
            "Every doctor working at the hospital treats the patient.",
            "If someone is a doctor, they should treat patients.",
            "If someone treats patients and is not a doctor they are a specialist.",
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∃x (Specialist(x) ∧ Surgeon(x)) ::: Some specialists are surgeons.",
            "∀x (Surgeon(x) → TreatsPatients(x)) ::: All surgeons treat patients.",
            "∀x (WorksAtHospital(x) → HospitalEmployee(x)) ::: Anyone who works at the hospital is a hospital employee.",
            "HospitalEmployee(alex) ::: Alex is a hospital employee.",
            "Specialist(alex) ::: Alex is a specialist.",
            "∃x (Doctor(x) ∧ Specialist(x)) ::: Some doctors are specialists.",
            "∀x (Surgeon(x) → Doctor(x)) ::: A surgeon is always a doctor.",
            "∀x (Doctor(x) ∧ WorksAtHospital(x) → TreatsPatients(x)) ::: Every doctor working at the hospital treats the patient.",
            "∀x (Doctor(x) → TreatsPatients(x)) ::: If someone is a doctor, they should treat patients.",
            "∀x (TreatsPatients(x) ∧ ¬Doctor(x) → Specialist(x)) ::: If someone treats patients and is not a doctor they are a specialist."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "WorksAtHospital(x) ::: x works at the hospital",
            "TreatsPatients(x) ::: x treats patients",
            "Surgeon(x) ::: x is a surgeon",
            "Specialist(x) ::: x is a specialist",
            "HospitalEmployee(x) ::: x is a hospital employee",
            "IsPatient(x) ::: x is a patient",
            "Cures(x,y) ::: x cures y"
        ]
    },
    {
        "premises-NL": [
            "Every doctor treats patients.",
            "If someone treats patients, then they studied medicine.",
            "Everyone who studies medicine has a medical degree.",
            "If someone has a medical degree they can treat patients.",
            "If someone is a doctor they have a medical degree.",
            "If someone works at the hospital, they should have medical degree.",
            "A scientist has a medical degree",
            "Some doctors are researchers.",
            "Researchers publish papers.",
            "People who publish papers are scientists.",
            "If someone is a doctor, they must study medicine.",
            "∀x (Doctor(x) → TreatsPatients(x)) ::: Every doctor treats patients.",
            "∀x (TreatsPatients(x) → StudiesMedicine(x)) ::: If someone treats patients, then they studied medicine.",
            "∀x (StudiesMedicine(x) → HasMedicalDegree(x)) ::: Everyone who studies medicine has a medical degree.",
            "∀x (HasMedicalDegree(x) → TreatsPatients(x)) ::: If someone has a medical degree they can treat patients."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → TreatsPatients(x)) ::: Every doctor treats patients.",
            "∀x (TreatsPatients(x) → StudiesMedicine(x)) ::: If someone treats patients, then they studied medicine.",
            "∀x (StudiesMedicine(x) → HasMedicalDegree(x)) ::: Everyone who studies medicine has a medical degree.",
            "∀x (HasMedicalDegree(x) → TreatsPatients(x)) ::: If someone has a medical degree they can treat patients.",
            "∀x (Doctor(x) → HasMedicalDegree(x)) ::: If someone is a doctor they have a medical degree.",
            "∀x (WorksAtHospital(x) → HasMedicalDegree(x)) ::: If someone works at the hospital, they should have medical degree.",
            "∀x (Scientist(x) → HasMedicalDegree(x)) ::: A scientist has a medical degree",
            "∃x (Doctor(x) ∧ Researcher(x)) ::: Some doctors are researchers.",
            "∀x (Researcher(x) → PublishesPapers(x)) ::: Researchers publish papers.",
            "∀x (PublishesPapers(x) → Scientist(x)) ::: People who publish papers are scientists.",
            "∀x (Doctor(x) → StudiesMedicine(x)) ::: If someone is a doctor, they must study medicine.",
            "∀x (Doctor(x) → TreatsPatients(x)) ::: Every doctor treats patients.",
            "∀x (TreatsPatients(x) → StudiesMedicine(x)) ::: If someone treats patients, then they studied medicine.",
            "∀x (StudiesMedicine(x) → HasMedicalDegree(x)) ::: Everyone who studies medicine has a medical degree."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "HasMedicalDegree(x) ::: x has a medical degree",
            "TreatsPatients(x) ::: x treats patients",
            "StudiesMedicine(x) ::: x studies medicine",
            "IsScientist(x) ::: x is a scientist",
            "WorksAtHospital(x) ::: x works at the hospital",
            "Researcher(x) ::: x is a researcher",
            "PublishesPapers(x) ::: x publishes papers"
        ]
    },
    {
        "premises-NL": [
            "All professors are educators.",
            "All professors teach students.",
            "If someone teaches students, then they are an educator.",
            "If someone is a professor and is an educator, they know the subject.",
            "If someone writes books, then they are a professor.",
            "If a researcher publishes papers, they are a professor.",
            "Anyone who attends conferences, is a professor.",
            "If someone lectures, they are a professor.",
            "If someone is an educator, they know the subject.",
            "If someone knows the subject and is a professor, they lecture.",
            "If someone teaches students, they lecture.",
            "∀x (Professor(x) → Educator(x)) ::: All professors are educators.",
            "∀x (Professor(x) → TeachesStudents(x)) ::: All professors teach students.",
            "∀x (TeachesStudents(x) → Educator(x)) ::: If someone teaches students, then they are an educator.",
            "∀x (Professor(x) ∧ Educator(x) → KnowsSubject(x)) ::: If someone is a professor and is an educator, they know the subject.",
            "∀x (WritesBooks(x) → Professor(x)) ::: If someone writes books, then they are a professor."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Educator(x)) ::: All professors are educators.",
            "∀x (Professor(x) → TeachesStudents(x)) ::: All professors teach students.",
            "∀x (TeachesStudents(x) → Educator(x)) ::: If someone teaches students, then they are an educator.",
            "∀x (Professor(x) ∧ Educator(x) → KnowsSubject(x)) ::: If someone is a professor and is an educator, they know the subject.",
            "∀x (WritesBooks(x) → Professor(x)) ::: If someone writes books, then they are a professor.",
            "∀x (Researcher(x) ∧ PublishesPapers(x) → Professor(x)) ::: If a researcher publishes papers, they are a professor.",
            "∀x (AttendsConferences(x) → Professor(x)) ::: Anyone who attends conferences, is a professor.",
            "∀x (Lectures(x) → Professor(x)) ::: If someone lectures, they are a professor.",
            "∀x (Educator(x) → KnowsSubject(x)) ::: If someone is an educator, they know the subject.",
            "∀x (KnowsSubject(x) ∧ Professor(x) → Lectures(x)) ::: If someone knows the subject and is a professor, they lecture.",
            "∀x (TeachesStudents(x) → Lectures(x)) ::: If someone teaches students, they lecture.",
            "∀x (Professor(x) → Educator(x)) ::: All professors are educators.",
            "∀x (Professor(x) → TeachesStudents(x)) ::: All professors teach students.",
            "∀x (TeachesStudents(x) → Educator(x)) ::: If someone teaches students, then they are an educator.",
            "∀x (Professor(x) ∧ Educator(x) → KnowsSubject(x)) ::: If someone is a professor and is an educator, they know the subject."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "TeachesStudents(x) ::: x teaches students",
            "Educator(x) ::: x is an educator",
            "KnowsSubject(x) ::: x knows the subject",
            "WritesBooks(x) ::: x writes books",
            "Researcher(x) ::: x is a researcher",
            "PublishesPapers(x) ::: x publishes papers",
            "AttendsConferences(x) ::: x attends conferences",
            "Lectures(x) ::: x lectures"
        ]
    },
    {
        "premises-NL": [
            "All students who are enrolled attend the workshop.",
            "Anyone who is enrolled is a student.",
            "John is enrolled.",
            "John is a student.",
            "Students who attend the workshop will receive a certificate."
        ],
        "premises-FOL": [
            "∀x ((IsStudent(x) ∧ IsEnrolled(x)) → AttendsWorkshop(x)) ::: All students who are enrolled attend the workshop.",
            "∀x (IsEnrolled(x) → IsStudent(x)) ::: Anyone who is enrolled is a student.",
            "IsEnrolled(john) ::: John is enrolled.",
            "IsStudent(john) ::: John is a student.",
            "∀x ((IsStudent(x) ∧ AttendsWorkshop(x)) → ReceivesCertificate(x)) ::: Students who attend the workshop will receive a certificate."
        ],
        "predicates": [
            "AttendsWorkshop(x) ::: x attends the workshop",
            "IsEnrolled(x) ::: x is enrolled",
            "ReceivesCertificate(x) ::: x receives a certificate",
            "IsStudent(x) ::: x is a student"
        ]
    },
    {
        "premises-NL": [
            "All patients who are diagnosed have the disease.",
            "Anyone who is diagnosed receives treatment.",
            "Anyone who receives treatment is prescribed medication.",
            "Sarah is a patient.",
            "Sarah is diagnosed.",
            "If Sarah is a patient, and is diagnosed, then she receives treatment."
        ],
        "premises-FOL": [
            "∀x ((IsPatient(x) ∧ IsDiagnosed(x)) → HasDisease(x)) ::: All patients who are diagnosed have the disease.",
            "∀x (IsDiagnosed(x) → ReceivesTreatment(x)) ::: Anyone who is diagnosed receives treatment.",
            "∀x (ReceivesTreatment(x) → PrescribedMedication(x)) ::: Anyone who receives treatment is prescribed medication.",
            "IsPatient(sarah) ::: Sarah is a patient.",
            "IsDiagnosed(sarah) ::: Sarah is diagnosed.",
            "(IsPatient(sarah) ∧ IsDiagnosed(sarah)) → ReceivesTreatment(sarah) ::: If Sarah is a patient, and is diagnosed, then she receives treatment."
        ],
        "predicates": [
            "HasDisease(x) ::: x has the disease",
            "IsDiagnosed(x) ::: x is diagnosed",
            "IsPatient(x) ::: x is a patient",
            "PrescribedMedication(x) ::: x is prescribed medication",
            "ReceivesTreatment(x) ::: x receives treatment"
        ]
    },
    {
        "premises-NL": [
            "All candidates with experience meet the requirements.",
            "Anyone who meets the requirement and is interviewed will pass the test.",
            "If someone passes the test, they are hired.",
            "If someone is a candidate and is interviewed, they will be given a reference.",
            "If someone is interviewed then they are a candidate.",
            "John is a candidate.",
            "John has experience.",
            "John is interviewed.",
            "John's skills match the requirement."
        ],
        "premises-FOL": [
            "∀x (HasExperience(x) → MeetsRequirement(x)) ::: All candidates with experience meet the requirements.",
            "∀x ((MeetsRequirement(x) ∧ IsInterviewed(x)) → PassedTest(x)) ::: Anyone who meets the requirement and is interviewed will pass the test.",
            "∀x (PassedTest(x) → IsHired(x)) ::: If someone passes the test, they are hired.",
            "∀x ((IsCandidate(x) ∧ IsInterviewed(x)) → HasReference(x)) ::: If someone is a candidate and is interviewed, they will be given a reference.",
            "∀x (IsInterviewed(x) → IsCandidate(x)) ::: If someone is interviewed then they are a candidate.",
            "IsCandidate(john) ::: John is a candidate.",
            "HasExperience(john) ::: John has experience.",
            "IsInterviewed(john) ::: John is interviewed.",
            "SkillsMatch(john, requirement) ::: John's skills match the requirement."
        ],
        "predicates": [
            "IsCandidate(x) ::: x is a candidate",
            "HasExperience(x) ::: x has experience",
            "IsInterviewed(x) ::: x is interviewed",
            "HasReference(x) ::: x has a reference",
            "IsHired(x) ::: x is hired",
            "MeetsRequirement(x) ::: x meets the requirement",
            "PassedTest(x) ::: x passed the test",
            "IsQualified(x) ::: x is qualified",
            "SkillsMatch(x, y) ::: x's skills match the requirement y"
        ]
    },
    {
        "premises-NL": [
            "Everyone who studies science is a scientist.",
            "Some people who are smart study science.",
            "Anyone who likes math is smart.",
            "A is smart and likes math.",
            "Someone is smart.",
            "If someone likes math, they are smart.",
            "If someone is smart, they study science.",
            "B likes math.",
            "If someone likes math they are smart.",
            "Everyone who is smart is a scientist.",
            "B studies science."
        ],
        "premises-FOL": [
            "∀x (StudiesScience(x) → IsScientist(x)) ::: For all x, if x studies science, then x is a scientist.",
            "∃x (IsSmart(x) ∧ StudiesScience(x)) ::: There exists an x such that x is smart and studies science.",
            "∀x (LikesMath(x) → IsSmart(x)) ::: For all x, if x likes math, then x is smart.",
            "LikesMath(a) ∧ IsSmart(a) ::: A likes math and is smart.",
            "∃x IsSmart(x) ::: There exists someone who is smart.",
            "∀x (LikesMath(x) → IsSmart(x)) ::: For all x, if x likes math, then x is smart.",
            "∀x (IsSmart(x) → StudiesScience(x)) ::: For all x, if x is smart, they study science.",
            "LikesMath(b) ::: B likes math.",
            "∀x (LikesMath(x) → IsSmart(x)) ::: For all x, if x likes math, then x is smart.",
            "∀x (IsSmart(x) → IsScientist(x)) ::: For all x, if x is smart, then x is a scientist.",
            "StudiesScience(b) ::: B studies science."
        ],
        "predicates": [
            "LikesMath(x) ::: Person x likes math.",
            "IsScientist(x) ::: Person x is a scientist.",
            "IsSmart(x) ::: Person x is smart.",
            "StudiesScience(x) ::: Person x studies science."
        ]
    },
    {
        "premises-NL": [
            "All students are registered in the university.",
            "Some students study hard.",
            "Anyone who fails the exam didn't study hard.",
            "No student can both fail and pass the exam.",
            "If a student is registered, then they are a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Registered(x)) ::: All students are registered in the university.",
            "∃x (Student(x) ∧ StudiesHard(x)) ::: Some students study hard.",
            "∀x (FailsExam(x) → ¬StudiesHard(x)) ::: Anyone who fails the exam didn't study hard.",
            "∀x (¬PassesExam(x) ∨ ¬FailsExam(x)) ::: No student can both fail and pass the exam.",
            "∀x (Registered(x) → Student(x)) ::: If a student is registered, then they are a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "FailsExam(x) ::: x fails the exam",
            "PassesExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "All doctors are specialists.",
            "All specialists practice medicine.",
            "Some doctors help the sick.",
            "Everyone who helps the sick has a degree.",
            "Some specialists have a degree.",
            "If someone is a doctor, they have a degree."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Specialist(x)) ::: All doctors are specialists.",
            "∀x (Specialist(x) → PracticesMedicine(x)) ::: All specialists practice medicine.",
            "∃x (Doctor(x) ∧ HelpsSick(x)) ::: Some doctors help the sick.",
            "∀x (HelpsSick(x) → HasDegree(x)) ::: Everyone who helps the sick has a degree.",
            "∃x (Specialist(x) ∧ HasDegree(x)) ::: Some specialists have a degree.",
            "∀x (Doctor(x) → HasDegree(x)) ::: If someone is a doctor, they have a degree."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Specialist(x) ::: x is a specialist",
            "PracticesMedicine(x) ::: x practices medicine",
            "HelpsSick(x) ::: x helps the sick",
            "HasDegree(x) ::: x has a degree"
        ]
    },
    {
        "premises-NL": [
            "All programmers use computers.",
            "If someone is a programmer, they have skills.",
            "Anyone who uses a computer and has skills can develop software.",
            "Some programmers know Python.",
            "Anyone who knows Python learns to code.",
            "If someone learns to code and is good at coding, they can develop software.",
            "All programmers work at a tech company.",
            "If a person is a programmer and knows Python, they are good at coding."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → UsesComputer(x)) ::: All programmers use computers.",
            "∀x (Programmer(x) → HasSkills(x)) ::: If someone is a programmer, they have skills.",
            "∀x (UsesComputer(x) ∧ HasSkills(x) → DevelopsSoftware(x)) ::: Anyone who uses a computer and has skills can develop software.",
            "∃x (Programmer(x) ∧ KnowsPython(x)) ::: Some programmers know Python.",
            "∀x (KnowsPython(x) → Learns(x, Coding)) ::: Anyone who knows Python learns to code.",
            "∀x (Learns(x, Coding) ∧ GoodAtCoding(x) → DevelopsSoftware(x)) ::: If someone learns to code and is good at coding, they can develop software.",
            "∀x (Programmer(x) → WorksAtTechCompany(x)) ::: All programmers work at a tech company.",
            "∀x (Programmer(x) ∧ KnowsPython(x) → GoodAtCoding(x)) ::: If a person is a programmer and knows Python, they are good at coding."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "KnowsPython(x) ::: x knows Python",
            "WorksAtTechCompany(x) ::: x works at a tech company",
            "DevelopsSoftware(x) ::: x develops software",
            "UsesComputer(x) ::: x uses a computer",
            "HasSkills(x) ::: x has skills",
            "Learns(x, y) ::: x learns y",
            "GoodAtCoding(x) ::: x is good at coding"
        ]
    },
    {
        "premises-NL": [
            "All mammals are animals.",
            "All animals that breathe air have lungs.",
            "All animals with lungs need oxygen.",
            "If an animal is aquatic, then it is in water.",
            "No animal that is in water lives on land.",
            "All mammals need oxygen.",
            "Some mammals eat plants.",
            "If an animal is a mammal, it breathes air.",
            "An animal either lives on land or in water."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → Animal(x)) ::: All mammals are animals.",
            "∀x (Animal(x) ∧ BreathesAir(x) → HasLungs(x)) ::: All animals that breathe air have lungs.",
            "∀x (HasLungs(x) → NeedsOxygen(x)) ::: All animals with lungs need oxygen.",
            "∀x (Aquatic(x) → InWater(x)) ::: If an animal is aquatic, then it is in water.",
            "∀x (InWater(x) → ¬LivesOnLand(x)) ::: No animal that is in water lives on land.",
            "∀x (Mammal(x) → NeedsOxygen(x)) ::: All mammals need oxygen.",
            "∃x (Mammal(x) ∧ EatsPlants(x)) ::: Some mammals eat plants.",
            "∀x (Mammal(x) → BreathesAir(x)) ::: If an animal is a mammal, it breathes air.",
            "∀x (LivesOnLand(x) ∨ InWater(x)) ::: An animal either lives on land or in water."
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal",
            "BreathesAir(x) ::: x breathes air",
            "Aquatic(x) ::: x is aquatic",
            "LivesOnLand(x) ::: x lives on land",
            "Animal(x) ::: x is an animal",
            "HasLungs(x) ::: x has lungs",
            "NeedsOxygen(x) ::: x needs oxygen",
            "InWater(x) ::: x is in water",
            "EatsPlants(x) ::: x eats plants"
        ]
    },
    {
        "premises-NL": [
            "All students who study biology and chemistry are researchers if they study both.",
            "All researchers are scientists.",
            "If someone studies both biology and chemistry, and they are a student, then they are a researcher.",
            "A student studies biology.",
            "A student studies chemistry."
        ],
        "premises-FOL": [
            "∀x ((Student(x) ∧ Studies(x, biology) ∧ Studies(x, chemistry)) → Researcher(x)) ::: All students who study biology and chemistry are researchers if they study both.",
            "∀x (Researcher(x) → Scientist(x)) ::: All researchers are scientists.",
            "∀x ((Studies(x, biology) ∧ Studies(x, chemistry) ∧ Student(x)) → Researcher(x)) ::: If someone studies both biology and chemistry, and they are a student, then they are a researcher.",
            "∃x (Student(x) ∧ Studies(x, biology)) ::: A student studies biology.",
            "∃x (Student(x) ∧ Studies(x, chemistry)) ::: A student studies chemistry."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Studies(x, y) ::: x studies y.",
            "Biology(x) ::: x is biology.",
            "Chemistry(x) ::: x is chemistry.",
            "Researcher(x) ::: x is a researcher.",
            "Scientist(x) ::: x is a scientist."
        ]
    },
    {
        "premises-NL": [
            "All smart students study hard if they are enrolled in a class.",
            "If someone is enrolled in a class they are a student.",
            "Someone is smart and enrolled in a class.",
            "If someone is smart and enrolled in a class, they study hard.",
            "All students are successful if they like a subject.",
            "Someone is enrolled in a class and likes a subject.",
            "If someone studies hard they like the subject.",
            "Some class is enjoyed"
        ],
        "premises-FOL": [
            "∀x ((Smart(x) ∧ EnrolledIn(x, y)) → StudiesHard(x)) ::: All smart students study hard if they are enrolled in a class.",
            "∀x ∀y (EnrolledIn(x, y) → Student(x)) ::: If someone is enrolled in a class they are a student.",
            "∃x ∃y (Smart(x) ∧ EnrolledIn(x, y)) ::: Someone is smart and enrolled in a class.",
            "∀x ∀y ((Smart(x) ∧ EnrolledIn(x, y)) → StudiesHard(x)) ::: If someone is smart and enrolled in a class, they study hard.",
            "∀x ∀y ((Student(x) ∧ Likes(x, y)) → Successful(x)) ::: All students are successful if they like a subject.",
            "∃x ∃y (EnrolledIn(x, y) ∧ Likes(x, y)) ::: Someone is enrolled in a class and likes a subject.",
            "∀x ∀y (StudiesHard(x) → Likes(x, y)) ::: If someone studies hard they like the subject.",
            "∃x Class(x) ::: Some class is enjoyed"
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Smart(x) ::: x is smart.",
            "StudiesHard(x) ::: x studies hard.",
            "Successful(x) ::: x is successful.",
            "EnrolledIn(x, y) ::: x is enrolled in y.",
            "Class(x) ::: x is a class.",
            "Likes(x, y) ::: x likes y."
        ]
    },
    {
        "premises-NL": [
            "Every student either studies hard or likes pizza.",
            "If someone studies hard, they will pass the exam.",
            "Every student either eats pizza or is happy.",
            "If someone eats pizza, then they are happy.",
            "Every student either has a car or drives a car.",
            "If someone has a car, they drive the car.",
            "Every student either can swim or is at the beach.",
            "If someone can swim, they are at the beach.",
            "Every student either has a book or reads a book.",
            "If someone has a book, they reads the book.",
            "Every student either plays guitar or likes pizza.",
            "If someone plays guitar, they are happy.",
            "John is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (StudiesHard(x) ∨ LikesPizza(x))) ::: Every student either studies hard or likes pizza.",
            "∀x (StudiesHard(x) → PassesExam(x)) ::: If someone studies hard, they will pass the exam.",
            "∀x (Student(x) → (EatsPizza(x) ∨ IsHappy(x))) ::: Every student either eats pizza or is happy.",
            "∀x (EatsPizza(x) → IsHappy(x)) ::: If someone eats pizza, then they are happy.",
            "∀x (Student(x) → (HasCar(x) ∨ DrivesCar(x))) ::: Every student either has a car or drives a car.",
            "∀x (HasCar(x) → DrivesCar(x)) ::: If someone has a car, they drive the car.",
            "∀x (Student(x) → (CanSwim(x) ∨ IsAtBeach(x))) ::: Every student either can swim or is at the beach.",
            "∀x (CanSwim(x) → IsAtBeach(x)) ::: If someone can swim, they are at the beach.",
            "∀x (Student(x) → (HasBook(x) ∨ ReadsBook(x))) ::: Every student either has a book or reads a book.",
            "∀x (HasBook(x) → ReadsBook(x)) ::: If someone has a book, they reads the book.",
            "∀x (Student(x) → (PlaysGuitar(x) ∨ LikesPizza(x))) ::: Every student either plays guitar or likes pizza.",
            "∀x (PlaysGuitar(x) → IsHappy(x)) ::: If someone plays guitar, they are happy.",
            "Student(john) ::: John is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassesExam(x) ::: x passes the exam",
            "LikesPizza(x) ::: x likes pizza",
            "EatsPizza(x) ::: x eats pizza",
            "IsHappy(x) ::: x is happy",
            "HasCar(x) ::: x has a car",
            "DrivesCar(x) ::: x drives a car",
            "CanSwim(x) ::: x can swim",
            "IsAtBeach(x) ::: x is at the beach",
            "HasBook(x) ::: x has a book",
            "ReadsBook(x) ::: x reads a book",
            "PlaysGuitar(x) ::: x plays guitar"
        ]
    },
    {
        "premises-NL": [
            "If it is raining, then the ground is wet.",
            "If it is raining, then John will stay indoors or take an umbrella.",
            "If John stays indoors, then he reads a book or watches a movie.",
            "If John reads a book, then he has a book.",
            "If John watches a movie, then he likes the movie.",
            "If John goes to the cinema, he buys popcorn.",
            "If John buys popcorn, he is happy.",
            "If it is cold, then John wears a coat.",
            "If John is cold, he drinks hot chocolate.",
            "If it is raining, then John is cold.",
            "John is a person.",
            "It is raining.",
            "The ground is wet.",
            "John likes the movie.",
            "John has a book."
        ],
        "premises-FOL": [
            "∀x (Raining(x) → GroundWet(x)) ::: If it is raining, then the ground is wet.",
            "∀x (Raining(x) → (StayIndoors(john) ∨ TakesUmbrella(john))) ::: If it is raining, then John will stay indoors or take an umbrella.",
            "∀x (StayIndoors(john) → (ReadsBook(john) ∨ WatchesMovie(john))) ::: If John stays indoors, then he reads a book or watches a movie.",
            "∀x (ReadsBook(john) → HasBook(john)) ::: If John reads a book, then he has a book.",
            "∀x (WatchesMovie(john) → LikesMovie(john)) ::: If John watches a movie, then he likes the movie.",
            "∀x (GoesToCinema(john) → BuysPopcorn(john)) ::: If John goes to the cinema, he buys popcorn.",
            "∀x (BuysPopcorn(john) → IsHappy(john)) ::: If John buys popcorn, he is happy.",
            "∀x (IsCold(john) → WearsCoat(john)) ::: If it is cold, then John wears a coat.",
            "∀x (IsCold(john) → DrinksHotChocolate(john)) ::: If John is cold, he drinks hot chocolate.",
            "∀x (Raining(x) → IsCold(john)) ::: If it is raining, then John is cold.",
            "Person(john) ::: John is a person.",
            "Raining(location) ::: It is raining.",
            "GroundWet(location) ::: The ground is wet.",
            "LikesMovie(john) ::: John likes the movie.",
            "HasBook(john) ::: John has a book."
        ],
        "predicates": [
            "Raining(x) ::: It is raining at location x",
            "GroundWet(x) ::: The ground is wet at location x",
            "StayIndoors(x) ::: x stays indoors",
            "TakesUmbrella(x) ::: x takes an umbrella",
            "Person(x) ::: x is a person",
            "WearsCoat(x) ::: x wears a coat",
            "IsCold(x) ::: x is cold",
            "DrinksHotChocolate(x) ::: x drinks hot chocolate",
            "ReadsBook(x) ::: x reads a book",
            "HasBook(x) ::: x has a book",
            "WatchesMovie(x) ::: x watches a movie",
            "LikesMovie(x) ::: x likes the movie",
            "GoesToCinema(x) ::: x goes to the cinema",
            "BuysPopcorn(x) ::: x buys popcorn",
            "IsHappy(x) ::: x is happy"
        ]
    },
    {
        "premises-NL": [
            "Every plant needs sunlight.",
            "Every plant needs water.",
            "If something is a plant and needs sunlight, then it receives sunlight.",
            "If something is a plant and needs water, then it receives water.",
            "If something grows, then it is alive.",
            "If something is a tree, then it is a plant.",
            "If something is a flower, then it is a plant.",
            "If something bears fruit, then it is a plant and grows.",
            "If something is a tree, it provides oxygen.",
            "If a plant receives sunlight and water, then it grows.",
            "Something is a plant.",
            "That thing needs sunlight.",
            "That thing needs water.",
            "If that thing bears fruit, it must be a tree.",
            "If something is a flower, then it is short.",
            "If something lives in the forest, then it is a tree.",
            "If something is a tree, then it has leaves."
        ],
        "premises-FOL": [
            "∀x (Plant(x) → NeedsSunlight(x)) ::: Every plant needs sunlight.",
            "∀x (Plant(x) → NeedsWater(x)) ::: Every plant needs water.",
            "∀x (Plant(x) ∧ NeedsSunlight(x) → ReceivesSunlight(x)) ::: If something is a plant and needs sunlight, then it receives sunlight.",
            "∀x (Plant(x) ∧ NeedsWater(x) → ReceivesWater(x)) ::: If something is a plant and needs water, then it receives water.",
            "∀x (Grows(x) → IsAlive(x)) ::: If something grows, then it is alive.",
            "∀x (IsTree(x) → Plant(x)) ::: If something is a tree, then it is a plant.",
            "∀x (IsFlower(x) → Plant(x)) ::: If something is a flower, then it is a plant.",
            "∀x (BearsFruit(x) → Plant(x) ∧ Grows(x)) ::: If something bears fruit, then it is a plant and grows.",
            "∀x (IsTree(x) → ProvidesOxygen(x)) ::: If something is a tree, it provides oxygen.",
            "∀x (Plant(x) ∧ ReceivesSunlight(x) ∧ ReceivesWater(x) → Grows(x)) ::: If a plant receives sunlight and water, then it grows.",
            "∃x Plant(x) ::: Something is a plant.",
            "NeedsSunlight(that) ::: That thing needs sunlight.",
            "NeedsWater(that) ::: That thing needs water.",
            "∀x (BearsFruit(x) → IsTree(x)) ::: If that thing bears fruit, it must be a tree.",
            "∀x (IsFlower(x) → IsShort(x)) ::: If something is a flower, then it is short.",
            "∀x (LivesInForest(x) → IsTree(x)) ::: If something lives in the forest, then it is a tree.",
            "∀x (IsTree(x) → HasLeaves(x)) ::: If something is a tree, then it has leaves."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "ReceivesSunlight(x) ::: x receives sunlight",
            "ReceivesWater(x) ::: x receives water",
            "Grows(x) ::: x grows",
            "IsGreen(x) ::: x is green",
            "HasLeaves(x) ::: x has leaves",
            "NeedsSunlight(x) ::: x needs sunlight",
            "NeedsWater(x) ::: x needs water",
            "IsAlive(x) ::: x is alive",
            "BearsFruit(x) ::: x bears fruit",
            "ProvidesOxygen(x) ::: x provides oxygen",
            "IsTall(x) ::: x is tall",
            "IsShort(x) ::: x is short",
            "LivesInForest(x) ::: x lives in the forest",
            "IsTree(x) ::: x is a tree",
            "IsFlower(x) ::: x is a flower"
        ]
    },
    {
        "premises-NL": [
            "All professors are academics.",
            "Alex is a professor.",
            "All professors are researchers.",
            "Some researchers publish papers.",
            "Anyone who publishes a paper is an academic.",
            "If someone is a professor, then they have a PhD.",
            "Alex has a PhD.",
            "If Alex has a PhD, then Alex is highly educated.",
            "If Alex is highly educated, then Alex is an academic.",
            "Alex teaches.",
            "Teaching is a form of academic work.",
            "If someone teaches, then they are an academic.",
            "Alex does research.",
            "If someone does research, they are an academic."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Academic(x)) ::: All professors are academics.",
            "Professor(alex) ::: Alex is a professor.",
            "∀x (Professor(x) → Researcher(x)) ::: All professors are researchers.",
            "∃x PublishesPaper(x) ::: Some researchers publish papers.",
            "∀x (PublishesPaper(x) → Academic(x)) ::: Anyone who publishes a paper is an academic.",
            "Professor(x) → PhD(x) ::: If someone is a professor, then they have a PhD.",
            "PhD(alex) ::: Alex has a PhD.",
            "PhD(alex) → HighlyEducated(alex) ::: If Alex has a PhD, then Alex is highly educated.",
            "HighlyEducated(alex) → Academic(alex) ::: If Alex is highly educated, then Alex is an academic.",
            "Teaches(alex) ::: Alex teaches.",
            "∀x (Teaches(x) → AcademicWork(x)) ::: Teaching is a form of academic work.",
            "∀x (Teaches(x) → Academic(x)) ::: If someone teaches, then they are an academic.",
            "DoesResearch(alex) ::: Alex does research.",
            "∀x (DoesResearch(x) → Academic(x)) ::: If someone does research, they are an academic."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor.",
            "Academic(x) ::: x is an academic.",
            "Researcher(x) ::: x is a researcher.",
            "PublishesPaper(x) ::: x publishes a paper."
        ]
    },
    {
        "premises-NL": [
            "If a student is enrolled, they must attend lectures.",
            "If a student attends lectures, they must study.",
            "If a student studies, they understand the material.",
            "If a student understands the material, they can participate.",
            "If a student participates, they will attempt the exam.",
            "If a student attempts the exam and studies, they might pass.",
            "If a student passes, they score more than 50%.",
            "John is enrolled.",
            "If John studies, then John participates.",
            "If John attends lectures and studies, then he will pass.",
            "If John studies, he will score more than 50%.",
            "If John attends lectures, he studies.",
            "If John scores more than 50%, then he passes the exam.",
            "If John studies and understands the material, he will pass.",
            "If John is enrolled and studies, he will participate.",
            "If John studies, then he can pass."
        ],
        "premises-FOL": [
            "∀x (Enrolled(x) → AttendsLectures(x)) ::: If a student is enrolled, they must attend lectures.",
            "∀x (AttendsLectures(x) → Studies(x)) ::: If a student attends lectures, they must study.",
            "∀x (Studies(x) → UnderstandsMaterial(x)) ::: If a student studies, they understand the material.",
            "∀x (UnderstandsMaterial(x) → Participates(x)) ::: If a student understands the material, they can participate.",
            "∀x (Participates(x) → AttemptsExam(x)) ::: If a student participates, they will attempt the exam.",
            "∀x (AttemptsExam(x) ∧ Studies(x) → PassExam(x)) ::: If a student attempts the exam and studies, they might pass.",
            "∀x (PassExam(x) → ScoreGreaterThan50(x)) ::: If a student passes, they score more than 50%.",
            "Enrolled(john) ::: John is enrolled.",
            "Studies(john) → Participates(john) ::: If John studies, then John participates.",
            "(AttendsLectures(john) ∧ Studies(john)) → PassExam(john) ::: If John attends lectures and studies, then he will pass.",
            "Studies(john) → ScoreGreaterThan50(john) ::: If John studies, he will score more than 50%.",
            "AttendsLectures(john) → Studies(john) ::: If John attends lectures, he studies.",
            "ScoreGreaterThan50(john) → PassExam(john) ::: If John scores more than 50%, then he passes the exam.",
            "Studies(john) ∧ UnderstandsMaterial(john) → PassExam(john) ::: If John studies and understands the material, he will pass.",
            "(Enrolled(john) ∧ Studies(john)) → Participates(john) ::: If John is enrolled and studies, he will participate.",
            "Studies(john) → PassExam(john) ::: If John studies, then he can pass."
        ],
        "predicates": [
            "Enrolled(x) ::: x is enrolled.",
            "Participates(x) ::: x participates.",
            "ScoreGreaterThan50(x) ::: x scores more than 50%.",
            "Studies(x) ::: x studies.",
            "AttendsLectures(x) ::: x attends lectures.",
            "UnderstandsMaterial(x) ::: x understands the material.",
            "PassExam(x) ::: x passes the exam."
        ]
    },
    {
        "premises-NL": [
            "All doctors who work at hospitals have high incomes.",
            "Any doctor who specializes in surgery is successful.",
            "All doctors are employed.",
            "Everyone with a high income is wealthy.",
            "Anyone who is successful and employed lives in luxury.",
            "Everyone who lives in luxury is wealthy.",
            "Every surgeon is a doctor.",
            "Some surgeons work at hospitals.",
            "Anyone who is educated is a doctor.",
            "Dr. Smith is educated."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) ∧ WorksAtHospital(x) → HasHighIncome(x)) ::: All doctors who work at hospitals have high incomes.",
            "∀x (Doctor(x) ∧ SpecializesInSurgery(x) → IsSuccessful(x)) ::: Any doctor who specializes in surgery is successful.",
            "∀x (Doctor(x) → IsEmployed(x)) ::: All doctors are employed.",
            "∀x (HasHighIncome(x) → Wealthy(x)) ::: Everyone with a high income is wealthy.",
            "∀x (IsSuccessful(x) ∧ IsEmployed(x) → LivesInLuxury(x)) ::: Anyone who is successful and employed lives in luxury.",
            "∀x (LivesInLuxury(x) → Wealthy(x)) ::: Everyone who lives in luxury is wealthy.",
            "∀x (SpecializesInSurgery(x) → Doctor(x)) ::: Every surgeon is a doctor.",
            "∃x (SpecializesInSurgery(x) ∧ WorksAtHospital(x)) ::: Some surgeons work at hospitals.",
            "∀x (IsEducated(x) → Doctor(x)) ::: Anyone who is educated is a doctor.",
            "Doctor(smith) ::: Dr. Smith is educated."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Wealthy(x) ::: x is wealthy",
            "WorksAtHospital(x) ::: x works at a hospital",
            "HasHighIncome(x) ::: x has a high income",
            "SpecializesInSurgery(x) ::: x specializes in surgery",
            "IsSuccessful(x) ::: x is successful",
            "IsEmployed(x) ::: x is employed",
            "IsEducated(x) ::: x is educated",
            "LivesInLuxury(x) ::: x lives in luxury"
        ]
    },
    {
        "premises-NL": [
            "All students who take calculus like math.",
            "All students who take physics like science.",
            "All students who are smart study hard.",
            "All students who study hard get good grades.",
            "Anyone who gets good grades is qualified for university.",
            "All students who are qualified for university attend the university.",
            "John takes calculus and physics.",
            "John is a student and is smart.",
            "Anyone who takes calculus likes math.",
            "If someone takes physics, they like science.",
            "Anyone who attends the university is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ TakesCalculus(x) → LikesMath(x)) ::: All students who take calculus like math.",
            "∀x (Student(x) ∧ TakesPhysics(x) → LikesScience(x)) ::: All students who take physics like science.",
            "∀x (Student(x) ∧ IsSmart(x) → StudiesHard(x)) ::: All students who are smart study hard.",
            "∀x (StudiesHard(x) → GetsGoodGrades(x)) ::: All students who study hard get good grades.",
            "∀x (GetsGoodGrades(x) → QualifiedForUniversity(x)) ::: Anyone who gets good grades is qualified for university.",
            "∀x (QualifiedForUniversity(x) → AttendsUniversity(x)) ::: All students who are qualified for university attend the university.",
            "TakesCalculus(john) ∧ TakesPhysics(john) ::: John takes calculus and physics.",
            "Student(john) ∧ IsSmart(john) ::: John is a student and is smart.",
            "∀x (TakesCalculus(x) → LikesMath(x)) ::: Anyone who takes calculus likes math.",
            "∀x (TakesPhysics(x) → LikesScience(x)) ::: If someone takes physics, they like science.",
            "∀x (AttendsUniversity(x) → Student(x)) ::: Anyone who attends the university is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "LikesMath(x) ::: x likes math",
            "LikesScience(x) ::: x likes science",
            "AttendsUniversity(x) ::: x attends the university",
            "TakesCalculus(x) ::: x takes calculus",
            "TakesPhysics(x) ::: x takes physics",
            "IsSmart(x) ::: x is smart",
            "StudiesHard(x) ::: x studies hard",
            "GetsGoodGrades(x) ::: x gets good grades",
            "QualifiedForUniversity(x) ::: x is qualified for university",
            "AttendsUniversity(x) ::: x attends university"
        ]
    },
    {
        "premises-NL": [
            "Every person who earns a lot has a high salary.",
            "Everyone with a high salary is wealthy.",
            "All wealthy people own a house or a car.",
            "If someone owns a house and a car, and is wealthy, then they have a high salary",
            "Someone earns a lot and sells assets.",
            "Anyone who sells assets invests money.",
            "Anyone who invests money and earns a lot buys luxury items.",
            "Those who buy luxury items are wealthy.",
            "Someone who works hard earns a lot.",
            "If someone works hard and invests money they are wealthy.",
            "If someone sells assets then they own a car and a house.",
            "If someone is wealthy they either own a car or a house."
        ],
        "premises-FOL": [
            "∀x (Person(x) ∧ EarnsALot(x) → HasHighSalary(x)) ::: Every person who earns a lot has a high salary.",
            "∀x (HasHighSalary(x) → Wealthy(x)) ::: Everyone with a high salary is wealthy.",
            "∀x (Wealthy(x) → OwnsHouse(x) ∨ OwnsCar(x)) ::: All wealthy people own a house or a car.",
            "∀x (OwnsHouse(x) ∧ OwnsCar(x) ∧ Wealthy(x) → HasHighSalary(x)) ::: If someone owns a house and a car, and is wealthy, then they have a high salary",
            "∃x (EarnsALot(x) ∧ SellsAssets(x)) ::: Someone earns a lot and sells assets.",
            "∀x (SellsAssets(x) → InvestsMoney(x)) ::: Anyone who sells assets invests money.",
            "∀x (InvestsMoney(x) ∧ EarnsALot(x) → BuysLuxuryItems(x)) ::: Anyone who invests money and earns a lot buys luxury items.",
            "∀x (BuysLuxuryItems(x) → Wealthy(x)) ::: Those who buy luxury items are wealthy.",
            "∃x (WorksHard(x) ∧ EarnsALot(x)) ::: Someone who works hard earns a lot.",
            "∀x (WorksHard(x) ∧ InvestsMoney(x) → Wealthy(x)) ::: If someone works hard and invests money they are wealthy.",
            "∀x (SellsAssets(x) → OwnsCar(x) ∧ OwnsHouse(x)) ::: If someone sells assets then they own a car and a house.",
            "∀x (Wealthy(x) → OwnsCar(x) ∨ OwnsHouse(x)) ::: If someone is wealthy they either own a car or a house."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "OwnsCar(x) ::: x owns a car",
            "OwnsHouse(x) ::: x owns a house",
            "Wealthy(x) ::: x is wealthy",
            "HasHighSalary(x) ::: x has a high salary",
            "SpendsMoney(x, y) ::: x spends money on y",
            "SavesMoney(x) ::: x saves money",
            "WorksHard(x) ::: x works hard",
            "BuysLuxuryItems(x) ::: x buys luxury items",
            "EarnsALot(x) ::: x earns a lot",
            "SellsAssets(x) ::: x sells assets",
            "InvestsMoney(x) ::: x invests money"
        ]
    },
    {
        "premises-NL": [
            "All students who study computer science take a programming course.",
            "All students who take a programming course like programming.",
            "Students who take a logic course like logic.",
            "All intelligent students take logic and math courses.",
            "All diligent students take programming and logic courses.",
            "Anyone who takes a math course likes math.",
            "Anyone who takes a programming course and takes a logic course, enjoys challenges.",
            "Anyone who enjoys challenges, is intelligent.",
            "Anyone who studies computer science and uses computers, takes a programming course.",
            "Anyone who is a student and studies computer science will attend university.",
            "John is a student and is diligent.",
            "Anyone who likes programming and studies computer science does not like math.",
            "Everyone who takes a logic course attends the university."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesComputerScience(x) → TakesProgrammingCourse(x)) ::: All students who study computer science take a programming course.",
            "∀x (TakesProgrammingCourse(x) → LikesProgramming(x)) ::: All students who take a programming course like programming.",
            "∀x (TakesLogicCourse(x) → LikesLogic(x)) ::: Students who take a logic course like logic.",
            "∀x (IsIntelligent(x) → TakesLogicCourse(x) ∧ TakesMathCourse(x)) ::: All intelligent students take logic and math courses.",
            "∀x (Student(x) ∧ IsDiligent(x) → TakesProgrammingCourse(x) ∧ TakesLogicCourse(x)) ::: All diligent students take programming and logic courses.",
            "∀x (TakesMathCourse(x) → LikesMath(x)) ::: Anyone who takes a math course likes math.",
            "∀x (TakesProgrammingCourse(x) ∧ TakesLogicCourse(x) → EnjoysChallenges(x)) ::: Anyone who takes a programming course and takes a logic course, enjoys challenges.",
            "∀x (EnjoysChallenges(x) → IsIntelligent(x)) ::: Anyone who enjoys challenges, is intelligent.",
            "∀x (StudiesComputerScience(x) ∧ UsesComputers(x) → TakesProgrammingCourse(x)) ::: Anyone who studies computer science and uses computers, takes a programming course.",
            "∀x (Student(x) ∧ StudiesComputerScience(x) → AttendsUniversity(x)) ::: Anyone who is a student and studies computer science will attend university.",
            "Student(john) ∧ IsDiligent(john) ::: John is a student and is diligent.",
            "∀x (LikesProgramming(x) ∧ StudiesComputerScience(x) → ¬LikesMath(x)) ::: Anyone who likes programming and studies computer science does not like math.",
            "∀x (TakesLogicCourse(x) → AttendsUniversity(x)) ::: Everyone who takes a logic course attends the university."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "LikesLogic(x) ::: x likes logic",
            "LikesProgramming(x) ::: x likes programming",
            "LikesMath(x) ::: x likes math",
            "StudiesComputerScience(x) ::: x studies computer science",
            "TakesLogicCourse(x) ::: x takes a logic course",
            "TakesProgrammingCourse(x) ::: x takes a programming course",
            "TakesMathCourse(x) ::: x takes a math course",
            "IsIntelligent(x) ::: x is intelligent",
            "IsDiligent(x) ::: x is diligent",
            "EnjoysChallenges(x) ::: x enjoys challenges",
            "UsesComputers(x) ::: x uses computers",
            "AttendsUniversity(x) ::: x attends university"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "Anyone who treats patients and specializes in surgery is a doctor.",
            "Every researcher publishes papers.",
            "Anyone who publishes papers and studies diseases works at a university.",
            "All people who work at a university are employed by a hospital.",
            "Everyone who has a high income is wealthy.",
            "All doctors who treat patients and study diseases have a high income.",
            "All researchers who receive grants conduct research.",
            "Everyone who has a PhD is educated.",
            "All doctors who conduct research are also researchers.",
            "Anyone who studies diseases is a doctor and conducts research.",
            "All doctors who are educated are employed by a hospital.",
            "John is a doctor who is educated.",
            "John studies diseases."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → TreatsPatients(x)) ::: All doctors treat patients.",
            "∀x (TreatsPatients(x) ∧ IsSpecialized(x, surgery) → Doctor(x)) ::: Anyone who treats patients and specializes in surgery is a doctor.",
            "∀x (Researcher(x) → PublishesPapers(x)) ::: Every researcher publishes papers.",
            "∀x (PublishesPapers(x) ∧ StudiesDiseases(x) → WorksAtUniversity(x)) ::: Anyone who publishes papers and studies diseases works at a university.",
            "∀x (WorksAtUniversity(x) → EmploysHospital(x)) ::: All people who work at a university are employed by a hospital.",
            "∀x (HasHighIncome(x) → Wealthy(x)) ::: Everyone who has a high income is wealthy.",
            "∀x (Doctor(x) ∧ TreatsPatients(x) ∧ StudiesDiseases(x) → HasHighIncome(x)) ::: All doctors who treat patients and study diseases have a high income.",
            "∀x (Researcher(x) ∧ ReceivesGrants(x) → ConductsResearch(x)) ::: All researchers who receive grants conduct research.",
            "∀x (HasPhD(x) → IsEducated(x)) ::: Everyone who has a PhD is educated.",
            "∀x (Doctor(x) ∧ ConductsResearch(x) → Researcher(x)) ::: All doctors who conduct research are also researchers.",
            "∀x (StudiesDiseases(x) → Doctor(x) ∧ ConductsResearch(x)) ::: Anyone who studies diseases is a doctor and conducts research.",
            "∀x (Doctor(x) ∧ IsEducated(x) → EmploysHospital(x)) ::: All doctors who are educated are employed by a hospital.",
            "Doctor(john) ∧ IsEducated(john) ::: John is a doctor who is educated.",
            "StudiesDiseases(john) ::: John studies diseases."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Researcher(x) ::: x is a researcher",
            "EmploysHospital(x) ::: x is employed by a hospital",
            "Wealthy(x) ::: x is wealthy",
            "WorksAtUniversity(x) ::: x works at a university",
            "PublishesPapers(x) ::: x publishes papers",
            "HasHighIncome(x) ::: x has a high income",
            "IsSpecialized(x, y) ::: x specializes in y",
            "TreatsPatients(x) ::: x treats patients",
            "StudiesDiseases(x) ::: x studies diseases",
            "ReceivesGrants(x) ::: x receives grants",
            "IsEducated(x) ::: x is educated",
            "HasPhD(x) ::: x has a PhD",
            "ConductsResearch(x) ::: x conducts research"
        ]
    },
    {
        "premises-NL": [
            "All students who attend classes study hard.",
            "Alex is a student.",
            "If Alex has good grades, then Alex attends classes.",
            "If Alex studies hard and Alex has good grades, then Alex passes the exam.",
            "Alex has good grades.",
            "All students attend classes.",
            "If someone is a student and studies hard, then they pass the exam.",
            "If someone is a student, then they either study hard or have good grades.",
            "Alex is a student and Alex attends classes."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ AttendsClasses(x) → StudiesHard(x)) ::: All students who attend classes study hard.",
            "Student(alex) ::: Alex is a student.",
            "HasGoodGrades(alex) → AttendsClasses(alex) ::: If Alex has good grades, then Alex attends classes.",
            "(StudiesHard(alex) ∧ HasGoodGrades(alex)) → PassesExam(alex) ::: If Alex studies hard and Alex has good grades, then Alex passes the exam.",
            "HasGoodGrades(alex) ::: Alex has good grades.",
            "∀x (Student(x) → AttendsClasses(x)) ::: All students attend classes.",
            "∀x (Student(x) ∧ StudiesHard(x) → PassesExam(x)) ::: If someone is a student and studies hard, then they pass the exam.",
            "∀x (Student(x) → StudiesHard(x) ∨ HasGoodGrades(x)) ::: If someone is a student, then they either study hard or have good grades.",
            "Student(alex) ∧ AttendsClasses(alex) ::: Alex is a student and Alex attends classes."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassesExam(x) ::: x passes the exam",
            "AttendsClasses(x) ::: x attends classes",
            "HasGoodGrades(x) ::: x has good grades"
        ]
    },
    {
        "premises-NL": [
            "All doctors are smart.",
            "All smart people are educated.",
            "If someone studies medicine, they will pass the exam.",
            "If someone passes the exam, they become a doctor.",
            "Some people study medicine."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Smart(x)) ::: All doctors are smart.",
            "∀x (Smart(x) → Educated(x)) ::: All smart people are educated.",
            "∀x (StudiesMedicine(x) → PassExam(x)) ::: If someone studies medicine, they will pass the exam.",
            "∀x (PassExam(x) → Doctor(x)) ::: If someone passes the exam, they become a doctor.",
            "∃x StudiesMedicine(x) ::: Some people study medicine."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Educated(x) ::: x is educated",
            "Smart(x) ::: x is smart",
            "StudiesMedicine(x) ::: x studies medicine",
            "PassExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "All professors are researchers.",
            "Some professors publish papers.",
            "If someone is a professor and publishes papers, they are a researcher.",
            "A professor teaches students.",
            "Students read their professors' papers.",
            "If someone is a professor, they publish papers."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Researcher(x)) ::: All professors are researchers.",
            "∃x PublishedPapers(x) ::: Some professors publish papers.",
            "∀x (Professor(x) ∧ PublishedPapers(x) → Researcher(x)) ::: If someone is a professor and publishes papers, they are a researcher.",
            "∀x ∃y Teaches(x, y) ::: A professor teaches students.",
            "∀y ∃x ReadsPapers(y, x) ::: Students read their professors' papers.",
            "∀x (Professor(x) → PublishedPapers(x)) ::: If someone is a professor, they publish papers."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "PublishedPapers(x) ::: x has published papers",
            "Researcher(x) ::: x is a researcher",
            "Teaches(x, y) ::: x teaches y",
            "Student(y) ::: y is a student",
            "ReadsPapers(y, x) ::: y reads x's papers"
        ]
    },
    {
        "premises-NL": [
            "All programmers know math.",
            "Anyone who knows math uses logic.",
            "If someone studies computer science, they know math.",
            "If someone uses logic, they are skilled.",
            "Some programmers study computer science.",
            "If someone is educated and solves problems, they are skilled.",
            "All educated people solve problems."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → KnowsMath(x)) ::: All programmers know math.",
            "∀x (KnowsMath(x) → UsesLogic(x)) ::: Anyone who knows math uses logic.",
            "∀x (StudiesComputerScience(x) → KnowsMath(x)) ::: If someone studies computer science, they know math.",
            "∀x (UsesLogic(x) → Skilled(x)) ::: If someone uses logic, they are skilled.",
            "∃x (Programmer(x) ∧ StudiesComputerScience(x)) ::: Some programmers study computer science.",
            "∀x ((Educated(x) ∧ SolvesProblems(x)) → Skilled(x)) ::: If someone is educated and solves problems, they are skilled.",
            "∀x (Educated(x) → SolvesProblems(x)) ::: All educated people solve problems."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "Skilled(x) ::: x is skilled",
            "Educated(x) ::: x is educated",
            "KnowsMath(x) ::: x knows math",
            "UsesLogic(x) ::: x uses logic",
            "StudiesComputerScience(x) ::: x studies computer science",
            "SolvesProblems(x) ::: x solves problems"
        ]
    },
    {
        "premises-NL": [
            "All tropical fruits are sweet.",
            "All mangoes are sweet.",
            "If something is sweet but not a mango, it's a pineapple or a banana.",
            "Pineapples grow in rainforests.",
            "Bananas are yellow.",
            "All pineapples have a crown.",
            "If something has a crown, it is a pineapple.",
            "All fruits that grow in a rainforest are tropical fruits."
        ],
        "premises-FOL": [
            "∀x (TropicalFruit(x) → Sweet(x)) ::: All tropical fruits are sweet.",
            "∀x (Mango(x) → Sweet(x)) ::: All mangoes are sweet.",
            "∀x ((Sweet(x) ∧ ¬Mango(x)) → (Pineapple(x) ∨ Banana(x))) ::: If something is sweet but not a mango, it's a pineapple or a banana.",
            "∀x (Pineapple(x) → GrowsInRainforest(x)) ::: Pineapples grow in rainforests.",
            "∀x (Banana(x) → Yellow(x)) ::: Bananas are yellow.",
            "∀x (Pineapple(x) → HasCrown(x)) ::: All pineapples have a crown.",
            "∀x (HasCrown(x) → Pineapple(x)) ::: If something has a crown, it is a pineapple.",
            "∀x (GrowsInRainforest(x) → TropicalFruit(x)) ::: All fruits that grow in a rainforest are tropical fruits."
        ],
        "predicates": [
            "TropicalFruit(x) ::: x is a tropical fruit",
            "Mango(x) ::: x is a mango",
            "Pineapple(x) ::: x is a pineapple",
            "Banana(x) ::: x is a banana",
            "Sweet(x) ::: x is sweet",
            "GrowsInRainforest(x) ::: x grows in a rainforest",
            "Yellow(x) ::: x is yellow",
            "HasCrown(x) ::: x has a crown"
        ]
    },
    {
        "premises-NL": [
            "All patients who have a fever are sick.",
            "Anyone who receives medication will either recover or be allergic.",
            "If someone is sick and needs rest, then they receive medication.",
            "Patients who are treated with antibiotics receive medication.",
            "No one who avoids sunlight is allergic.",
            "If someone recovers, then they avoid sunlight.",
            "Anyone who is sick and does not avoid sunlight, does not need rest.",
            "If someone is sick, they need rest.",
            "All antibiotics are medication."
        ],
        "premises-FOL": [
            "∀x (HasFever(x) → Sick(x)) ::: All patients who have a fever are sick.",
            "∀x (ReceivesMedication(x) → (Recover(x) ∨ Allergic(x))) ::: Anyone who receives medication will either recover or be allergic.",
            "∀x ((Sick(x) ∧ NeedsRest(x)) → ReceivesMedication(x)) ::: If someone is sick and needs rest, then they receive medication.",
            "∀x ∀y (IsTreated(x, y) ∧ Antibiotic(y) → ReceivesMedication(x)) ::: Patients who are treated with antibiotics receive medication.",
            "∀x (¬AvoidsSunlight(x) → ¬Allergic(x)) ::: No one who avoids sunlight is allergic.",
            "∀x (Recover(x) → AvoidsSunlight(x)) ::: If someone recovers, then they avoid sunlight.",
            "∀x (Sick(x) ∧ ¬AvoidsSunlight(x) → ¬NeedsRest(x)) ::: Anyone who is sick and does not avoid sunlight, does not need rest.",
            "∀x (Sick(x) → NeedsRest(x)) ::: If someone is sick, they need rest.",
            "∀y (Antibiotic(y) → ReceivesMedication(y)) ::: All antibiotics are medication."
        ],
        "predicates": [
            "Sick(x) ::: x is sick",
            "ReceivesMedication(x) ::: x receives medication",
            "Allergic(x) ::: x is allergic",
            "Recover(x) ::: x recovers",
            "HasFever(x) ::: x has a fever",
            "IsTreated(x, y) ::: x is treated with y",
            "Antibiotic(y) ::: y is an antibiotic",
            "NeedsRest(x) ::: x needs rest",
            "AvoidsSunlight(x) ::: x avoids sunlight"
        ]
    },
    {
        "premises-NL": [
            "All patients either have a disease or are treated with medication A.",
            "If a patient is not treated with medication A, they die.",
            "There exists a patient with a disease.",
            "If a patient dies, they are not treated with any medication.",
            "Every patient either has a disease or is treated with medication A or both."
        ],
        "premises-FOL": [
            "∀x (Patient(x) → (HasDisease(x) ∨ TreatedWithA(x))) ::: All patients either have a disease or are treated with medication A.",
            "∀x (Patient(x) ∧ ¬TreatedWithA(x) → Dies(x)) ::: If a patient is not treated with medication A, they die.",
            "∃x (Patient(x) ∧ HasDisease(x)) ::: There exists a patient with a disease.",
            "∀x (Dies(x) → ¬TreatedWithA(x)) ::: If a patient dies, they are not treated with any medication.",
            "∀x (Patient(x) → ((HasDisease(x) ∨ TreatedWithA(x)) ∧ ¬(HasDisease(x) ∧ TreatedWithA(x)))) ::: Every patient either has a disease or is treated with medication A or both."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient.",
            "HasDisease(x) ::: x has a disease.",
            "TreatedWithA(x) ::: x is treated with medication A.",
            "Dies(x) ::: x dies."
        ]
    },
    {
        "premises-NL": [
            "All students attending the lecture are diligent.",
            "All students in the class attend the lecture.",
            "Every student is either in class or not attending the lecture.",
            "There exists a student who is attending the lecture.",
            "If someone is a student, then they are either in class or attending the lecture.",
            "If someone is diligent and a student, then they pass.",
            "Some students in the class are not attending the lecture.",
            "All attending students are students."
        ],
        "premises-FOL": [
            "∀x (AttendsLecture(x) → Diligent(x)) ::: All students attending the lecture are diligent.",
            "∀x (StudentInClass(x) → AttendsLecture(x)) ::: All students in the class attend the lecture.",
            "∀x (Student(x) → (StudentInClass(x) ∨ ¬AttendsLecture(x))) ::: Every student is either in class or not attending the lecture.",
            "∃x AttendsLecture(x) ::: There exists a student who is attending the lecture.",
            "∀x (Student(x) → (StudentInClass(x) ∨ AttendsLecture(x))) ::: If someone is a student, then they are either in class or attending the lecture.",
            "∀x ((Diligent(x) ∧ Student(x)) → Pass(x)) ::: If someone is diligent and a student, then they pass.",
            "∃x (StudentInClass(x) ∧ ¬AttendsLecture(x)) ::: Some students in the class are not attending the lecture.",
            "∀x (AttendsLecture(x) → Student(x)) ::: All attending students are students."
        ],
        "predicates": [
            "StudentInClass(x) ::: x is a student in the class",
            "AttendsLecture(x) ::: x attends the lecture",
            "Diligent(x) ::: x is diligent",
            "Student(x) ::: x is a student"
        ]
    },
    {
        "premises-NL": [
            "All doctors are smart.",
            "Anyone who studies medicine and graduates becomes a doctor.",
            "If someone is a doctor, they work at a hospital.",
            "Sophia studies medicine.",
            "Sophia graduated.",
            "All smart people are successful.",
            "John is not a doctor.",
            "If John is a doctor, he works at a hospital.",
            "Sophia is a doctor or John is a doctor.",
            "If someone is a student, they are not a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Smart(x)) ::: All doctors are smart.",
            "∀x ((StudiesMedicine(x) ∧ Graduated(x)) → Doctor(x)) ::: Anyone who studies medicine and graduates becomes a doctor.",
            "∀x (Doctor(x) → WorksAtHospital(x)) ::: If someone is a doctor, they work at a hospital.",
            "StudiesMedicine(sophia) ::: Sophia studies medicine.",
            "Graduated(sophia) ::: Sophia graduated.",
            "∀x (Smart(x) → Successful(x)) ::: All smart people are successful.",
            "¬Doctor(john) ::: John is not a doctor.",
            "∀x (Doctor(john) → WorksAtHospital(john)) ::: If John is a doctor, he works at a hospital.",
            "Doctor(sophia) ∨ Doctor(john) ::: Sophia is a doctor or John is a doctor.",
            "∀x (Student(x) → ¬Doctor(x)) ::: If someone is a student, they are not a doctor."
        ],
        "predicates": [
            "Smart(x) ::: x is smart",
            "StudiesMedicine(x) ::: x studies medicine",
            "Doctor(x) ::: x is a doctor",
            "Graduated(x) ::: x graduated",
            "WorksAtHospital(x) ::: x works at a hospital"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "Some surgeons are not specialists.",
            "There are some surgeons."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: For all x, if x is a surgeon, then x is a doctor.",
            "∃x (Surgeon(x) ∧ ¬Specialist(x)) ::: There exists an x such that x is a surgeon and x is not a specialist.",
            "∃x Surgeon(x) ::: There exists an x such that x is a surgeon."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Specialist(x) ::: x is a specialist",
            "Surgeon(x) ::: x is a surgeon",
            "IsASurgeon(x, y) ::: x is a surgeon and y is a surgeon",
            "IsASpecialist(x, y) ::: x is a specialist and y is a specialist"
        ]
    },
    {
        "premises-NL": [
            "All students take either math or science, or both.",
            "John is a student.",
            "If someone takes math, then they are a student.",
            "If someone takes science, then they are a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (TakesMath(x) ∨ TakesScience(x))) ::: For all x, if x is a student, then x takes math or science.",
            "Student(john) ::: John is a student.",
            "∀x (TakesMath(x) → Student(x)) ::: For all x, if x takes math, then x is a student.",
            "∀x (TakesScience(x) → Student(x)) ::: For all x, if x takes science, then x is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "TakesMath(x) ::: x takes math",
            "TakesScience(x) ::: x takes science",
            "IsTaking(x, y) ::: x is taking y",
            "IsEnrolled(x, y) ::: x is enrolled in y"
        ]
    },
    {
        "premises-NL": [
            "All employees are either in the engineering department or the marketing department.",
            "No one in the marketing department works on the project.",
            "Some employees are in the marketing department.",
            "If someone is an employee and in the engineering department, then they work on the project.",
            "John is an employee."
        ],
        "premises-FOL": [
            "∀x (Employee(x) → (IsInDepartment(x, engineering) ∨ IsInDepartment(x, marketing))) ::: For all x, if x is an employee, then x is in the engineering or marketing department.",
            "∀x (IsInDepartment(x, marketing) → ¬WorksOnProject(x)) ::: For all x, if x is in the marketing department, then x does not work on the project.",
            "∃x (Employee(x) ∧ IsInDepartment(x, marketing)) ::: There exists an x such that x is an employee and is in the marketing department.",
            "∀x ((Employee(x) ∧ IsInDepartment(x, engineering)) → WorksOnProject(x)) ::: For all x, if x is an employee and is in the engineering department, then x works on the project.",
            "Employee(john) ::: John is an employee."
        ],
        "predicates": [
            "Employee(x) ::: x is an employee",
            "WorksOnProject(x) ::: x works on the project",
            "IsInDepartment(x, y) ::: x is in department y",
            "DepartmentHead(x) ::: x is a department head"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "Some doctors are happy.",
            "Every student is studious.",
            "All studious people are smart.",
            "Anyone who is smart passes the exam.",
            "Some students know a lot.",
            "Anyone who knows a lot gets a good grade.",
            "Anyone with a good grade is employed.",
            "Anyone who is employed earns money.",
            "Anyone who earns money is rich.",
            "Some rich people like to travel.",
            "Some rich people love their family.",
            "Anyone who is a doctor is employed.",
            "Anyone who is employed is happy.",
            "Anyone who is rich and loves their family is happy."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Treats(x, y)) ::: All doctors treat patients.",
            "∃x (Doctor(x) ∧ Happy(x)) ::: Some doctors are happy.",
            "∀x (Student(x) → Studious(x)) ::: Every student is studious.",
            "∀x (Studious(x) → Smart(x)) ::: All studious people are smart.",
            "∀x (Smart(x) → PassExam(x)) ::: Anyone who is smart passes the exam.",
            "∃x (Student(x) ∧ Knows(x, y)) ::: Some students know a lot.",
            "∀x (Knows(x, y) → GoodGrade(x)) ::: Anyone who knows a lot gets a good grade.",
            "∀x (GoodGrade(x) → IsEmployed(x)) ::: Anyone with a good grade is employed.",
            "∀x (IsEmployed(x) → EarnsMoney(x)) ::: Anyone who is employed earns money.",
            "∀x (EarnsMoney(x) → IsRich(x)) ::: Anyone who earns money is rich.",
            "∃x (IsRich(x) ∧ Likes(x, y)) ::: Some rich people like to travel.",
            "∃x (IsRich(x) ∧ Loves(x, y)) ::: Some rich people love their family.",
            "∀x (Doctor(x) → IsEmployed(x)) ::: Anyone who is a doctor is employed.",
            "∀x (IsEmployed(x) → Happy(x)) ::: Anyone who is employed is happy.",
            "∀x (IsRich(x) ∧ Loves(x, y) → Happy(x)) ::: Anyone who is rich and loves their family is happy."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Doctor(x) ::: x is a doctor",
            "Happy(x) ::: x is happy",
            "Patient(x) ::: x is a patient",
            "Treats(x, y) ::: x treats y",
            "Studious(x) ::: x is studious",
            "Smart(x) ::: x is smart",
            "PassExam(x) ::: x passes the exam",
            "Knows(x, y) ::: x knows y",
            "GoodGrade(x) ::: x has a good grade",
            "IsEmployed(x) ::: x is employed",
            "EarnsMoney(x) ::: x earns money",
            "IsRich(x) ::: x is rich",
            "Likes(x, y) ::: x likes y",
            "Loves(x, y) ::: x loves y"
        ]
    },
    {
        "premises-NL": [
            "All students who take the Logic course passed the exam.",
            "Some students take the Logic course.",
            "All students in the Programming class are taking the Logic course.",
            "John is a student.",
            "John is in the Programming class.",
            "All students are either in the Programming class or take the Logic course.",
            "If a student is taking the Logic course, they passed the exam.",
            "If a student is in the Programming class, they passed the exam.",
            "If a student takes a course and that course is the logic course, they passed the exam.",
            "If John passed the exam, then he's not in the programming class"
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ TakesCourse(x, \"Logic\") → PassedExam(x)) ::: If x is a student and takes the Logic course, then x passed the exam.",
            "∃x (Student(x) ∧ TakesCourse(x, \"Logic\")) ::: There exists a student who takes the Logic course.",
            "∀x (InClass(x, \"Programming\") → TakesCourse(x, \"Logic\")) ::: All students in the Programming class are taking the Logic course.",
            "Student(\"John\") ::: John is a student.",
            "InClass(\"John\", \"Programming\") ::: John is in the Programming class.",
            "∀x (Student(x) → (InClass(x, \"Programming\") ∨ TakesCourse(x, \"Logic\"))) ::: All students are either in the Programming class or take the Logic course.",
            "∀x (Student(x) ∧ TakesCourse(x, \"Logic\") → PassedExam(x)) ::: If a student is taking the Logic course, they passed the exam.",
            "∀x (Student(x) ∧ InClass(x, \"Programming\") → PassedExam(x)) ::: If a student is in the Programming class, they passed the exam.",
            "∀x (Student(x) ∧ TakesCourse(x, \"Logic\") → PassedExam(x)) ::: If a student takes the Logic course, they passed the exam.",
            "PassedExam(\"John\") → ¬InClass(\"John\", \"Programming\") ::: If John passed the exam, then he's not in the programming class"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PassedExam(x) ::: x passed the exam",
            "InClass(x, y) ::: x is in class y",
            "TakesCourse(x, y) ::: x takes course y"
        ]
    },
    {
        "premises-NL": [
            "All students study hard.",
            "If someone studies hard, they take the exam.",
            "If someone takes the exam, they pass.",
            "If someone passes, they get a good grade.",
            "All students are intelligent.",
            "There is at least one student.",
            "If someone is a student and they study hard, they pass.",
            "If someone studies hard and passes, they get a good grade.",
            "If someone passes the exam, they take it.",
            "If someone gets a good grade, they are a student.",
            "If someone is intelligent they will get a good grade.",
            "If someone takes the exam, they will pass.",
            "At least one student studies hard.",
            "If a student gets a good grade, then they have studied hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) → StudiesHard(x)) ::: All students study hard.",
            "∀x (StudiesHard(x) → TakesExam(x)) ::: If someone studies hard, they take the exam.",
            "∀x (TakesExam(x) → PassesExam(x)) ::: If someone takes the exam, they pass.",
            "∀x (PassesExam(x) → GoodGrade(x)) ::: If someone passes, they get a good grade.",
            "∀x (Student(x) → Intelligent(x)) ::: All students are intelligent.",
            "∃x Student(x) ::: There is at least one student.",
            "∀x (Student(x) ∧ StudiesHard(x) → PassesExam(x)) ::: If someone is a student and they study hard, they pass.",
            "∀x (StudiesHard(x) ∧ PassesExam(x) → GoodGrade(x)) ::: If someone studies hard and passes, they get a good grade.",
            "∀x (PassesExam(x) → TakesExam(x)) ::: If someone passes the exam, they take it.",
            "∀x (GoodGrade(x) → Student(x)) ::: If someone gets a good grade, they are a student.",
            "∀x (Intelligent(x) → GoodGrade(x)) ::: If someone is intelligent they will get a good grade.",
            "∀x (TakesExam(x) → PassesExam(x)) ::: If someone takes the exam, they will pass.",
            "∃x (Student(x) ∧ StudiesHard(x)) ::: At least one student studies hard.",
            "∀x (GoodGrade(x) → StudiesHard(x)) ::: If a student gets a good grade, then they have studied hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassesExam(x) ::: x passes the exam",
            "GoodGrade(x) ::: x gets a good grade",
            "TakesExam(x) ::: x takes an exam"
        ]
    },
    {
        "premises-NL": [
            "All doctors are educated.",
            "No musician is educated.",
            "Someone is a doctor.",
            "Every educated person is smart.",
            "There is an educated person",
            "All students are smart",
            "Someone is smart",
            "No doctor is a student",
            "All people are doctors or musicians",
            "No student is a musician",
            "Anyone smart is educated",
            "Every doctor is a student"
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Educated(x)) ::: All doctors are educated",
            "∀x (Musician(x) → ¬Educated(x)) ::: No musician is educated.",
            "∃x Doctor(x) ::: Someone is a doctor.",
            "∀x (Educated(x) → Smart(x)) ::: Every educated person is smart.",
            "∃x Educated(x) ::: There is an educated person.",
            "∀x (Student(x) → Smart(x)) ::: All students are smart",
            "∃x Smart(x) ::: Someone is smart",
            "∀x (Doctor(x) → ¬Student(x)) ::: No doctor is a student",
            "∀x (Doctor(x) ∨ Musician(x)) ::: All people are doctors or musicians",
            "∀x (Student(x) → ¬Musician(x)) ::: No student is a musician",
            "∀x (Smart(x) → Educated(x)) ::: Anyone smart is educated",
            "∀x (Doctor(x) → Student(x)) ::: Every doctor is a student"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Musician(x) ::: x is a musician",
            "Student(x) ::: x is a student",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All athletes are healthy.",
            "No doctor is healthy.",
            "Someone is an athlete.",
            "All healthy people are not doctors.",
            "Someone is not a doctor.",
            "All students are healthy",
            "Someone is healthy",
            "All athletes are not students",
            "All people are athletes or doctors",
            "All students are doctors.",
            "No doctor is a student",
            "Everyone is a student or athlete",
            "Someone is an athlete and is healthy"
        ],
        "premises-FOL": [
            "∀x (Athlete(x) → Healthy(x)) ::: All athletes are healthy.",
            "∀x (Doctor(x) → ¬Healthy(x)) ::: No doctor is healthy.",
            "∃x Athlete(x) ::: Someone is an athlete.",
            "∀x (Healthy(x) → ¬Doctor(x)) ::: All healthy people are not doctors.",
            "∃x ¬Doctor(x) ::: Someone is not a doctor.",
            "∀x (Student(x) → Healthy(x)) ::: All students are healthy",
            "∃x Healthy(x) ::: Someone is healthy.",
            "∀x (Athlete(x) → ¬Student(x)) ::: All athletes are not students",
            "∀x (Athlete(x) ∨ Doctor(x)) ::: All people are athletes or doctors",
            "∀x (Student(x) → Doctor(x)) ::: All students are doctors.",
            "∀x (Doctor(x) → ¬Student(x)) ::: No doctor is a student",
            "∀x (Student(x) ∨ Athlete(x)) ::: Everyone is a student or athlete",
            "∃x (Athlete(x) ∧ Healthy(x)) ::: Someone is an athlete and is healthy"
        ],
        "predicates": [
            "Athlete(x) ::: x is an athlete",
            "Doctor(x) ::: x is a doctor",
            "Student(x) ::: x is a student",
            "Smart(x) ::: x is smart",
            "Healthy(x) ::: x is healthy"
        ]
    },
    {
        "premises-NL": [
            "All programmers are smart.",
            "No teacher is smart.",
            "Someone is a programmer.",
            "All smart people are engineers.",
            "Someone is not a teacher.",
            "All students are smart.",
            "Someone is smart.",
            "All programmers are not students.",
            "All people are programmers or teachers.",
            "All students are teachers.",
            "No teacher is a student.",
            "Everyone is a student or programmer.",
            "Someone is a programmer and is smart.",
            "All engineers are programmers."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → Smart(x)) ::: All programmers are smart.",
            "∀x (Teacher(x) → ¬Smart(x)) ::: No teacher is smart.",
            "∃x Programmer(x) ::: Someone is a programmer.",
            "∀x (Smart(x) → Engineer(x)) ::: All smart people are engineers.",
            "∃x ¬Teacher(x) ::: Someone is not a teacher.",
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "∃x Smart(x) ::: Someone is smart.",
            "∀x (Programmer(x) → ¬Student(x)) ::: All programmers are not students.",
            "∀x (Programmer(x) ∨ Teacher(x)) ::: All people are programmers or teachers.",
            "∀x (Student(x) → Teacher(x)) ::: All students are teachers.",
            "∀x (Teacher(x) → ¬Student(x)) ::: No teacher is a student.",
            "∀x (Student(x) ∨ Programmer(x)) ::: Everyone is a student or programmer.",
            "∃x (Programmer(x) ∧ Smart(x)) ::: Someone is a programmer and is smart.",
            "∀x (Engineer(x) → Programmer(x)) ::: All engineers are programmers."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "Teacher(x) ::: x is a teacher",
            "Student(x) ::: x is a student",
            "Smart(x) ::: x is smart",
            "Engineer(x) ::: x is an engineer"
        ]
    },
    {
        "premises-NL": [
            "All artists are creative.",
            "No writer is creative.",
            "Someone is an artist.",
            "All creative people are painters.",
            "Someone is not a writer.",
            "All musicians are creative.",
            "Someone is creative.",
            "All artists are not musicians.",
            "All people are artists or writers.",
            "All musicians are writers.",
            "No writer is a musician.",
            "Everyone is a musician or artist.",
            "Someone is an artist and is creative.",
            "All painters are artists.",
            "Some people are writers."
        ],
        "premises-FOL": [
            "∀x (Artist(x) → Creative(x)) ::: All artists are creative.",
            "∀x (Writer(x) → ¬Creative(x)) ::: No writer is creative.",
            "∃x Artist(x) ::: Someone is an artist.",
            "∀x (Creative(x) → Painter(x)) ::: All creative people are painters.",
            "∃x ¬Writer(x) ::: Someone is not a writer.",
            "∀x (Musician(x) → Creative(x)) ::: All musicians are creative.",
            "∃x Creative(x) ::: Someone is creative.",
            "∀x (Artist(x) → ¬Musician(x)) ::: All artists are not musicians.",
            "∀x (Artist(x) ∨ Writer(x)) ::: All people are artists or writers.",
            "∀x (Musician(x) → Writer(x)) ::: All musicians are writers.",
            "∀x (Writer(x) → ¬Musician(x)) ::: No writer is a musician.",
            "∀x (Musician(x) ∨ Artist(x)) ::: Everyone is a musician or artist.",
            "∃x (Artist(x) ∧ Creative(x)) ::: Someone is an artist and is creative.",
            "∀x (Painter(x) → Artist(x)) ::: All painters are artists.",
            "∃x Writer(x) ::: Some people are writers."
        ],
        "predicates": [
            "Artist(x) ::: x is an artist",
            "Writer(x) ::: x is a writer",
            "Musician(x) ::: x is a musician",
            "Creative(x) ::: x is creative",
            "Painter(x) ::: x is a painter"
        ]
    },
    {
        "premises-NL": [
            "All scientists are logical.",
            "No philosopher is logical.",
            "Someone is a scientist.",
            "All logical people are researchers.",
            "Someone is not a philosopher.",
            "All engineers are logical.",
            "Someone is logical.",
            "All scientists are not engineers.",
            "All people are scientists or philosophers.",
            "All engineers are philosophers.",
            "No philosopher is an engineer.",
            "Everyone is an engineer or scientist.",
            "Someone is a scientist and is logical.",
            "All researchers are scientists.",
            "Some people are philosophers.",
            "All scientists are researchers."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Logical(x)) ::: All scientists are logical.",
            "∀x (Philosopher(x) → ¬Logical(x)) ::: No philosopher is logical.",
            "∃x Scientist(x) ::: Someone is a scientist.",
            "∀x (Logical(x) → Researcher(x)) ::: All logical people are researchers.",
            "∃x ¬Philosopher(x) ::: Someone is not a philosopher.",
            "∀x (Engineer(x) → Logical(x)) ::: All engineers are logical.",
            "∃x Logical(x) ::: Someone is logical.",
            "∀x (Scientist(x) → ¬Engineer(x)) ::: All scientists are not engineers.",
            "∀x (Scientist(x) ∨ Philosopher(x)) ::: All people are scientists or philosophers.",
            "∀x (Engineer(x) → Philosopher(x)) ::: All engineers are philosophers.",
            "∀x (Philosopher(x) → ¬Engineer(x)) ::: No philosopher is an engineer.",
            "∀x (Engineer(x) ∨ Scientist(x)) ::: Everyone is an engineer or scientist.",
            "∃x (Scientist(x) ∧ Logical(x)) ::: Someone is a scientist and is logical.",
            "∀x (Researcher(x) → Scientist(x)) ::: All researchers are scientists.",
            "∃x Philosopher(x) ::: Some people are philosophers.",
            "∀x (Scientist(x) → Researcher(x)) ::: All scientists are researchers."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Philosopher(x) ::: x is a philosopher",
            "Engineer(x) ::: x is an engineer",
            "Logical(x) ::: x is logical",
            "Researcher(x) ::: x is a researcher"
        ]
    },
    {
        "premises-NL": [
            "All students attend class.",
            "If someone attends class, they study.",
            "If someone studies, they pass the exam.",
            "If someone passes the exam, they are successful.",
            "All students get good grades.",
            "If someone gets good grades, they pass the exam.",
            "If someone attends class, they take notes.",
            "If someone takes notes and studies, they get good grades.",
            "Someone is a student, studies and takes notes.",
            "Someone studies and gets good grades.",
            "If someone studies, they attend class.",
            "If someone takes notes, they study.",
            "Someone is a student or is successful.",
            "Someone is a student and studies.",
            "Everyone who is a student or successful attends class."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClass(x)) ::: All students attend class.",
            "∀x (AttendsClass(x) → Studies(x)) ::: If someone attends class, they study.",
            "∀x (Studies(x) → PassesExam(x)) ::: If someone studies, they pass the exam.",
            "∀x (PassesExam(x) → Successful(x)) ::: If someone passes the exam, they are successful.",
            "∀x (Student(x) → GetsGoodGrades(x)) ::: All students get good grades.",
            "∀x (GetsGoodGrades(x) → PassesExam(x)) ::: If someone gets good grades, they pass the exam.",
            "∀x (AttendsClass(x) → TakesNotes(x)) ::: If someone attends class, they take notes.",
            "∀x (TakesNotes(x) ∧ Studies(x) → GetsGoodGrades(x)) ::: If someone takes notes and studies, they get good grades.",
            "∃x (Student(x) ∧ Studies(x) ∧ TakesNotes(x)) ::: Someone is a student, studies and takes notes.",
            "∃x (Studies(x) ∧ GetsGoodGrades(x)) ::: Someone studies and gets good grades.",
            "∀x (Studies(x) → AttendsClass(x)) ::: If someone studies, they attend class.",
            "∀x (TakesNotes(x) → Studies(x)) ::: If someone takes notes, they study.",
            "∃x Student(x) ∨ Successful(x) ::: Someone is a student or is successful.",
            "∃x Student(x) ∧ Studies(x) ::: Someone is a student and studies.",
            "∀x ((Student(x) ∨ Successful(x)) → AttendsClass(x)) ::: Everyone who is a student or successful attends class."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Studies(x) ::: x studies.",
            "PassesExam(x) ::: x passes the exam.",
            "Successful(x) ::: x is successful.",
            "AttendsClass(x) ::: x attends class.",
            "GetsGoodGrades(x) ::: x gets good grades.",
            "TakesNotes(x) ::: x takes notes."
        ]
    },
    {
        "premises-NL": [
            "All professors publish papers.",
            "John is a professor or publishes papers.",
            "Professors teach students.",
            "All students attend classes.",
            "John is a researcher.",
            "Researchers also teach students.",
            "All professors also teach students."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → PublishesPapers(x)) ::: All professors publish papers.",
            "Professor(john) ∨ PublishesPapers(john) ::: John is a professor or publishes papers.",
            "∀x (Professor(x) → Teaches(x, students)) ::: Professors teach students.",
            "∀x (Student(x) → AttendsClass(x)) ::: All students attend classes.",
            "Researcher(john) ::: John is a researcher.",
            "∀x (Researcher(x) → Teaches(x, students)) ::: Researchers also teach students.",
            "∀x (Professor(x) → Teaches(x, students)) ::: All professors also teach students."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "PublishesPapers(x) ::: x publishes papers",
            "Teaches(x, y) ::: x teaches y",
            "Student(x) ::: x is a student",
            "Researcher(x) ::: x is a researcher"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "All surgeons are doctors.",
            "All specialists are doctors.",
            "Dr. Smith is a surgeon.",
            "Dr. Jones is a specialist.",
            "All doctors have a medical license.",
            "All researchers do not treat patients.",
            "If someone has a medical license, they are a doctor.",
            "Dr. Smith is a doctor.",
            "No surgeons are researchers.",
            "Some specialists do not treat patients.",
            "If someone treats patients, they are not a researcher.",
            "All employed doctors work at hospitals.",
            "If someone is a doctor, they must have a medical license."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → TreatsPatients(x)) ::: All doctors treat patients",
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors",
            "∀x (Specialist(x) → Doctor(x)) ::: All specialists are doctors",
            "Surgeon(smith) ::: Dr. Smith is a surgeon",
            "Specialist(jones) ::: Dr. Jones is a specialist",
            "∀x (Doctor(x) → HasLicense(x)) ::: All doctors have a medical license",
            "∀x (Researcher(x) → ¬TreatsPatients(x)) ::: All researchers do not treat patients",
            "∀x (HasLicense(x) → Doctor(x)) ::: If someone has a medical license, they are a doctor",
            "Doctor(smith) ::: Dr. Smith is a doctor",
            "∀x (Surgeon(x) → ¬Researcher(x)) ::: No surgeons are researchers",
            "∃x (Specialist(x) ∧ ¬TreatsPatients(x)) ::: Some specialists do not treat patients",
            "∀x (TreatsPatients(x) → ¬Researcher(x)) ::: If someone treats patients, they are not a researcher",
            "∀x (Doctor(x) → EmployedByHospital(x)) ::: All employed doctors work at hospitals",
            "∀x (Doctor(x) → HasLicense(x)) ::: If someone is a doctor, they must have a medical license."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "EmployedByHospital(x) ::: x is employed by a hospital",
            "Specialist(x) ::: x is a specialist",
            "Surgeon(x) ::: x is a surgeon",
            "TreatsPatients(x) ::: x treats patients",
            "HasLicense(x) ::: x has a medical license",
            "Researcher(x) ::: x is a researcher"
        ]
    },
    {
        "premises-NL": [
            "All students either study hard or fail the exam.",
            "If a student does not fail the exam, then they pass it.",
            "John is a student.",
            "John does not fail the exam.",
            "Therefore, if John is a student and does not fail the exam, then he passes the exam.",
            "If John does not fail the exam, then he studies hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (StudiesHard(x) ∨ FailsExam(x))) ::: All students either study hard or fail the exam.",
            "∀x (¬FailsExam(x) → PassesExam(x)) ::: If a student does not fail the exam, then they pass it.",
            "Student(John) ::: John is a student.",
            "¬FailsExam(John) ::: John does not fail the exam.",
            "Student(John) ∧ ¬FailsExam(John) → PassesExam(John) ::: Therefore, if John is a student and does not fail the exam, then he passes the exam.",
            "¬FailsExam(John) → StudiesHard(John) ::: If John does not fail the exam, then he studies hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "FailsExam(x) ::: x fails the exam",
            "PassesExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "All mangoes are fruits.",
            "All ripe fruits are edible.",
            "All edible fruits are sweet.",
            "If something is a mango, it is a fruit.",
            "This fruit is a mango and is ripe.",
            "Therefore, if the fruit is a mango and is ripe, then it is sweet.",
            "Mangoes are fruits."
        ],
        "premises-FOL": [
            "∀x (Mango(x) → Fruit(x)) ::: All mangoes are fruits.",
            "∀x (Ripe(x) ∧ Fruit(x) → Edible(x)) ::: All ripe fruits are edible.",
            "∀x (Edible(x) → Sweet(x)) ::: All edible fruits are sweet.",
            "∀x (Mango(x) → Fruit(x)) ::: If something is a mango, it is a fruit.",
            "Mango(y) ∧ Ripe(y) ::: This fruit is a mango and is ripe.",
            "Mango(y) ∧ Ripe(y) → Sweet(y) ::: Therefore, if the fruit is a mango and is ripe, then it is sweet.",
            "∀x (Mango(x) → Fruit(x)) ::: Mangoes are fruits."
        ],
        "predicates": [
            "Fruit(x) ::: x is a fruit",
            "Mango(x) ::: x is a mango",
            "Apple(x) ::: x is an apple",
            "Ripe(x) ::: x is ripe",
            "Sweet(x) ::: x is sweet",
            "Edible(x) ::: x is edible"
        ]
    },
    {
        "premises-NL": [
            "All cars are made of metal.",
            "All sports cars are fast.",
            "All red cars have a good engine.",
            "If a car has a good engine, it is expensive to maintain.",
            "Red cars have doors.",
            "Cars need fuel.",
            "Cars use gas.",
            "All cars have seats.",
            "A car is red.",
            "A car is a sports car.",
            "All cars have wheels.",
            "The car is new.",
            "The car is made of metal."
        ],
        "premises-FOL": [
            "∀x (Car(x) → MadeOfMetal(x)) ::: All cars are made of metal.",
            "∀x (SportsCar(x) → Fast(x)) ::: All sports cars are fast.",
            "∀x (Red(x) → GoodEngine(x)) ::: All red cars have a good engine.",
            "∀x (GoodEngine(x) → ExpensiveToMaintain(x)) ::: If a car has a good engine, it is expensive to maintain.",
            "∀x (Red(x) → HasDoors(x)) ::: Red cars have doors.",
            "∀x (Car(x) → NeedsFuel(x)) ::: Cars need fuel.",
            "∀x (Car(x) → UsesGas(x)) ::: Cars use gas.",
            "∀x (Car(x) → HasSeats(x)) ::: All cars have seats.",
            "Red(Car1) ::: A car is red.",
            "SportsCar(Car1) ::: A car is a sports car.",
            "∀x (Car(x) → HasWheels(x)) ::: All cars have wheels.",
            "IsNew(Car1) ::: The car is new.",
            "MadeOfMetal(Car1) ::: The car is made of metal."
        ],
        "predicates": [
            "Car(x) ::: x is a car",
            "Red(x) ::: x is red",
            "GoodEngine(x) ::: x has a good engine",
            "ExpensiveToMaintain(x) ::: x is expensive to maintain",
            "Fast(x) ::: x is fast",
            "SportsCar(x) ::: x is a sports car",
            "HasWheels(x) ::: x has wheels",
            "NeedsFuel(x) ::: x needs fuel",
            "UsesGas(x) ::: x uses gas",
            "IsNew(x) ::: x is new",
            "MadeOfMetal(x) ::: x is made of metal",
            "HasDoors(x) ::: x has doors",
            "HasSeats(x) ::: x has seats"
        ]
    },
    {
        "premises-NL": [
            "All students are registered.",
            "Some students attend the lecture.",
            "If someone is a student and attends the lecture, they are interested.",
            "If someone is interested, they are registered.",
            "If someone is registered, they are a student.",
            "Every student is either registered or doesn't attend the lecture",
            "If someone is a student, then they are registered.",
            "Someone is a student.",
            "Someone attends the lecture."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Registered(x)) ::: All students are registered",
            "∃x (Student(x) ∧ AttendLecture(x)) ::: Some students attend the lecture",
            "∀x (Student(x) ∧ AttendLecture(x) → Interested(x)) ::: If someone is a student and attends the lecture, they are interested",
            "∀x (Interested(x) → Registered(x)) ::: If someone is interested, they are registered",
            "∀x (Registered(x) → Student(x)) ::: If someone is registered, they are a student",
            "∀x (Student(x) → (Registered(x) ∨ ¬AttendLecture(x))) ::: Every student is either registered or doesn't attend the lecture",
            "∀x (Student(x) → Registered(x)) ::: If someone is a student, then they are registered",
            "∃x Student(x) ::: Someone is a student",
            "∃x AttendLecture(x) ::: Someone attends the lecture"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Registered(x) ::: x is registered",
            "AttendLecture(x) ::: x attends the lecture"
        ]
    },
    {
        "premises-NL": [
            "All large companies invest in research.",
            "If a company is profitable and spends on marketing, then it is large.",
            "If a company invests in research, then it employs scientists.",
            "If a company is innovative, then it has patents and is profitable.",
            "If a company employs scientists and has patents, then it is innovative.",
            "If a company is large, it spends on marketing.",
            "Some companies are profitable and large.",
            "If a company invests in research, it is either large or profitable.",
            "A company is profitable if and only if it spends on marketing, and has patents.",
            "If a company is innovative, then it invests in research"
        ],
        "premises-FOL": [
            "∀x (Large(x) → InvestsResearch(x)) ::: All large companies invest in research",
            "∀x (Profitable(x) ∧ SpendsOnMarketing(x) → Large(x)) ::: If a company is profitable and spends on marketing, then it is large",
            "∀x (InvestsResearch(x) → EmploysScientists(x)) ::: If a company invests in research, then it employs scientists",
            "∀x (Innovative(x) → (HasPatents(x) ∧ Profitable(x))) ::: If a company is innovative, then it has patents and is profitable",
            "∀x (EmploysScientists(x) ∧ HasPatents(x) → Innovative(x)) ::: If a company employs scientists and has patents, then it is innovative",
            "∀x (Large(x) → SpendsOnMarketing(x)) ::: If a company is large, it spends on marketing",
            "∃x (Profitable(x) ∧ Large(x)) ::: Some companies are profitable and large",
            "∀x (InvestsResearch(x) → (Large(x) ∨ Profitable(x))) ::: If a company invests in research, it is either large or profitable",
            "∀x (Profitable(x) ↔ (SpendsOnMarketing(x) ∧ HasPatents(x))) ::: A company is profitable if and only if it spends on marketing, and has patents.",
            "∀x (Innovative(x) → InvestsResearch(x)) ::: If a company is innovative, then it invests in research"
        ],
        "predicates": [
            "Company(x) ::: x is a company",
            "Profitable(x) ::: Company x is profitable",
            "InvestsResearch(x) ::: Company x invests in research",
            "Innovative(x) ::: Company x is innovative",
            "Large(x) ::: Company x is large",
            "SpendsOnMarketing(x) ::: Company x spends on marketing",
            "EmploysScientists(x) ::: Company x employs scientists",
            "HasPatents(x) ::: Company x has patents"
        ]
    },
    {
        "premises-NL": [
            "All doctors are empathetic.",
            "Dr. Smith is a doctor.",
            "Some patients are not empathetic.",
            "If someone is a doctor, then they love their patients.",
            "Anyone who is a doctor is also a patient.",
            "Someone is a patient."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Empathetic(x)) ::: For all x, if x is a doctor, then x is empathetic.",
            "Doctor(Smith) ::: Smith is a doctor.",
            "∃x (Patient(x) ∧ ¬Empathetic(x)) ::: There exists someone, x, who is a patient and is not empathetic.",
            "∀x (Doctor(x) → Loves(x, x)) ::: For all x, if x is a doctor, then x loves x.",
            "∀x (Doctor(x) → Patient(x)) ::: For all x, if x is a doctor, then x is a patient.",
            "∃x Patient(x) ::: There exists someone, x, who is a patient."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Patient(x) ::: x is a patient",
            "Loves(x, y) ::: x loves y"
        ]
    },
    {
        "premises-NL": [
            "All athletes receive scholarships.",
            "Some students do not receive scholarships.",
            "If someone receives a scholarship, they are a student.",
            "All students study.",
            "Someone is an athlete.",
            "No one studies if they don't receive a scholarship.",
            "Some people are not students."
        ],
        "premises-FOL": [
            "∀x (Athlete(x) → ReceivesScholarship(x)) ::: For all x, if x is an athlete, then x receives a scholarship.",
            "∃x (Student(x) ∧ ¬ReceivesScholarship(x)) ::: There exists someone, x, who is a student and does not receive a scholarship.",
            "∀x (ReceivesScholarship(x) → Student(x)) ::: For all x, if x receives a scholarship, then x is a student.",
            "∀x (Student(x) → Studies(x)) ::: For all x, if x is a student, then x studies.",
            "∃x Athlete(x) ::: There exists someone, x, who is an athlete.",
            "∀x (¬ReceivesScholarship(x) → ¬Studies(x)) ::: For all x, if x does not receive a scholarship, then x does not study.",
            "∃x ¬Student(x) ::: There exists someone, x, who is not a student."
        ],
        "predicates": [
            "Athlete(x) ::: x is an athlete",
            "Student(x) ::: x is a student",
            "ReceivesScholarship(x) ::: x receives a scholarship"
        ]
    },
    {
        "premises-NL": [
            "All doctors have graduated from medical school.",
            "All doctors are licensed.",
            "Anyone who is a doctor can prescribe medications.",
            "Graduating from medical school implies passing the required exams.",
            "If someone is a doctor they have studied biology.",
            "Alice is a doctor.",
            "Alice has graduated from medical school.",
            "If someone is licensed they can prescribe medication.",
            "Bob is a doctor.",
            "Charlie is a doctor.",
            "All doctors must have studied biology.",
            "If someone studied biology, they may have passed exams."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → GraduatedMedSchool(x)) ::: All doctors have graduated from medical school.",
            "∀x (Doctor(x) → Licensed(x)) ::: All doctors are licensed.",
            "∀x (Doctor(x) → CanPrescribe(x)) ::: Anyone who is a doctor can prescribe medications.",
            "∀x (GraduatedMedSchool(x) → PassedExams(x)) ::: Graduating from medical school implies passing the required exams.",
            "∀x (Doctor(x) → StudiedBiology(x)) ::: If someone is a doctor they have studied biology.",
            "Doctor(Alice) ::: Alice is a doctor.",
            "GraduatedMedSchool(Alice) ::: Alice has graduated from medical school.",
            "∀x (Licensed(x) → CanPrescribe(x)) ::: If someone is licensed they can prescribe medication.",
            "Doctor(Bob) ::: Bob is a doctor.",
            "Doctor(Charlie) ::: Charlie is a doctor.",
            "∀x (Doctor(x) → StudiedBiology(x)) ::: All doctors must have studied biology.",
            "∀x (StudiedBiology(x) → PassedExams(x)) ::: If someone studied biology, they may have passed exams."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "GraduatedMedSchool(x) ::: x has graduated from medical school",
            "CanPrescribe(x) ::: x can prescribe medications",
            "StudiedBiology(x) ::: x has studied biology",
            "PassedExams(x) ::: x has passed required exams",
            "Licensed(x) ::: x is licensed"
        ]
    },
    {
        "premises-NL": [
            "All companies that invest in sustainable practices are environmentally conscious.",
            "All companies that use renewable energy are environmentally conscious.",
            "If a company invests in sustainable practices and uses renewable energy, then the company is profitable.",
            "If a company is environmentally conscious, they are profitable.",
            "Company A invests in sustainable practices.",
            "Company A uses renewable energy.",
            "Company B is profitable.",
            "If a company is profitable, it employs local workers.",
            "Company C invests in sustainable practices and uses renewable energy.",
            "All environmentally conscious companies employ local workers.",
            "If a company employs local workers then it uses renewable energy.",
            "Company D invests in sustainable practices.",
            "Company D uses renewable energy.",
            "Company E uses renewable energy."
        ],
        "premises-FOL": [
            "∀x (Company(x) ∧ InvestsInSustainablePractices(x) → EnvironmentallyConscious(x)) ::: All companies that invest in sustainable practices are environmentally conscious.",
            "∀x (Company(x) ∧ UsesRenewableEnergy(x) → EnvironmentallyConscious(x)) ::: All companies that use renewable energy are environmentally conscious.",
            "∀x ((Company(x) ∧ InvestsInSustainablePractices(x) ∧ UsesRenewableEnergy(x)) → Profitable(x)) ::: If a company invests in sustainable practices and uses renewable energy, then the company is profitable.",
            "∀x (EnvironmentallyConscious(x) → Profitable(x)) ::: If a company is environmentally conscious, they are profitable.",
            "InvestsInSustainablePractices(CompanyA) ::: Company A invests in sustainable practices.",
            "UsesRenewableEnergy(CompanyA) ::: Company A uses renewable energy.",
            "Profitable(CompanyB) ::: Company B is profitable.",
            "∀x (Profitable(x) → EmploysLocalWorkers(x)) ::: If a company is profitable, it employs local workers.",
            "InvestsInSustainablePractices(CompanyC) ∧ UsesRenewableEnergy(CompanyC) ::: Company C invests in sustainable practices and uses renewable energy.",
            "∀x (EnvironmentallyConscious(x) → EmploysLocalWorkers(x)) ::: All environmentally conscious companies employ local workers.",
            "∀x (EmploysLocalWorkers(x) → UsesRenewableEnergy(x)) ::: If a company employs local workers then it uses renewable energy.",
            "InvestsInSustainablePractices(CompanyD) ::: Company D invests in sustainable practices.",
            "UsesRenewableEnergy(CompanyD) ::: Company D uses renewable energy.",
            "UsesRenewableEnergy(CompanyE) ::: Company E uses renewable energy."
        ],
        "predicates": [
            "Company(x) ::: x is a company",
            "InvestsInSustainablePractices(x) ::: x invests in sustainable practices",
            "UsesRenewableEnergy(x) ::: x uses renewable energy",
            "EnvironmentallyConscious(x) ::: x is environmentally conscious",
            "Profitable(x) ::: x is profitable",
            "EmploysLocalWorkers(x) ::: x employs local workers"
        ]
    },
    {
        "premises-NL": [
            "All researchers are expected to present a paper at the conference.",
            "Sarah is a researcher.",
            "Anyone who has funding is expected to present a paper.",
            "Sarah does not have funding.",
            "If someone works at the university, they are expected to present a paper.",
            "Only researchers are expected to present at the conference.",
            "Anyone who attends the conference is expected to present a paper or doesn't have funding.",
            "Sarah works at the university.",
            "Sarah is expected to present at the conference or has funding."
        ],
        "premises-FOL": [
            "∀x (IsResearcher(x) → PresentsPaper(x)) ::: All researchers are expected to present a paper at the conference.",
            "IsResearcher(sarah) ::: Sarah is a researcher.",
            "∀x (HasFunding(x) → PresentsPaper(x)) ::: Anyone who has funding is expected to present a paper.",
            "¬HasFunding(sarah) ::: Sarah does not have funding.",
            "∀x (WorksAt(x, university) → PresentsPaper(x)) ::: If someone works at the university, they are expected to present a paper.",
            "∀x (PresentsPaper(x) → IsResearcher(x)) ::: Only researchers are expected to present at the conference.",
            "∀x (AttendsConference(x) → PresentsPaper(x) ∨ ¬HasFunding(x)) ::: Anyone who attends the conference is expected to present a paper or doesn't have funding.",
            "WorksAt(sarah, university) ::: Sarah works at the university.",
            "PresentsPaper(sarah) ∨ HasFunding(sarah) ::: Sarah is expected to present at the conference or has funding."
        ],
        "predicates": [
            "AttendsConference(x) ::: x attends the conference",
            "IsResearcher(x) ::: x is a researcher",
            "PresentsPaper(x) ::: x presents a paper",
            "HasFunding(x) ::: x has funding",
            "WorksAt(x, y) ::: x works at y"
        ]
    },
    {
        "premises-NL": [
            "The server is running or requires a security update.",
            "If the server is running, it has a database.",
            "If the server requires a security update, the website is not accessible.",
            "If a server has a database, the website is accessible.",
            "If the server has a database and is connected to the internet, the website is accessible.",
            "The server is connected to the internet.",
            "If the server is not running, it requires a security update.",
            "If the website is accessible, the server is running or has a database.",
            "If the server is connected to the internet, it has a database.",
            "If the server has a database, it is running.",
            "If a server is running and connected to the internet then the website is accessible.",
            "The server is running or is not connected to the internet."
        ],
        "premises-FOL": [
            "IsRunning(server) ∨ RequiresSecurityUpdate(server) ::: The server is running or requires a security update.",
            "IsRunning(server) → HasDatabase(server) ::: If the server is running, it has a database.",
            "RequiresSecurityUpdate(server) → ¬IsAccessible(website) ::: If the server requires a security update, the website is not accessible.",
            "HasDatabase(server) → IsAccessible(website) ::: If a server has a database, the website is accessible.",
            "HasDatabase(server) ∧ IsConnected(server, internet) → IsAccessible(website) ::: If the server has a database and is connected to the internet, the website is accessible.",
            "IsConnected(server, internet) ::: The server is connected to the internet.",
            "¬IsRunning(server) → RequiresSecurityUpdate(server) ::: If the server is not running, it requires a security update.",
            "IsAccessible(website) → IsRunning(server) ∨ HasDatabase(server) ::: If the website is accessible, the server is running or has a database.",
            "IsConnected(server, internet) → HasDatabase(server) ::: If the server is connected to the internet, it has a database.",
            "HasDatabase(server) → IsRunning(server) ::: If the server has a database, it is running.",
            "IsRunning(server) ∧ IsConnected(server, internet) → IsAccessible(website) ::: If a server is running and connected to the internet then the website is accessible.",
            "IsRunning(server) ∨ ¬IsConnected(server, internet) ::: The server is running or is not connected to the internet."
        ],
        "predicates": [
            "IsRunning(x) ::: x is running",
            "IsAccessible(x) ::: x is accessible",
            "HasDatabase(x) ::: x has a database",
            "IsConnected(x, y) ::: x is connected to y",
            "RequiresSecurityUpdate(x) ::: x requires a security update"
        ]
    },
    {
        "premises-NL": [
            "All doctors have graduated from medical school.",
            "If someone graduates from medical school, then they are a doctor.",
            "Some doctors treat patients.",
            "If a doctor is not kind, then they are not liked.",
            "All who are not liked are considered unethical.",
            "No doctors are considered unethical.",
            "If a doctor treats a patient, then that patient is happy.",
            "Some patients are not happy.",
            "If a doctor is kind, then they are liked.",
            "A doctor is either kind or unethical.",
            "Any person who graduates is a doctor"
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Graduate(x)) ::: All doctors have graduated from medical school.",
            "∀x (Graduate(x) → Doctor(x)) ::: If someone graduates from medical school, then they are a doctor.",
            "∃x ∃y (Doctor(x) ∧ Treats(x, y)) ::: Some doctors treat patients.",
            "∀x (¬Kind(x) → ¬Liked(x)) ::: If a doctor is not kind, then they are not liked.",
            "∀x (¬Liked(x) → Unethical(x)) ::: All who are not liked are considered unethical.",
            "∀x (Doctor(x) → ¬Unethical(x)) ::: No doctors are considered unethical.",
            "∀x ∀y (Treats(x, y) → Happy(y)) ::: If a doctor treats a patient, then that patient is happy.",
            "∃x (Patient(x) ∧ ¬Happy(x)) ::: Some patients are not happy.",
            "∀x (Kind(x) → Liked(x)) ::: If a doctor is kind, then they are liked.",
            "∀x (Doctor(x) → (Kind(x) ∨ Unethical(x))) ::: A doctor is either kind or unethical.",
            "∀x (Graduate(x) → Doctor(x)) ::: Any person who graduates is a doctor"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Patient(x) ::: x is a patient",
            "Treats(x, y) ::: x treats y",
            "Kind(x) ::: x is kind"
        ]
    },
    {
        "premises-NL": [
            "All employees receive training.",
            "If an employee is trained, then they are efficient.",
            "Some employees are highly skilled.",
            "Employees are either skilled or unskilled.",
            "Highly skilled employees are trained.",
            "An employee is either efficient or inefficient.",
            "If an employee is highly skilled and efficient, they are valuable.",
            "If an employee is unskilled they are not efficient.",
            "Some employees are not inefficient.",
            "If an employee is not highly skilled, they are unskilled.",
            "All valuable employees are highly skilled.",
            "No employee is both skilled and unskilled.",
            "If an employee is efficient, they are useful.",
            "Every useful employee is highly skilled."
        ],
        "premises-FOL": [
            "∀x (Employee(x) → Trained(x)) ::: All employees receive training.",
            "∀x (Trained(x) → Efficient(x)) ::: If an employee is trained, then they are efficient.",
            "∃x (Employee(x) ∧ HighlySkilled(x)) ::: Some employees are highly skilled.",
            "∀x (Employee(x) → (HighlySkilled(x) ∨ Unskilled(x))) ::: Employees are either skilled or unskilled.",
            "∀x (HighlySkilled(x) → Trained(x)) ::: Highly skilled employees are trained.",
            "∀x (Employee(x) → (Efficient(x) ∨ Inefficient(x))) ::: An employee is either efficient or inefficient.",
            "∀x (Employee(x) ∧ HighlySkilled(x) ∧ Efficient(x) → Valuable(x)) ::: If an employee is highly skilled and efficient, they are valuable.",
            "∀x (Unskilled(x) → ¬Efficient(x)) ::: If an employee is unskilled they are not efficient.",
            "∃x (Employee(x) ∧ ¬Inefficient(x)) ::: Some employees are not inefficient.",
            "∀x (Employee(x) ∧ ¬HighlySkilled(x) → Unskilled(x)) ::: If an employee is not highly skilled, they are unskilled.",
            "∀x (Valuable(x) → HighlySkilled(x)) ::: All valuable employees are highly skilled.",
            "∀x ¬(Skilled(x) ∧ Unskilled(x)) ::: No employee is both skilled and unskilled.",
            "∀x (Efficient(x) → Useful(x)) ::: If an employee is efficient, they are useful.",
            "∀x (Useful(x) → HighlySkilled(x)) ::: Every useful employee is highly skilled."
        ],
        "predicates": [
            "Employee(x) ::: x is an employee",
            "Trained(x) ::: x is trained",
            "Efficient(x) ::: x is efficient",
            "Valuable(x) ::: x is valuable"
        ]
    },
    {
        "premises-NL": [
            "All students take courses.",
            "Anyone who takes a course studies a subject.",
            "Some students like science.",
            "People who like science study science.",
            "Some students do not like art.",
            "People who do not like art do not study art.",
            "If a student likes science, they study science.",
            "If a student does not like art, they are not studying art.",
            "All students study either science or art or neither.",
            "Students either like science or like art.",
            "Some students like both science and art.",
            "Anyone who studies neither science nor art is not taking a course.",
            "Every student who studies art likes art.",
            "Some students are taking courses, but don't like art.",
            "No students like everything."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakesCourse(x)) ::: All students take courses.",
            "∀x (TakesCourse(x) → Studies(x, y)) ::: Anyone who takes a course studies a subject.",
            "∃x (Student(x) ∧ Likes(x, 'Science')) ::: Some students like science.",
            "∀x (Likes(x, 'Science') → Studies(x, 'Science')) ::: People who like science study science.",
            "∃x (Student(x) ∧ ¬Likes(x, 'Art')) ::: Some students do not like art.",
            "∀x (¬Likes(x, 'Art') → ¬Studies(x, 'Art')) ::: People who do not like art do not study art.",
            "∀x (Student(x) ∧ Likes(x, 'Science') → Studies(x, 'Science')) ::: If a student likes science, they study science.",
            "∀x (Student(x) ∧ ¬Likes(x, 'Art') → ¬Studies(x, 'Art')) ::: If a student does not like art, they are not studying art.",
            "∀x (Student(x) → (Studies(x, 'Science') ∨ Studies(x, 'Art') ∨ ¬Studies(x, 'Science') ∧ ¬Studies(x, 'Art'))) ::: All students study either science or art or neither.",
            "∀x (Student(x) → (Likes(x, 'Science') ∨ Likes(x, 'Art'))) ::: Students either like science or like art.",
            "∃x (Student(x) ∧ Likes(x, 'Science') ∧ Likes(x, 'Art')) ::: Some students like both science and art.",
            "∀x (¬Studies(x, 'Science') ∧ ¬Studies(x, 'Art') → ¬TakesCourse(x)) ::: Anyone who studies neither science nor art is not taking a course.",
            "∀x (Student(x) ∧ Studies(x, 'Art') → Likes(x, 'Art')) ::: Every student who studies art likes art.",
            "∃x (Student(x) ∧ TakesCourse(x) ∧ ¬Likes(x, 'Art')) ::: Some students are taking courses, but don't like art.",
            "∀x ¬(Student(x) ∧ Likes(x, 'Science') ∧ Likes(x, 'Art') ∧ Likes(x, 'EverythingElse')) ::: No students like everything."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x, y) ::: x studies y",
            "Likes(x, y) ::: x likes y"
        ]
    },
    {
        "premises-NL": [
            "All programmers use a programming language.",
            "If a programmer uses Python, they have experience.",
            "Some programmers work on complex projects.",
            "Programmers are either experienced or inexperienced.",
            "If a programmer is experienced, they know Python.",
            "If a programmer is inexperienced, they do not know Python.",
            "If a programmer works on a complex project and knows Python, they are experienced.",
            "Some programmers work on complex projects and use Python.",
            "All programmers either use Python or Java.",
            "Programmers who use Java are not experienced.",
            "No programmer knows both Python and Java.",
            "Any experienced programmer knows Python.",
            "If a programmer uses Java, they are using a compiled language.",
            "Any programmer who uses a compiled language is also inexperienced.",
            "Some programmers are not working on complex projects.",
            "Every inexperienced programmer knows a compiled language."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → Uses(x, y)) ::: All programmers use a programming language.",
            "∀x (Programmer(x) ∧ Uses(x, 'Python') → Experienced(x)) ::: If a programmer uses Python, they have experience.",
            "∃x (Programmer(x) ∧ ComplexProject(x)) ::: Some programmers work on complex projects.",
            "∀x (Programmer(x) → (Experienced(x) ∨ Inexperienced(x))) ::: Programmers are either experienced or inexperienced.",
            "∀x (Experienced(x) → Knows(x, 'Python')) ::: If a programmer is experienced, they know Python.",
            "∀x (Inexperienced(x) → ¬Knows(x, 'Python')) ::: If a programmer is inexperienced, they do not know Python.",
            "∀x (Programmer(x) ∧ ComplexProject(x) ∧ Knows(x, 'Python') → Experienced(x)) ::: If a programmer works on a complex project and knows Python, they are experienced.",
            "∃x (Programmer(x) ∧ ComplexProject(x) ∧ Uses(x, 'Python')) ::: Some programmers work on complex projects and use Python.",
            "∀x (Programmer(x) → (Uses(x, 'Python') ∨ Uses(x, 'Java'))) ::: All programmers either use Python or Java.",
            "∀x (Programmer(x) ∧ Uses(x, 'Java') → ¬Experienced(x)) ::: Programmers who use Java are not experienced.",
            "∀x ¬(Knows(x, 'Python') ∧ Knows(x, 'Java')) ::: No programmer knows both Python and Java.",
            "∀x (Experienced(x) → Knows(x, 'Python')) ::: Any experienced programmer knows Python.",
            "∀x (Programmer(x) ∧ Uses(x, 'Java') → Uses(x, 'CompiledLanguage')) ::: If a programmer uses Java, they are using a compiled language.",
            "∀x (Programmer(x) ∧ Uses(x, 'CompiledLanguage') → Inexperienced(x)) ::: Any programmer who uses a compiled language is also inexperienced.",
            "∃x (Programmer(x) ∧ ¬ComplexProject(x)) ::: Some programmers are not working on complex projects.",
            "∀x (Inexperienced(x) → Knows(x, 'CompiledLanguage')) ::: Every inexperienced programmer knows a compiled language."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "Uses(x, y) ::: x uses y",
            "ComplexProject(x) ::: x is working on a complex project",
            "Experienced(x) ::: x is experienced"
        ]
    },
    {
        "premises-NL": [
            "All students either study hard or attend classes.",
            "All students study hard only if they pass the exam.",
            "Alice is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (StudiesHard(x) ∨ AttendsClasses(x))) ::: All students either study hard or attend classes",
            "∀x (StudiesHard(x) → PassExam(x)) ::: All students study hard only if they pass the exam",
            "Student(Alice) ::: Alice is a student"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "AttendsClasses(x) ::: x attends classes",
            "PassExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "All programmers are either creative or logical.",
            "All creative people are artists.",
            "All logical people write clean code.",
            "Bob is a programmer."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → (Creative(x) ∨ Logical(x))) ::: All programmers are either creative or logical",
            "∀x (Creative(x) → Artist(x)) ::: All creative people are artists",
            "∀x (Logical(x) → WritesCleanCode(x)) ::: All logical people write clean code",
            "Programmer(Bob) ::: Bob is a programmer"
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "Creative(x) ::: x is creative",
            "Logical(x) ::: x is logical",
            "Artist(x) ::: x is an artist",
            "WritesCleanCode(x) ::: x writes clean code"
        ]
    },
    {
        "premises-NL": [
            "Every dog loves playing fetch.",
            "Only dogs are canines.",
            "Everything that loves playing fetch is happy.",
            "Fido is a dog."
        ],
        "premises-FOL": [
            "∀x (Dog(x) → LovesFetch(x)) ::: Every dog loves playing fetch",
            "∀x (Canine(x) → Dog(x)) ::: Only dogs are canines",
            "∀x (LovesFetch(x) → Happy(x)) ::: Everything that loves playing fetch is happy",
            "Dog(Fido) ::: Fido is a dog"
        ],
        "predicates": [
            "Dog(x) ::: x is a dog",
            "LovesFetch(x) ::: x loves playing fetch",
            "Canine(x) ::: x is a canine",
            "Happy(x) ::: x is happy"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "If a doctor treats a disease, they are expected to be skilled in treating it.",
            "Doctors specialize in various fields.",
            "Cardiologists are doctors who specialize in cardiology.",
            "If a doctor is a cardiologist, they treat heart disease.",
            "If a doctor practices in a hospital, they treat patients.",
            "A researcher publishes papers related to the field they research in.",
            "If a doctor doesn't treat the disease, they won't be skilled in treating it.",
            "If a doctor publishes paper in the cardiology field, the doctor specializes in cardiology.",
            "If a doctor specializes in cardiology and publishes papers, then they are skilled.",
            "If a person is a doctor, they are either a researcher, a practitioner or a specialist.",
            "Doctors who specialize in certain fields also practice there."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → TreatsPatients(x)) ::: All doctors treat patients.",
            "∀x ∀y (Treats(x, y) → SkilledInTreating(x, y)) ::: If a doctor treats a disease, they are expected to be skilled in treating it.",
            "∀x ∃y SpecializesIn(x, y) ::: Doctors specialize in various fields.",
            "∀x (SpecializesIn(x, Cardiology) → Doctor(x)) ::: Cardiologists are doctors who specialize in cardiology.",
            "∀x (SpecializesIn(x, Cardiology) → Treats(x, HeartDisease)) ::: If a doctor is a cardiologist, they treat heart disease.",
            "∀x ∀y (PracticesIn(x, y) → TreatsPatients(x)) ::: If a doctor practices in a hospital, they treat patients.",
            "∀x ∀y (Researcher(x) ∧ ResearchField(y) → PublishesPaper(x, y)) ::: A researcher publishes papers related to the field they research in.",
            "∀x ∀y (¬Treats(x, y) → ¬SkilledInTreating(x, y)) ::: If a doctor doesn't treat the disease, they won't be skilled in treating it.",
            "∀x (PublishesPaper(x, Cardiology) → SpecializesIn(x, Cardiology)) ::: If a doctor publishes paper in the cardiology field, the doctor specializes in cardiology.",
            "∀x (SpecializesIn(x, Cardiology) ∧ PublishesPaper(x, Cardiology) → SkilledInTreating(x, HeartDisease)) ::: If a doctor specializes in cardiology and publishes papers, then they are skilled.",
            "∀x (Doctor(x) → (Researcher(x) ∨ Practitioner(x) ∨ Specialist(x))) ::: If a person is a doctor, they are either a researcher, a practitioner or a specialist.",
            "∀x ∀y (SpecializesIn(x,y) → PracticesIn(x,y)) ::: Doctors who specialize in certain fields also practice there."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "SpecializesIn(x, y) ::: x specializes in y",
            "Treats(x, y) ::: x treats disease y",
            "SkilledInTreating(x, y) ::: x is skilled in treating disease y",
            "PracticesIn(x, y) ::: x practices in hospital y",
            "Researcher(x) ::: x is a researcher",
            "PublishesPaper(x, y) ::: x publishes a paper on y"
        ]
    },
    {
        "premises-NL": [
            "All applicants must meet the job requirements.",
            "If an applicant has a high GPA, they possess strong skills.",
            "If an applicant has relevant experience, they possess strong skills.",
            "If an applicant has strong skills and meets the requirements, they will pass the initial screening.",
            "If an applicant passes the initial screening and does well in the interview, they will be offered the job.",
            "If an applicant is referred by an employee, they will be considered.",
            "If an applicant has a degree, they meet the job requirements.",
            "If an applicant works hard and referred by someone, they do well in the interview.",
            "Applicants are also evaluated on their personality.",
            "Applicants must either meet the requirements or pass the screening.",
            "Applicants with both a high GPA and relevant experience will pass the screening.",
            "If applicants work hard and are referred by someone, they do well."
        ],
        "premises-FOL": [
            "∀x (Applicant(x) → MeetsRequirements(x)) ::: All applicants must meet the job requirements.",
            "∀x (HighGPA(x) → StrongSkills(x)) ::: If an applicant has a high GPA, they possess strong skills.",
            "∀x (RelevantExperience(x) → StrongSkills(x)) ::: If an applicant has relevant experience, they possess strong skills.",
            "∀x (StrongSkills(x) ∧ MeetsRequirements(x) → PassedScreening(x)) ::: If an applicant has strong skills and meets the requirements, they will pass the initial screening.",
            "∀x (PassedScreening(x) ∧ GoodInterview(x) → OfferedJob(x)) ::: If an applicant passes the initial screening and does well in the interview, they will be offered the job.",
            "∀x ∃y (ReferredBy(x, y) → Considered(x)) ::: If an applicant is referred by an employee, they will be considered.",
            "∀x ∃y (HasDegree(x, y) → MeetsRequirements(x)) ::: If an applicant has a degree, they meet the job requirements.",
            "∀x ∃y (WorksHard(x) ∧ ReferredBy(x, y) → GoodInterview(x)) ::: If an applicant works hard and referred by someone, they do well in the interview.",
            "∀x (Applicant(x) → EvaluatedPersonality(x)) ::: Applicants are also evaluated on their personality.",
            "∀x (Applicant(x) → MeetsRequirements(x) ∨ PassedScreening(x)) ::: Applicants must either meet the requirements or pass the screening.",
            "∀x (HighGPA(x) ∧ RelevantExperience(x) → PassedScreening(x)) ::: Applicants with both a high GPA and relevant experience will pass the screening.",
            "∀x ∃y (WorksHard(x) ∧ ReferredBy(x, y) → GoodInterview(x)) ::: If applicants work hard and are referred by someone, they do well."
        ],
        "predicates": [
            "Applicant(x) ::: x is an applicant",
            "HighGPA(x) ::: x has a high GPA",
            "RelevantExperience(x) ::: x has relevant experience",
            "GoodInterview(x) ::: x did well in the interview",
            "OfferedJob(x) ::: x was offered the job",
            "MeetsRequirements(x) ::: x meets the job requirements",
            "StrongSkills(x) ::: x has strong skills",
            "PassedScreening(x) ::: x passed the initial screening",
            "ReferredBy(x, y) ::: x was referred by y",
            "HasDegree(x,y) ::: x has degree y",
            "WorksHard(x) ::: x works hard"
        ]
    },
    {
        "premises-NL": [
            "A species with high genetic diversity is more likely to adapt to new threats.",
            "If a species is exposed to a threat, it is more likely to be vulnerable.",
            "A species is considered protected or migrating.",
            "If a species is migrating or is protected, it is not thriving.",
            "Species which are vulnerable to threats are likely to have low genetic diversity.",
            "Species that have a high reproduction rate are not easily threatened.",
            "A species can either be thriving or not.",
            "A thriving species is likely to survive.",
            "A species with high genetic diversity are resistant to diseases.",
            "Species that are infected are not thriving.",
            "Species with high genetic diversity have the ability to adapt.",
            "If a significant portion of a species adapts to the environment, they are likely to survive.",
            "If a species is resistant to disease, they are likely to survive.",
            "High genetic diversity means species can be highly resistant to threats."
        ],
        "premises-FOL": [
            "∀x (HighGeneticDiversity(x) → AbleToAdapt(x)) ::: A species with high genetic diversity is more likely to adapt to new threats.",
            "∀x (ExposedToThreat(x) → VulnerableToThreat(x)) ::: If a species is exposed to a threat, it is more likely to be vulnerable.",
            "∀x (Protected(x) ∨ Migrating(x)) ::: A species is considered protected or migrating.",
            "∀x ((Migrating(x) ∨ Protected(x)) → ¬Thriving(x)) ::: If a species is migrating or is protected, it is not thriving.",
            "∀x (VulnerableToThreat(x) → LowGeneticDiversity(x)) ::: Species which are vulnerable to threats are likely to have low genetic diversity.",
            "∀x (HighReproductionRate(x) → ¬EasilyThreatened(x)) ::: Species that have a high reproduction rate are not easily threatened.",
            "∀x (Thriving(x) ∨ ¬Thriving(x)) ::: A species can either be thriving or not.",
            "∀x (Thriving(x) → LikelyToSurvive(x)) ::: A thriving species is likely to survive.",
            "∀x (HighGeneticDiversity(x) → ResistantToDisease(x)) ::: A species with high genetic diversity are resistant to diseases.",
            "∀x (Infected(x) → ¬Thriving(x)) ::: Species that are infected are not thriving.",
            "∀x (HighGeneticDiversity(x) → AbleToAdapt(x)) ::: Species with high genetic diversity have the ability to adapt.",
            "∀x ∀p (AdaptedToEnvironment(x, p) → LikelyToSurvive(x)) ::: If a significant portion of a species adapts to the environment, they are likely to survive.",
            "∀x (ResistantToDisease(x) → LikelyToSurvive(x)) ::: If a species is resistant to disease, they are likely to survive.",
            "∀x (HighGeneticDiversity(x) → HighResistantToThreat(x)) ::: High genetic diversity means species can be highly resistant to threats."
        ],
        "predicates": [
            "Species(x) ::: x is a species",
            "HighGeneticDiversity(x) ::: x has high genetic diversity",
            "AdaptedToEnvironment(x, p) ::: p percent of species x is adapted to the environment",
            "LikelyToSurvive(x) ::: x is likely to survive",
            "ExposedToThreat(x) ::: x is exposed to a threat",
            "LowGeneticDiversity(x) ::: x has low genetic diversity",
            "HighReproductionRate(x) ::: x has a high reproduction rate",
            "VulnerableToThreat(x) ::: x is vulnerable to a threat",
            "Protected(x) ::: x is protected",
            "Migrating(x) ::: x is migrating",
            "Infected(x) ::: x is infected",
            "Thriving(x) ::: x is thriving",
            "ResistantToDisease(x) ::: x is resistant to disease"
        ]
    },
    {
        "premises-NL": [
            "All birds are animals.",
            "All birds that live in a forest can fly.",
            "Some birds are green.",
            "All birds that can fly have feathers.",
            "All mammals are animals.",
            "Some animals that live in forests are green.",
            "All green animals eat plants.",
            "All reptiles are animals.",
            "All reptiles have scales.",
            "All reptiles eat insects.",
            "No reptile is a mammal.",
            "There is a bird that lives in a forest.",
            "All birds are either reptiles or mammals."
        ],
        "premises-FOL": [
            "∀x (IsBird(x) → Animal(x)) ::: For all x, if x is a bird then x is an animal.",
            "∀x ((IsBird(x) ∧ LivesInForest(x)) → CanFly(x)) ::: For all x, if x is a bird and lives in a forest, then x can fly.",
            "∃x (IsBird(x) ∧ Green(x)) ::: There exists an x such that x is a bird and green.",
            "∀x (CanFly(x) → HasFeathers(x)) ::: For all x, if x can fly, then x has feathers.",
            "∀x (Mammal(x) → Animal(x)) ::: For all x, if x is a mammal, then x is an animal.",
            "∃x (Animal(x) ∧ LivesInForest(x) ∧ Green(x)) ::: There exists an x such that x is an animal, lives in a forest, and is green.",
            "∀x (Green(x) → EatsPlants(x)) ::: For all x, if x is green, then x eats plants.",
            "∀x (Reptile(x) → Animal(x)) ::: For all x, if x is a reptile, then x is an animal.",
            "∀x (Reptile(x) → HasScales(x)) ::: For all x, if x is a reptile, then x has scales.",
            "∀x (Reptile(x) → EatsInsects(x)) ::: For all x, if x is a reptile, then x eats insects.",
            "∀x (Reptile(x) → ¬Mammal(x)) ::: For all x, if x is a reptile, then x is not a mammal.",
            "∃x (IsBird(x) ∧ LivesInForest(x)) ::: There exists an x such that x is a bird and lives in a forest.",
            "∀x (IsBird(x) → (Reptile(x) ∨ Mammal(x))) ::: For all x, if x is a bird, then x is a reptile or a mammal."
        ],
        "predicates": [
            "Animal(x) ::: x is an animal",
            "Mammal(x) ::: x is a mammal",
            "Green(x) ::: x is green",
            "EatsPlants(x) ::: x eats plants",
            "IsBird(x) ::: x is a bird",
            "LivesInForest(x) ::: x lives in a forest",
            "Reptile(x) ::: x is a reptile",
            "EatsInsects(x) ::: x eats insects",
            "Plant(x) ::: x is a plant",
            "Eats(x, y) ::: x eats y",
            "HasFeathers(x) ::: x has feathers",
            "HasScales(x) ::: x has scales",
            "CanFly(x) ::: x can fly"
        ]
    },
    {
        "premises-NL": [
            "All students are studying Biology, Math or Science.",
            "Some students do not take the Math exam.",
            "All students taking the Math exam are also taking the Biology exam.",
            "No student is taking the Biology exam and the Math exam.",
            "Some students are taking an exam.",
            "All students studying Biology, are taking the exam.",
            "Students take exams.",
            "All student pass math.",
            "All students that are in math are taking exam.",
            "All biology students are students.",
            "All student takes Biology or not.",
            "All students taking Math exam is not taking Biology."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Studies(x, biology) ∨ Studies(x, math) ∨ Studies(x, science)) ::: All students are studying Biology, Math or Science.",
            "∃x (Student(x) ∧ ¬TakesExam(x)) ::: Some students do not take the Math exam.",
            "∀x (Student(x) ∧ TakesExam(x) → TakesExam(x)) ::: All students taking the Math exam are also taking the Biology exam.",
            "¬∃x (Student(x) ∧ TakesExam(x) ∧ TakesExam(x)) ::: No student is taking the Biology exam and the Math exam.",
            "∃x (Student(x) ∧ TakesExam(x)) ::: Some students are taking an exam.",
            "∀x (Student(x) ∧ Studies(x, biology) → TakesExam(x)) ::: All students studying Biology, are taking the exam.",
            "∀x (Student(x) → TakesExam(x)) ::: Students take exams.",
            "∀x (Student(x) ∧ Studies(x, math) → Pass(x, math)) ::: All student pass math.",
            "∀x (Student(x) ∧ Studies(x, math) → TakesExam(x)) ::: All students that are in math are taking exam.",
            "∀x (Studies(x, biology) → Student(x)) ::: All biology students are students.",
            "∀x (Student(x) → (TakesExam(x) ∨ ¬TakesExam(x))) ::: All student takes Biology or not.",
            "∀x (Student(x) ∧ TakesExam(x) → ¬TakesExam(x)) ::: All students taking Math exam is not taking Biology."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x, y) ::: x studies subject y",
            "Biology(x) ::: x is Biology subject",
            "TakesExam(x) ::: x takes the exam",
            "Math(x) ::: x is Math subject",
            "Science(x) ::: x is Science subject",
            "Exam(x) ::: x is exam",
            "Pass(x, y) ::: x passes y"
        ]
    },
    {
        "premises-NL": [
            "All people are either rich or poor.",
            "All people with high incomes pay taxes.",
            "People who work in finance have high incomes.",
            "People who have high incomes are rich.",
            "Anyone who works in healthcare does not pay high taxes.",
            "John is a person who works in finance.",
            "John has a high income.",
            "All people who pay taxes, pay high taxes.",
            "All rich person have high income.",
            "John pays taxes.",
            "Anyone who owns a company pays high taxes.",
            "All who owns a company is a person."
        ],
        "premises-FOL": [
            "∀x (Person(x) → HighIncome(x) ∨ LowIncome(x)) ::: All people are either rich or poor.",
            "∀x (HighIncome(x) → PaysTaxes(x)) ::: All people with high incomes pay taxes.",
            "∀x (WorksIn(x, finance) → HighIncome(x)) ::: People who work in finance have high incomes.",
            "∀x (HighIncome(x) → Rich(x)) ::: People who have high incomes are rich.",
            "∀x (WorksIn(x, healthcare) → ¬HighTaxes(x)) ::: Anyone who works in healthcare does not pay high taxes.",
            "Person(john) ∧ WorksIn(john, finance) ::: John is a person who works in finance.",
            "HighIncome(john) ::: John has a high income.",
            "∀x (PaysTaxes(x) → HighTaxes(x)) ::: All people who pay taxes, pay high taxes.",
            "∀x (Rich(x) → HighIncome(x)) ::: All rich person have high income.",
            "PaysTaxes(john) ::: John pays taxes.",
            "∀x (Owns(x, company) → HighTaxes(x)) ::: Anyone who owns a company pays high taxes.",
            "∀x (Owns(x, company) → Person(x)) ::: All who owns a company is a person."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "HighIncome(x) ::: x has high income",
            "WorksIn(x, y) ::: x works in industry y",
            "Finance(x) ::: x is Finance industry",
            "HighTaxes(x) ::: x pays high taxes",
            "LowIncome(x) ::: x has low income",
            "Healthcare(x) ::: x is Healthcare industry",
            "PaysTaxes(x) ::: x pays taxes",
            "Owns(x, y) ::: x owns y"
        ]
    },
    {
        "premises-NL": [
            "Some artists are also athletes.",
            "Everyone who is an artist is creative.",
            "Everyone who is an athlete is in good shape.",
            "If someone is creative and in good shape, they are healthy.",
            "If someone is an artist, they enjoy art.",
            "If someone is an athlete, they enjoy sports.",
            "If someone enjoys art or sports, they are happy.",
            "Some people who are in good shape enjoy sports.",
            "Some people who are creative enjoy art.",
            "If someone is happy, they are positive.",
            "Everyone is either an artist or an athlete.",
            "If someone is creative and happy, they are productive.",
            "If someone is in good shape and happy, they are strong.",
            "If someone is an athlete and an artist, they are creative.",
            "If someone is healthy, they are positive.",
            "Every activity can be enjoyed by someone."
        ],
        "premises-FOL": [
            "∃x (Artist(x) ∧ Athlete(x)) ::: Some artists are also athletes.",
            "∀x (Artist(x) → Creative(x)) ::: Everyone who is an artist is creative.",
            "∀x (Athlete(x) → GoodShape(x)) ::: Everyone who is an athlete is in good shape.",
            "∀x ((Creative(x) ∧ GoodShape(x)) → Healthy(x)) ::: If someone is creative and in good shape, they are healthy.",
            "∀x (Artist(x) → Enjoys(x, Art)) ::: If someone is an artist, they enjoy art.",
            "∀x (Athlete(x) → Enjoys(x, Sports)) ::: If someone is an athlete, they enjoy sports.",
            "∀x ((Enjoys(x, Art) ∨ Enjoys(x, Sports)) → Happy(x)) ::: If someone enjoys art or sports, they are happy.",
            "∃x (GoodShape(x) ∧ Enjoys(x, Sports)) ::: Some people who are in good shape enjoy sports.",
            "∃x (Creative(x) ∧ Enjoys(x, Art)) ::: Some people who are creative enjoy art.",
            "∀x (Happy(x) → Positive(x)) ::: If someone is happy, they are positive.",
            "∀x (Artist(x) ∨ Athlete(x)) ::: Everyone is either an artist or an athlete.",
            "∀x ((Creative(x) ∧ Happy(x)) → Productive(x)) ::: If someone is creative and happy, they are productive.",
            "∀x ((GoodShape(x) ∧ Happy(x)) → Strong(x)) ::: If someone is in good shape and happy, they are strong.",
            "∀x (Athlete(x) ∧ Artist(x) → Creative(x)) ::: If someone is an athlete and an artist, they are creative.",
            "∀x (Healthy(x) → Positive(x)) ::: If someone is healthy, they are positive.",
            "∀x ∃y Enjoys(x, y) ::: Every activity can be enjoyed by someone."
        ],
        "predicates": [
            "Artist(x) ::: x is an artist",
            "Athlete(x) ::: x is an athlete",
            "Creative(x) ::: x is creative",
            "GoodShape(x) ::: x is in good shape",
            "Enjoys(x, y) ::: x enjoys activity y",
            "Activity(x) ::: x is an activity",
            "Is(x, y) ::: x is y"
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "Sarah is a student.",
            "If someone is smart and studies, they will pass the exam.",
            "Sarah is smart.",
            "If a student studies, then the student is smart.",
            "If Sarah studies, Sarah is a student.",
            "Either Sarah studies or Sarah does not study.",
            "If Sarah is not a student, Sarah is not smart.",
            "Students who study do well.",
            "If a student is smart, they will pass the exam.",
            "Sarah studies."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "Student(sarah) ::: Sarah is a student.",
            "∀x ((Smart(x) ∧ Studies(x)) → PassExam(x)) ::: If someone is smart and studies, they will pass the exam.",
            "Smart(sarah) ::: Sarah is smart.",
            "∀x (Studies(x) → Smart(x)) ::: If a student studies, then the student is smart.",
            "Studies(sarah) → Student(sarah) ::: If Sarah studies, Sarah is a student.",
            "Studies(sarah) ∨ ¬Studies(sarah) ::: Either Sarah studies or Sarah does not study.",
            "¬Student(sarah) → ¬Smart(sarah) ::: If Sarah is not a student, Sarah is not smart.",
            "∀x (Student(x) ∧ Studies(x) → PassExam(x)) ::: Students who study do well.",
            "∀x (Smart(x) → PassExam(x)) ::: If a student is smart, they will pass the exam.",
            "Studies(sarah) ::: Sarah studies."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Studies(x) ::: x studies.",
            "PassExam(x) ::: x passes the exam.",
            "Smart(x) ::: x is smart."
        ]
    },
    {
        "premises-NL": [
            "All eagles are birds.",
            "All eagles can fly.",
            "All penguins are birds.",
            "No penguins can fly.",
            "There exists an eagle.",
            "There exists a penguin.",
            "If someone can fly, then is not a penguin.",
            "If someone is smart, then succeeds.",
            "Everyone has a friend.",
            "Everyone is a student."
        ],
        "premises-FOL": [
            "∀x (Eagle(x) → Bird(x)) ::: For all x, if x is an eagle then x is a bird.",
            "∀x (Eagle(x) → Flies(x)) ::: For all x, if x is an eagle then x flies.",
            "∀x (Penguin(x) → Bird(x)) ::: For all x, if x is a penguin then x is a bird.",
            "∀x (Penguin(x) → ¬Flies(x)) ::: For all x, if x is a penguin then x does not fly.",
            "∃x Eagle(x) ::: There exists an eagle.",
            "∃x Penguin(x) ::: There exists a penguin.",
            "∀x (Flies(x) → ¬Penguin(x)) ::: For all x, if x flies then x is not a penguin.",
            "∀x (Smart(x) → Succeeds(x, y)) ::: If x is smart, then succeeds something.",
            "∀x ∃y FriendOf(x, y) ::: For all x, there exists a y such that x is friend of y.",
            "∀x Student(x) ::: For all x, x is a student."
        ],
        "predicates": [
            "Bird(x) ::: x is a bird",
            "Flies(x) ::: x can fly",
            "Penguin(x) ::: x is a penguin",
            "Eagle(x) ::: x is an eagle",
            "IsA(x, y) ::: x is a y",
            "Succeeds(x,y) ::: x succeeds y",
            "Smart(x) ::: x is smart",
            "FriendOf(x, y) ::: x is a friend of y"
        ]
    },
    {
        "premises-NL": [
            "Every doctor works at a hospital.",
            "Some doctors have a degree in medicine.",
            "Anyone who has a degree in medicine is a researcher.",
            "Dr. Alice is a doctor.",
            "Dr. Alice has a degree in medicine.",
            "Dr. Alice works at a hospital.",
            "Some researchers specialize in medical research."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → WorksAtHospital(x)) ::: Every doctor works at a hospital.",
            "∃x (Doctor(x) ∧ HasDegree(x, \"Medicine\")) ::: Some doctors have a degree in medicine.",
            "∀x (HasDegree(x, \"Medicine\") → Researcher(x)) ::: Anyone who has a degree in medicine is a researcher.",
            "Doctor(\"Alice\") ::: Dr. Alice is a doctor.",
            "HasDegree(\"Alice\", \"Medicine\") ::: Dr. Alice has a degree in medicine.",
            "WorksAtHospital(\"Alice\") ::: Dr. Alice works at a hospital.",
            "∃x (Researcher(x) ∧ SpecializesIn(x, \"MedicalResearch\")) ::: Some researchers specialize in medical research."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Researcher(x) ::: x is a researcher.",
            "WorksAtHospital(x) ::: x works at a hospital.",
            "HasDegree(x, y) ::: x has a degree in y.",
            "SpecializesIn(x, y) ::: x specializes in y."
        ]
    },
    {
        "premises-NL": [
            "All students study or attend lectures.",
            "Anyone who attends lectures reads books.",
            "Anyone who reads books studies.",
            "If a student doesn't study, they fail the exam.",
            "John is a student.",
            "John does not fail the exam.",
            "John studies or attends lectures.",
            "John attends lectures."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Studies(x) ∨ AttendsLectures(x))) ::: All students study or attend lectures.",
            "∀x (AttendsLectures(x) → ReadsBooks(x)) ::: Anyone who attends lectures reads books.",
            "∀x (ReadsBooks(x) → Studies(x)) ::: Anyone who reads books studies.",
            "∀x (¬Studies(x) → FailsExam(x)) ::: If a student doesn't study, they fail the exam.",
            "Student(\"John\") ::: John is a student.",
            "¬FailsExam(\"John\") ::: John does not fail the exam.",
            "(Studies(\"John\") ∨ AttendsLectures(\"John\")) ::: John studies or attends lectures.",
            "AttendsLectures(\"John\") ::: John attends lectures."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Studies(x) ::: x studies.",
            "PassExam(x) ::: x passes the exam.",
            "AttendsLectures(x) ::: x attends lectures.",
            "ReadsBooks(x) ::: x reads books.",
            "FailsExam(x) ::: x fails the exam."
        ]
    },
    {
        "premises-NL": [
            "Everyone likes apples or oranges.",
            "If someone eats something, they like it.",
            "If someone has an allergy to something, they dislike it.",
            "No one eats something they are allergic to.",
            "Alice eats apples and oranges.",
            "Bob has no allergies.",
            "Alice is a person.",
            "Bob eats apples.",
            "Alice likes oranges."
        ],
        "premises-FOL": [
            "∀x (Person(x) → (Likes(x, \"Apples\") ∨ Likes(x, \"Oranges\"))) ::: Everyone likes apples or oranges.",
            "∀x ∀y (Eats(x, y) → Likes(x, y)) ::: If someone eats something, they like it.",
            "∀x ∀y (Allergy(x, y) → Dislikes(x, y)) ::: If someone has an allergy to something, they dislike it.",
            "∀x ∀y (Allergy(x, y) → ¬Eats(x, y)) ::: No one eats something they are allergic to.",
            "Eats(\"Alice\", \"Apples\") ∧ Eats(\"Alice\", \"Oranges\") ::: Alice eats apples and oranges.",
            "¬∃y Allergy(\"Bob\", y) ::: Bob has no allergies.",
            "Person(\"Alice\") ::: Alice is a person.",
            "Eats(\"Bob\", \"Apples\") ::: Bob eats apples.",
            "Likes(\"Alice\", \"Oranges\") ::: Alice likes oranges."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "Likes(x, y) ::: x likes y.",
            "Eats(x, y) ::: x eats y.",
            "Dislikes(x, y) ::: x dislikes y.",
            "Allergy(x, y) ::: x has an allergy to y."
        ]
    },
    {
        "premises-NL": [
            "All members of the club attend meetings and pay dues.",
            "Anyone who doesn't pay dues is excluded.",
            "Anyone who is excluded is not eligible.",
            "If someone is eligible, then they are not excluded.",
            "John attends meetings.",
            "John is a member of the club.",
            "John pays dues.",
            "John is eligible.",
            "Mary is a member of the club.",
            "Mary is not excluded."
        ],
        "premises-FOL": [
            "∀x (MemberOfClub(x) → (AttendsMeetings(x) ∧ PaysDues(x))) ::: All members of the club attend meetings and pay dues.",
            "∀x (¬PaysDues(x) → Excluded(x)) ::: Anyone who doesn't pay dues is excluded.",
            "∀x (Excluded(x) → ¬IsEligible(x)) ::: Anyone who is excluded is not eligible.",
            "∀x (IsEligible(x) → ¬Excluded(x)) ::: If someone is eligible, then they are not excluded.",
            "AttendsMeetings(\"John\") ::: John attends meetings.",
            "MemberOfClub(\"John\") ::: John is a member of the club.",
            "PaysDues(\"John\") ::: John pays dues.",
            "IsEligible(\"John\") ::: John is eligible.",
            "MemberOfClub(\"Mary\") ::: Mary is a member of the club.",
            "¬Excluded(\"Mary\") ::: Mary is not excluded."
        ],
        "predicates": [
            "MemberOfClub(x) ::: x is a member of the club.",
            "AttendsMeetings(x) ::: x attends meetings.",
            "Excluded(x) ::: x is excluded.",
            "PaysDues(x) ::: x pays dues.",
            "IsEligible(x) ::: x is eligible."
        ]
    },
    {
        "premises-NL": [
            "Everyone who speaks a language knows that language.",
            "If someone is a citizen of the US, then they speak English.",
            "If someone is a citizen of Spain, then they speak Spanish.",
            "Anyone can learn a language that they do not already know.",
            "Alice is a citizen of the US.",
            "Bob is a citizen of Spain.",
            "Alice knows English.",
            "Bob speaks Spanish.",
            "Alice speaks English.",
            "Bob knows Spanish.",
            "Alice is a person."
        ],
        "premises-FOL": [
            "∀x ∀y (Speaks(x, y) → Knows(x, y)) ::: Everyone who speaks a language knows that language.",
            "∀x (CitizenOf(x, \"US\") → Speaks(x, \"English\")) ::: If someone is a citizen of the US, then they speak English.",
            "∀x (CitizenOf(x, \"Spain\") → Speaks(x, \"Spanish\")) ::: If someone is a citizen of Spain, then they speak Spanish.",
            "∀x ∀y (¬Knows(x, y) → Learns(x, y)) ::: Anyone can learn a language that they do not already know.",
            "CitizenOf(\"Alice\", \"US\") ::: Alice is a citizen of the US.",
            "CitizenOf(\"Bob\", \"Spain\") ::: Bob is a citizen of Spain.",
            "Knows(\"Alice\", \"English\") ::: Alice knows English.",
            "Speaks(\"Bob\", \"Spanish\") ::: Bob speaks Spanish.",
            "Speaks(\"Alice\", \"English\") ::: Alice speaks English.",
            "Knows(\"Bob\", \"Spanish\") ::: Bob knows Spanish.",
            "Person(\"Alice\") ::: Alice is a person."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "Knows(x, y) ::: x knows language y.",
            "Speaks(x, y) ::: x speaks language y.",
            "Learns(x, y) ::: x learns language y.",
            "Teaches(x, y) ::: x teaches language y.",
            "CitizenOf(x, y) ::: x is a citizen of y."
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "Anyone who can operate is a surgeon.",
            "Some doctors can operate.",
            "Anyone who can operate can treat patients.",
            "Some patients need treatment.",
            "If someone is a patient, then they need treatment.",
            "If someone is a doctor, then they have studied medicine.",
            "Some doctors work at hospitals.",
            "Those who work at hospitals help patients.",
            "Not all doctors can operate.",
            "Some who have studied medicine work at hospitals.",
            "Anyone who can treat patients is a doctor or a nurse.",
            "A doctor is someone who helps patients."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (CanOperate(x) → Surgeon(x)) ::: Anyone who can operate is a surgeon.",
            "∃x (Doctor(x) ∧ CanOperate(x)) ::: Some doctors can operate.",
            "∀x (CanOperate(x) → CanTreat(x)) ::: Anyone who can operate can treat patients.",
            "∃x Patient(x) ::: Some patients need treatment.",
            "∀x (Patient(x) → NeedsTreatment(x)) ::: If someone is a patient, then they need treatment.",
            "∀x (Doctor(x) → StudiedMedicine(x)) ::: If someone is a doctor, then they have studied medicine.",
            "∃x (Doctor(x) ∧ WorksAtHospital(x)) ::: Some doctors work at hospitals.",
            "∀x (WorksAtHospital(x) → HelpsPatients(x)) ::: Those who work at hospitals help patients.",
            "¬∀x (Doctor(x) → CanOperate(x)) ::: Not all doctors can operate.",
            "∃x (StudiedMedicine(x) ∧ WorksAtHospital(x)) ::: Some who have studied medicine work at hospitals.",
            "∀x (CanTreat(x) → (Doctor(x) ∨ Nurse(x))) ::: Anyone who can treat patients is a doctor or a nurse.",
            "∀x (Doctor(x) → HelpsPatients(x)) ::: A doctor is someone who helps patients."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "CanOperate(x) ::: x can operate",
            "CanTreat(x) ::: x can treat patients",
            "Patient(x) ::: x is a patient"
        ]
    },
    {
        "premises-NL": [
            "All intelligent students attend lectures.",
            "All students who attend lectures read books.",
            "Some students are intelligent.",
            "Students who read books study diligently.",
            "If a student studies diligently, then they get good grades.",
            "If a student gets good grades, they will pass the exam.",
            "All students enjoy learning or they do not study diligently.",
            "Students who enjoy learning are intelligent.",
            "Some students do not enjoy learning.",
            "If a student is intelligent and studies diligently, then they attend lectures.",
            "Some who are intelligent do not attend lectures.",
            "Some students pass the exam.",
            "Some students do not study diligently.",
            "All students who do not read books, fail the exam."
        ],
        "premises-FOL": [
            "∀x (Intelligent(x) → AttendsLectures(x)) ::: All intelligent students attend lectures.",
            "∀x (AttendsLectures(x) → ReadsBooks(x)) ::: All students who attend lectures read books.",
            "∃x Intelligent(x) ::: Some students are intelligent.",
            "∀x (ReadsBooks(x) → StudiesDiligently(x)) ::: Students who read books study diligently.",
            "∀x (StudiesDiligently(x) → GetsGoodGrades(x)) ::: If a student studies diligently, then they get good grades.",
            "∀x (GetsGoodGrades(x) → PassExam(x)) ::: If a student gets good grades, they will pass the exam.",
            "∀x (Student(x) → (EnjoysLearning(x) ∨ ¬StudiesDiligently(x))) ::: All students enjoy learning or they do not study diligently.",
            "∀x (EnjoysLearning(x) → Intelligent(x)) ::: Students who enjoy learning are intelligent.",
            "∃x (Student(x) ∧ ¬EnjoysLearning(x)) ::: Some students do not enjoy learning.",
            "∀x ((Intelligent(x) ∧ StudiesDiligently(x)) → AttendsLectures(x)) ::: If a student is intelligent and studies diligently, then they attend lectures.",
            "∃x (Intelligent(x) ∧ ¬AttendsLectures(x)) ::: Some who are intelligent do not attend lectures.",
            "∃x PassExam(x) ::: Some students pass the exam.",
            "∃x (Student(x) ∧ ¬StudiesDiligently(x)) ::: Some students do not study diligently.",
            "∀x (Student(x) ∧ ¬ReadsBooks(x) → ¬PassExam(x)) ::: All students who do not read books, fail the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Intelligent(x) ::: x is intelligent",
            "StudiesDiligently(x) ::: x studies diligently",
            "PassExam(x) ::: x passes the exam",
            "AttendsLectures(x) ::: x attends lectures",
            "ReadsBooks(x) ::: x reads books",
            "GetsGoodGrades(x) ::: x gets good grades",
            "EnjoysLearning(x) ::: x enjoys learning"
        ]
    },
    {
        "premises-NL": [
            "All books are items.",
            "All library items can be borrowed.",
            "Some books are library items.",
            "If an item is borrowed, then it is not available.",
            "All borrowed items are read or lost.",
            "All books have pages.",
            "If an item is available, then it is not borrowed.",
            "All items that are read are either books or magazines.",
            "All fiction books are read.",
            "Some books are fiction.",
            "If an item is a book and available, then it has not been read.",
            "All library items are items.",
            "If an item is a book and is borrowed, it is in the library.",
            "Books are read or are not available.",
            "If an item has pages, it is a book."
        ],
        "premises-FOL": [
            "∀x (Book(x) → Item(x)) ::: All books are items.",
            "∀x (LibraryItem(x) → CanBeBorrowed(x)) ::: All library items can be borrowed.",
            "∃x (Book(x) ∧ LibraryItem(x)) ::: Some books are library items.",
            "∀x (Borrowed(x) → ¬Available(x)) ::: If an item is borrowed, then it is not available.",
            "∀x (Borrowed(x) → (Read(x) ∨ Lost(x))) ::: All borrowed items are read or lost.",
            "∀x (Book(x) → HasPages(x)) ::: All books have pages.",
            "∀x (Available(x) → ¬Borrowed(x)) ::: If an item is available, then it is not borrowed.",
            "∀x (Read(x) → (Book(x) ∨ Magazine(x))) ::: All items that are read are either books or magazines.",
            "∀x (IsFiction(x) ∧ Book(x) → Read(x)) ::: All fiction books are read.",
            "∃x (Book(x) ∧ IsFiction(x)) ::: Some books are fiction.",
            "∀x ((Book(x) ∧ Available(x)) → ¬Read(x)) ::: If an item is a book and available, then it has not been read.",
            "∀x (LibraryItem(x) → Item(x)) ::: All library items are items.",
            "∀x ((Book(x) ∧ Borrowed(x)) → InLibrary(x)) ::: If an item is a book and is borrowed, it is in the library.",
            "∀x (Book(x) → (Read(x) ∨ ¬Available(x))) ::: Books are read or are not available.",
            "∀x (HasPages(x) → Book(x)) ::: If an item has pages, it is a book."
        ],
        "predicates": [
            "Item(x) ::: x is an item",
            "Book(x) ::: x is a book",
            "Borrowed(x) ::: x is borrowed",
            "Read(x) ::: x is read",
            "Available(x) ::: x is available",
            "LibraryItem(x) ::: x is a library item",
            "HasPages(x) ::: x has pages",
            "IsFiction(x) ::: x is fiction"
        ]
    },
    {
        "premises-NL": [
            "All students are persons.",
            "If someone is a friend of a student, then they are a student.",
            "Some students are enrolled in courses.",
            "Anyone enrolled in a course takes exams.",
            "If someone takes an exam and passes, they are smart.",
            "All smart people do not have homework.",
            "If someone is a friend of a person, then that person is a friend of them.",
            "Some friends of students are students and are not smart.",
            "Anyone who takes an exam has homework.",
            "If someone is a friend of a friend, then the second one is a student and the first is a person.",
            "Some people are enrolled and take exams.",
            "If a student is smart, then they passed the exam.",
            "Students who pass the exam are smart or do homework.",
            "No student is both smart and has homework.",
            "If someone is a student, and they are a friend of another, they are friends.",
            "If someone is a friend of someone who is smart, then that someone has homework."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Person(x)) ::: All students are persons.",
            "∀x ∀y ((FriendOf(x, y) ∧ Student(y)) → Student(x)) ::: If someone is a friend of a student, then they are a student.",
            "∃x ∃y (Student(x) ∧ EnrolledIn(x, y)) ::: Some students are enrolled in courses.",
            "∀x ∀y (EnrolledIn(x, y) → TakesExam(x, y)) ::: Anyone enrolled in a course takes exams.",
            "∀x ∀y ((TakesExam(x, y) ∧ PassedExam(x, y)) → Smart(x)) ::: If someone takes an exam and passes, they are smart.",
            "∀x (Smart(x) → ¬HasHomework(x)) ::: All smart people do not have homework.",
            "∀x ∀y (FriendOf(x, y) → FriendOf(y, x)) ::: If someone is a friend of a person, then that person is a friend of them.",
            "∃x ∃y (FriendOf(x, y) ∧ Student(y) ∧ Student(x) ∧ ¬Smart(x)) ::: Some friends of students are students and are not smart.",
            "∀x ∀y (TakesExam(x, y) → HasHomework(x)) ::: Anyone who takes an exam has homework.",
            "∀x ∀y ∀z ((FriendOf(x, y) ∧ FriendOf(y, z)) → (Student(z) ∧ Person(x))) ::: If someone is a friend of a friend, then the second one is a student and the first is a person.",
            "∃x ∃y (EnrolledIn(x, y) ∧ TakesExam(x, y)) ::: Some people are enrolled and take exams.",
            "∀x (Student(x) ∧ Smart(x) → PassedExam(x, y)) ::: If a student is smart, then they passed the exam.",
            "∀x (Student(x) ∧ PassedExam(x, y) → (Smart(x) ∨ HasHomework(x))) ::: Students who pass the exam are smart or do homework.",
            "∀x (¬(Student(x) ∧ Smart(x) ∧ HasHomework(x))) ::: No student is both smart and has homework.",
            "∀x ∀y ((Student(x) ∧ FriendOf(x, y)) → FriendOf(x, y)) ::: If someone is a student, and they are a friend of another, they are friends.",
            "∀x ∀y ((FriendOf(x, y) ∧ Smart(y)) → HasHomework(x)) ::: If someone is a friend of someone who is smart, then that someone has homework."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "FriendOf(x, y) ::: x is a friend of y",
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in course y",
            "TakesExam(x, y) ::: x takes exam y",
            "PassedExam(x, y) ::: x passed exam y",
            "Smart(x) ::: x is smart",
            "HasHomework(x) ::: x has homework"
        ]
    },
    {
        "premises-NL": [
            "All students are people.",
            "Some people study a subject.",
            "Anyone who studies a subject loves learning.",
            "Anyone who studies a subject and is a student is hard working.",
            "All hard-working people love to learn.",
            "Some students enjoy studying subjects.",
            "If someone enjoys something and is a student, then they are a student and love to learn.",
            "All professors are students.",
            "Professor Smith teaches a subject."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Person(x)) ::: All students are people.",
            "∃x ∃y (Person(x) ∧ Studies(x, y) ∧ Subject(y)) ::: Some people study a subject.",
            "∀x ∀y (Studies(x, y) ∧ Subject(y) → LovesToLearn(x)) ::: Anyone who studies a subject loves learning.",
            "∀x ∀y ((Studies(x, y) ∧ Student(x) ∧ Subject(y)) → HardWorking(x)) ::: Anyone who studies a subject and is a student is hard working.",
            "∀x (HardWorking(x) → LovesToLearn(x)) ::: All hard-working people love to learn.",
            "∃x ∃y (Student(x) ∧ Enjoys(x, y) ∧ Subject(y)) ::: Some students enjoy studying subjects.",
            "∀x ∀y ((Enjoys(x, y) ∧ Student(x) ∧ Subject(y)) → (Student(x) ∧ LovesToLearn(x))) ::: If someone enjoys something and is a student, then they are a student and love to learn.",
            "∀x (Professor(x) → Student(x)) ::: All professors are students.",
            "∃y (Teaches(smith, y) ∧ Subject(y)) ::: Professor Smith teaches a subject."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "Student(x) ::: x is a student.",
            "LovesToLearn(x) ::: x loves to learn.",
            "Studies(x, y) ::: x studies y.",
            "Subject(y) ::: y is a subject.",
            "HardWorking(x) ::: x is hard working.",
            "Enjoys(x, y) ::: x enjoys y.",
            "Teaches(x, y) ::: x teaches y.",
            "Professor(x) ::: x is a professor."
        ]
    },
    {
        "premises-NL": [
            "All scientists have a degree.",
            "Some scientists study biology.",
            "All who study biology are researchers.",
            "Some scientists are employed by the university.",
            "Everyone employed by the university is a scientist.",
            "All who have a degree are scientists.",
            "If someone studies biology and has a degree, then they are a researcher.",
            "Some scientists study biology and have a degree.",
            "Anyone who is a scientist is also a researcher.",
            "Every researcher studies biology.",
            "The university only employs researchers.",
            "Only researchers have degrees.",
            "All who are scientists study biology."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → HasDegree(x, something)) ::: All scientists have a degree.",
            "∃x (Scientist(x) ∧ Studies(x, Biology)) ::: Some scientists study biology.",
            "∀x (Studies(x, Biology) → Researcher(x)) ::: All who study biology are researchers.",
            "∃x (Scientist(x) ∧ IsEmployedBy(x, University)) ::: Some scientists are employed by the university.",
            "∀x (IsEmployedBy(x, University) → Scientist(x)) ::: Everyone employed by the university is a scientist.",
            "∀x (HasDegree(x, something) → Scientist(x)) ::: All who have a degree are scientists.",
            "∀x ∀y ((Studies(x, Biology) ∧ HasDegree(x, y)) → Researcher(x)) ::: If someone studies biology and has a degree, then they are a researcher.",
            "∃x (Scientist(x) ∧ Studies(x, Biology) ∧ HasDegree(x, something)) ::: Some scientists study biology and have a degree.",
            "∀x (Scientist(x) → Researcher(x)) ::: Anyone who is a scientist is also a researcher.",
            "∀x (Researcher(x) → Studies(x, Biology)) ::: Every researcher studies biology.",
            "∀x (IsEmployedBy(x, University) → Researcher(x)) ::: The university only employs researchers.",
            "∀x (HasDegree(x, something) → Researcher(x)) ::: Only researchers have degrees.",
            "∀x (Scientist(x) → Studies(x, Biology)) ::: All who are scientists study biology."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Researcher(x) ::: x is a researcher",
            "Studies(x, y) ::: x studies y",
            "HasDegree(x, y) ::: x has a degree in y",
            "IsEmployedBy(x, y) ::: x is employed by y"
        ]
    },
    {
        "premises-NL": [
            "All students either study or work hard.",
            "If someone is smart, they study.",
            "Some students work hard.",
            "Anyone who studies is smart.",
            "If someone works hard, they are successful.",
            "Not all students work hard.",
            "Some students are smart.",
            "If someone studies they work hard.",
            "Some students are smart and not successful.",
            "All students either are successful or study",
            "There exists at least one student.",
            "If someone works hard, they are smart.",
            "No student is both smart and does not study.",
            "If someone is successful they either work hard or study."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Studies(x) ∨ WorksHard(x))) ::: All students either study or work hard.",
            "∀x (Smart(x) → Studies(x)) ::: If someone is smart, they study.",
            "∃x (Student(x) ∧ WorksHard(x)) ::: Some students work hard.",
            "∀x (Studies(x) → Smart(x)) ::: Anyone who studies is smart.",
            "∀x (WorksHard(x) → Successful(x)) ::: If someone works hard, they are successful.",
            "¬∀x (Student(x) → WorksHard(x)) ::: Not all students work hard.",
            "∃x (Student(x) ∧ Smart(x)) ::: Some students are smart.",
            "∀x (Studies(x) → WorksHard(x)) ::: If someone studies they work hard.",
            "∃x (Student(x) ∧ Smart(x) ∧ ¬Successful(x)) ::: Some students are smart and not successful.",
            "∀x (Student(x) → (Successful(x) ∨ Studies(x))) ::: All students either are successful or study",
            "∃x Student(x) ::: There exists at least one student.",
            "∀x (WorksHard(x) → Smart(x)) ::: If someone works hard, they are smart.",
            "¬∃x (Student(x) ∧ Smart(x) ∧ ¬Studies(x)) ::: No student is both smart and does not study.",
            "∀x (Successful(x) → (WorksHard(x) ∨ Studies(x))) ::: If someone is successful they either work hard or study."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Smart(x) ::: x is smart",
            "Successful(x) ::: x is successful",
            "Studies(x) ::: x studies",
            "WorksHard(x) ::: x works hard"
        ]
    },
    {
        "premises-NL": [
            "Some politicians are corrupt.",
            "All politicians are either honest or corrupt.",
            "No honest person is corrupt.",
            "If a politician is corrupt, then they are influenced.",
            "Some politicians are influenced.",
            "If a politician is wealthy, they are not corrupt.",
            "Some politicians are not wealthy.",
            "All politicians are either honest or wealthy.",
            "Some politicians are influenced by someone.",
            "If someone is influenced they are a politician.",
            "If someone is honest, they are not influenced.",
            "If someone is corrupt, they are a politician.",
            "Some politicians are honest.",
            "If someone is wealthy, they are a politician.",
            "If someone is corrupt they are not wealthy."
        ],
        "premises-FOL": [
            "∃x (Politician(x) ∧ Corrupt(x)) ::: Some politicians are corrupt.",
            "∀x (Politician(x) → (Honest(x) ∨ Corrupt(x))) ::: All politicians are either honest or corrupt.",
            "¬∃x (Honest(x) ∧ Corrupt(x)) ::: No honest person is corrupt.",
            "∀x (Politician(x) ∧ Corrupt(x) → Influenced(x, y)) ::: If a politician is corrupt, then they are influenced.",
            "∃x Influenced(x, y) ∧ Politician(x) ::: Some politicians are influenced.",
            "∀x (Politician(x) ∧ Wealthy(x) → ¬Corrupt(x)) ::: If a politician is wealthy, they are not corrupt.",
            "∃x (Politician(x) ∧ ¬Wealthy(x)) ::: Some politicians are not wealthy.",
            "∀x (Politician(x) → (Honest(x) ∨ Wealthy(x))) ::: All politicians are either honest or wealthy.",
            "∃x ∃y Influenced(x, y) ∧ Politician(x) ::: Some politicians are influenced by someone.",
            "∀x (Influenced(x, y) → Politician(x)) ::: If someone is influenced they are a politician.",
            "∀x (Honest(x) → ¬Influenced(x, y)) ::: If someone is honest, they are not influenced.",
            "∀x (Corrupt(x) → Politician(x)) ::: If someone is corrupt, they are a politician.",
            "∃x (Politician(x) ∧ Honest(x)) ::: Some politicians are honest.",
            "∀x (Wealthy(x) → Politician(x)) ::: If someone is wealthy, they are a politician.",
            "∀x (Corrupt(x) → ¬Wealthy(x)) ::: If someone is corrupt they are not wealthy."
        ],
        "predicates": [
            "Politician(x) ::: x is a politician",
            "Honest(x) ::: x is honest",
            "Wealthy(x) ::: x is wealthy",
            "Corrupt(x) ::: x is corrupt",
            "Influenced(x, y) ::: x is influenced by y"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All doctors are employed.",
            "If someone has a medical license, they are a doctor.",
            "If someone is a surgeon, then they have a license.",
            "Alice is a surgeon.",
            "Bob is a doctor.",
            "Charlie is a doctor."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Doctor(x) → Employed(x)) ::: All doctors are employed.",
            "∀x (HasLicense(x) → Doctor(x)) ::: If someone has a medical license, they are a doctor.",
            "∀x (Surgeon(x) → HasLicense(x)) ::: If someone is a surgeon, then they have a license.",
            "Surgeon(Alice) ::: Alice is a surgeon.",
            "Doctor(Bob) ::: Bob is a doctor.",
            "Doctor(Charlie) ::: Charlie is a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "Employed(x) ::: x is employed",
            "HasLicense(x) ::: x has a medical license"
        ]
    },
    {
        "premises-NL": [
            "All books are library items.",
            "All borrowed items are overdue.",
            "All library items can be borrowed.",
            "If something is a book it has a due date.",
            "This is a book.",
            "This book is borrowed.",
            "That item is a book.",
            "That item is borrowed."
        ],
        "premises-FOL": [
            "∀x (Book(x) → LibraryItem(x)) ::: All books are library items.",
            "∀x (Borrowed(x) → Overdue(x)) ::: All borrowed items are overdue.",
            "∀x (LibraryItem(x) → Borrowed(x)) ::: All library items can be borrowed.",
            "∀x (Book(x) → HasDueDate(x)) ::: If something is a book it has a due date.",
            "Book(this) ::: This is a book.",
            "Borrowed(this) ::: This book is borrowed.",
            "Book(that) ::: That item is a book.",
            "Borrowed(that) ::: That item is borrowed."
        ],
        "predicates": [
            "Book(x) ::: x is a book",
            "Borrowed(x) ::: x is borrowed",
            "Overdue(x) ::: x is overdue",
            "LibraryItem(x) ::: x is a library item",
            "HasDueDate(x) ::: x has a due date"
        ]
    },
    {
        "premises-NL": [
            "All teachers are educators.",
            "All mentors are educators.",
            "If someone is a researcher, they write papers.",
            "If someone writes papers, they are a mentor.",
            "Alice is a teacher.",
            "Bob is a mentor.",
            "Charlie is a researcher.",
            "David is a teacher and mentor.",
            "Eve advises Bob."
        ],
        "premises-FOL": [
            "∀x (Teacher(x) → Educator(x)) ::: All teachers are educators.",
            "∀x (Mentor(x) → Educator(x)) ::: All mentors are educators.",
            "∀x (Researcher(x) → WritesPapers(x)) ::: If someone is a researcher, they write papers.",
            "∀x (WritesPapers(x) → Mentor(x)) ::: If someone writes papers, they are a mentor.",
            "Teacher(Alice) ::: Alice is a teacher.",
            "Mentor(Bob) ::: Bob is a mentor.",
            "Researcher(Charlie) ::: Charlie is a researcher.",
            "(Teacher(David) ∧ Mentor(David)) ::: David is a teacher and mentor.",
            "AdvisesStudents(David, Bob) ::: Eve advises Bob."
        ],
        "predicates": [
            "Teacher(x) ::: x is a teacher",
            "Mentor(x) ::: x is a mentor",
            "Educator(x) ::: x is an educator",
            "Researcher(x) ::: x is a researcher",
            "WritesPapers(x) ::: x writes papers",
            "AdvisesStudents(x, y) ::: x advises student y"
        ]
    },
    {
        "premises-NL": [
            "All scientists work at a university.",
            "Some scientists study biology.",
            "Any scientist who studies biology also studies chemistry.",
            "Dr. Smith is a scientist.",
            "Dr. Smith works at Oxford University.",
            "Dr. Smith studies biology.",
            "All those who study chemistry work at a university.",
            "Some scientists teach.",
            "If someone teaches then he is a scientist.",
            "Oxford university is the best university"
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → WorksAtUniversity(x, y)) ::: All scientists work at a university.",
            "∃x (Scientist(x) ∧ StudiesBiology(x)) ::: Some scientists study biology.",
            "∀x (Scientist(x) ∧ StudiesBiology(x) → StudiesChemistry(x)) ::: Any scientist who studies biology also studies chemistry.",
            "Scientist(drSmith) ::: Dr. Smith is a scientist.",
            "WorksAtUniversity(drSmith, oxford) ::: Dr. Smith works at Oxford University.",
            "StudiesBiology(drSmith) ::: Dr. Smith studies biology.",
            "∀x (StudiesChemistry(x) → WorksAtUniversity(x, y)) ::: All those who study chemistry work at a university.",
            "∃x (Scientist(x) ∧ Teaches(x, y)) ::: Some scientists teach.",
            "∀x (Teaches(x, y) → Scientist(x)) ::: If someone teaches then he is a scientist.",
            "BestUniversity(oxford) ::: Oxford university is the best university."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "StudiesBiology(x) ::: x studies biology",
            "StudiesChemistry(x) ::: x studies chemistry",
            "WorksAtUniversity(x, y) ::: x works at university y",
            "Teaches(x, y) ::: x teaches y"
        ]
    },
    {
        "premises-NL": [
            "All authors write.",
            "Some authors write fiction.",
            "Some authors write non-fiction.",
            "If someone writes fiction and non-fiction, they're an author.",
            "If someone writes fiction they also gets published.",
            "If someone writes non-fiction and is an author, they get published.",
            "Jane is an author.",
            "Jane writes fiction.",
            "Jane writes non-fiction.",
            "All writers who write fiction or non-fiction are published.",
            "If someone is published, they are famous."
        ],
        "premises-FOL": [
            "∀x (Author(x) → Writes(x, y)) ::: All authors write.",
            "∃x (Author(x) ∧ WritesFiction(x)) ::: Some authors write fiction.",
            "∃x (Author(x) ∧ WritesNonFiction(x)) ::: Some authors write non-fiction.",
            "∀x (WritesFiction(x) ∧ WritesNonFiction(x) → Author(x)) ::: If someone writes fiction and non-fiction, they're an author.",
            "∀x (WritesFiction(x) → GetsPublished(x)) ::: If someone writes fiction they also gets published.",
            "∀x (WritesNonFiction(x) ∧ Author(x) → GetsPublished(x)) ::: If someone writes non-fiction and is an author, they get published.",
            "Author(jane) ::: Jane is an author.",
            "WritesFiction(jane) ::: Jane writes fiction.",
            "WritesNonFiction(jane) ::: Jane writes non-fiction.",
            "∀x ((WritesFiction(x) ∨ WritesNonFiction(x)) → GetsPublished(x)) ::: All writers who write fiction or non-fiction are published.",
            "∀x (GetsPublished(x) → Famous(x)) ::: If someone is published, they are famous."
        ],
        "predicates": [
            "Author(x) ::: x is an author",
            "WritesFiction(x) ::: x writes fiction",
            "WritesNonFiction(x) ::: x writes non-fiction",
            "GetsPublished(x) ::: x gets published",
            "Writes(x, y) ::: x writes about y"
        ]
    },
    {
        "premises-NL": [
            "All programmers write code.",
            "Some writers are programmers.",
            "If someone is a writer, they read books.",
            "If someone reads books and writes code, then they are creative.",
            "No creative people are lazy.",
            "All programmers are intelligent.",
            "Some intelligent people are writers.",
            "If x is a writer and y is a programmer, then x knows y.",
            "Every writer is either a programmer or reads books.",
            "If x writes code then x is a programmer or a writer."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → WritesCode(x)) ::: All programmers write code.",
            "∃x (Writer(x) ∧ Programmer(x)) ::: Some writers are programmers.",
            "∀x (Writer(x) → ReadsBooks(x)) ::: If someone is a writer, they read books.",
            "∀x ((ReadsBooks(x) ∧ WritesCode(x)) → Creative(x)) ::: If someone reads books and writes code, then they are creative.",
            "∀x (Creative(x) → ¬Lazy(x)) ::: No creative people are lazy.",
            "∀x (Programmer(x) → Intelligent(x)) ::: All programmers are intelligent.",
            "∃x (Intelligent(x) ∧ Writer(x)) ::: Some intelligent people are writers.",
            "∀x ∀y ((Writer(x) ∧ Programmer(y)) → Knows(x, y)) ::: If x is a writer and y is a programmer, then x knows y.",
            "∀x (Writer(x) → (Programmer(x) ∨ ReadsBooks(x))) ::: Every writer is either a programmer or reads books.",
            "∀x (WritesCode(x) → (Programmer(x) ∨ Writer(x))) ::: If x writes code then x is a programmer or a writer."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "WritesCode(x) ::: x writes code",
            "Writer(x) ::: x is a writer",
            "ReadsBooks(x) ::: x reads books"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard pass the exam.",
            "Sarah is a student.",
            "Sarah studies hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ HardStudy(x) → PassExam(x)) ::: All students who study hard pass the exam.",
            "Student(sarah) ::: Sarah is a student.",
            "HardStudy(sarah) ::: Sarah studies hard.",
            "¬(PassExam(sarah) ∧ ¬(HardStudy(sarah))) ::: Sarah must study hard if she pass the exam.",
            "Student(john) ∨ ¬(Student(john)) ::: John is a student or John isn't a student.",
            "∀x (PassExam(x) → ¬(FailExam(x))) ::: All students who pass the exam don't fail the exam.",
            "Student(mike) → (HardStudy(mike) ∨ ¬(PassExam(mike))) ::: If Mike is a student, he studies hard or he doesn't pass.",
            "Student(sarah) → (HardStudy(sarah) ∨ ¬(PassExam(sarah))) ::: If Sarah is a student, she studies hard or she doesn't pass."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "HardStudy(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "If someone likes apples, then they eat apples.",
            "If someone likes bananas, then they eat bananas.",
            "Anyone who eats apples dislikes apples.",
            "Anyone who eats bananas likes bananas.",
            "Alice likes apples and bananas.",
            "Bob dislikes apples.",
            "If someone likes bananas and dislikes apples, then they dislike apples.",
            "If Alice likes apples, then she eats apples and is a fruit.",
            "If Bob dislikes apples, then Bob eats apples or Bob doesn't like apples.",
            "If Bob dislikes apples, then Bob doesn't eat bananas or Bob doesn't eat apples.",
            "If someone likes bananas and dislikes apples, then they dislike apples and like bananas.",
            "Everyone eats only fruits."
        ],
        "premises-FOL": [
            "∀x (Likes(x, apples) → Eats(x, apples)) ::: If someone likes apples, then they eat apples.",
            "∀x (Likes(x, bananas) → Eats(x, bananas)) ::: If someone likes bananas, then they eat bananas.",
            "∀x (Eats(x, apples) → Dislikes(x, apples)) ::: Anyone who eats apples dislikes apples.",
            "∀x (Eats(x, bananas) → Likes(x, bananas)) ::: Anyone who eats bananas likes bananas.",
            "Likes(alice, apples) ∧ Likes(alice, bananas) ::: Alice likes apples and bananas.",
            "Dislikes(bob, apples) ::: Bob dislikes apples.",
            "∀x (Likes(x, bananas) ∧ Dislikes(x, apples) → Dislikes(x, apples)) ::: If someone likes bananas and dislikes apples, then they dislike apples.",
            "Likes(alice, apples) → (Eats(alice, apples) ∧ IsFruit(alice)) ::: If Alice likes apples, then she eats apples and is a fruit.",
            "Dislikes(bob, apples) → (Eats(bob, apples) ∨ ¬Likes(bob, apples)) ::: If Bob dislikes apples, then Bob eats apples or Bob doesn't like apples.",
            "Dislikes(bob, apples) → (¬Eats(bob, bananas) ∨ ¬Eats(bob, apples)) ::: If Bob dislikes apples, then Bob doesn't eat bananas or Bob doesn't eat apples.",
            "∀x ((Likes(x, bananas) ∧ Dislikes(x, apples)) → (Dislikes(x, apples) ∧ Likes(x, bananas))) ::: If someone likes bananas and dislikes apples, then they dislike apples and like bananas.",
            "∀x ∀y (Eats(x, y) → IsFruit(y)) ::: Everyone eats only fruits."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Dislikes(x, y) ::: x dislikes y",
            "Eats(x, y) ::: x eats y",
            "IsFruit(x) ::: x is a fruit"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard will pass the exam.",
            "Alice is a student.",
            "Alice studies hard.",
            "If someone is smart then they study hard.",
            "Alice is smart.",
            "If someone studies hard, then they will pass the exam.",
            "All students are smart.",
            "If someone is a student and studies hard, they will pass the exam."
        ],
        "premises-FOL": [
            "∀x ((Student(x) ∧ StudiesHard(x)) → PassExam(x)) ::: All students who study hard will pass the exam.",
            "Student(alice) ::: Alice is a student.",
            "StudiesHard(alice) ::: Alice studies hard.",
            "∀x (IsSmart(x) → StudiesHard(x)) ::: If someone is smart then they study hard.",
            "IsSmart(alice) ::: Alice is smart.",
            "∀x (StudiesHard(x) → PassExam(x)) ::: If someone studies hard, then they will pass the exam.",
            "∀x (Student(x) → IsSmart(x)) ::: All students are smart.",
            "∀x ((Student(x) ∧ StudiesHard(x)) → PassExam(x)) ::: If someone is a student and studies hard, they will pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x will pass the exam",
            "IsSmart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All doctors are licensed.",
            "John is a doctor.",
            "All licensed individuals practice medicine.",
            "If someone is a surgeon, then they are a doctor.",
            "All doctors have a medical degree.",
            "John is licensed.",
            "John practices medicine.",
            "All surgeons are licensed.",
            "John is a surgeon."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → IsLicensed(x)) ::: All doctors are licensed.",
            "Doctor(john) ::: John is a doctor.",
            "∀x (IsLicensed(x) → PracticesMedicine(x)) ::: All licensed individuals practice medicine.",
            "∀x (Surgeon(x) → Doctor(x)) ::: If someone is a surgeon, then they are a doctor.",
            "∀x (Doctor(x) → HasMedicalDegree(x)) ::: All doctors have a medical degree.",
            "IsLicensed(john) ::: John is licensed.",
            "PracticesMedicine(john) ::: John practices medicine.",
            "∀x (Surgeon(x) → IsLicensed(x)) ::: All surgeons are licensed.",
            "Surgeon(john) ::: John is a surgeon."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "HasMedicalDegree(x) ::: x has a medical degree",
            "IsLicensed(x) ::: x is licensed",
            "PracticesMedicine(x) ::: x practices medicine",
            "Surgeon(x) ::: x is a surgeon"
        ]
    },
    {
        "premises-NL": [
            "All rich people own a car.",
            "Some people are rich.",
            "Everyone who reads an interesting book enjoys reading.",
            "All fiction books are interesting.",
            "Someone reads a fiction book.",
            "If a person has a job, then they are rich.",
            "Someone works at a company.",
            "All who have a job and work at a company owns a car.",
            "People who read books also enjoy reading."
        ],
        "premises-FOL": [
            "∀x (Rich(x) → OwnsCar(x)) ::: For all x, if x is rich, then x owns a car.",
            "∃x Rich(x) ::: There exists an x such that x is rich.",
            "∀x ∀y (ReadsBook(x, y) ∧ IsInterestingBook(y) → EnjoysReading(x)) ::: For all x and y, if x reads y and y is interesting, then x enjoys reading.",
            "∀x (IsFictionBook(x) → IsInterestingBook(x)) ::: For all x, if x is a fiction book, then x is an interesting book.",
            "∃x ∃y (ReadsBook(x, y) ∧ IsFictionBook(y)) ::: There exists an x and y such that x reads y and y is a fiction book.",
            "∀x (HasJob(x) → Rich(x)) ::: For all x, if x has a job, then x is rich.",
            "∃x ∃y WorksAt(x, y) ::: There exists an x and y such that x works at y.",
            "∀x ∀y (HasJob(x) ∧ WorksAt(x, y) → OwnsCar(x)) ::: For all x and y, if x has a job and works at y, then x owns a car.",
            "∀x ∀y (ReadsBook(x, y) → EnjoysReading(x)) ::: For all x and y, if x reads y, then x enjoys reading."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "EnjoysReading(x) ::: x enjoys reading.",
            "OwnsCar(x) ::: x owns a car.",
            "Rich(x) ::: x is rich.",
            "HasJob(x) ::: x has a job.",
            "ReadsBook(x, y) ::: x reads book y.",
            "IsInterestingBook(x) ::: x is an interesting book.",
            "IsFictionBook(x) ::: x is a fiction book.",
            "WorksAt(x, y) ::: x works at company y."
        ]
    },
    {
        "premises-NL": [
            "All doctors are either surgeons or specialists.",
            "Some doctors work at hospitals.",
            "All surgeons treat illnesses.",
            "Anyone who works at a hospital, cares for patients.",
            "Some specialists have a good reputation.",
            "No wealthy person has a good reputation.",
            "Anyone who has a good reputation treats illnesses.",
            "Anyone who is a surgeon is a doctor.",
            "There is at least one doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → (Surgeon(x) ∨ Specialist(x))) ::: All doctors are either surgeons or specialists.",
            "∃x (Doctor(x) ∧ WorksAtHospital(x)) ::: Some doctors work at hospitals.",
            "∀x (Surgeon(x) → TreatsIllness(x)) ::: All surgeons treat illnesses.",
            "∀x (WorksAtHospital(x) → CaresForPatients(x)) ::: Anyone who works at a hospital, cares for patients.",
            "∃x (Specialist(x) ∧ HasGoodReputation(x)) ::: Some specialists have a good reputation.",
            "∀x (Wealthy(x) → ¬HasGoodReputation(x)) ::: No wealthy person has a good reputation.",
            "∀x (HasGoodReputation(x) → TreatsIllness(x)) ::: Anyone who has a good reputation treats illnesses.",
            "∀x (Surgeon(x) → Doctor(x)) ::: Anyone who is a surgeon is a doctor.",
            "∃x Doctor(x) ::: There is at least one doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Wealthy(x) ::: x is wealthy",
            "CaresForPatients(x) ::: x cares for patients",
            "WorksAtHospital(x) ::: x works at a hospital",
            "Surgeon(x) ::: x is a surgeon",
            "Specialist(x) ::: x is a specialist",
            "TreatsIllness(x) ::: x treats an illness",
            "HasGoodReputation(x) ::: x has a good reputation"
        ]
    },
    {
        "premises-NL": [
            "All researchers publish papers.",
            "Anyone who publishes papers receives grants.",
            "Anyone who receives a grant does not lack resources.",
            "Some researchers work at a university.",
            "Anyone who works at a university needs funding.",
            "Anyone who studies science needs funding.",
            "Anyone who needs funding lacks resources.",
            "Researchers study science.",
            "All researchers have colleagues.",
            "Some individuals are researchers."
        ],
        "premises-FOL": [
            "∀x (Researcher(x) → PublishesPapers(x)) ::: All researchers publish papers.",
            "∀x (PublishesPapers(x) → ReceivesGrant(x)) ::: Anyone who publishes papers receives grants.",
            "∀x (ReceivesGrant(x) → ¬LacksResources(x)) ::: Anyone who receives a grant does not lack resources.",
            "∃x (Researcher(x) ∧ WorksAtUniversity(x)) ::: Some researchers work at a university.",
            "∀x (WorksAtUniversity(x) → NeedsFunding(x)) ::: Anyone who works at a university needs funding.",
            "∀x (StudiesScience(x) → NeedsFunding(x)) ::: Anyone who studies science needs funding.",
            "∀x (NeedsFunding(x) → LacksResources(x)) ::: Anyone who needs funding lacks resources.",
            "∀x (Researcher(x) → StudiesScience(x)) ::: Researchers study science.",
            "∀x (Researcher(x) → HasColleagues(x)) ::: All researchers have colleagues.",
            "∃x Researcher(x) ::: Some individuals are researchers."
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher",
            "LacksResources(x) ::: x lacks resources",
            "PublishesPapers(x) ::: x publishes papers",
            "ReceivesGrant(x) ::: x receives a grant",
            "NeedsFunding(x) ::: x needs funding",
            "WorksAtUniversity(x) ::: x works at a university",
            "StudiesScience(x) ::: x studies science",
            "HasColleagues(x) ::: x has colleagues"
        ]
    },
    {
        "premises-NL": [
            "Anyone who has a high income spends money.",
            "Anyone who spends money is not at risk of poverty.",
            "Anyone who works in finance has a high income.",
            "Anyone who is employed pays taxes.",
            "Anyone who is unemployed receives government aid.",
            "Anyone who lives in a city and is employed is not at risk of poverty.",
            "Anyone who is educated works in finance or receives government aid.",
            "Anyone who receives government aid is at risk of poverty.",
            "Everyone is either employed or unemployed.",
            "Anyone who is employed has savings.",
            "If someone has savings then they spend money."
        ],
        "premises-FOL": [
            "∀x (HasHighIncome(x) → SpendsMoney(x)) ::: Anyone who has a high income spends money.",
            "∀x (SpendsMoney(x) → ¬AtRiskOfPoverty(x)) ::: Anyone who spends money is not at risk of poverty.",
            "∀x (WorksInFinance(x) → HasHighIncome(x)) ::: Anyone who works in finance has a high income.",
            "∀x (Employed(x) → PaysTaxes(x)) ::: Anyone who is employed pays taxes.",
            "∀x (IsUnemployed(x) → ReceivesGovernmentAid(x)) ::: Anyone who is unemployed receives government aid.",
            "∀x ((LivesInCity(x) ∧ Employed(x)) → ¬AtRiskOfPoverty(x)) ::: Anyone who lives in a city and is employed is not at risk of poverty.",
            "∀x (IsEducated(x) → (WorksInFinance(x) ∨ ReceivesGovernmentAid(x))) ::: Anyone who is educated works in finance or receives government aid.",
            "∀x (ReceivesGovernmentAid(x) → AtRiskOfPoverty(x)) ::: Anyone who receives government aid is at risk of poverty.",
            "∀x (Employed(x) ∨ IsUnemployed(x)) ::: Everyone is either employed or unemployed.",
            "∀x (Employed(x) → HasSavings(x)) ::: Anyone who is employed has savings.",
            "∀x (HasSavings(x) → SpendsMoney(x)) ::: If someone has savings then they spend money."
        ],
        "predicates": [
            "HasHighIncome(x) ::: x has a high income",
            "Employed(x) ::: x is employed",
            "AtRiskOfPoverty(x) ::: x is at risk of poverty",
            "ReceivesGovernmentAid(x) ::: x receives government aid",
            "HasSavings(x) ::: x has savings",
            "WorksInFinance(x) ::: x works in finance",
            "SpendsMoney(x) ::: x spends money",
            "LivesInCity(x) ::: x lives in a city",
            "IsUnemployed(x) ::: x is unemployed",
            "IsEducated(x) ::: x is educated",
            "PaysTaxes(x) ::: x pays taxes"
        ]
    },
    {
        "premises-NL": [
            "All students study hard or attend lectures.",
            "All students who attend lectures read books.",
            "All students who read books and study hard pass exams.",
            "Students who pass exams do well in their studies.",
            "Some students are intelligent.",
            "Intelligent students study hard.",
            "Students who fail exams need help.",
            "Students who fail exams do not do well.",
            "Some students ask questions.",
            "Students who ask questions get tutoring.",
            "Students with good grades do well.",
            "Students who study hard have good grades."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (StudiesHard(x) ∨ AttendsLectures(x))) ::: All students study hard or attend lectures.",
            "∀x (AttendsLectures(x) → ReadsBooks(x)) ::: All students who attend lectures read books.",
            "∀x ((ReadsBooks(x) ∧ StudiesHard(x)) → PassesExams(x)) ::: All students who read books and study hard pass exams.",
            "∀x (PassesExams(x) → DoesWell(x)) ::: Students who pass exams do well in their studies.",
            "∃x (Student(x) ∧ IsIntelligent(x)) ::: Some students are intelligent.",
            "∀x (IsIntelligent(x) → StudiesHard(x)) ::: Intelligent students study hard.",
            "∀x (FailsExams(x) → NeedsHelp(x)) ::: Students who fail exams need help.",
            "∀x (FailsExams(x) → ¬DoesWell(x)) ::: Students who fail exams do not do well.",
            "∃x (Student(x) ∧ AsksQuestions(x)) ::: Some students ask questions.",
            "∀x (AsksQuestions(x) → GetsTutoring(x)) ::: Students who ask questions get tutoring.",
            "∀x (HasGoodGrades(x) → DoesWell(x)) ::: Students with good grades do well.",
            "∀x (StudiesHard(x) → HasGoodGrades(x)) ::: Students who study hard have good grades."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "DoesWell(x) ::: x does well in their studies",
            "AttendsLectures(x) ::: x attends lectures",
            "ReadsBooks(x) ::: x reads books",
            "PassesExams(x) ::: x passes exams",
            "IsIntelligent(x) ::: x is intelligent",
            "FailsExams(x) ::: x fails exams",
            "HasGoodGrades(x) ::: x has good grades",
            "NeedsHelp(x) ::: x needs help",
            "AsksQuestions(x) ::: x asks questions",
            "GetsTutoring(x) ::: x gets tutoring"
        ]
    },
    {
        "premises-NL": [
            "All extreme weather events are a result of climate change.",
            "All events that increase sea levels are a result of climate change.",
            "Anything that threatens biodiversity is a result of climate change.",
            "All pollution is a result of fossil fuels.",
            "Anything from fossil fuels reduces air quality.",
            "Anything that reduces air quality causes environmental damage.",
            "All carbon emissions are from fossil fuels.",
            "Anything that melts glaciers threatens biodiversity or causes ocean acidification.",
            "All deforestation results in carbon emissions.",
            "Anything that damages ecosystems threatens biodiversity or causes ocean acidification.",
            "Anything that causes ocean acidification causes environmental damage.",
            "All climate change is related to environmental damage.",
            "All extreme weather events damage ecosystems."
        ],
        "premises-FOL": [
            "∀x (IsExtremeWeatherEvent(x) → ResultOfClimateChange(x)) ::: All extreme weather events are a result of climate change.",
            "∀x (IncreasesSeaLevel(x) → ResultOfClimateChange(x)) ::: All events that increase sea levels are a result of climate change.",
            "∀x (ThreatensBiodiversity(x) → ResultOfClimateChange(x)) ::: Anything that threatens biodiversity is a result of climate change.",
            "∀x (IsPollution(x) → IsFromFossilFuels(x)) ::: All pollution is a result of fossil fuels.",
            "∀x (IsFromFossilFuels(x) → ReducesAirQuality(x)) ::: Anything from fossil fuels reduces air quality.",
            "∀x (ReducesAirQuality(x) → CausesEnvironmentalDamage(x)) ::: Anything that reduces air quality causes environmental damage.",
            "∀x (IsCarbonEmission(x) → IsFromFossilFuels(x)) ::: All carbon emissions are from fossil fuels.",
            "∀x (MeltsGlaciers(x) → (ThreatensBiodiversity(x) ∨ CausesOceanAcidification(x))) ::: Anything that melts glaciers threatens biodiversity or causes ocean acidification.",
            "∀x (IsFromDeforestation(x) → IsCarbonEmission(x)) ::: All deforestation results in carbon emissions.",
            "∀x (DamagesEcosystems(x) → (ThreatensBiodiversity(x) ∨ CausesOceanAcidification(x))) ::: Anything that damages ecosystems threatens biodiversity or causes ocean acidification.",
            "∀x (CausesOceanAcidification(x) → CausesEnvironmentalDamage(x)) ::: Anything that causes ocean acidification causes environmental damage.",
            "∀x (ResultOfClimateChange(x) → CausesEnvironmentalDamage(x)) ::: All climate change is related to environmental damage.",
            "∀x (IsExtremeWeatherEvent(x) → DamagesEcosystems(x)) ::: All extreme weather events damage ecosystems."
        ],
        "predicates": [
            "ResultOfClimateChange(x) ::: x is a result of climate change",
            "CausesEnvironmentalDamage(x) ::: x causes environmental damage",
            "IsExtremeWeatherEvent(x) ::: x is an extreme weather event",
            "IncreasesSeaLevel(x) ::: x increases sea level",
            "ThreatensBiodiversity(x) ::: x threatens biodiversity",
            "IsPollution(x) ::: x is pollution",
            "IsFromFossilFuels(x) ::: x is from fossil fuels",
            "ReducesAirQuality(x) ::: x reduces air quality",
            "CausesOceanAcidification(x) ::: x causes ocean acidification",
            "IsFromDeforestation(x) ::: x is from deforestation",
            "IsCarbonEmission(x) ::: x is a carbon emission",
            "MeltsGlaciers(x) ::: x melts glaciers",
            "DamagesEcosystems(x) ::: x damages ecosystems"
        ]
    },
    {
        "premises-NL": [
            "All students attend the lecture.",
            "All diligent students have the study material.",
            "If someone is a student, then they either attend the lecture or don't have the study material.",
            "If someone has the study material then they are diligent.",
            "If someone is diligent and a student, then they will pass the exam.",
            "All students either attend the lecture or will not pass the exam.",
            "No one is a student and diligent."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendLecture(x)) ::: All students attend the lecture.",
            "∀x (Diligent(x) → StudyMaterial(x)) ::: All diligent students have the study material.",
            "∀x (Student(x) → (AttendLecture(x) ∨ ¬StudyMaterial(x))) ::: If someone is a student, then they either attend the lecture or don't have the study material.",
            "∀x (StudyMaterial(x) → Diligent(x)) ::: If someone has the study material then they are diligent.",
            "∀x ((Student(x) ∧ Diligent(x)) → PassExam(x)) ::: If someone is diligent and a student, then they will pass the exam.",
            "∀x (Student(x) → (AttendLecture(x) ∨ ¬PassExam(x))) ::: All students either attend the lecture or will not pass the exam.",
            "¬∃x (Student(x) ∧ Diligent(x)) ::: No one is a student and diligent."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "AttendLecture(x) ::: x attends the lecture.",
            "Diligent(x) ::: x is diligent.",
            "PassExam(x) ::: x passes the exam.",
            "StudyMaterial(x) ::: x has the study material."
        ]
    },
    {
        "premises-NL": [
            "All students either attend class or do not have the textbook.",
            "Anyone who attends class understands the material.",
            "If someone studies, then they have the textbook.",
            "Students who understand the material will receive good grades.",
            "Anyone who studies either passes the exam or fails.",
            "Anyone who passes the exam understands the material.",
            "Anyone who understands the material and studies receives a good grade.",
            "Students always attend class.",
            "If a student studies and has a good grade, then they pass the exam.",
            "Students always have a textbook.",
            "If someone has the textbook, they will study.",
            "If someone is a student, then they will study, and they will pass the exam.",
            "If a student studies and has a good grade, they will understand the material",
            "Anyone who receives a good grade will pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (AttendsClass(x) ∨ ¬HasTextbook(x))) ::: All students either attend class or do not have the textbook.",
            "∀x (AttendsClass(x) → UnderstandsMaterial(x)) ::: Anyone who attends class understands the material.",
            "∀x (Studies(x) → HasTextbook(x)) ::: If someone studies, then they have the textbook.",
            "∀x (UnderstandsMaterial(x) → GoodGrade(x)) ::: Students who understand the material will receive good grades.",
            "∀x (Studies(x) → (PassExam(x) ∨ ¬PassExam(x))) ::: Anyone who studies either passes the exam or fails.",
            "∀x (PassExam(x) → UnderstandsMaterial(x)) ::: Anyone who passes the exam understands the material.",
            "∀x ((UnderstandsMaterial(x) ∧ Studies(x)) → GoodGrade(x)) ::: Anyone who understands the material and studies receives a good grade.",
            "∀x (Student(x) → AttendsClass(x)) ::: Students always attend class.",
            "∀x ((Student(x) ∧ Studies(x) ∧ GoodGrade(x)) → PassExam(x)) ::: If a student studies and has a good grade, then they pass the exam.",
            "∀x (Student(x) → HasTextbook(x)) ::: Students always have a textbook.",
            "∀x (HasTextbook(x) → Studies(x)) ::: If someone has the textbook, they will study.",
            "∀x (Student(x) → (Studies(x) ∧ PassExam(x))) ::: If someone is a student, then they will study, and they will pass the exam.",
            "∀x ((Student(x) ∧ Studies(x) ∧ GoodGrade(x)) → UnderstandsMaterial(x)) ::: If a student studies and has a good grade, they will understand the material",
            "∀x (GoodGrade(x) → PassExam(x)) ::: Anyone who receives a good grade will pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "GoodGrade(x) ::: x receives a good grade.",
            "Studies(x) ::: x studies.",
            "PassExam(x) ::: x passes the exam.",
            "AttendsClass(x) ::: x attends class.",
            "UnderstandsMaterial(x) ::: x understands the material.",
            "HasTextbook(x) ::: x has the textbook."
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled in at least one class.",
            "Alice is a student.",
            "No professor is enrolled in any class.",
            "If someone is a professor, they teach at least one class.",
            "Alice is not teaching any class.",
            "If someone teaches a class, they are a professor."
        ],
        "premises-FOL": [
            "∀x ∃y (Student(x) → Enrolled(x, y)) ::: All students are enrolled in at least one class.",
            "Student(alice) ::: Alice is a student.",
            "∀x ∀y (Professor(x) → ¬Enrolled(x, y)) ::: No professor is enrolled in any class.",
            "∀x ∃y (Professor(x) → Teaches(x, y)) ::: If someone is a professor, they teach at least one class.",
            "¬∃y Teaches(alice, y) ::: Alice is not teaching any class.",
            "∀x ∀y (Teaches(x, y) → Professor(x)) ::: If someone teaches a class, they are a professor."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Professor(x) ::: x is a professor",
            "Enrolled(x, y) ::: x is enrolled in y",
            "Teaches(x, y) ::: x teaches y"
        ]
    },
    {
        "premises-NL": [
            "All doctors work at a hospital.",
            "All researchers work at a university.",
            "Bob works at a hospital or Bob works at a university.",
            "Bob is either a doctor or a researcher.",
            "Anyone who is a doctor, is a scientist.",
            "If someone is a scientist, they are not a researcher.",
            "Bob is a scientist."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → WorksAtHospital(x)) ::: All doctors work at a hospital.",
            "∀x (Researcher(x) → WorksAtUniversity(x)) ::: All researchers work at a university.",
            "WorksAtHospital(bob) ∨ WorksAtUniversity(bob) ::: Bob works at a hospital or Bob works at a university.",
            "Doctor(bob) ∨ Researcher(bob) ::: Bob is either a doctor or a researcher.",
            "∀x (Doctor(x) → IsScientist(x)) ::: Anyone who is a doctor, is a scientist.",
            "∀x (IsScientist(x) → ¬Researcher(x)) ::: If someone is a scientist, they are not a researcher.",
            "IsScientist(bob) ::: Bob is a scientist."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Researcher(x) ::: x is a researcher",
            "WorksAtHospital(x) ::: x works at a hospital",
            "WorksAtUniversity(x) ::: x works at a university",
            "IsScientist(x) ::: x is a scientist"
        ]
    },
    {
        "premises-NL": [
            "John and Mary like each other.",
            "If John likes Mary, then Mary likes John.",
            "If John and Mary share posts, then they are friends.",
            "John and Mary share posts.",
            "If John and Mary have common interests, then they have met.",
            "John and Mary have common interests or share posts.",
            "If John attends an event organized by Mary, then John is friends with Mary.",
            "Mary organizes an event, and John is interested in it.",
            "John is active on social media or Mary is not active on social media."
        ],
        "premises-FOL": [
            "Likes(john, mary) ∧ Likes(mary, john) ::: John and Mary like each other.",
            "∀x ∀y (Likes(x, y) → Likes(y, x)) ::: If John likes Mary, then Mary likes John.",
            "∀x ∀y (SharedPosts(x, y) → Friends(x, y)) ::: If John and Mary share posts, then they are friends.",
            "SharedPosts(john, mary) ::: John and Mary share posts.",
            "∀x ∀y (HasCommonInterest(x, y) → HasMet(x, y)) ::: If John and Mary have common interests, then they have met.",
            "HasCommonInterest(john, mary) ∨ SharedPosts(john, mary) ::: John and Mary have common interests or share posts.",
            "∀x ∀y (AttendsEvent(x, y) ∧ OrganizesEvent(y, z) → Friends(x, z)) ::: If John attends an event organized by Mary, then John is friends with Mary.",
            "OrganizesEvent(mary, z) ∧ IsInterestedIn(john, z) ::: Mary organizes an event, and John is interested in it.",
            "IsActiveOnSocialMedia(john) ∨ ¬IsActiveOnSocialMedia(mary) ::: John is active on social media or Mary is not active on social media."
        ],
        "predicates": [
            "Friends(x, y) ::: x and y are friends",
            "Likes(x, y) ::: x likes y",
            "IsActiveOnSocialMedia(x) ::: x is active on social media",
            "SharedPosts(x, y) ::: x and y have shared posts",
            "HasCommonInterest(x, y) ::: x and y share common interests",
            "HasMet(x, y) ::: x and y have met",
            "AttendsEvent(x, y) ::: x attends event y",
            "OrganizesEvent(x, y) ::: x organizes event y",
            "IsInterestedIn(x, y) ::: x is interested in y"
        ]
    },
    {
        "premises-NL": [
            "All senior managers are employees.",
            "Any employee who receives a promotion is a senior manager.",
            "Employees who work overtime are eligible for a bonus.",
            "Any employee who is eligible for a bonus has a good performance review.",
            "Some employees are senior managers.",
            "If an employee receives a raise, they are promoted.",
            "If an employee has good performance, then they are promoted.",
            "If an employee manages someone, then they are an employee.",
            "Employees with a good performance get a raise."
        ],
        "premises-FOL": [
            "∀x (SeniorManager(x) → Employee(x)) ::: All senior managers are employees.",
            "∀x (Employee(x) ∧ ReceivesPromotion(x) → SeniorManager(x)) ::: Any employee who receives a promotion is a senior manager.",
            "∀x (Employee(x) ∧ WorksOvertime(x) → EligibleForBonus(x)) ::: Employees who work overtime are eligible for a bonus.",
            "∀x (Employee(x) ∧ EligibleForBonus(x) → HasGoodReview(x)) ::: Any employee who is eligible for a bonus has a good performance review.",
            "∃x (Employee(x) ∧ SeniorManager(x)) ::: Some employees are senior managers.",
            "∀x (Employee(x) ∧ ReceivesRaise(x) → ReceivesPromotion(x)) ::: If an employee receives a raise, they are promoted.",
            "∀x (Employee(x) ∧ GoodPerformance(x) → ReceivesPromotion(x)) ::: If an employee has good performance, then they are promoted.",
            "∀x ∀y (Manages(x, y) → Employee(x)) ::: If an employee manages someone, then they are an employee.",
            "∀x (Employee(x) ∧ GoodPerformance(x) → ReceivesRaise(x)) ::: Employees with a good performance get a raise."
        ],
        "predicates": [
            "WorksOvertime(x) ::: x works overtime",
            "SeniorManager(x) ::: x is a senior manager",
            "EligibleForBonus(x) ::: x is eligible for a bonus",
            "HasGoodReview(x) ::: x has a good performance review",
            "Employee(x) ::: x is an employee",
            "Manages(x, y) ::: x manages y",
            "ReceivesPromotion(x) ::: x receives a promotion",
            "IsPromotedTo(x, y) ::: x is promoted to y",
            "GoodPerformance(x) ::: x has good performance",
            "ReceivesRaise(x) ::: x receives a raise"
        ]
    },
    {
        "premises-NL": [
            "All species with a complex social structure communicate.",
            "If a species lives in a group and forages together, it has a complex social structure.",
            "If a species has a complex social structure, it either shows cooperative behavior or high aggression.",
            "If a species is dominant, then it has territory.",
            "If a species has territory, it shows high aggression.",
            "Species that protect their young will show cooperative behavior.",
            "Some species have a complex social structure.",
            "If a species forages together, it lives in groups.",
            "If species are dominant, they have a territory and forage together."
        ],
        "premises-FOL": [
            "∀x (ComplexSocialStructure(x) → UsesCommunication(x)) ::: All species with a complex social structure communicate.",
            "∀x (LivesInGroup(x) ∧ ForagesTogether(x) → ComplexSocialStructure(x)) ::: If a species lives in a group and forages together, it has a complex social structure.",
            "∀x (ComplexSocialStructure(x) → (CooperativeBehavior(x) ∨ HighAggression(x))) ::: If a species has a complex social structure, it either shows cooperative behavior or high aggression.",
            "∀x ∀y (Dominant(x, y) → HasTerritory(x)) ::: If a species is dominant, then it has territory.",
            "∀x (HasTerritory(x) → HighAggression(x)) ::: If a species has territory, it shows high aggression.",
            "∀x (ProtectsYoung(x) → CooperativeBehavior(x)) ::: Species that protect their young will show cooperative behavior.",
            "∃x ComplexSocialStructure(x) ::: Some species have a complex social structure.",
            "∀x (ForagesTogether(x) → LivesInGroup(x)) ::: If a species forages together, it lives in groups.",
            "∀x ∀y (Dominant(x, y) → (HasTerritory(x) ∧ ForagesTogether(x))) ::: If species are dominant, they have a territory and forage together."
        ],
        "predicates": [
            "ComplexSocialStructure(x) ::: x has a complex social structure",
            "UsesCommunication(x) ::: x uses communication",
            "CooperativeBehavior(x) ::: x shows cooperative behavior",
            "HighAggression(x) ::: x shows high aggression",
            "Species(x) ::: x is a species",
            "LivesInGroup(x) ::: x lives in a group",
            "ForagesTogether(x) ::: x forages together",
            "Dominant(x, y) ::: x is dominant over y",
            "HasTerritory(x) ::: x has territory",
            "ProtectsYoung(x) ::: x protects young"
        ]
    },
    {
        "premises-NL": [
            "All scientists who study biology are researchers.",
            "Some researchers use microscopes.",
            "All scientists publish papers.",
            "If someone studies biology, then they are a scientist.",
            "Anyone who uses a microscope is a researcher.",
            "Some researchers publish papers.",
            "No one studies biology and doesn't publish papers."
        ],
        "premises-FOL": [
            "∀x ((Scientist(x) ∧ StudiesBiology(x)) → Researcher(x)) ::: All scientists studying biology are researchers.",
            "∃x (Researcher(x) ∧ UsesMicroscope(x)) ::: Some researchers use microscopes.",
            "∀x (Scientist(x) → PublishesPaper(x)) ::: All scientists publish papers.",
            "∀x (StudiesBiology(x) → Scientist(x)) ::: If someone studies biology, then they are a scientist.",
            "∀x (UsesMicroscope(x) → Researcher(x)) ::: Anyone who uses a microscope is a researcher.",
            "∃x (Researcher(x) ∧ PublishesPaper(x)) ::: Some researchers publish papers.",
            "¬∃x (StudiesBiology(x) ∧ ¬PublishesPaper(x)) ::: No one studies biology without publishing a paper."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "StudiesBiology(x) ::: x studies biology",
            "Researcher(x) ::: x is a researcher",
            "UsesMicroscope(x) ::: x uses a microscope",
            "PublishesPaper(x) ::: x publishes a paper"
        ]
    },
    {
        "premises-NL": [
            "Everyone who likes apples also likes bananas.",
            "Everyone who likes bananas likes carrots.",
            "If someone eats fruit, they are healthy.",
            "Everyone who likes apples eats fruit.",
            "If someone is healthy, they run marathons.",
            "If someone likes carrots, they are an athlete.",
            "Everyone who is an athlete likes bananas.",
            "Someone likes apples and bananas.",
            "Someone runs marathons and likes carrots."
        ],
        "premises-FOL": [
            "∀x (LikesApples(x) → LikesBananas(x)) ::: All individuals who like apples also like bananas.",
            "∀x (LikesBananas(x) → LikesCarrots(x)) ::: All individuals who like bananas also like carrots.",
            "∀x (EatsFruit(x) → Healthy(x)) ::: If someone eats fruit, they are healthy.",
            "∀x (LikesApples(x) → EatsFruit(x)) ::: Everyone who likes apples eats fruit.",
            "∀x (Healthy(x) → RunsMarathon(x)) ::: If someone is healthy, they run marathons.",
            "∀x (LikesCarrots(x) → IsAthlete(x)) ::: If someone likes carrots, they are an athlete.",
            "∀x (IsAthlete(x) → LikesBananas(x)) ::: Everyone who is an athlete likes bananas.",
            "∃x (LikesApples(x) ∧ LikesBananas(x)) ::: Someone likes apples and bananas.",
            "∃x (RunsMarathon(x) ∧ LikesCarrots(x)) ::: Someone runs marathons and likes carrots."
        ],
        "predicates": [
            "LikesApples(x) ::: x likes apples",
            "LikesBananas(x) ::: x likes bananas",
            "LikesCarrots(x) ::: x likes carrots",
            "EatsFruit(x) ::: x eats fruit",
            "Healthy(x) ::: x is healthy",
            "RunsMarathon(x) ::: x runs a marathon",
            "IsAthlete(x) ::: x is an athlete"
        ]
    },
    {
        "premises-NL": [
            "All doctors are intelligent.",
            "Some intelligent people are rich.",
            "Some rich people are generous.",
            "All doctors are kind.",
            "Some doctors study medicine.",
            "Anyone who studies medicine helps patients.",
            "Anyone who helps patients is kind.",
            "Some kind people are happy.",
            "If someone is rich, they are not unkind.",
            "If someone is intelligent, they are either rich or kind.",
            "Some intelligent people are not doctors.",
            "All doctors are either intelligent or generous.",
            "No one is a doctor and not intelligent.",
            "Some rich people are not intelligent.",
            "Everyone who is kind helps patients.",
            "Someone is rich and happy."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Intelligent(x)) ::: All doctors are intelligent.",
            "∃x (Intelligent(x) ∧ Rich(x)) ::: Some intelligent people are rich.",
            "∃x (Rich(x) ∧ Generous(x)) ::: Some rich people are generous.",
            "∀x (Doctor(x) → Kind(x)) ::: All doctors are kind.",
            "∃x (Doctor(x) ∧ StudiesMedicine(x)) ::: Some doctors study medicine.",
            "∀x (StudiesMedicine(x) → HelpsPatients(x)) ::: Anyone who studies medicine helps patients.",
            "∀x (HelpsPatients(x) → Kind(x)) ::: Anyone who helps patients is kind.",
            "∃x (Kind(x) ∧ IsHappy(x)) ::: Some kind people are happy.",
            "∀x (Rich(x) → ¬Unkind(x)) ::: If someone is rich, they are not unkind.",
            "∀x (Intelligent(x) → (Rich(x) ∨ Kind(x))) ::: If someone is intelligent, they are either rich or kind.",
            "∃x (Intelligent(x) ∧ ¬Doctor(x)) ::: Some intelligent people are not doctors.",
            "∀x (Doctor(x) → (Intelligent(x) ∨ Generous(x))) ::: All doctors are either intelligent or generous.",
            "¬∃x (Doctor(x) ∧ ¬Intelligent(x)) ::: No one is a doctor and not intelligent.",
            "∃x (Rich(x) ∧ ¬Intelligent(x)) ::: Some rich people are not intelligent.",
            "∀x (Kind(x) → HelpsPatients(x)) ::: Everyone who is kind helps patients.",
            "∃x (Rich(x) ∧ IsHappy(x)) ::: Someone is rich and happy."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Intelligent(x) ::: x is intelligent",
            "Rich(x) ::: x is rich",
            "Generous(x) ::: x is generous",
            "Kind(x) ::: x is kind",
            "StudiesMedicine(x) ::: x studies medicine",
            "HelpsPatients(x) ::: x helps patients",
            "IsHappy(x) ::: x is happy"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "John is a doctor.",
            "Mary is a patient.",
            "If someone is a doctor and treats someone, then that person is a patient.",
            "John treats Mary.",
            "A doctor treats someone if and only if the person is a patient."
        ],
        "premises-FOL": [
            "∀x ∃y (Doctor(x) → Treats(x, y)) ::: All doctors treat patients.",
            "Doctor(john) ::: John is a doctor.",
            "Patient(mary) ::: Mary is a patient.",
            "∀x ∀y ((Doctor(x) ∧ Treats(x, y)) → Patient(y)) ::: If someone is a doctor and treats someone, then that person is a patient.",
            "Treats(john, mary) ::: John treats Mary.",
            "∀x ∀y (Treats(x, y) ↔ Patient(y)) ::: A doctor treats someone if and only if the person is a patient."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Patient(x) ::: x is a patient",
            "Treats(x, y) ::: x treats y"
        ]
    },
    {
        "premises-NL": [
            "Everyone who has a cold takes medicine.",
            "Anyone who takes medicine feels better.",
            "If someone feels better, then that person is not sick.",
            "Some people have a cold.",
            "Someone feels better if and only if they take medicine.",
            "If someone takes medicine and has a cold, then they are sick.",
            "Anyone who is sick has a cold."
        ],
        "premises-FOL": [
            "∀x (HasCold(x) → TakesMedicine(x)) ::: Everyone who has a cold takes medicine.",
            "∀x (TakesMedicine(x) → FeelsBetter(x)) ::: Anyone who takes medicine feels better.",
            "∀x (FeelsBetter(x) → ¬Sick(x)) ::: If someone feels better, then that person is not sick.",
            "∃x HasCold(x) ::: Some people have a cold.",
            "∀x (FeelsBetter(x) ↔ TakesMedicine(x)) ::: Someone feels better if and only if they take medicine.",
            "∀x ((TakesMedicine(x) ∧ HasCold(x)) → Sick(x)) ::: If someone takes medicine and has a cold, then they are sick.",
            "∀x (Sick(x) → HasCold(x)) ::: Anyone who is sick has a cold."
        ],
        "predicates": [
            "HasCold(x) ::: x has a cold",
            "TakesMedicine(x) ::: x takes medicine",
            "Sick(x) ::: x is sick",
            "FeelsBetter(x) ::: x feels better"
        ]
    },
    {
        "premises-NL": [
            "All students take the exam.",
            "Anyone who studies attends class.",
            "If someone attends class and takes the exam, they will pass.",
            "All students study.",
            "John is a student.",
            "If John studies, he takes the exam.",
            "If a student takes the exam they will pass.",
            "Someone takes the exam if and only if they attend class."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakesExam(x)) ::: All students take the exam.",
            "∀x (Studies(x) → AttendsClass(x)) ::: Anyone who studies attends class.",
            "∀x ((AttendsClass(x) ∧ TakesExam(x)) → PassExam(x)) ::: If someone attends class and takes the exam, they will pass.",
            "∀x (Student(x) → Studies(x)) ::: All students study.",
            "Student(john) ::: John is a student.",
            "Studies(john) → TakesExam(john) ::: If John studies, he takes the exam.",
            "∀x (Student(x) ∧ TakesExam(x) → PassExam(x)) ::: If a student takes the exam they will pass.",
            "∀x (TakesExam(x) ↔ AttendsClass(x)) ::: Someone takes the exam if and only if they attend class."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "PassExam(x) ::: x passes the exam",
            "TakesExam(x) ::: x takes the exam",
            "AttendsClass(x) ::: x attends class"
        ]
    },
    {
        "premises-NL": [
            "All programmers write code.",
            "Anyone who writes code uses a computer.",
            "John is a programmer.",
            "All programmers know Python.",
            "If someone knows Python, they are employed by Google.",
            "If someone is employed by Google, they use a computer.",
            "If someone uses a computer, then they write code.",
            "John writes code.",
            "John knows Python."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → WritesCode(x)) ::: All programmers write code.",
            "∀x (WritesCode(x) → UsesComputer(x)) ::: Anyone who writes code uses a computer.",
            "Programmer(john) ::: John is a programmer.",
            "∀x (Programmer(x) → KnowsLanguage(x, python)) ::: All programmers know Python.",
            "∀x (KnowsLanguage(x, python) → IsEmployedBy(x, google)) ::: If someone knows Python, they are employed by Google.",
            "∀x (IsEmployedBy(x, google) → UsesComputer(x)) ::: If someone is employed by Google, they use a computer.",
            "∀x (UsesComputer(x) → WritesCode(x)) ::: If someone uses a computer, then they write code.",
            "WritesCode(john) ::: John writes code.",
            "KnowsLanguage(john, python) ::: John knows Python."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "UsesComputer(x) ::: x uses a computer",
            "WritesCode(x) ::: x writes code",
            "KnowsLanguage(x, y) ::: x knows language y",
            "IsEmployedBy(x, y) ::: x is employed by y"
        ]
    },
    {
        "premises-NL": [
            "All students are people.",
            "John is a student.",
            "If someone likes Mary, then they are friends with Mary.",
            "If someone is a student, they like Mary.",
            "All people who like Mary are friends with her.",
            "Mary is a person.",
            "John likes Mary.",
            "Mary is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Person(x)) ::: All students are people.",
            "Student(john) ::: John is a student.",
            "∀x (Likes(x, mary) → Friend(x, mary)) ::: If someone likes Mary, then they are friends with Mary.",
            "∀x (Student(x) → Likes(x, mary)) ::: If someone is a student, they like Mary.",
            "∀x (Likes(x, mary) → Friend(x, mary)) ::: All people who like Mary are friends with her.",
            "Person(mary) ::: Mary is a person.",
            "Likes(john, mary) ::: John likes Mary.",
            "Student(mary) ::: Mary is a student."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "Student(x) ::: x is a student.",
            "Friend(x, y) ::: x is a friend of y.",
            "Likes(x, y) ::: x likes y."
        ]
    },
    {
        "premises-NL": [
            "All students attend a university.",
            "If a student studies computer science, then they attend a university.",
            "If a student studies mathematics, then they attend a university.",
            "Sarah is a student.",
            "If someone is a professor, they teach computer science or mathematics.",
            "All computer science professors teach computer science.",
            "All mathematics professors teach mathematics.",
            "Sarah studies computer science or mathematics.",
            "If someone is a student, then they study computer science or mathematics.",
            "All students are smart."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsUniversity(x)) ::: All students attend a university.",
            "∀x (Student(x) ∧ Studies(x, computerScience) → AttendsUniversity(x)) ::: If a student studies computer science, then they attend a university.",
            "∀x (Student(x) ∧ Studies(x, mathematics) → AttendsUniversity(x)) ::: If a student studies mathematics, then they attend a university.",
            "Student(sarah) ::: Sarah is a student.",
            "∀x (Professor(x) → (Teaches(x, computerScience) ∨ Teaches(x, mathematics))) ::: If someone is a professor, they teach computer science or mathematics.",
            "∀x (Professor(x) ∧ Teaches(x, computerScience) → Studies(x, computerScience)) ::: All computer science professors teach computer science.",
            "∀x (Professor(x) ∧ Teaches(x, mathematics) → Studies(x, mathematics)) ::: All mathematics professors teach mathematics.",
            "(Studies(sarah, computerScience) ∨ Studies(sarah, mathematics)) ::: Sarah studies computer science or mathematics.",
            "∀x (Student(x) → (Studies(x, computerScience) ∨ Studies(x, mathematics))) ::: If someone is a student, then they study computer science or mathematics.",
            "∀x (Student(x) → Smart(x)) ::: All students are smart."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Professor(x) ::: x is a professor.",
            "Studies(x, y) ::: x studies y.",
            "Teaches(x, y) ::: x teaches y.",
            "ComputerScience(x) ::: x is computer science.",
            "Mathematics(x) ::: x is mathematics."
        ]
    },
    {
        "premises-NL": [
            "All people invest in companies.",
            "If a company has a high profit, then it is a successful company.",
            "Some companies are good investments.",
            "If a company is a good investment, then it has a high profit.",
            "If a person invests in a company, then the person takes a risk.",
            "If a company is successful, it is a good investment.",
            "All successful companies have high profit.",
            "If a person earns money, then they become rich.",
            "All people invest in risk.",
            "If a person has a risk, they are investing.",
            "There are some successful companies.",
            "Some companies have a high profit."
        ],
        "premises-FOL": [
            "∀x ∀y (Person(x) → InvestsIn(x, y)) ::: All people invest in companies.",
            "∀x (HighProfit(x) → CompanySuccessful(x)) ::: If a company has a high profit, then it is a successful company.",
            "∃x GoodInvestment(x) ::: Some companies are good investments.",
            "∀x (GoodInvestment(x) → HighProfit(x)) ::: If a company is a good investment, then it has a high profit.",
            "∀x ∀y (InvestsIn(x, y) → HasRisk(x)) ::: If a person invests in a company, then the person takes a risk.",
            "∀x (CompanySuccessful(x) → GoodInvestment(x)) ::: If a company is successful, it is a good investment.",
            "∀x (CompanySuccessful(x) → HighProfit(x)) ::: All successful companies have high profit.",
            "∀x (EarnsMoney(x) → IsRich(x)) ::: If a person earns money, then they become rich.",
            "∀x ∀y (Person(x) → HasRisk(x)) ::: All people invest in risk.",
            "∀x ∀y (HasRisk(x) → InvestsIn(x, y)) ::: If a person has a risk, they are investing.",
            "∃x CompanySuccessful(x) ::: There are some successful companies.",
            "∃x HighProfit(x) ::: Some companies have a high profit."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "InvestsIn(x, y) ::: x invests in y",
            "Company(x) ::: x is a company",
            "CompanySuccessful(x) ::: x is a successful company",
            "EarnsMoney(x) ::: x earns money",
            "IsRich(x) ::: x is rich",
            "GoodInvestment(x) ::: x is a good investment",
            "HighProfit(x) ::: x has high profit",
            "Invests(x, y) ::: x invests in y",
            "Risk(x) ::: x is a risk",
            "HasRisk(x) ::: x has risk"
        ]
    },
    {
        "premises-NL": [
            "All mammals live on land.",
            "All mammals have fur.",
            "If a creature is a mammal, it breathes.",
            "If a creature breathes, it is warm-blooded.",
            "Some mammals eat meat.",
            "All creatures that eat meat are carnivores.",
            "If a creature has fur, it is fast.",
            "Some creatures are slow.",
            "All fast creatures have claws.",
            "If a creature has claws, it hunts.",
            "No mammal has wings.",
            "All warm-blooded creatures breathe.",
            "Some creatures are fast."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → LivesOnLand(x)) ::: All mammals live on land.",
            "∀x (Mammal(x) → HasFur(x)) ::: All mammals have fur.",
            "∀x (Mammal(x) → Breathes(x)) ::: If a creature is a mammal, it breathes.",
            "∀x (Breathes(x) → WarmBlooded(x)) ::: If a creature breathes, it is warm-blooded.",
            "∃x (Mammal(x) ∧ EatsMeat(x)) ::: Some mammals eat meat.",
            "∀x (EatsMeat(x) → IsCarnivore(x)) ::: All creatures that eat meat are carnivores.",
            "∀x (HasFur(x) → IsFast(x)) ::: If a creature has fur, it is fast.",
            "∃x IsSlow(x) ::: Some creatures are slow.",
            "∀x (IsFast(x) → HasClaws(x)) ::: All fast creatures have claws.",
            "∀x (HasClaws(x) → Hunts(x)) ::: If a creature has claws, it hunts.",
            "∀x ¬(Mammal(x) ∧ HasWings(x)) ::: No mammal has wings.",
            "∀x (WarmBlooded(x) → Breathes(x)) ::: All warm-blooded creatures breathe.",
            "∃x IsFast(x) ::: Some creatures are fast."
        ],
        "predicates": [
            "Creature(x) ::: x is a creature",
            "Mammal(x) ::: x is a mammal",
            "Breathes(x) ::: x breathes",
            "WarmBlooded(x) ::: x is warm-blooded",
            "LivesOnLand(x) ::: x lives on land",
            "HasFur(x) ::: x has fur",
            "EatsMeat(x) ::: x eats meat",
            "IsCarnivore(x) ::: x is a carnivore",
            "IsFast(x) ::: x is fast",
            "IsSlow(x) ::: x is slow",
            "HasClaws(x) ::: x has claws",
            "Hunts(x) ::: x hunts",
            "HasWings(x) ::: x has wings"
        ]
    },
    {
        "premises-NL": [
            "All patients with a fever require treatment.",
            "If a patient requires treatment, then they are likely to become very sick.",
            "If a patient is treated by Dr. Smith, then they receive the treatment.",
            "If a patient does not receive the treatment, they won't improve.",
            "John has a fever.",
            "If a patient requires a specific treatment and does not get the specific treatment, they will not improve",
            "If a patient is not treated by Dr. Smith, then they do not receive treatment.",
            "John requires a specific treatment",
            "If a patient is treated by Dr. Smith, the doctor provides the specific treatment.",
            "Patients that get treated improve their health"
        ],
        "premises-FOL": [
            "∀x (HasFever(x) → RequiresTreatment(x)) ::: All patients with a fever require treatment.",
            "∀x (RequiresTreatment(x) → VerySick(x)) ::: If a patient requires treatment, then they are likely to become very sick.",
            "∀x (TreatedBy(x, smith) → ReceivesTreatment(x)) ::: If a patient is treated by Dr. Smith, then they receive the treatment.",
            "∀x (¬ReceivesTreatment(x) → ¬Improves(x)) ::: If a patient does not receive the treatment, they won't improve.",
            "HasFever(john) ::: John has a fever.",
            "∀x (RequiresSpecificTreatment(x) ∧ ¬ReceivesTreatment(x) → ¬Improves(x)) ::: If a patient requires a specific treatment and does not get the specific treatment, they will not improve.",
            "∀x (¬TreatedBy(x, smith) → ¬ReceivesTreatment(x)) ::: If a patient is not treated by Dr. Smith, then they do not receive treatment.",
            "RequiresSpecificTreatment(john) ::: John requires a specific treatment",
            "∀x (TreatedBy(x, smith) → ReceivesSpecificTreatment(x)) ::: If a patient is treated by Dr. Smith, the doctor provides the specific treatment.",
            "∀x (ReceivesTreatment(x) → Improves(x)) ::: Patients that get treated improve their health"
        ],
        "predicates": [
            "HasFever(x) ::: Patient x has a fever.",
            "TreatedBy(x, y) ::: Patient x is treated by doctor y.",
            "VerySick(x) ::: Patient x is very sick.",
            "RequiresTreatment(x) ::: Patient x requires treatment.",
            "ReceivesTreatment(x) ::: Patient x receives treatment.",
            "TreatedBySmith(x) ::: Patient x is treated by Dr. Smith.",
            "RequiresSpecificTreatment(x) ::: Patient x requires a specific treatment."
        ]
    },
    {
        "premises-NL": [
            "All students who study hard will pass the exam.",
            "Some students skip classes.",
            "Students who skip classes do not read books.",
            "Students who do not attend lectures are lazy.",
            "Some students fail the course.",
            "All students who are tutored need help.",
            "All students who fail the course do not understand the material.",
            "All students who have good grades understand the material.",
            "Smart students always pass the exam.",
            "Some students are lazy and get sick.",
            "All students who are prepared will pass the exam.",
            "Anyone who skips classes does not study hard.",
            "All those who get sick fail the course.",
            "Some students are smart and skip classes.",
            "All students who fail the course are lazy."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: All students who study hard will pass the exam.",
            "∃x (Student(x) ∧ SkipsClasses(x)) ::: Some students skip classes.",
            "∀x (SkipsClasses(x) → ¬ReadsBooks(x)) ::: Students who skip classes do not read books.",
            "∀x (¬AttendsLectures(x) → IsLazy(x)) ::: Students who do not attend lectures are lazy.",
            "∃x FailsCourse(x) ::: Some students fail the course.",
            "∀x (IsTutored(x) → NeedsHelp(x)) ::: All students who are tutored need help.",
            "∀x (FailsCourse(x) → ¬UnderstandsMaterial(x)) ::: All students who fail the course do not understand the material.",
            "∀x (HasGoodGrades(x) → UnderstandsMaterial(x)) ::: All students who have good grades understand the material.",
            "∀x (Student(x) ∧ IsSmart(x) → PassExam(x)) ::: Smart students always pass the exam.",
            "∃x (Student(x) ∧ IsLazy(x) ∧ GetsSick(x)) ::: Some students are lazy and get sick.",
            "∀x (IsPrepared(x) → PassExam(x)) ::: All students who are prepared will pass the exam.",
            "∀x (SkipsClasses(x) → ¬StudiesHard(x)) ::: Anyone who skips classes does not study hard.",
            "∀x (GetsSick(x) → FailsCourse(x)) ::: All those who get sick fail the course.",
            "∃x (Student(x) ∧ IsSmart(x) ∧ SkipsClasses(x)) ::: Some students are smart and skip classes.",
            "∀x (FailsCourse(x) → IsLazy(x)) ::: All students who fail the course are lazy."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x will pass the exam",
            "SkipsClasses(x) ::: x skips classes",
            "ReadsBooks(x) ::: x reads books",
            "AttendsLectures(x) ::: x attends lectures",
            "FailsCourse(x) ::: x fails the course",
            "IsTutored(x) ::: x is tutored",
            "NeedsHelp(x) ::: x needs help",
            "UnderstandsMaterial(x) ::: x understands the material",
            "HasGoodGrades(x) ::: x has good grades",
            "IsSmart(x) ::: x is smart",
            "IsLazy(x) ::: x is lazy",
            "GetsSick(x) ::: x gets sick",
            "IsPrepared(x) ::: x is prepared"
        ]
    },
    {
        "premises-NL": [
            "All people who own a cat like cats.",
            "All people who own a dog like dogs.",
            "Some people are allergic to cats.",
            "All people who are allergic to cats do not like cats.",
            "All pet owners like dogs.",
            "All friendly people like cats.",
            "No mean people like dogs.",
            "Some people play with cats.",
            "All people who play with cats are happy.",
            "Some people hate cats.",
            "All people who hate cats do not like cats.",
            "All people who are happy have friends.",
            "Some people do not have friends.",
            "Some people like dogs and do not like cats.",
            "Everyone who is generous is a neighbor.",
            "All people who own a cat are generous.",
            "No one who is a neighbor owns a dog."
        ],
        "premises-FOL": [
            "∀x (OwnsCat(x) → LikesCats(x)) ::: All people who own a cat like cats.",
            "∀x (OwnsDog(x) → LikesDogs(x)) ::: All people who own a dog like dogs.",
            "∃x AllergicToCats(x) ::: Some people are allergic to cats.",
            "∀x (AllergicToCats(x) → ¬LikesCats(x)) ::: All people who are allergic to cats do not like cats.",
            "∀x (IsPetOwner(x) → LikesDogs(x)) ::: All pet owners like dogs.",
            "∀x (IsFriendly(x) → LikesCats(x)) ::: All friendly people like cats.",
            "∀x (IsMean(x) → ¬LikesDogs(x)) ::: No mean people like dogs.",
            "∃x PlaysWithCats(x) ::: Some people play with cats.",
            "∀x (PlaysWithCats(x) → IsHappy(x)) ::: All people who play with cats are happy.",
            "∃x HatesCats(x) ::: Some people hate cats.",
            "∀x (HatesCats(x) → ¬LikesCats(x)) ::: All people who hate cats do not like cats.",
            "∀x (IsHappy(x) → HasFriends(x)) ::: All people who are happy have friends.",
            "∃x ¬HasFriends(x) ::: Some people do not have friends.",
            "∃x (LikesDogs(x) ∧ ¬LikesCats(x)) ::: Some people like dogs and do not like cats.",
            "∀x ∀y (IsGenerous(x) → IsNeighborOf(x, y)) ::: Everyone who is generous is a neighbor.",
            "∀x (OwnsCat(x) → IsGenerous(x)) ::: All people who own a cat are generous.",
            "∀x ∀y (IsNeighborOf(x, y) → ¬OwnsDog(x)) ::: No one who is a neighbor owns a dog."
        ],
        "predicates": [
            "LikesCats(x) ::: x likes cats",
            "LikesDogs(x) ::: x likes dogs",
            "OwnsCat(x) ::: x owns a cat",
            "OwnsDog(x) ::: x owns a dog",
            "AllergicToCats(x) ::: x is allergic to cats",
            "AllergicToDogs(x) ::: x is allergic to dogs",
            "IsPetOwner(x) ::: x is a pet owner",
            "IsFriendly(x) ::: x is friendly",
            "IsMean(x) ::: x is mean",
            "PlaysWithCats(x) ::: x plays with cats",
            "PlaysWithDogs(x) ::: x plays with dogs",
            "IsHappy(x) ::: x is happy",
            "HatesCats(x) ::: x hates cats",
            "HatesDogs(x) ::: x hates dogs",
            "HasFriends(x) ::: x has friends",
            "IsNeighborOf(x, y) ::: x is a neighbor of y",
            "IsGenerous(x) ::: x is generous"
        ]
    },
    {
        "premises-NL": [
            "All members are invited to the event.",
            "If someone is invited, they can attend.",
            "If someone attends, they are registered.",
            "Anyone who is not a member is not invited.",
            "If someone is not a member, they can't attend.",
            "Everyone who attends is registered.",
            "John is a member.",
            "The event is a party.",
            "Everyone is invited to the party.",
            "Someone who is not a member cannot attend.",
            "Anyone who is invited can attend.",
            "If someone attends, they must be registered.",
            "John is invited to the party."
        ],
        "premises-FOL": [
            "∀x (Member(x) → Invited(x, event1)) ::: All members are invited to the event.",
            "∀x ∀y (Invited(x, y) → Attends(x, y)) ::: If someone is invited, they can attend.",
            "∀x ∀y (Attends(x, y) → Registered(x, y)) ::: If someone attends, they are registered.",
            "∀x (¬Member(x) → ¬Invited(x, event1)) ::: Anyone who is not a member is not invited.",
            "∀x (¬Member(x) → ¬Attends(x, event1)) ::: If someone is not a member, they can't attend.",
            "∀x ∀y (Attends(x, y) → Registered(x, y)) ::: Everyone who attends is registered.",
            "Member(john) ::: John is a member.",
            "IsEvent(party) ::: The event is a party.",
            "∀x (Invited(x, party)) ::: Everyone is invited to the party.",
            "∀x (¬Member(x) → ¬Attends(x, party)) ::: Someone who is not a member cannot attend.",
            "∀x ∀y (Invited(x, y) → Attends(x, y)) ::: Anyone who is invited can attend.",
            "∀x ∀y (Attends(x, y) → Registered(x, y)) ::: If someone attends, they must be registered.",
            "Invited(john, party) ::: John is invited to the party."
        ],
        "predicates": [
            "Member(x) ::: x is a member",
            "Attends(x, y) ::: x attends event y",
            "Invited(x, y) ::: x is invited to event y",
            "Registered(x, y) ::: x is registered for event y",
            "IsEvent(x) ::: x is an event"
        ]
    },
    {
        "premises-NL": [
            "All students are smart or they study.",
            "David is a student.",
            "If someone is smart, then they pass.",
            "David is smart."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Smart(x) ∨ Studies(x))) ::: All students are smart or they study.",
            "Student(david) ::: David is a student.",
            "∀x (Smart(x) → Pass(x)) ::: If someone is smart, then they pass.",
            "Smart(david) ::: David is smart.",
            "Student(bob) ::: Bob is a student.",
            "Studies(bob) ::: Bob studies.",
            "∀x (Studies(x) → Pass(x)) ::: If anyone studies, they will pass.",
            "¬Pass(david) → ¬Studies(david) ::: If David doesn't pass then he doesn't study.",
            "∀x (Studies(x) ∨ ¬Pass(x)) ::: Anyone will study or not pass.",
            "¬Smart(david) ∨ Studies(david) ::: David is either not smart or studies.",
            "∀x (¬Smart(x) ∨ Pass(x)) ::: Anyone will pass or is not smart."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "Pass(x) ::: x passes",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "Everyone is friends with someone.",
            "If someone is friends with Charlie, then Charlie likes them.",
            "Alice is friends with Charlie.",
            "Bob is friends with Charlie.",
            "Anyone who likes someone is friends with them.",
            "David likes Eve.",
            "Eve is friends with David.",
            "If someone is friends with David then David likes them.",
            "If someone likes Charlie, then Charlie is friends with them.",
            "If someone likes Bob, then Bob is friends with them.",
            "Charlie likes someone.",
            "Charlie is friends with someone."
        ],
        "premises-FOL": [
            "∀x ∃y FriendsWith(x, y) ::: Everyone is friends with someone.",
            "∀x (FriendsWith(x, charlie) → Likes(charlie, x)) ::: If someone is friends with Charlie, then Charlie likes them.",
            "FriendsWith(alice, charlie) ::: Alice is friends with Charlie.",
            "FriendsWith(bob, charlie) ::: Bob is friends with Charlie.",
            "∀x ∀y (Likes(x, y) → FriendsWith(x, y)) ::: Anyone who likes someone is friends with them.",
            "Likes(david, eve) ::: David likes Eve.",
            "FriendsWith(eve, david) ::: Eve is friends with David.",
            "∀x (FriendsWith(x, david) → Likes(david, x)) ::: If someone is friends with David then David likes them.",
            "∀x (Likes(x, charlie) → FriendsWith(charlie, x)) ::: If someone likes Charlie, then Charlie is friends with them.",
            "∀x (Likes(x, bob) → FriendsWith(bob, x)) ::: If someone likes Bob, then Bob is friends with them.",
            "∃x Likes(charlie, x) ::: Charlie likes someone.",
            "∃x FriendsWith(charlie, x) ::: Charlie is friends with someone."
        ],
        "predicates": [
            "FriendsWith(x, y) ::: x is friends with y",
            "Likes(x, y) ::: x likes y"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "Anyone who treats a patient helps the patient.",
            "John is a doctor.",
            "All doctors are doctors.",
            "Mary is a patient.",
            "If someone is a doctor, then they treat patients."
        ],
        "premises-FOL": [
            "∀x ∀y (Doctor(x) ∧ Patient(y) → Treats(x, y)) ::: All doctors treat patients.",
            "∀x ∀y (Treats(x, y) → Helps(x, y)) ::: Anyone who treats a patient helps the patient.",
            "Doctor(john) ::: John is a doctor.",
            "∀x (Doctor(x) → IsDoctor(x)) ::: All doctors are doctors.",
            "Patient(mary) ::: Mary is a patient.",
            "∀x (IsDoctor(x) → Treats(x, y)) ::: If someone is a doctor, then they treat patients."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Patient(x) ::: x is a patient",
            "Helps(x, y) ::: x helps y",
            "Treats(x, y) ::: x treats y",
            "IsDoctor(x) ::: x is a doctor"
        ]
    },
    {
        "premises-NL": [
            "All students who are smart like their teachers.",
            "Anyone who understands a subject passes it.",
            "If a student studies a subject, then they like that subject.",
            "If someone likes a teacher and the subject, they are hardworking.",
            "All smart students are hardworking.",
            "If someone passes a subject, then they understand the subject.",
            "John is a student and studies History.",
            "John's teacher is Ms. Smith.",
            "If a teacher teaches a subject to a student, the student studies that subject.",
            "John is smart."
        ],
        "premises-FOL": [
            "∀x ∀y (Student(x) ∧ Smart(x) ∧ Teacher(y) → Likes(x, y)) ::: All students who are smart like their teachers.",
            "∀x ∀y (Understands(x, y) → Passes(x, y)) ::: Anyone who understands a subject passes it.",
            "∀x ∀y (Student(x) ∧ Studies(x, y) → Likes(x, y)) ::: If a student studies a subject, then they like that subject.",
            "∀x ∀y ∀z (Likes(x, y) ∧ Likes(x, z) → Hardworking(x)) ::: If someone likes a teacher and the subject, they are hardworking.",
            "∀x (Smart(x) → Hardworking(x)) ::: All smart students are hardworking.",
            "∀x ∀y (Passes(x, y) → Understands(x, y)) ::: If someone passes a subject, then they understand the subject.",
            "Student(john) ∧ Studies(john, history) ::: John is a student and studies History.",
            "Teacher(msSmith) ::: John's teacher is Ms. Smith.",
            "∀x ∀y ∀z (Teaches(y, x, z) → Studies(x, z)) ::: If a teacher teaches a subject to a student, the student studies that subject.",
            "Smart(john) ::: John is smart."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Teacher(x) ::: x is a teacher",
            "Subject(x) ::: x is a subject",
            "Teaches(x, y, z) ::: x teaches y subject z",
            "Likes(x, y) ::: x likes y",
            "Studies(x, y) ::: x studies y",
            "Smart(x) ::: x is smart",
            "Hardworking(x) ::: x is hardworking",
            "Understands(x, y) ::: x understands y",
            "Passes(x, y) ::: x passes y"
        ]
    },
    {
        "premises-NL": [
            "All scientists are researchers.",
            "All researchers are doing research.",
            "If someone is a scientist, they are doing research.",
            "If someone is a researcher and studies biology, then they are doing research.",
            "If someone works at a university, they are a scientist.",
            "If someone is a scientist, they work at a university.",
            "Some scientists are studying biology.",
            "If someone studies biology, they are a researcher.",
            "If someone studies biology and is a researcher, they are doing research.",
            "All scientists are doing research.",
            "Anyone who works at a university is a scientist.",
            "Some researchers are studying biology.",
            "Everyone doing research is a scientist.",
            "If someone is a researcher they are doing research.",
            "Every researcher is a scientist."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Researcher(x)) ::: All scientists are researchers.",
            "∀x (Researcher(x) → DoingResearch(x)) ::: All researchers are doing research.",
            "∀x (Scientist(x) → DoingResearch(x)) ::: If someone is a scientist, they are doing research.",
            "∀x ((Researcher(x) ∧ StudiesBiology(x)) → DoingResearch(x)) ::: If someone is a researcher and studies biology, then they are doing research.",
            "∀x (WorksAtUniversity(x) → Scientist(x)) ::: If someone works at a university, they are a scientist.",
            "∀x (Scientist(x) → WorksAtUniversity(x)) ::: If someone is a scientist, they work at a university.",
            "∃x (Scientist(x) ∧ StudiesBiology(x)) ::: Some scientists are studying biology.",
            "∀x (StudiesBiology(x) → Researcher(x)) ::: If someone studies biology, they are a researcher.",
            "∀x ((StudiesBiology(x) ∧ Researcher(x)) → DoingResearch(x)) ::: If someone studies biology and is a researcher, they are doing research.",
            "∀x (Scientist(x) → DoingResearch(x)) ::: All scientists are doing research.",
            "∀x (WorksAtUniversity(x) → Scientist(x)) ::: Anyone who works at a university is a scientist.",
            "∃x (Researcher(x) ∧ StudiesBiology(x)) ::: Some researchers are studying biology.",
            "∀x (DoingResearch(x) → Scientist(x)) ::: Everyone doing research is a scientist.",
            "∀x (Researcher(x) → DoingResearch(x)) ::: If someone is a researcher they are doing research.",
            "∀x (Researcher(x) → Scientist(x)) ::: Every researcher is a scientist."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Researcher(x) ::: x is a researcher",
            "DoingResearch(x) ::: x is doing research",
            "StudiesBiology(x) ::: x studies biology",
            "WorksAtUniversity(x) ::: x works at a university"
        ]
    },
    {
        "premises-NL": [
            "If someone likes an event, they attend it.",
            "Mark and Jane are friends.",
            "If someone attends an event, then their friend attends it.",
            "If Mark attends an event, he likes the event.",
            "Jane likes a specific event.",
            "If someone likes an event, their friend also shares interests."
        ],
        "premises-FOL": [
            "∀x ∀z (LikesEvent(x, z) → AttendsEvent(x, z)) ::: If someone likes an event, they attend it.",
            "Friends(mark, jane) ::: Mark and Jane are friends.",
            "∀x ∀y ∀z (Friends(x, y) ∧ AttendsEvent(x, z) → AttendsEvent(y, z)) ::: If someone attends an event, then their friend attends it.",
            "∀x ∀z (AttendsEvent(x, z) → LikesEvent(x, z)) ::: If Mark attends an event, he likes the event.",
            "∃z LikesEvent(jane, z) ::: Jane likes a specific event.",
            "∀x ∀y ∀z (LikesEvent(x, z) ∧ Friends(x, y) → SharesInterest(x, y)) ::: If someone likes an event, their friend also shares interests."
        ],
        "predicates": [
            "Friends(x, y) ::: x and y are friends",
            "AttendsEvent(x, z) ::: x attends event z",
            "LikesEvent(x, z) ::: x likes event z",
            "SharesInterest(x, y) ::: x and y share interests"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "Alex is a doctor.",
            "If a doctor treats a patient, then the patient has a disease.",
            "If a patient has a disease and is treated, they will get better.",
            "Alex treats patients.",
            "Patients have diseases.",
            "If a doctor cures a disease, then the patient gets better."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → TreatsPatients(x)) ::: All doctors treat patients.",
            "Doctor(alex) ::: Alex is a doctor.",
            "∀x ∀y (TreatsPatients(x) ∧ IsPatient(y) → HasDisease(y)) ::: If a doctor treats a patient, then the patient has a disease.",
            "∀x (HasDisease(x) ∧ TreatsPatients(alex) → GetsBetter(x)) ::: If a patient has a disease and is treated, they will get better.",
            "TreatsPatients(alex) ::: Alex treats patients.",
            "∀x (IsPatient(x) → HasDisease(x)) ::: Patients have diseases.",
            "∀x ∀y (Doctor(x) ∧ CuresDisease(x, y) → GetsBetter(y)) ::: If a doctor cures a disease, then the patient gets better."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "TreatsPatients(x) ::: x treats patients",
            "HasDisease(x) ::: x has a disease",
            "GetsBetter(x) ::: x gets better",
            "CuresDisease(x, y) ::: x cures disease y",
            "IsPatient(x) ::: x is a patient"
        ]
    },
    {
        "premises-NL": [
            "All students study.",
            "Sarah is a student.",
            "If someone studies, they will pass, unless they are distracted.",
            "Sarah is not distracted.",
            "If someone is a student, they study, or they are lazy.",
            "Sarah is not lazy.",
            "If someone is lazy they do not study.",
            "Being distracted means someone does not study."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Studies(x)) ::: All students study.",
            "Student(Sarah) ::: Sarah is a student.",
            "∀x (Studies(x) → Passes(x) ∨ Distracted(x)) ::: If someone studies, they pass or are distracted.",
            "¬Distracted(Sarah) ::: Sarah is not distracted.",
            "∀x (Student(x) → Studies(x) ∨ Lazy(x)) ::: If someone is a student, they study or are lazy.",
            "¬Lazy(Sarah) ::: Sarah is not lazy.",
            "∀x (Lazy(x) → ¬Studies(x)) ::: If someone is lazy, they do not study.",
            "∀x (Distracted(x) → ¬Studies(x)) ::: Being distracted means someone does not study."
        ],
        "predicates": [
            "Studies(x) ::: x studies",
            "Student(x) ::: x is a student",
            "Passes(x) ::: x passes the exam",
            "Sarah(x) ::: x is Sarah"
        ]
    },
    {
        "premises-NL": [
            "Everyone who likes someone knows that person.",
            "If someone knows someone, and that person likes the first person, then they are friends.",
            "John likes Mary.",
            "Mary knows John.",
            "If John likes Mary, then Mary knows John."
        ],
        "premises-FOL": [
            "∀x ∀y (Likes(x, y) → Knows(x, y)) ::: Everyone who likes someone knows that person.",
            "∀x ∀y ((Knows(x, y) ∧ Likes(y, x)) → Friends(x, y)) ::: If someone knows someone, and that person likes the first person, then they are friends.",
            "Likes(john, mary) ::: John likes Mary.",
            "Knows(mary, john) ::: Mary knows John.",
            "Likes(john, mary) → Knows(mary, john) ::: If John likes Mary, then Mary knows John."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Knows(x, y) ::: x knows y",
            "Friends(x, y) ::: x and y are friends"
        ]
    },
    {
        "premises-NL": [
            "Everyone either likes or hates every animal.",
            "If someone likes an animal, they are not a friend of that animal.",
            "If someone hates an animal, they are a friend of that animal.",
            "Cats and dogs are animals.",
            "No one is a friend of both cats and dogs.",
            "Alex hates cats.",
            "Alex likes dogs.",
            "If someone likes an animal, then they are not a friend of any animal."
        ],
        "premises-FOL": [
            "∀x ∀y (IsAnimal(y) → (Likes(x, y) ∨ Hates(x, y))) ::: Everyone either likes or hates every animal.",
            "∀x ∀y (Likes(x, y) → ¬FriendOf(x, y)) ::: If someone likes an animal, they are not a friend of that animal.",
            "∀x ∀y (Hates(x, y) → FriendOf(x, y)) ::: If someone hates an animal, they are a friend of that animal.",
            "IsAnimal(cats) ∧ IsAnimal(dogs) ::: Cats and dogs are animals.",
            "¬∃x (FriendOf(x, cats) ∧ FriendOf(x, dogs)) ::: No one is a friend of both cats and dogs.",
            "Hates(alex, cats) ::: Alex hates cats.",
            "Likes(alex, dogs) ::: Alex likes dogs.",
            "∀x ∀y (Likes(x, y) ∧ IsAnimal(y) → ¬FriendOf(x, y)) ::: If someone likes an animal, then they are not a friend of any animal."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Hates(x, y) ::: x hates y",
            "IsAnimal(x) ::: x is an animal",
            "FriendOf(x, y) ::: x is a friend of y"
        ]
    },
    {
        "premises-NL": [
            "All students take an exam.",
            "If someone studies hard, they have knowledge.",
            "If someone has knowledge and takes an exam, they will succeed.",
            "Alex is a student.",
            "Alex studies hard.",
            "If Alex takes an exam, Alex will succeed.",
            "If someone studies hard, they take the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakesExam(x)) ::: All students take an exam",
            "∀x (StudiesHard(x) → HasKnowledge(x)) ::: If someone studies hard, they have knowledge",
            "∀x (HasKnowledge(x) ∧ TakesExam(x) → Succeed(x)) ::: If someone has knowledge and takes an exam, they will succeed",
            "Student(Alex) ::: Alex is a student",
            "StudiesHard(Alex) ::: Alex studies hard",
            "TakesExam(Alex) → Succeed(Alex) ::: If Alex takes an exam, Alex will succeed",
            "∀x (StudiesHard(x) → TakesExam(x)) ::: If someone studies hard, they take the exam"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "Succeed(x) ::: x will succeed",
            "TakesExam(x) ::: x takes an exam",
            "HasKnowledge(x) ::: x has knowledge"
        ]
    },
    {
        "premises-NL": [
            "If a patient has influenza, they are sick.",
            "A cough and fever are symptoms of pneumonia.",
            "If a patient has influenza and a fever, then they have pneumonia.",
            "If a patient has a cough and pneumonia, then they are sick.",
            "If a patient has a fever, they take medicine.",
            "Anyone with pneumonia is treatable with antibiotics.",
            "Having influenza causes fever.",
            "If someone takes antibiotics, then they are not sick.",
            "If a patient has a fever and a cough, then they have pneumonia."
        ],
        "premises-FOL": [
            "∀x (HasInfluenza(x) → IsSick(x)) ::: If a patient has influenza, they are sick",
            "∀x (SymptomsOf(Cough, Pneumonia) ∧ SymptomsOf(Fever, Pneumonia)) ::: A cough and fever are symptoms of pneumonia",
            "∀x (HasInfluenza(x) ∧ HasFever(x) → HasPneumonia(x)) ::: If a patient has influenza and a fever, then they have pneumonia",
            "∀x (HasCough(x) ∧ HasPneumonia(x) → IsSick(x)) ::: If a patient has a cough and pneumonia, then they are sick",
            "∀x (HasFever(x) → TakesMedicine(x, Antibiotics)) ::: If a patient has a fever, they take medicine",
            "∀x (HasPneumonia(x) → TreatableWith(x, Antibiotics)) ::: Anyone with pneumonia is treatable with antibiotics",
            "∀x (Causes(Influenza, Fever)) ::: Having influenza causes fever",
            "∀x (TakesMedicine(x, Antibiotics) → ¬IsSick(x)) ::: If someone takes antibiotics, then they are not sick",
            "∀x (HasFever(x) ∧ HasCough(x) → HasPneumonia(x)) ::: If a patient has a fever and a cough, then they have pneumonia"
        ],
        "predicates": [
            "HasFever(x) ::: x has a fever",
            "HasCough(x) ::: x has a cough",
            "HasInfluenza(x) ::: x has influenza",
            "HasPneumonia(x) ::: x has pneumonia",
            "IsSick(x) ::: x is sick",
            "TreatableWith(x, y) ::: x is treatable with y",
            "TakesMedicine(x, y) ::: x takes medicine y",
            "SymptomsOf(x, y) ::: x is a symptom of y",
            "Causes(x, y) ::: x causes y"
        ]
    },
    {
        "premises-NL": [
            "If a company is profitable and undervalued, then buy its stock.",
            "If a company reports earnings, it is profitable.",
            "If a stock is undervalued and the company has no debt, it's a good investment.",
            "If a company is profitable, the stock price goes up.",
            "Companies in the technology sector are growing if they have cash flow.",
            "If the company is profitable and the stock is undervalued, then it's a good investment.",
            "If a company has debt, then the stock is not a good investment.",
            "If a stock is a good investment, buy it.",
            "If a company reports earnings and has no debt, then buy the stock.",
            "If a company has cash flow, then it is growing."
        ],
        "premises-FOL": [
            "∀x (Profitable(x) ∧ Undervalued(x) → BuyStock(x)) ::: If a company is profitable and undervalued, then buy its stock.",
            "∀x (ReportsEarnings(x) → Profitable(x)) ::: If a company reports earnings, it is profitable.",
            "∀x (Undervalued(x) ∧ ¬HasDebt(x) → GoodInvestment(x)) ::: If a stock is undervalued and the company has no debt, it's a good investment.",
            "∀x (Profitable(x) → StockPriceUp(x)) ::: If a company is profitable, the stock price goes up.",
            "∀x (IsTechnology(x) ∧ HasCashFlow(x) → IsGrowing(x)) ::: Companies in the technology sector are growing if they have cash flow.",
            "∀x (Profitable(x) ∧ Undervalued(x) → GoodInvestment(x)) ::: If the company is profitable and the stock is undervalued, then it's a good investment.",
            "∀x (HasDebt(x) → ¬GoodInvestment(x)) ::: If a company has debt, then the stock is not a good investment.",
            "∀x (GoodInvestment(x) → BuyStock(x)) ::: If a stock is a good investment, buy it.",
            "∀x (ReportsEarnings(x) ∧ ¬HasDebt(x) → BuyStock(x)) ::: If a company reports earnings and has no debt, then buy the stock.",
            "∀x (HasCashFlow(x) → IsGrowing(x)) ::: If a company has cash flow, then it is growing."
        ],
        "predicates": [
            "Undervalued(x) ::: Stock x is undervalued",
            "Profitable(x) ::: Company x is profitable",
            "BuyStock(x) ::: Buy stock x",
            "HasDebt(x) ::: Company x has debt",
            "GoodInvestment(x) ::: x is a good investment",
            "ReportsEarnings(x) ::: Company x reports earnings",
            "StockPriceUp(x) ::: Stock price of x is up",
            "IsTechnology(x) ::: Company x is in technology sector",
            "IsGrowing(x) ::: Company x is growing",
            "HasCashFlow(x) ::: Company x has cash flow"
        ]
    },
    {
        "premises-NL": [
            "All apples are fruit.",
            "All apples are red.",
            "All apples are sweet.",
            "John eats apples.",
            "If something is an apple, then it is fruit.",
            "John eats something that is red.",
            "John eats only fruit.",
            "John only eats red fruits.",
            "John likes all red things.",
            "John eats only apples.",
            "Some apples are sweet.",
            "All apples are round.",
            "John eats red fruit.",
            "John eats all red fruits.",
            "John eats apples and also likes them.",
            "John always eats fruits."
        ],
        "premises-FOL": [
            "∀x (Apple(x) → Fruit(x)) ::: For all x, if x is an apple, then x is a fruit.",
            "∀x (Apple(x) → Red(x)) ::: For all x, if x is an apple, then x is red.",
            "∀x (Apple(x) → Sweet(x)) ::: For all x, if x is an apple, then x is sweet.",
            "∃x (Apple(x) ∧ Eats(John, x)) ::: John eats apples.",
            "∀x (Apple(x) → Fruit(x)) ::: If something is an apple, then it is fruit.",
            "∃x (Red(x) ∧ Eats(John, x)) ::: John eats something that is red.",
            "∀x (Eats(John, x) → Fruit(x)) ::: John eats only fruit.",
            "∀x (Eats(John, x) → (Fruit(x) ∧ Red(x))) ::: John only eats red fruits.",
            "∀x (Red(x) → Likes(John, x)) ::: John likes all red things.",
            "∀x (Eats(John, x) → Apple(x)) ::: John eats only apples.",
            "∃x (Apple(x) ∧ Sweet(x)) ::: Some apples are sweet.",
            "∀x (Apple(x) → Round(x)) ::: All apples are round.",
            "∃x (Fruit(x) ∧ Red(x) ∧ Eats(John, x)) ::: John eats red fruit.",
            "∀x ((Fruit(x) ∧ Red(x)) → Eats(John, x)) ::: John eats all red fruits.",
            "∃x (Apple(x) ∧ Eats(John, x) ∧ Likes(John, x)) ::: John eats apples and also likes them.",
            "∀x (Eats(John, x) → Fruit(x)) ::: John always eats fruits."
        ],
        "predicates": [
            "Fruit(x) ::: x is a fruit.",
            "Red(x) ::: x is red.",
            "Sweet(x) ::: x is sweet.",
            "Apple(x) ::: x is an apple.",
            "Eats(x, y) ::: x eats y."
        ]
    },
    {
        "premises-NL": [
            "If Alex studies hard, then Alex knows the answers.",
            "If Alex knows the answers, then Alex answered correctly.",
            "If Alex answered correctly, then Alex will pass the exam.",
            "Alex studies hard.",
            "Question 1 is easy.",
            "Alex knows the answer to question 1."
        ],
        "premises-FOL": [
            "StudyHard(alex) → KnowsAnswer(alex, 1) ::: If Alex studies hard, then Alex knows the answers.",
            "KnowsAnswer(alex, 1) → AnsweredCorrectly(alex, 1) ::: If Alex knows the answers, then Alex answered correctly.",
            "AnsweredCorrectly(alex, 1) → PassExam(alex) ::: If Alex answered correctly, then Alex will pass the exam.",
            "StudyHard(alex) ::: Alex studies hard.",
            "QuestionIsEasy(1) ::: Question 1 is easy.",
            "KnowsAnswer(alex, 1) ::: Alex knows the answer to question 1."
        ],
        "predicates": [
            "StudyHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "KnowsAnswer(x, y) ::: x knows the answer to question y",
            "QuestionIsEasy(x) ::: Question x is easy",
            "AnsweredCorrectly(x, y) ::: x answered question y correctly"
        ]
    },
    {
        "premises-NL": [
            "All diligent students attend class.",
            "All students who attend class like lectures.",
            "All students who like lectures study regularly.",
            "Some diligent students are smart.",
            "All smart students get a good grade.",
            "Alice is a student.",
            "Alice is diligent."
        ],
        "premises-FOL": [
            "∀x (Diligent(x) → AttendsClass(x)) ::: All diligent students attend class.",
            "∀x (AttendsClass(x) → LikesLectures(x)) ::: All students who attend class like lectures.",
            "∀x (LikesLectures(x) → StudiesRegularly(x)) ::: All students who like lectures study regularly.",
            "∃x (Diligent(x) ∧ IsSmart(x)) ::: Some diligent students are smart.",
            "∀x (IsSmart(x) → GoodGrade(x)) ::: All smart students get a good grade.",
            "Student(alice) ::: Alice is a student.",
            "Diligent(alice) ::: Alice is diligent."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Diligent(x) ::: x is diligent",
            "GoodGrade(x) ::: x gets a good grade",
            "AttendsClass(x) ::: x attends class",
            "LikesLectures(x) ::: x likes lectures",
            "StudiesRegularly(x) ::: x studies regularly",
            "IsSmart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "Alice is a student.",
            "If someone is a student and studies hard, they will pass the exam.",
            "Alice studies hard.",
            "All students take the exam.",
            "Being enrolled implies taking the exam.",
            "Alice is enrolled in the exam.",
            "If someone takes the exam and is a student, they either study hard or they will fail."
        ],
        "premises-FOL": [
            "Student(alice) ::: Alice is a student",
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: If someone is a student and studies hard, they will pass the exam.",
            "StudiesHard(alice) ::: Alice studies hard.",
            "∀x (Student(x) → TakesExam(x)) ::: All students take the exam.",
            "∀x ∀y (Enrolled(x, y) → TakesExam(x)) ::: Being enrolled implies taking the exam.",
            "Enrolled(alice, exam) ::: Alice is enrolled in the exam.",
            "∀x (TakesExam(x) ∧ Student(x) → StudiesHard(x) ∨ ¬PassExam(x)) ::: If someone takes the exam and is a student, they either study hard or they will fail."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x will pass the exam",
            "TakesExam(x) ::: x takes the exam",
            "Enrolled(x,y) ::: x is enrolled in y"
        ]
    },
    {
        "premises-NL": [
            "All doctors have a medical degree.",
            "Anyone with a medical degree is studying medicine.",
            "John is a doctor.",
            "John is good at his job.",
            "If someone is a doctor and studying medicine, they can help others.",
            "If someone is good at the job, they have a degree.",
            "If someone has a degree, they will help others.",
            "John has a medical degree.",
            "John is studying medicine."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HasDegree(x, medical)) ::: All doctors have a medical degree.",
            "∀x (HasDegree(x, medical) → StudyingMedicine(x)) ::: Anyone with a medical degree is studying medicine.",
            "Doctor(john) ::: John is a doctor.",
            "GoodAtJob(john) ::: John is good at his job.",
            "∀x (Doctor(x) ∧ StudyingMedicine(x) → WillHelpOthers(x)) ::: If someone is a doctor and studying medicine, they can help others.",
            "∀x (GoodAtJob(x) → HasDegree(x,medical)) ::: If someone is good at the job, they have a degree.",
            "∀x (HasDegree(x, medical) → WillHelpOthers(x)) ::: If someone has a degree, they will help others.",
            "HasDegree(john, medical) ::: John has a medical degree.",
            "StudyingMedicine(john) ::: John is studying medicine."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "StudyingMedicine(x) ::: x is studying medicine",
            "GoodAtJob(x) ::: x is good at the job",
            "WillHelpOthers(x) ::: x will help others",
            "HasDegree(x,y) ::: x has degree y",
            "IsRelatedTo(x,y) ::: x is related to y"
        ]
    },
    {
        "premises-NL": [
            "All scientists do research.",
            "If someone does research and publishes papers, they contribute to society.",
            "If someone studies physics, they are a scientist.",
            "Scientists publish papers.",
            "John is a scientist.",
            "John studies physics.",
            "If John does research, then John has a grant.",
            "John does research and publishes papers.",
            "If John studies physics and is doing research, then John contributes to society.",
            "John is doing research."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → DoingResearch(x)) ::: All scientists do research.",
            "∀x (DoingResearch(x) ∧ PublishesPapers(x) → ContributesToSociety(x)) ::: If someone does research and publishes papers, they contribute to society.",
            "∀x (StudiesPhysics(x) → Scientist(x)) ::: If someone studies physics, they are a scientist.",
            "∀x (Scientist(x) → PublishesPapers(x)) ::: Scientists publish papers.",
            "Scientist(john) ::: John is a scientist.",
            "StudiesPhysics(john) ::: John studies physics.",
            "∀x (DoingResearch(x) → HasGrant(x)) ::: If John does research, then John has a grant.",
            "DoingResearch(john) ∧ PublishesPapers(john) ::: John does research and publishes papers.",
            "StudiesPhysics(john) ∧ DoingResearch(john) → ContributesToSociety(john) ::: If John studies physics and is doing research, then John contributes to society.",
            "DoingResearch(john) ::: John is doing research."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "PublishesPapers(x) ::: x publishes papers",
            "DoingResearch(x) ::: x is doing research",
            "StudiesPhysics(x) ::: x studies physics",
            "ContributesToSociety(x) ::: x contributes to society",
            "HasGrant(x) ::: x has a grant",
            "WorksAt(x,y) ::: x works at y"
        ]
    },
    {
        "premises-NL": [
            "John likes apples.",
            "John likes bananas.",
            "Apples and bananas are fruits.",
            "John is a student.",
            "If someone likes something, then they like a fruit.",
            "If someone likes apples and bananas, then they like fruit.",
            "If someone likes apples, then they like a fruit.",
            "If someone likes bananas, then they like a fruit.",
            "If someone likes apples and bananas and is a student, then they like apples or bananas.",
            "If someone likes apples and bananas and is a student, then they like bananas.",
            "If someone likes apples and bananas, then they like fruit, or they aren't a student."
        ],
        "premises-FOL": [
            "Likes(john, apples) ::: John likes apples.",
            "Likes(john, bananas) ::: John likes bananas.",
            "IsFruit(apples) ∧ IsFruit(bananas) ::: Apples and bananas are fruits.",
            "Student(john) ::: John is a student.",
            "∀x ∃y (Likes(x, y) → IsFruit(y)) ::: If someone likes something, then they like a fruit.",
            "∀x (Likes(x, apples) ∧ Likes(x, bananas) → Likes(x, fruit)) ::: If someone likes apples and bananas, then they like fruit.",
            "∀x (Likes(x, apples) → Likes(x, fruit)) ::: If someone likes apples, then they like a fruit.",
            "∀x (Likes(x, bananas) → Likes(x, fruit)) ::: If someone likes bananas, then they like a fruit.",
            "∀x (Likes(x, apples) ∧ Likes(x, bananas) ∧ Student(x) → Likes(x, apples) ∨ Likes(x, bananas)) ::: If someone likes apples and bananas and is a student, then they like apples or bananas.",
            "∀x (Likes(x, apples) ∧ Likes(x, bananas) ∧ Student(x) → Likes(x, bananas)) ::: If someone likes apples and bananas and is a student, then they like bananas.",
            "∀x (Likes(x, apples) ∧ Likes(x, bananas) → Likes(x, fruit) ∨ ¬Student(x)) ::: If someone likes apples and bananas, then they like fruit, or they aren't a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Likes(x, y) ::: x likes y",
            "IsFruit(x) ::: x is a fruit"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "If x is a surgeon, then x treats patients.",
            "If x treats patients, then x helps people.",
            "Doctors help people or do not have a scalpel.",
            "If x has a scalpel, then x is a surgeon.",
            "If someone is a hospital employee, they are a doctor.",
            "All surgeons are hospital employees.",
            "If x is a surgeon, then x helps people.",
            "If x is not a doctor, then x does not help people.",
            "If x is a doctor, then x is a hospital employee.",
            "If x is a surgeon and x has a scalpel, then x treats patients.",
            "If x does not treat patients, then x is not a surgeon.",
            "If x is a surgeon, then x has a scalpel.",
            "Surgeons are doctors and hospital employees.",
            "If x is a doctor, then x is a surgeon."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Surgeon(x) → TreatsPatients(x)) ::: If x is a surgeon, then x treats patients.",
            "∀x (TreatsPatients(x) → HelpsPeople(x)) ::: If x treats patients, then x helps people.",
            "∀x (Doctor(x) → HelpsPeople(x) ∨ ¬HasScalpel(x)) ::: Doctors help people or do not have a scalpel.",
            "∀x (HasScalpel(x) → Surgeon(x)) ::: If x has a scalpel, then x is a surgeon.",
            "∀x (IsHospitalEmployee(x) → Doctor(x)) ::: If someone is a hospital employee, they are a doctor.",
            "∀x (Surgeon(x) → IsHospitalEmployee(x)) ::: All surgeons are hospital employees.",
            "∀x (Surgeon(x) → HelpsPeople(x)) ::: If x is a surgeon, then x helps people.",
            "∀x (¬Doctor(x) → ¬HelpsPeople(x)) ::: If x is not a doctor, then x does not help people.",
            "∀x (Doctor(x) → IsHospitalEmployee(x)) ::: If x is a doctor, then x is a hospital employee.",
            "∀x (Surgeon(x) ∧ HasScalpel(x) → TreatsPatients(x)) ::: If x is a surgeon and x has a scalpel, then x treats patients.",
            "∀x (¬TreatsPatients(x) → ¬Surgeon(x)) ::: If x does not treat patients, then x is not a surgeon.",
            "∀x (Surgeon(x) → HasScalpel(x)) ::: If x is a surgeon, then x has a scalpel.",
            "∀x (Surgeon(x) ∧ IsHospitalEmployee(x) → Doctor(x)) ::: Surgeons are doctors and hospital employees.",
            "∀x (Doctor(x) → Surgeon(x)) ::: If x is a doctor, then x is a surgeon."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "HelpsPeople(x) ::: x helps people",
            "HasScalpel(x) ::: x has a scalpel",
            "TreatsPatients(x) ::: x treats patients",
            "IsHospitalEmployee(x) ::: x is a hospital employee"
        ]
    },
    {
        "premises-NL": [
            "All students either play sports or study math.",
            "All students who study math do not play sports.",
            "Some students study science.",
            "All students who study science are active.",
            "John is a student.",
            "John studies math.",
            "If someone studies math, then they do not play sports.",
            "If someone is active, they play sports.",
            "All students like reading.",
            "If someone is a student and likes reading, then they don't study science.",
            "If someone doesn't play sports, they like reading.",
            "Some students are friends.",
            "No student likes reading and studies math.",
            "Someone is a student or does not play sports.",
            "Every student is active.",
            "If someone is a student they are active."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (PlaysSports(x) ∨ StudiesMath(x))) ::: All students either play sports or study math.",
            "∀x (StudiesMath(x) → ¬PlaysSports(x)) ::: All students who study math do not play sports.",
            "∃x (Student(x) ∧ StudiesScience(x)) ::: Some students study science.",
            "∀x (StudiesScience(x) → IsActive(x)) ::: All students who study science are active.",
            "Student(john) ::: John is a student.",
            "StudiesMath(john) ::: John studies math.",
            "∀x (StudiesMath(x) → ¬PlaysSports(x)) ::: If someone studies math, then they do not play sports.",
            "∀x (IsActive(x) → PlaysSports(x)) ::: If someone is active, they play sports.",
            "∀x (Student(x) → LikesReading(x)) ::: All students like reading.",
            "∀x (Student(x) ∧ LikesReading(x) → ¬StudiesScience(x)) ::: If someone is a student and likes reading, then they don't study science.",
            "∀x (¬PlaysSports(x) → LikesReading(x)) ::: If someone doesn't play sports, they like reading.",
            "∃x ∃y HasFriends(x, y) ::: Some students are friends.",
            "¬∃x (Student(x) ∧ LikesReading(x) ∧ StudiesMath(x)) ::: No student likes reading and studies math.",
            "∀x (Student(x) ∨ ¬PlaysSports(x)) ::: Someone is a student or does not play sports.",
            "∀x (Student(x) → IsActive(x)) ::: Every student is active.",
            "∀x (Student(x) → IsActive(x)) ::: If someone is a student they are active."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PlaysSports(x) ::: x plays sports",
            "StudiesMath(x) ::: x studies math",
            "StudiesScience(x) ::: x studies science",
            "IsActive(x) ::: x is active",
            "HasFriends(x, y) ::: x has y as a friend",
            "LikesReading(x) ::: x likes reading"
        ]
    },
    {
        "premises-NL": [
            "All artists paint.",
            "All artists like music.",
            "Some artists are famous.",
            "All famous people play an instrument.",
            "If someone is an artist, they are creative.",
            "John is an artist.",
            "John likes music.",
            "Anyone who paints, sells artwork.",
            "Not all artists are famous.",
            "Some famous artists sell artwork.",
            "If someone is creative, they are an artist.",
            "If someone plays an instrument they are not famous.",
            "All artists sells artwork.",
            "Some people who sell artwork, are not famous.",
            "If someone likes music, they are an artist.",
            "If someone sells artwork they are not famous.",
            "John plays an instrument."
        ],
        "premises-FOL": [
            "∀x (Artist(x) → Paints(x, y)) ::: All artists paint.",
            "∀x (Artist(x) → LikesMusic(x)) ::: All artists like music.",
            "∃x (Artist(x) ∧ Famous(x)) ::: Some artists are famous.",
            "∀x (Famous(x) → PlaysInstrument(x)) ::: All famous people play an instrument.",
            "∀x (Artist(x) → IsCreative(x)) ::: If someone is an artist, they are creative.",
            "Artist(john) ::: John is an artist.",
            "LikesMusic(john) ::: John likes music.",
            "∀x (Paints(x, y) → SellsArtwork(x)) ::: Anyone who paints, sells artwork.",
            "¬∀x (Artist(x) → Famous(x)) ::: Not all artists are famous.",
            "∃x (Famous(x) ∧ SellsArtwork(x)) ::: Some famous artists sell artwork.",
            "∀x (IsCreative(x) → Artist(x)) ::: If someone is creative, they are an artist.",
            "∀x (PlaysInstrument(x) → ¬Famous(x)) ::: If someone plays an instrument they are not famous.",
            "∀x (Artist(x) → SellsArtwork(x)) ::: All artists sells artwork.",
            "∃x (SellsArtwork(x) ∧ ¬Famous(x)) ::: Some people who sell artwork, are not famous.",
            "∀x (LikesMusic(x) → Artist(x)) ::: If someone likes music, they are an artist.",
            "∀x (SellsArtwork(x) → ¬Famous(x)) ::: If someone sells artwork they are not famous.",
            "PlaysInstrument(john) ::: John plays an instrument."
        ],
        "predicates": [
            "Artist(x) ::: x is an artist",
            "Famous(x) ::: x is famous",
            "Paints(x, y) ::: x paints y",
            "LikesMusic(x) ::: x likes music",
            "PlaysInstrument(x) ::: x plays an instrument",
            "IsCreative(x) ::: x is creative",
            "SellsArtwork(x) ::: x sells artwork"
        ]
    },
    {
        "premises-NL": [
            "All software engineers code.",
            "All software engineers know languages.",
            "Some software engineers design systems.",
            "All software engineers are skilled or they manage projects.",
            "John is a software engineer.",
            "John codes in Python.",
            "Anyone who codes, uses frameworks.",
            "Anyone who knows languages, is skilled.",
            "If someone designs systems, they are a software engineer.",
            "Some skilled people manage projects.",
            "No software engineers are unskilled.",
            "If someone uses frameworks, then they are skilled.",
            "John manages projects.",
            "If someone designs systems, they know languages.",
            "If someone manages projects, they use frameworks.",
            "Some skilled people use frameworks.",
            "All software engineers uses frameworks.",
            "John is skilled."
        ],
        "premises-FOL": [
            "∀x (SoftwareEngineer(x) → Codes(x, y)) ::: All software engineers code.",
            "∀x (SoftwareEngineer(x) → KnowsLanguage(x, y)) ::: All software engineers know languages.",
            "∃x (SoftwareEngineer(x) ∧ DesignsSystem(x)) ::: Some software engineers design systems.",
            "∀x (SoftwareEngineer(x) → (Skilled(x) ∨ ManagesProject(x))) ::: All software engineers are skilled or they manage projects.",
            "SoftwareEngineer(john) ::: John is a software engineer.",
            "Codes(john, Python) ::: John codes in Python.",
            "∀x (Codes(x, y) → UsesFramework(x, y)) ::: Anyone who codes, uses frameworks.",
            "∀x (KnowsLanguage(x, y) → Skilled(x)) ::: Anyone who knows languages, is skilled.",
            "∀x (DesignsSystem(x) → SoftwareEngineer(x)) ::: If someone designs systems, they are a software engineer.",
            "∃x (Skilled(x) ∧ ManagesProject(x)) ::: Some skilled people manage projects.",
            "¬∃x (SoftwareEngineer(x) ∧ ¬Skilled(x)) ::: No software engineers are unskilled.",
            "∀x (UsesFramework(x, y) → Skilled(x)) ::: If someone uses frameworks, then they are skilled.",
            "ManagesProject(john) ::: John manages projects.",
            "∀x (DesignsSystem(x) → KnowsLanguage(x, y)) ::: If someone designs systems, they know languages.",
            "∀x (ManagesProject(x) → UsesFramework(x, y)) ::: If someone manages projects, they use frameworks.",
            "∃x (Skilled(x) ∧ UsesFramework(x, y)) ::: Some skilled people use frameworks.",
            "∀x (SoftwareEngineer(x) → UsesFramework(x, y)) ::: All software engineers uses frameworks.",
            "Skilled(john) ::: John is skilled."
        ],
        "predicates": [
            "SoftwareEngineer(x) ::: x is a software engineer",
            "Skilled(x) ::: x is skilled",
            "Codes(x, y) ::: x codes in y",
            "UsesFramework(x, y) ::: x uses framework y",
            "KnowsLanguage(x, y) ::: x knows language y",
            "DesignsSystem(x) ::: x designs systems",
            "ManagesProject(x) ::: x manages projects"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients or they study diseases.",
            "All researchers publish papers.",
            "Some doctors have a specialty.",
            "All doctors who have a specialty attend conferences.",
            "John is a doctor.",
            "John has a specialty in cardiology.",
            "Anyone who treats patients is a doctor.",
            "Anyone who studies a disease is a researcher.",
            "If someone publishes papers, then they are a researcher.",
            "Some doctors treat patients.",
            "John studies diseases.",
            "If someone attends conferences, they are not a doctor.",
            "If someone studies diseases, they treat patients.",
            "Anyone who treats patients has a specialty.",
            "Anyone who has a specialty, attends conferences.",
            "John attends conferences.",
            "All doctors who do not research, treat patients.",
            "If someone is a researcher, they study diseases.",
            "Anyone who studies diseases publishes papers."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → (TreatsPatients(x, y) ∨ StudiesDisease(x, y))) ::: All doctors treat patients or they study diseases.",
            "∀x (Researcher(x) → PublishesPapers(x)) ::: All researchers publish papers.",
            "∃x (Doctor(x) ∧ HasSpecialty(x, y)) ::: Some doctors have a specialty.",
            "∀x (Doctor(x) ∧ HasSpecialty(x, y) → AttendsConferences(x)) ::: All doctors who have a specialty attend conferences.",
            "Doctor(john) ::: John is a doctor.",
            "HasSpecialty(john, Cardiology) ::: John has a specialty in cardiology.",
            "∀x (TreatsPatients(x, y) → Doctor(x)) ::: Anyone who treats patients is a doctor.",
            "∀x (StudiesDisease(x, y) → Researcher(x)) ::: Anyone who studies a disease is a researcher.",
            "∀x (PublishesPapers(x) → Researcher(x)) ::: If someone publishes papers, then they are a researcher.",
            "∃x (Doctor(x) ∧ TreatsPatients(x, y)) ::: Some doctors treat patients.",
            "StudiesDisease(john, z) ::: John studies diseases.",
            "∀x (AttendsConferences(x) → ¬Doctor(x)) ::: If someone attends conferences, they are not a doctor.",
            "∀x (StudiesDisease(x, y) → TreatsPatients(x, z)) ::: If someone studies diseases, they treat patients.",
            "∀x (TreatsPatients(x, y) → HasSpecialty(x, z)) ::: Anyone who treats patients has a specialty.",
            "∀x (HasSpecialty(x, y) → AttendsConferences(x)) ::: Anyone who has a specialty, attends conferences.",
            "AttendsConferences(john) ::: John attends conferences.",
            "∀x (Doctor(x) ∧ ¬Researcher(x) → TreatsPatients(x, y)) ::: All doctors who do not research, treat patients.",
            "∀x (Researcher(x) → StudiesDisease(x, y)) ::: If someone is a researcher, they study diseases.",
            "∀x (StudiesDisease(x, y) → PublishesPapers(x)) ::: Anyone who studies diseases publishes papers."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Researcher(x) ::: x is a researcher",
            "TreatsPatients(x, y) ::: x treats patient y",
            "StudiesDisease(x, y) ::: x studies disease y",
            "PublishesPapers(x) ::: x publishes papers",
            "HasSpecialty(x, y) ::: x has specialty y",
            "AttendsConferences(x) ::: x attends conferences"
        ]
    },
    {
        "premises-NL": [
            "All students are intelligent.",
            "If someone studies hard and attends class, then they are a diligent student.",
            "Anyone who studies hard has good notes.",
            "If a student attends class and has good notes, they are prepared for the exam.",
            "All diligent students pass the exam.",
            "John is a student.",
            "John studies hard.",
            "All students who are prepared for the exam will pass the exam.",
            "Jane is a student.",
            "Jane attends class.",
            "Jane has good notes.",
            "If a student is diligent, then they study hard.",
            "Mike is a student",
            "Mike is diligent.",
            "If someone studies hard, they will pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Intelligent(x)) ::: All students are intelligent.",
            "∀x ((StudyHard(x) ∧ AttendsClass(x)) → DiligentStudent(x)) ::: If someone studies hard and attends class, then they are a diligent student.",
            "∀x (StudyHard(x) → HasGoodNotes(x)) ::: Anyone who studies hard has good notes.",
            "∀x ((AttendsClass(x) ∧ HasGoodNotes(x)) → IsPrepared(x)) ::: If a student attends class and has good notes, they are prepared for the exam.",
            "∀x (DiligentStudent(x) → PassExam(x)) ::: All diligent students pass the exam.",
            "Student(John) ::: John is a student.",
            "StudyHard(John) ::: John studies hard.",
            "∀x (IsPrepared(x) → PassExam(x)) ::: All students who are prepared for the exam will pass the exam.",
            "Student(Jane) ::: Jane is a student.",
            "AttendsClass(Jane) ::: Jane attends class.",
            "HasGoodNotes(Jane) ::: Jane has good notes.",
            "∀x (DiligentStudent(x) → StudyHard(x)) ::: If a student is diligent, then they study hard.",
            "Student(Mike) ::: Mike is a student",
            "DiligentStudent(Mike) ::: Mike is diligent.",
            "∀x (StudyHard(x) → PassExam(x)) ::: If someone studies hard, they will pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudyHard(x) ::: x studies hard",
            "DiligentStudent(x) ::: x is a diligent student",
            "PassExam(x) ::: x passes the exam",
            "AttendsClass(x) ::: x attends class",
            "HasGoodNotes(x) ::: x has good notes",
            "IsPrepared(x) ::: x is prepared for the exam"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All doctors who treat patients practice medicine.",
            "If someone practices medicine, they are helpful.",
            "All surgeons treat patients.",
            "If someone is a doctor, they either treat patients or are a specialist.",
            "If someone is a specialist, then they are not helpful.",
            "If someone is a surgeon and a specialist, then they are not helpful.",
            "Doctors who treat patients are helpful.",
            "Everyone who practices medicine is a doctor.",
            "If someone is a doctor, then they are helpful.",
            "If someone is a doctor, then they practice medicine.",
            "If someone treats patients, they practice medicine."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Doctor(x) ∧ TreatsPatients(x) → PracticesMedicine(x)) ::: All doctors who treat patients practice medicine.",
            "∀x (PracticesMedicine(x) → Helpful(x)) ::: If someone practices medicine, they are helpful.",
            "∀x (Surgeon(x) → TreatsPatients(x)) ::: All surgeons treat patients.",
            "∀x (Doctor(x) → (TreatsPatients(x) ∨ Specialist(x))) ::: If someone is a doctor, they either treat patients or are a specialist.",
            "∀x (Specialist(x) → ¬Helpful(x)) ::: If someone is a specialist, then they are not helpful.",
            "∀x (Surgeon(x) ∧ Specialist(x) → ¬Helpful(x)) ::: If someone is a surgeon and a specialist, then they are not helpful.",
            "∀x (Doctor(x) ∧ TreatsPatients(x) → Helpful(x)) ::: Doctors who treat patients are helpful.",
            "∀x (PracticesMedicine(x) → Doctor(x)) ::: Everyone who practices medicine is a doctor.",
            "∀x (Doctor(x) → Helpful(x)) ::: If someone is a doctor, then they are helpful.",
            "∀x (Doctor(x) → PracticesMedicine(x)) ::: If someone is a doctor, then they practice medicine.",
            "∀x (TreatsPatients(x) → PracticesMedicine(x)) ::: If someone treats patients, they practice medicine."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "PracticesMedicine(x) ::: x practices medicine",
            "TreatsPatients(x) ::: x treats patients",
            "Helpful(x) ::: x is helpful",
            "Surgeon(x) ::: x is a surgeon",
            "Specialist(x) ::: x is a specialist",
            "Patient(x) ::: x is a patient"
        ]
    },
    {
        "premises-NL": [
            "If it is raining, then the ground is wet.",
            "If the ground is wet, then the plants are growing.",
            "If the sun is shining, then the plants are not growing.",
            "If clouds are present, the sun is not shining.",
            "It is raining, or the sun is shining.",
            "The ground is wet if and only if it is raining.",
            "If the ground is wet and the plants are growing, then the plants are growing.",
            "If someone is watering the plants, then the ground is wet.",
            "If it is raining, the plants are not growing.",
            "If the day is today, then the ground is wet.",
            "If it is day, then it is either raining or sunny.",
            "If it is day, then it is raining."
        ],
        "premises-FOL": [
            "∀x (Raining(x) → GroundWet(x)) ::: If it is raining, then the ground is wet.",
            "∀x (GroundWet(x) → PlantsGrowing(x)) ::: If the ground is wet, then the plants are growing.",
            "∀x (SunShining(x) → ¬PlantsGrowing(x)) ::: If the sun is shining, then the plants are not growing.",
            "∀x (CloudsPresent(x) → ¬SunShining(x)) ::: If clouds are present, the sun is not shining.",
            "∃x (Raining(x) ∨ SunShining(x)) ::: It is raining, or the sun is shining.",
            "∀x (GroundWet(x) ↔ Raining(x)) ::: The ground is wet if and only if it is raining.",
            "∀x ((GroundWet(x) ∧ PlantsGrowing(x)) → PlantsGrowing(x)) ::: If the ground is wet and the plants are growing, then the plants are growing.",
            "∀x (Watering(x) → GroundWet(x)) ::: If someone is watering the plants, then the ground is wet.",
            "∀x (Raining(x) → ¬PlantsGrowing(x)) ::: If it is raining, the plants are not growing.",
            "∀x (Day(x) → GroundWet(x)) ::: If the day is today, then the ground is wet.",
            "∀x (Day(x) → (Raining(x) ∨ SunShining(x))) ::: If it is day, then it is either raining or sunny.",
            "∀x (Day(x) → Raining(x)) ::: If it is day, then it is raining."
        ],
        "predicates": [
            "Raining(x) ::: It is raining on x",
            "GroundWet(x) ::: The ground is wet on x",
            "PlantsGrowing(x) ::: The plants are growing on x",
            "SunShining(x) ::: The sun is shining on x",
            "CloudsPresent(x) ::: Clouds are present on x",
            "Watering(x) ::: Watering is happening on x",
            "Day(x) ::: It is day on x"
        ]
    },
    {
        "premises-NL": [
            "All students either study hard or they fail.",
            "Some students are enrolled in a course.",
            "All students who are enrolled in a course, take the course.",
            "All who take the course, study hard.",
            "Anyone who studies hard is successful.",
            "All those who don't study hard, fail the course.",
            "Kat is a student.",
            "Kat is enrolled in Chemistry101.",
            "If someone fails the course, they're not successful."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (StudiesHard(x) ∨ ¬Successful(x))) ::: All students either study hard or they fail.",
            "∃x ∃y (Student(x) ∧ Enrolled(x, y)) ::: Some students are enrolled in a course.",
            "∀x ∀y (Enrolled(x, y) → TakesCourse(x, y)) ::: All students who are enrolled in a course, take the course.",
            "∀x ∀y (TakesCourse(x, y) → StudiesHard(x)) ::: All who take the course, study hard.",
            "∀x (StudiesHard(x) → Successful(x)) ::: Anyone who studies hard is successful.",
            "∀x ∀y (¬StudiesHard(x) → ¬Successful(x)) ::: All those who don't study hard, fail the course.",
            "Student(Kat) ::: Kat is a student.",
            "Enrolled(Kat, Chemistry101) ::: Kat is enrolled in Chemistry101.",
            "∀x ∀y (¬StudiesHard(x) → ¬Successful(x)) ::: If someone fails the course, they're not successful."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesHard(x) ::: x studies hard.",
            "Successful(x) ::: x is successful.",
            "Enrolled(x, y) ::: Student x is enrolled in course y.",
            "Course(y) ::: y is a course.",
            "PassesExam(x, y) ::: x passes exam y.",
            "TakesCourse(x, y) ::: x takes course y."
        ]
    },
    {
        "premises-NL": [
            "All students who are enrolled in both Math and Physics, take both courses.",
            "All students who take Math study hard.",
            "All students who are smart, like Physics.",
            "All students are either smart or they do not study hard.",
            "Some students are enrolled in Math.",
            "All students who are enrolled in Physics, take Physics.",
            "All students are enrolled in either Math or Physics.",
            "Anyone who studies hard takes Physics.",
            "Some students are smart.",
            "If a student likes Physics then they takes Physics.",
            "If someone takes Math and Physics, then they are enrolled in both."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ Enrolled(x, Math) ∧ Enrolled(x, Physics) → (TakesMath(x) ∧ TakesPhysics(x))) ::: All students who are enrolled in both Math and Physics, take both courses.",
            "∀x (TakesMath(x) → StudiesHard(x)) ::: All students who take Math study hard.",
            "∀x (Smart(x) → Likes(x, Physics)) ::: All students who are smart, like Physics.",
            "∀x (Student(x) → (Smart(x) ∨ ¬StudiesHard(x))) ::: All students are either smart or they do not study hard.",
            "∃x (Student(x) ∧ Enrolled(x, Math)) ::: Some students are enrolled in Math.",
            "∀x (Student(x) ∧ Enrolled(x, Physics) → TakesPhysics(x)) ::: All students who are enrolled in Physics, take Physics.",
            "∀x (Student(x) → (Enrolled(x, Math) ∨ Enrolled(x, Physics))) ::: All students are enrolled in either Math or Physics.",
            "∀x (StudiesHard(x) → TakesPhysics(x)) ::: Anyone who studies hard takes Physics.",
            "∃x (Student(x) ∧ Smart(x)) ::: Some students are smart.",
            "∀x (Likes(x, Physics) → TakesPhysics(x)) ::: If a student likes Physics then they takes Physics.",
            "∀x (TakesMath(x) ∧ TakesPhysics(x) → Enrolled(x, Math) ∧ Enrolled(x, Physics)) ::: If someone takes Math and Physics, then they are enrolled in both."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "TakesMath(x) ::: x takes Math.",
            "TakesPhysics(x) ::: x takes Physics.",
            "StudiesHard(x) ::: x studies hard.",
            "Likes(x, y) ::: x likes y.",
            "Enrolled(x, y) ::: Student x is enrolled in course y.",
            "Course(y) ::: y is a course.",
            "Smart(x) ::: x is smart."
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All doctors treat patients.",
            "All surgeons are good at surgery.",
            "Everyone who treats patients helps people.",
            "All specialists are doctors.",
            "Anyone who works at a hospital treats patients.",
            "All doctors either work at a hospital or they do not.",
            "Some people are surgeons.",
            "If someone is a doctor, they are a specialist.",
            "Everyone is either a doctor or not.",
            "Anyone who helps people is a doctor.",
            "If someone is a surgeon, they are good at surgery."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Doctor(x) → TreatsPatients(x)) ::: All doctors treat patients.",
            "∀x (Surgeon(x) → GoodAtSurgery(x)) ::: All surgeons are good at surgery.",
            "∀x (TreatsPatients(x) → HelpsPeople(x)) ::: Everyone who treats patients helps people.",
            "∀x (Specialist(x) → Doctor(x)) ::: All specialists are doctors.",
            "∀x (WorksAtHospital(x) → TreatsPatients(x)) ::: Anyone who works at a hospital treats patients.",
            "∀x (Doctor(x) → (WorksAtHospital(x) ∨ ¬WorksAtHospital(x))) ::: All doctors either work at a hospital or they do not.",
            "∃x (Person(x) ∧ Surgeon(x)) ::: Some people are surgeons.",
            "∀x (Doctor(x) → Specialist(x)) ::: If someone is a doctor, they are a specialist.",
            "∀x (Person(x) → (Doctor(x) ∨ ¬Doctor(x))) ::: Everyone is either a doctor or not.",
            "∀x (HelpsPeople(x) → Doctor(x)) ::: Anyone who helps people is a doctor.",
            "∀x (Surgeon(x) → GoodAtSurgery(x)) ::: If someone is a surgeon, they are good at surgery."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Surgeon(x) ::: x is a surgeon.",
            "HelpsPeople(x) ::: x helps people.",
            "TreatsPatients(x) ::: x treats patients.",
            "GoodAtSurgery(x) ::: x is good at surgery.",
            "Person(x) ::: x is a person.",
            "Specialist(x) ::: x is a specialist.",
            "WorksAtHospital(x) ::: x works at a hospital."
        ]
    },
    {
        "premises-NL": [
            "All students attend classes.",
            "Alice is a student.",
            "If someone is a student and studies hard, they know the material.",
            "If someone attends classes, they are smart.",
            "If someone knows the material and is smart, they pass the exam.",
            "Alice studies hard.",
            "If Alice studies hard, she knows the material.",
            "If Alice attends classes, she is smart.",
            "Alice attends classes.",
            "If someone is a student and does not studies hard then they do not know the material.",
            "If someone is smart, then they can pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClasses(x)) ::: All students attend classes.",
            "Student(alice) ::: Alice is a student.",
            "∀x (Student(x) ∧ StudiesHard(x) → KnowsMaterial(x)) ::: If someone is a student and studies hard, they know the material.",
            "∀x (AttendsClasses(x) → Smart(x)) ::: If someone attends classes, they are smart.",
            "∀x (KnowsMaterial(x) ∧ Smart(x) → PassesExam(x)) ::: If someone knows the material and is smart, they pass the exam.",
            "StudiesHard(alice) ::: Alice studies hard.",
            "StudiesHard(alice) → KnowsMaterial(alice) ::: If Alice studies hard, she knows the material.",
            "AttendsClasses(alice) → Smart(alice) ::: If Alice attends classes, she is smart.",
            "AttendsClasses(alice) ::: Alice attends classes.",
            "∀x (Student(x) ∧ ¬StudiesHard(x) → ¬KnowsMaterial(x)) ::: If someone is a student and does not studies hard then they do not know the material.",
            "∀x (Smart(x) → PassesExam(x)) ::: If someone is smart, then they can pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "AttendsClasses(x) ::: x attends classes",
            "PassesExam(x) ::: x passes the exam",
            "Smart(x) ::: x is smart",
            "KnowsMaterial(x) ::: x knows the material"
        ]
    },
    {
        "premises-NL": [
            "Every student is smart.",
            "Anyone who is smart is good at math.",
            "Anyone who is good at math likes math.",
            "Every student studies.",
            "If someone likes math, then they are a genius.",
            "If someone is a genius, they study hard.",
            "If someone studies hard, they study.",
            "Some student likes math.",
            "Everyone who is good at math is smart.",
            "There is a student.",
            "If someone studies, then they work hard.",
            "Anyone who is smart works hard.",
            "If someone is smart and works hard, then they are genius.",
            "Every student studies hard.",
            "Every student likes math.",
            "Someone likes math.",
            "If someone likes math, they are a genius."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: Every student is smart",
            "∀x (Smart(x) → GoodAtMath(x)) ::: Anyone who is smart is good at math",
            "∀x (GoodAtMath(x) → LikesMath(x)) ::: Anyone who is good at math likes math",
            "∀x (Student(x) → Studies(x)) ::: Every student studies",
            "∀x (LikesMath(x) → Genius(x)) ::: If someone likes math, then they are a genius",
            "∀x (Genius(x) → WorksHard(x)) ::: If someone is a genius, they study hard",
            "∀x (WorksHard(x) → Studies(x)) ::: If someone studies hard, they study",
            "∃x (Student(x) ∧ LikesMath(x)) ::: Some student likes math",
            "∀x (GoodAtMath(x) → Smart(x)) ::: Everyone who is good at math is smart",
            "∃x Student(x) ::: There is a student",
            "∀x (Studies(x) → WorksHard(x)) ::: If someone studies, then they work hard",
            "∀x (Smart(x) → WorksHard(x)) ::: Anyone who is smart works hard",
            "∀x (Smart(x) ∧ WorksHard(x) → Genius(x)) ::: If someone is smart and works hard, then they are genius",
            "∀x (Student(x) → WorksHard(x)) ::: Every student studies hard",
            "∀x (Student(x) → LikesMath(x)) ::: Every student likes math",
            "∃x LikesMath(x) ::: Someone likes math",
            "∀x (LikesMath(x) → Genius(x)) ::: If someone likes math, they are a genius"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Genius(x) ::: x is a genius",
            "Studies(x) ::: x studies",
            "LikesMath(x) ::: x likes math",
            "GoodAtMath(x) ::: x is good at math",
            "WorksHard(x) ::: x works hard",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All students are smart or they study hard.",
            "David is a student.",
            "If David is smart, he will pass the exam.",
            "David is a friend of John.",
            "John studies hard.",
            "John is a student.",
            "If someone studies hard and is a student, then they will pass the exam.",
            "It is not the case that John is not a student.",
            "If someone is a student and is a friend of John then they are smart.",
            "David is a friend of himself.",
            "Only students are smart and study hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Smart(x) ∨ StudyHard(x))) ::: All students are smart or they study hard",
            "Student(david) ::: David is a student",
            "Smart(david) → PassExam(david) ::: If David is smart, he will pass the exam",
            "IsFriendOf(david, john) ::: David is a friend of John",
            "StudyHard(john) ::: John studies hard",
            "Student(john) ::: John is a student",
            "∀x ((StudyHard(x) ∧ Student(x)) → PassExam(x)) ::: If someone studies hard and is a student, then they will pass the exam",
            "¬(¬Student(john)) ::: It is not the case that John is not a student",
            "∀x ((Student(x) ∧ IsFriendOf(x, john)) → Smart(x)) ::: If someone is a student and is a friend of John then they are smart",
            "IsFriendOf(david, david) ::: David is a friend of himself",
            "∀x ((Smart(x) ∧ StudyHard(x)) → Student(x)) ::: Only students are smart and study hard"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudyHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "Smart(x) ::: x is smart",
            "IsFriendOf(x, y) ::: x is a friend of y"
        ]
    },
    {
        "premises-NL": [
            "Everyone who attends the party either likes the music or is dancing.",
            "Everyone who attends the party enjoys the party.",
            "Everyone who enjoys the party is happy.",
            "Anyone happy likes the food.",
            "Some people are not happy.",
            "Everyone who is dancing attends the party.",
            "Not everyone is dancing",
            "Anyone who likes music dances.",
            "Anyone who is not dancing does not like music.",
            "Anyone who is happy likes food or music.",
            "If someone is dancing, then that person enjoys the party.",
            "Someone attends the party and likes the music.",
            "Someone is happy and attends the party."
        ],
        "premises-FOL": [
            "∀x (Attends(x) → (LikesMusic(x) ∨ IsDancing(x))) ::: Everyone who attends the party either likes the music or is dancing.",
            "∀x (Attends(x) → EnjoysParty(x)) ::: Everyone who attends the party enjoys the party.",
            "∀x (EnjoysParty(x) → IsHappy(x)) ::: Everyone who enjoys the party is happy.",
            "∀x (IsHappy(x) → LikesFood(x)) ::: Anyone happy likes the food.",
            "∃x ¬IsHappy(x) ::: Some people are not happy.",
            "∀x (IsDancing(x) → Attends(x)) ::: Everyone who is dancing attends the party.",
            "∃x ¬IsDancing(x) ::: Not everyone is dancing",
            "∀x (LikesMusic(x) → IsDancing(x)) ::: Anyone who likes music dances.",
            "∀x (¬IsDancing(x) → ¬LikesMusic(x)) ::: Anyone who is not dancing does not like music.",
            "∀x (IsHappy(x) → (LikesFood(x) ∨ LikesMusic(x))) ::: Anyone who is happy likes food or music.",
            "∀x (IsDancing(x) → EnjoysParty(x)) ::: If someone is dancing, then that person enjoys the party.",
            "∃x (Attends(x) ∧ LikesMusic(x)) ::: Someone attends the party and likes the music.",
            "∃x (IsHappy(x) ∧ Attends(x)) ::: Someone is happy and attends the party."
        ],
        "predicates": [
            "Attends(x) ::: x attends the party",
            "LikesMusic(x) ::: x likes the music",
            "LikesFood(x) ::: x likes the food",
            "EnjoysParty(x) ::: x enjoys the party",
            "IsDancing(x) ::: x is dancing",
            "IsHappy(x) ::: x is happy"
        ]
    },
    {
        "premises-NL": [
            "All students study.",
            "Anyone who studies takes exams.",
            "Anyone who takes exams passes them.",
            "If someone studies, they have good grades.",
            "John is a student.",
            "John takes an exam.",
            "If someone listens in class then they are intelligent.",
            "Anyone who attends class listens in class.",
            "John attends class.",
            "Anyone with good grades is intelligent."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Studies(x)) ::: All students study.",
            "∀x (Studies(x) → TakesExam(x)) ::: Anyone who studies takes exams.",
            "∀x (TakesExam(x) → PassesExam(x)) ::: Anyone who takes exams passes them.",
            "∀x (Studies(x) → HasGoodGrades(x)) ::: If someone studies, they have good grades.",
            "Student(john) ::: John is a student.",
            "TakesExam(john) ::: John takes an exam.",
            "∀x (ListensInClass(x) → Intelligent(x)) ::: If someone listens in class then they are intelligent.",
            "∀x (AttendsClass(x) → ListensInClass(x)) ::: Anyone who attends class listens in class.",
            "AttendsClass(john) ::: John attends class.",
            "∀x (HasGoodGrades(x) → Intelligent(x)) ::: Anyone with good grades is intelligent."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Intelligent(x) ::: x is intelligent",
            "Studies(x) ::: x studies",
            "TakesExam(x) ::: x takes an exam",
            "PassesExam(x) ::: x passes an exam",
            "Teaches(x, y) ::: x teaches y",
            "Understands(x, y) ::: x understands y",
            "HasGoodGrades(x) ::: x has good grades",
            "ListensInClass(x) ::: x listens in class",
            "AttendsClass(x) ::: x attends class"
        ]
    },
    {
        "premises-NL": [
            "All cats like to play with yarn.",
            "All cats chase mice.",
            "Cats are animals.",
            "All animals are alive.",
            "All cats are warm-blooded.",
            "All warm-blooded animals have fur.",
            "If something has fur, it is a cat.",
            "If something likes yarn, they play with yarn.",
            "If something chases mice, they hunt them.",
            "Whiskers is a cat.",
            "Whiskers likes yarn."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → Likes(x, yarn)) ::: All cats like to play with yarn.",
            "∀x (Cat(x) → Chases(x, mice)) ::: All cats chase mice.",
            "∀x (Cat(x) → Animal(x)) ::: Cats are animals.",
            "∀x (Animal(x) → IsAlive(x)) ::: All animals are alive.",
            "∀x (Cat(x) → IsWarmBlooded(x)) ::: All cats are warm-blooded.",
            "∀x (IsWarmBlooded(x) → HasFur(x)) ::: All warm-blooded animals have fur.",
            "∀x (HasFur(x) → Cat(x)) ::: If something has fur, it is a cat.",
            "∀x (Likes(x, yarn) → PlaysWith(x, yarn)) ::: If something likes yarn, they play with yarn.",
            "∀x (Chases(x, mice) → Hunts(x, mice)) ::: If something chases mice, they hunt them.",
            "Cat(whiskers) ::: Whiskers is a cat.",
            "Likes(whiskers, yarn) ::: Whiskers likes yarn."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Enjoys(x, y) ::: x enjoys y",
            "Chases(x, y) ::: x chases y",
            "Likes(x, y) ::: x likes y",
            "Hunts(x, y) ::: x hunts y",
            "IsSmall(x) ::: x is small",
            "Eats(x, y) ::: x eats y",
            "PlaysWith(x, y) ::: x plays with y",
            "IsAlive(x) ::: x is alive",
            "IsWarmBlooded(x) ::: x is warm-blooded",
            "HasFur(x) ::: x has fur"
        ]
    },
    {
        "premises-NL": [
            "All students study hard.",
            "Sarah is a student.",
            "All students with helpful teachers pass their exams.",
            "All teachers are helpful.",
            "John is a teacher.",
            "Sarah has John as a teacher.",
            "John is a good teacher.",
            "If someone is smart, they will pass the exam.",
            "Smart students study hard.",
            "David is a student.",
            "David studies hard.",
            "David has a good teacher.",
            "If Sarah has a good teacher, she is smart.",
            "If David is a student, he will study hard.",
            "If David has a good teacher, he will pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → StudiesHard(x)) ::: All students study hard.",
            "Student(sarah) ::: Sarah is a student.",
            "∀x (Student(x) ∧ Helpful(y) ∧ Teaches(y, x) → PassExam(x)) ::: All students with helpful teachers pass their exams.",
            "∀x (Teaches(x, y) → Helpful(x)) ::: All teachers are helpful.",
            "Teaches(john, sarah) ::: John is a teacher.",
            "Teaches(john, sarah) ::: Sarah has John as a teacher.",
            "GoodTeacher(john) ::: John is a good teacher.",
            "∀x (Smart(x) → PassExam(x)) ::: If someone is smart, they will pass the exam.",
            "∀x (Smart(x) → StudiesHard(x)) ::: Smart students study hard.",
            "Student(david) ::: David is a student.",
            "StudiesHard(david) ::: David studies hard.",
            "GoodTeacher(david) ::: David has a good teacher.",
            "GoodTeacher(sarah) → Smart(sarah) ::: If Sarah has a good teacher, she is smart.",
            "Student(david) → StudiesHard(david) ::: If David is a student, he will study hard.",
            "GoodTeacher(david) → PassExam(david) ::: If David has a good teacher, he will pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "GoodTeacher(x) ::: x has a good teacher",
            "PassExam(x) ::: x will pass the exam",
            "Teaches(x, y) ::: x teaches y",
            "Helpful(x) ::: x is helpful",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "Every doctor is a person.",
            "Some people have a degree.",
            "All people who have a degree are doctors.",
            "No one is healthy if they are not a doctor.",
            "There is a person who is not a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Person(x)) ::: Every doctor is a person.",
            "∃x HasDegree(x) ::: Some people have a degree.",
            "∀x (HasDegree(x) → Doctor(x)) ::: All people who have a degree are doctors.",
            "∀x (¬Doctor(x) → ¬Healthy(x)) ::: No one is healthy if they are not a doctor.",
            "∃x ¬Doctor(x) ::: There is a person who is not a doctor."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Doctor(x) ::: x is a doctor",
            "Healthy(x) ::: x is healthy",
            "HasDegree(x) ::: x has a degree"
        ]
    },
    {
        "premises-NL": [
            "Every doctor is overworked.",
            "Dr. Smith is a doctor.",
            "If someone is a doctor, then they are a person.",
            "Dr. Smith is a person.",
            "If someone is a person, then they have a job.",
            "Dr. Smith has a job.",
            "If someone has a job and is overworked, then they are stressed.",
            "Dr. Smith is stressed.",
            "If someone is stressed, then they need a vacation."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Overworked(x)) ::: Every doctor is overworked",
            "Doctor(Smith) ::: Dr. Smith is a doctor",
            "∀x (Doctor(x) → Person(x)) ::: If someone is a doctor, then they are a person",
            "Person(Smith) ::: Dr. Smith is a person",
            "∀x (Person(x) → HasJob(x)) ::: If someone is a person, then they have a job",
            "HasJob(Smith) ::: Dr. Smith has a job",
            "∀x (HasJob(x) ∧ Overworked(x) → Stressed(x)) ::: If someone has a job and is overworked, then they are stressed",
            "Stressed(Smith) ::: Dr. Smith is stressed",
            "∀x (Stressed(x) → NeedsVacation(x)) ::: If someone is stressed, then they need a vacation"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Overworked(x) ::: x is overworked"
        ]
    },
    {
        "premises-NL": [
            "Every student is either smart or studies.",
            "Some students are smart.",
            "If someone is smart, then they will study.",
            "If someone studies, then they will pass.",
            "If someone is not smart, then they must study.",
            "Every student who studies will pass.",
            "Some students are not smart.",
            "If someone is a student, then they are enrolled.",
            "A student is enrolled and is studying."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Smart(x) ∨ Studies(x))) ::: Every student is either smart or studies",
            "∃x (Student(x) ∧ Smart(x)) ::: Some students are smart",
            "∀x (Smart(x) → Studies(x)) ::: If someone is smart, then they will study",
            "∀x (Studies(x) → Passes(x)) ::: If someone studies, then they will pass",
            "∀x (¬Smart(x) → Studies(x)) ::: If someone is not smart, then they must study",
            "∀x (Student(x) ∧ Studies(x) → Passes(x)) ::: Every student who studies will pass",
            "∃x (Student(x) ∧ ¬Smart(x)) ::: Some students are not smart",
            "∀x (Student(x) → Enrolled(x)) ::: If someone is a student, then they are enrolled",
            "∃x (Enrolled(x) ∧ Studies(x)) ::: A student is enrolled and is studying"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Smart(x) ::: x is smart",
            "Studies(x) ::: x studies",
            "Passes(x) ::: x passes"
        ]
    },
    {
        "premises-NL": [
            "All books are library items.",
            "Some library items are borrowed.",
            "If something is borrowed, then it is a library item.",
            "If something is a library item and is borrowed, then it must be returned.",
            "If something is a library item, then it must be available.",
            "If something is a book and available, then it can be borrowed.",
            "A book is a library item.",
            "Some books are borrowed.",
            "If something is borrowed, then it is returned.",
            "If an item is a library item and not returned, then it is lost.",
            "If an item is lost, then someone is in trouble."
        ],
        "premises-FOL": [
            "∀x (Book(x) → LibraryItem(x)) ::: All books are library items",
            "∃x (LibraryItem(x) ∧ Borrowed(x)) ::: Some library items are borrowed",
            "∀x (Borrowed(x) → LibraryItem(x)) ::: If something is borrowed, then it is a library item",
            "∀x (LibraryItem(x) ∧ Borrowed(x) → Returned(x)) ::: If something is a library item and is borrowed, then it must be returned",
            "∀x (LibraryItem(x) → Available(x)) ::: If something is a library item, then it must be available",
            "∀x (Book(x) ∧ Available(x) → Borrowable(x)) ::: If something is a book and available, then it can be borrowed",
            "∀x (Book(x) → LibraryItem(x)) ::: A book is a library item",
            "∃x (Book(x) ∧ Borrowed(x)) ::: Some books are borrowed",
            "∀x (Borrowed(x) → Returned(x)) ::: If something is borrowed, then it is returned",
            "∀x (LibraryItem(x) ∧ ¬Returned(x) → Lost(x)) ::: If an item is a library item and not returned, then it is lost",
            "∀x (Lost(x) → InTrouble(x)) ::: If an item is lost, then someone is in trouble"
        ],
        "predicates": [
            "Book(x) ::: x is a book",
            "Borrowed(x) ::: x is borrowed",
            "Returned(x) ::: x is returned",
            "LibraryItem(x) ::: x is a library item"
        ]
    },
    {
        "premises-NL": [
            "Alice is a student.",
            "Bob is a student.",
            "Alice is enrolled in Class A.",
            "Bob is enrolled in Class A.",
            "If two students are enrolled in the same class, they are in the same class.",
            "Class A is a class."
        ],
        "premises-FOL": [
            "Student(alice) ::: Alice is a student.",
            "Student(bob) ::: Bob is a student.",
            "Enrolled(alice, classA) ::: Alice is enrolled in Class A.",
            "Enrolled(bob, classA) ::: Bob is enrolled in Class A.",
            "∀x ∀y ∀z (Enrolled(x, z) ∧ Enrolled(y, z) → InClass(x, y)) ::: If two students are enrolled in the same class, they are in the same class.",
            "Class(classA) ::: Class A is a class."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Enrolled(x, y) ::: Student x is enrolled in class y.",
            "InClass(x, y) ::: Student x and Student y are in the same class."
        ]
    },
    {
        "premises-NL": [
            "All professors like students.",
            "If someone likes someone, then that someone is teaching them.",
            "Professor Smith is a professor.",
            "Student Alice is a student.",
            "Professor Smith likes Student Alice.",
            "If a professor teaches a student, then the student is learning.",
            "Professor Smith teaches Alice",
            "All professors teach their students."
        ],
        "premises-FOL": [
            "∀x ∀y (Professor(x) ∧ Student(y) → Likes(x, y)) ::: All professors like students.",
            "∀x ∀y (Likes(x, y) → Teaches(x, y)) ::: If someone likes someone, then that someone is teaching them.",
            "Professor(smith) ::: Professor Smith is a professor.",
            "Student(alice) ::: Student Alice is a student.",
            "Likes(smith, alice) ::: Professor Smith likes Student Alice.",
            "∀x ∀y (Teaches(x, y) → Learning(y)) ::: If a professor teaches a student, then the student is learning.",
            "Teaches(smith, alice) ::: Professor Smith teaches Alice",
            "∀x ∀y (Professor(x) ∧ Student(y) ∧ Teaches(x, y) ) ::: All professors teach their students."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor.",
            "Student(x) ::: x is a student.",
            "Teaches(x, y) ::: Professor x teaches student y.",
            "Likes(x, y) ::: x likes y."
        ]
    },
    {
        "premises-NL": [
            "All doctors are employed.",
            "Dr. Smith is a doctor.",
            "If someone is a doctor then they are employed.",
            "If someone is employed, they receive a salary.",
            "Dr. Smith is healthy.",
            "If someone is healthy, they live long.",
            "If someone is a doctor, they can prescribe medicine.",
            "If someone is employed and a doctor, they can help people.",
            "Doctors are educated people.",
            "If doctors are employed, people will get cured."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Employed(x)) ::: All doctors are employed.",
            "Doctor(smith) ::: Dr. Smith is a doctor.",
            "∀x (Doctor(x) → Employed(x)) ::: If someone is a doctor then they are employed.",
            "∀x (Employed(x) → ReceiveSalary(x)) ::: If someone is employed, they receive a salary.",
            "Healthy(smith) ::: Dr. Smith is healthy.",
            "∀x (Healthy(x) → LiveLong(x)) ::: If someone is healthy, they live long.",
            "∀x (Doctor(x) → CanPrescribe(x)) ::: If someone is a doctor, they can prescribe medicine.",
            "∀x (Doctor(x) ∧ Employed(x) → CanHelp(x)) ::: If someone is employed and a doctor, they can help people.",
            "∀x (Doctor(x) → Educated(x)) ::: Doctors are educated people.",
            "∀x (Doctor(x) ∧ Employed(x) → PeopleCured(x)) ::: If doctors are employed, people will get cured."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Employed(x) ::: x is employed."
        ]
    },
    {
        "premises-NL": [
            "John is a person.",
            "Apples are fruits.",
            "Bananas are fruits.",
            "If John likes a fruit, then John is happy.",
            "John likes either apples or bananas.",
            "If John likes apples, he does not dislike it.",
            "John dislikes bananas.",
            "If someone does not dislike something and it's a fruit, then he likes it.",
            "If someone is happy and likes apples, they eat apples.",
            "If someone eats apples, then they are healthy.",
            "If someone likes bananas then they are happy."
        ],
        "premises-FOL": [
            "Person(john) ::: John is a person.",
            "Fruit(apple) ::: Apples are fruits.",
            "Fruit(banana) ::: Bananas are fruits.",
            "∀x ∀y (Person(x) ∧ Fruit(y) ∧ Likes(x, y) → Happy(x)) ::: If John likes a fruit, then John is happy.",
            "Likes(john, apple) ∨ Likes(john, banana) ::: John likes either apples or bananas.",
            "∀x (Likes(john, apple) → ¬Dislikes(john, apple)) ::: If John likes apples, he does not dislike it.",
            "Dislikes(john, banana) ::: John dislikes bananas.",
            "∀x ∀y (Person(x) ∧ Fruit(y) ∧ ¬Dislikes(x, y) → Likes(x, y)) ::: If someone does not dislike something and it's a fruit, then he likes it.",
            "∀x (Happy(x) ∧ Likes(x, apple) → Eats(x, apple)) ::: If someone is happy and likes apples, they eat apples.",
            "∀x (Eats(x, apple) → Healthy(x)) ::: If someone eats apples, then they are healthy.",
            "∀x (Likes(x, banana) → Happy(x)) ::: If someone likes bananas then they are happy."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "Fruit(x) ::: x is a fruit.",
            "Likes(x, y) ::: x likes y."
        ]
    },
    {
        "premises-NL": [
            "All students either attend the lecture or study.",
            "Some students attend the lecture.",
            "No student both attends the lecture and does not study.",
            "If someone studies, they get good grades.",
            "If someone attends the lecture and studies, they like the topic.",
            "Some students like the topic.",
            "If someone likes the topic, they participate in discussions.",
            "If someone participates in discussions, they ask questions.",
            "If someone asks questions, they understand the concepts.",
            "Some students are smart.",
            "Smart students study.",
            "If someone studies, they pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendLecture(x) ∨ Study(x)) ::: All students either attend the lecture or study.",
            "∃x (Student(x) ∧ AttendLecture(x)) ::: Some students attend the lecture.",
            "¬∃x (Student(x) ∧ AttendLecture(x) ∧ ¬Study(x)) ::: No student both attends the lecture and does not study.",
            "∀x (Study(x) → GoodGrades(x)) ::: If someone studies, they get good grades.",
            "∀x (AttendLecture(x) ∧ Study(x) → LikesTopic(x)) ::: If someone attends the lecture and studies, they like the topic.",
            "∃x (Student(x) ∧ LikesTopic(x)) ::: Some students like the topic.",
            "∀x (LikesTopic(x) → Participate(x)) ::: If someone likes the topic, they participate in discussions.",
            "∀x (Participate(x) → AskQuestions(x)) ::: If someone participates in discussions, they ask questions.",
            "∀x (AskQuestions(x) → UnderstandConcepts(x)) ::: If someone asks questions, they understand the concepts.",
            "∃x (Student(x) ∧ Smart(x)) ::: Some students are smart.",
            "∀x (Student(x) ∧ Smart(x) → Study(x)) ::: Smart students study.",
            "∀x (Study(x) → PassExam(x)) ::: If someone studies, they pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "AttendLecture(x) ::: x attends the lecture.",
            "Study(x) ::: x studies."
        ]
    },
    {
        "premises-NL": [
            "All patients are either treatable or have the disease.",
            "Some patients have the disease.",
            "No patient is both treatable and has the disease.",
            "If a patient is treatable, then they will recover.",
            "If a patient recovers, they will be discharged.",
            "Some patients are smokers.",
            "Smokers tend to have the disease.",
            "If a patient has the disease and smokes, then they will not recover.",
            "If someone has the disease, they may experience symptoms.",
            "If a patient is not treatable, they have the disease.",
            "If a patient is a smoker, they will not be discharged.",
            "Some patients are discharged and are also happy.",
            "If a patient has the disease and is discharged, they will recover."
        ],
        "premises-FOL": [
            "∀x (Patient(x) → Treatable(x) ∨ HasDisease(x)) ::: All patients are either treatable or have the disease.",
            "∃x (Patient(x) ∧ HasDisease(x)) ::: Some patients have the disease.",
            "¬∃x (Patient(x) ∧ Treatable(x) ∧ HasDisease(x)) ::: No patient is both treatable and has the disease.",
            "∀x (Treatable(x) → Recover(x)) ::: If a patient is treatable, then they will recover.",
            "∀x (Recover(x) → Discharged(x)) ::: If a patient recovers, they will be discharged.",
            "∃x (Patient(x) ∧ Smoker(x)) ::: Some patients are smokers.",
            "∀x (Smoker(x) → HasDisease(x)) ::: Smokers tend to have the disease.",
            "∀x (HasDisease(x) ∧ Smoker(x) → ¬Recover(x)) ::: If a patient has the disease and smokes, then they will not recover.",
            "∀x (HasDisease(x) → MayExperienceSymptoms(x)) ::: If someone has the disease, they may experience symptoms.",
            "∀x (Patient(x) ∧ ¬Treatable(x) → HasDisease(x)) ::: If a patient is not treatable, they have the disease.",
            "∀x (Smoker(x) → ¬Discharged(x)) ::: If a patient is a smoker, they will not be discharged.",
            "∃x (Patient(x) ∧ Discharged(x) ∧ Happy(x)) ::: Some patients are discharged and are also happy.",
            "∀x (Patient(x) ∧ HasDisease(x) ∧ Discharged(x) → Recover(x)) ::: If a patient has the disease and is discharged, they will recover."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient.",
            "HasDisease(x) ::: x has the disease.",
            "Treatable(x) ::: x is treatable.",
            "Recover(x) ::: x recovers."
        ]
    },
    {
        "premises-NL": [
            "All doctors are employed.",
            "Dr. Smith is a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Employed(x)) ::: For all x, if x is a doctor, then x is employed.",
            "Doctor(smith) ::: Dr. Smith is a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Employed(x) ::: x is employed."
        ]
    },
    {
        "premises-NL": [
            "All students are people.",
            "Some students are studying."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Studying(x)) ::: For all x, if x is a student, then x is studying.",
            "∃x (Student(x) ∧ Studying(x)) ::: There exists a student x who is studying."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Studying(x) ::: x is studying."
        ]
    },
    {
        "premises-NL": [
            "All cats are mammals.",
            "Garfield is a cat."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → Mammal(x)) ::: For all x, if x is a cat, then x is a mammal.",
            "Cat(garfield) ::: Garfield is a cat."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat.",
            "Mammal(x) ::: x is a mammal."
        ]
    },
    {
        "premises-NL": [
            "Everyone loves someone.",
            "Someone loves everyone."
        ],
        "premises-FOL": [
            "∀x ∃y Loves(x, y) ::: For all x, there exists a y such that x loves y.",
            "∃x ∀y Loves(x, y) ::: There exists an x such that for all y, x loves y."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "Loves(x, y) ::: x loves y."
        ]
    },
    {
        "premises-NL": [
            "All engineers have a degree.",
            "Alice is an engineer.",
            "John has a degree.",
            "Bob is not an engineer.",
            "If someone is an engineer, then they have a degree.",
            "If someone is a student, then they are smart.",
            "All students are smart.",
            "Alice is a student.",
            "If someone has a degree, then they are qualified."
        ],
        "premises-FOL": [
            "∀x (Engineer(x) → HasDegree(x)) ::: All engineers have a degree.",
            "Engineer(alice) ::: Alice is an engineer.",
            "HasDegree(john) ::: John has a degree.",
            "¬Engineer(bob) ::: Bob is not an engineer.",
            "∀x (Engineer(x) → HasDegree(x)) ::: If someone is an engineer, then they have a degree.",
            "∀x (Student(x) → Smart(x)) ::: If someone is a student, then they are smart.",
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "Student(alice) ::: Alice is a student.",
            "∀x (HasDegree(x) → Qualified(x)) ::: If someone has a degree, then they are qualified."
        ],
        "predicates": [
            "Engineer(x) ::: x is an engineer",
            "HasDegree(x) ::: x has a degree"
        ]
    },
    {
        "premises-NL": [
            "If John is a student and studies hard, then he will graduate.",
            "John is a student.",
            "If someone studies hard and attends class, they will pass.",
            "John studies hard.",
            "If someone passes, then they graduate.",
            "If someone attends class, they are smart.",
            "Alice is a student.",
            "If someone does not study hard, they fail.",
            "If someone does not fail, they pass.",
            "John attends class.",
            "If someone is not smart then they fail.",
            "If someone graduates, then they are happy.",
            "Bob is a student."
        ],
        "premises-FOL": [
            "∀x ((Student(x) ∧ StudiesHard(x)) → WillGraduate(x)) ::: If John is a student and studies hard, then he will graduate.",
            "Student(john) ::: John is a student.",
            "∀x ((StudiesHard(x) ∧ AttendsClass(x)) → Pass(x)) ::: If someone studies hard and attends class, they will pass.",
            "StudiesHard(john) ::: John studies hard.",
            "∀x (Pass(x) → WillGraduate(x)) ::: If someone passes, then they graduate.",
            "∀x (AttendsClass(x) → Smart(x)) ::: If someone attends class, they are smart.",
            "Student(alice) ::: Alice is a student.",
            "∀x (¬StudiesHard(x) → Fail(x)) ::: If someone does not study hard, they fail.",
            "∀x (¬Fail(x) → Pass(x)) ::: If someone does not fail, they pass.",
            "AttendsClass(john) ::: John attends class.",
            "∀x (¬Smart(x) → Fail(x)) ::: If someone is not smart then they fail.",
            "∀x (WillGraduate(x) → Happy(x)) ::: If someone graduates, then they are happy.",
            "Student(bob) ::: Bob is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "AttendsClass(x) ::: x attends class",
            "WillGraduate(x) ::: x will graduate"
        ]
    },
    {
        "premises-NL": [
            "All programmers know Python.",
            "Anyone who knows Python uses a computer.",
            "Some people are programmers.",
            "If someone has a laptop, then they use a computer.",
            "Alice is a programmer.",
            "If someone uses a computer and has a laptop, then they also use a computer."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → KnowsPython(x)) ::: All programmers know Python.",
            "∀x (KnowsPython(x) → UsesComputer(x)) ::: Anyone who knows Python uses a computer.",
            "∃x Programmer(x) ::: Some people are programmers.",
            "∀x (HasLaptop(x) → UsesComputer(x)) ::: If someone has a laptop, then they use a computer.",
            "Programmer(Alice) ::: Alice is a programmer.",
            "∀x ((UsesComputer(x) ∧ HasLaptop(x)) → UsesComputer(x)) ::: If someone uses a computer and has a laptop, then they also use a computer."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "UsesComputer(x) ::: x uses a computer",
            "KnowsPython(x) ::: x knows Python",
            "HasLaptop(x) ::: x has a laptop"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All doctors treat patients.",
            "Anyone who performs surgery is skilled.",
            "All surgeons perform surgery.",
            "If someone treats patients, then they are a doctor.",
            "Bob is a surgeon.",
            "If someone is a doctor, they treat patients."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Doctor(x) → TreatsPatients(x)) ::: All doctors treat patients.",
            "∀x (PerformsSurgery(x) → Skilled(x)) ::: Anyone who performs surgery is skilled.",
            "∀x (Surgeon(x) → PerformsSurgery(x)) ::: All surgeons perform surgery.",
            "∀x (TreatsPatients(x) → Doctor(x)) ::: If someone treats patients, then they are a doctor.",
            "Surgeon(Bob) ::: Bob is a surgeon.",
            "∀x (Doctor(x) → TreatsPatients(x)) ::: If someone is a doctor, they treat patients."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "Skilled(x) ::: x is skilled",
            "TreatsPatients(x) ::: x treats patients",
            "PerformsSurgery(x) ::: x performs surgery"
        ]
    },
    {
        "premises-NL": [
            "All students who attend classes study hard.",
            "Anyone who studies hard will get good grades.",
            "Anyone who gets good grades will pass the exam.",
            "Sarah is a student.",
            "Sarah attends classes.",
            "If someone likes reading, they are a student.",
            "If someone is a student and studies hard, they pass the exam.",
            "Students who attend classes study hard."
        ],
        "premises-FOL": [
            "∀x ((Student(x) ∧ AttendsClasses(x)) → StudiesHard(x)) ::: All students who attend classes study hard.",
            "∀x (StudiesHard(x) → GetsGoodGrades(x)) ::: Anyone who studies hard will get good grades.",
            "∀x (GetsGoodGrades(x) → PassesExam(x)) ::: Anyone who gets good grades will pass the exam.",
            "Student(Sarah) ::: Sarah is a student.",
            "AttendsClasses(Sarah) ::: Sarah attends classes.",
            "∀x (LikesReading(x) → Student(x)) ::: If someone likes reading, they are a student.",
            "∀x ((Student(x) ∧ StudiesHard(x)) → PassesExam(x)) ::: If someone is a student and studies hard, they pass the exam.",
            "∀x ((Student(x) ∧ AttendsClasses(x)) → StudiesHard(x)) ::: Students who attend classes study hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassesExam(x) ::: x passes the exam",
            "AttendsClasses(x) ::: x attends classes",
            "GetsGoodGrades(x) ::: x gets good grades",
            "LikesReading(x) ::: x likes reading"
        ]
    },
    {
        "premises-NL": [
            "All teachers give lectures.",
            "Anyone who gives lectures is a teacher.",
            "If someone is a teacher, they read books.",
            "If someone enjoys teaching, then they love knowledge.",
            "Anyone who loves knowledge is passionate.",
            "Sarah is a teacher and enjoys teaching.",
            "If someone is a teacher and writes papers, then they give lectures.",
            "Anyone who enjoys teaching reads books.",
            "If someone is a teacher and reads books, they enjoy teaching."
        ],
        "premises-FOL": [
            "∀x (Teacher(x) → GivesLectures(x)) ::: All teachers give lectures.",
            "∀x (GivesLectures(x) → Teacher(x)) ::: Anyone who gives lectures is a teacher.",
            "∀x (Teacher(x) → ReadsBooks(x)) ::: If someone is a teacher, they read books.",
            "∀x (EnjoysTeaching(x) → LovesKnowledge(x)) ::: If someone enjoys teaching, then they love knowledge.",
            "∀x (LovesKnowledge(x) → Passionate(x)) ::: Anyone who loves knowledge is passionate.",
            "(Teacher(Sarah) ∧ EnjoysTeaching(Sarah)) ::: Sarah is a teacher and enjoys teaching.",
            "∀x ((Teacher(x) ∧ WritesPapers(x)) → GivesLectures(x)) ::: If someone is a teacher and writes papers, then they give lectures.",
            "∀x (EnjoysTeaching(x) → ReadsBooks(x)) ::: Anyone who enjoys teaching reads books.",
            "∀x ((Teacher(x) ∧ ReadsBooks(x)) → EnjoysTeaching(x)) ::: If someone is a teacher and reads books, they enjoy teaching."
        ],
        "predicates": [
            "Teacher(x) ::: x is a teacher",
            "EnjoysTeaching(x) ::: x enjoys teaching",
            "Passionate(x) ::: x is passionate",
            "GivesLectures(x) ::: x gives lectures",
            "WritesPapers(x) ::: x writes papers",
            "LovesKnowledge(x) ::: x loves knowledge",
            "ReadsBooks(x) ::: x reads books"
        ]
    },
    {
        "premises-NL": [
            "All scientists work in a lab.",
            "Anyone who works in a lab collects data.",
            "Anyone who collects data analyzes data.",
            "Anyone who analyzes data studies.",
            "All scientists read journals.",
            "Anyone who studies publishes papers.",
            "If someone reads journals, they are a scientist.",
            "If someone attends conferences, then they are a scientist.",
            "All scientists attend conferences.",
            "Anyone who is a scientist analyzes data."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → WorksInLab(x)) ::: All scientists work in a lab.",
            "∀x (WorksInLab(x) → CollectsData(x)) ::: Anyone who works in a lab collects data.",
            "∀x (CollectsData(x) → AnalyzesData(x)) ::: Anyone who collects data analyzes data.",
            "∀x (AnalyzesData(x) → Studies(x)) ::: Anyone who analyzes data studies.",
            "∀x (Scientist(x) → ReadsJournals(x)) ::: All scientists read journals.",
            "∀x (Studies(x) → PublishesPapers(x)) ::: Anyone who studies publishes papers.",
            "∀x (ReadsJournals(x) → Scientist(x)) ::: If someone reads journals, they are a scientist.",
            "∀x (AttendsConferences(x) → Scientist(x)) ::: If someone attends conferences, then they are a scientist.",
            "∀x (Scientist(x) → AttendsConferences(x)) ::: All scientists attend conferences.",
            "∀x (Scientist(x) → AnalyzesData(x)) ::: Anyone who is a scientist analyzes data."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Studies(x) ::: x studies",
            "PublishesPapers(x) ::: x publishes papers",
            "WorksInLab(x) ::: x works in a lab",
            "CollectsData(x) ::: x collects data",
            "AnalyzesData(x) ::: x analyzes data",
            "ReadsJournals(x) ::: x reads journals",
            "AttendsConferences(x) ::: x attends conferences"
        ]
    },
    {
        "premises-NL": [
            "Sarah is a student.",
            "All students who study hard will pass the exam.",
            "Sarah studies hard.",
            "Students who like pizza don't study hard.",
            "Sarah likes pizza.",
            "If someone studies hard, then they either pass the exam or like pizza.",
            "If someone passes the exam, then they did not like pizza."
        ],
        "premises-FOL": [
            "Student(sarah) ::: Sarah is a student",
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: All students who study hard will pass the exam.",
            "StudiesHard(sarah) ::: Sarah studies hard.",
            "∀x (Student(x) ∧ LikesPizza(x) → ¬StudiesHard(x)) ::: Students who like pizza don't study hard.",
            "LikesPizza(sarah) ::: Sarah likes pizza.",
            "∀x (StudiesHard(x) → (PassExam(x) ∨ LikesPizza(x))) ::: If someone studies hard, then they either pass the exam or like pizza.",
            "∀x (PassExam(x) → ¬LikesPizza(x)) ::: If someone passes the exam, then they did not like pizza."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "LikesPizza(x) ::: x likes pizza"
        ]
    },
    {
        "premises-NL": [
            "All students like pizza.",
            "Alex is a student.",
            "If someone is smart, then they study hard.",
            "Alex is smart.",
            "If someone likes pizza and studies hard, then they will pass the exam.",
            "Everyone who passes the exam is not lazy.",
            "Alex likes pizza."
        ],
        "premises-FOL": [
            "∀x (Student(x) → LikesPizza(x)) ::: All students like pizza.",
            "Student(Alex) ::: Alex is a student.",
            "∀x (Smart(x) → StudiesHard(x)) ::: If someone is smart, then they study hard.",
            "Smart(Alex) ::: Alex is smart.",
            "∀x (LikesPizza(x) ∧ StudiesHard(x) → PassesExam(x)) ::: If someone likes pizza and studies hard, then they will pass the exam.",
            "∀x (PassesExam(x) → ¬Lazy(x)) ::: Everyone who passes the exam is not lazy.",
            "LikesPizza(Alex) ::: Alex likes pizza."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesHard(x) ::: x studies hard.",
            "PassesExam(x) ::: x passes the exam.",
            "LikesPizza(x) ::: x likes pizza.",
            "Smart(x) ::: x is smart."
        ]
    },
    {
        "premises-NL": [
            "Alice likes Bob.",
            "If Alice likes someone, then that person is Bob's friend.",
            "If someone is Bob's friend, then Bob is happy.",
            "Bob's only friend is who likes him."
        ],
        "premises-FOL": [
            "Likes(alice, bob) ::: Alice likes Bob",
            "∀x (Likes(alice, x) → Friend(x, bob)) ::: If Alice likes someone, then that person is Bob's friend.",
            "∀x (Friend(x, bob) → Happy(bob)) ::: If someone is Bob's friend, then Bob is happy.",
            "∀x (Friend(x, bob) ↔ Likes(x, bob)) ::: Bob's only friend is who likes him."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Happy(x) ::: x is happy",
            "Friend(x, y) ::: x is a friend of y"
        ]
    },
    {
        "premises-NL": [
            "All students like music.",
            "Every singer is musical.",
            "Everyone who is musical plays guitar.",
            "If someone plays guitar, they perform at a concert.",
            "If someone performs at a concert, they are musical.",
            "All singers are students.",
            "Some students are singers.",
            "If a student is a singer, they play guitar.",
            "Anyone who plays guitar likes music.",
            "If someone enjoys music, they are a student.",
            "There exists a student who enjoys music.",
            "If someone is a singer, they perform at a concert.",
            "All who perform at a concert are students.",
            "No one who likes music is a singer.",
            "At least one student sings, and at least one singer studies."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Likes(x, music)) ::: All students like music.",
            "∀x (Singer(x) → IsMusical(x)) ::: Every singer is musical.",
            "∀x (IsMusical(x) → PlaysGuitar(x)) ::: Everyone who is musical plays guitar.",
            "∀x (PlaysGuitar(x) → PerformsAt(x, concert)) ::: If someone plays guitar, they perform at a concert.",
            "∀x (PerformsAt(x, concert) → IsMusical(x)) ::: If someone performs at a concert, they are musical.",
            "∀x (Singer(x) → Student(x)) ::: All singers are students.",
            "∃x (Student(x) ∧ Singer(x)) ::: Some students are singers.",
            "∀x (Student(x) ∧ Singer(x) → PlaysGuitar(x)) ::: If a student is a singer, they play guitar.",
            "∀x (PlaysGuitar(x) → Likes(x, music)) ::: Anyone who plays guitar likes music.",
            "∀x (Enjoys(x, music) → Student(x)) ::: If someone enjoys music, they are a student.",
            "∃x (Student(x) ∧ Enjoys(x, music)) ::: There exists a student who enjoys music.",
            "∀x (Singer(x) → PerformsAt(x, concert)) ::: If someone is a singer, they perform at a concert.",
            "∀x (PerformsAt(x, concert) → Student(x)) ::: All who perform at a concert are students.",
            "¬∃x (Likes(x, music) ∧ Singer(x)) ::: No one who likes music is a singer.",
            "∃x (Student(x) ∧ Singer(x)) ::: At least one student sings, and at least one singer studies."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Singer(x) ::: x is a singer",
            "PlaysGuitar(x) ::: x plays guitar",
            "IsMusical(x) ::: x is musical",
            "Enjoys(x, y) ::: x enjoys y",
            "PerformsAt(x, y) ::: x performs at y",
            "Likes(x, y) ::: x likes y"
        ]
    },
    {
        "premises-NL": [
            "All students study.",
            "Some students are smart.",
            "Student(Alice).",
            "Student(Bob).",
            "Studies(Alice).",
            "Studies(Bob).",
            "Smart(Alice).",
            "Smart(Bob).",
            "∀x (Student(x) → Studies(x)).",
            "∃x (Student(x) ∧ Smart(x)).",
            "Student(Charlie).",
            "Studies(Charlie).",
            "Smart(Charlie)."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Studies(x)) ::: All students study.",
            "∃x (Student(x) ∧ Smart(x)) ::: Some students are smart.",
            "Student(Alice) ::: Alice is a student.",
            "Student(Bob) ::: Bob is a student.",
            "Studies(Alice) ::: Alice studies.",
            "Studies(Bob) ::: Bob studies.",
            "Smart(Alice) ::: Alice is smart.",
            "Smart(Bob) ::: Bob is smart.",
            "∀x (Student(x) → Studies(x)) ::: All students study.",
            "∃x (Student(x) ∧ Smart(x)) ::: Some students are smart.",
            "Student(Charlie) ::: Charlie is a student.",
            "Studies(Charlie) ::: Charlie studies.",
            "Smart(Charlie) ::: Charlie is smart."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All doctors are busy.",
            "Some doctors are specialists.",
            "Doctor(John).",
            "Doctor(Mary).",
            "Busy(John).",
            "Busy(Mary).",
            "Specialist(John).",
            "Specialist(Mary).",
            "∀x (Doctor(x) → Busy(x)).",
            "∃x (Doctor(x) ∧ Specialist(x)).",
            "Doctor(David).",
            "Busy(David).",
            "Specialist(David).",
            "Doctor(Emily).",
            "Busy(Emily)."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Busy(x)) ::: All doctors are busy.",
            "∃x (Doctor(x) ∧ Specialist(x)) ::: Some doctors are specialists.",
            "Doctor(John) ::: John is a doctor.",
            "Doctor(Mary) ::: Mary is a doctor.",
            "Busy(John) ::: John is busy.",
            "Busy(Mary) ::: Mary is busy.",
            "Specialist(John) ::: John is a specialist.",
            "Specialist(Mary) ::: Mary is a specialist.",
            "∀x (Doctor(x) → Busy(x)) ::: All doctors are busy.",
            "∃x (Doctor(x) ∧ Specialist(x)) ::: Some doctors are specialists.",
            "Doctor(David) ::: David is a doctor.",
            "Busy(David) ::: David is busy.",
            "Specialist(David) ::: David is a specialist.",
            "Doctor(Emily) ::: Emily is a doctor.",
            "Busy(Emily) ::: Emily is busy."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Busy(x) ::: x is busy",
            "Specialist(x) ::: x is a specialist"
        ]
    },
    {
        "premises-NL": [
            "All scientists are educated.",
            "Some educated people are researchers.",
            "All researchers publish.",
            "Scientist(John).",
            "Scientist(Mary).",
            "Educated(John).",
            "Educated(Mary).",
            "Researcher(John).",
            "Researcher(Mary).",
            "Publishes(John).",
            "Publishes(Mary).",
            "∀x (Scientist(x) → Educated(x)).",
            "∃x (Educated(x) ∧ Researcher(x)).",
            "∀x (Researcher(x) → Publishes(x)).",
            "Scientist(David).",
            "Educated(David)."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Educated(x)) ::: All scientists are educated.",
            "∃x (Educated(x) ∧ Researcher(x)) ::: Some educated people are researchers.",
            "∀x (Researcher(x) → Publishes(x)) ::: All researchers publish.",
            "Scientist(John) ::: John is a scientist.",
            "Scientist(Mary) ::: Mary is a scientist.",
            "Educated(John) ::: John is educated.",
            "Educated(Mary) ::: Mary is educated.",
            "Researcher(John) ::: John is a researcher.",
            "Researcher(Mary) ::: Mary is a researcher.",
            "Publishes(John) ::: John publishes.",
            "Publishes(Mary) ::: Mary publishes.",
            "∀x (Scientist(x) → Educated(x)) ::: All scientists are educated.",
            "∃x (Educated(x) ∧ Researcher(x)) ::: Some educated people are researchers.",
            "∀x (Researcher(x) → Publishes(x)) ::: All researchers publish.",
            "Scientist(David) ::: David is a scientist.",
            "Educated(David) ::: David is educated."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Educated(x) ::: x is educated",
            "Researcher(x) ::: x is a researcher",
            "Publishes(x) ::: x publishes"
        ]
    },
    {
        "premises-NL": [
            "All musicians are creative.",
            "Some creative people are artists.",
            "All artists attend concerts.",
            "Some musicians play an instrument.",
            "Some people who attend concerts enjoy music.",
            "If someone enjoys music, they are happy.",
            "Musician(John).",
            "Creative(John).",
            "Artist(John).",
            "AttendsConcert(John).",
            "PlaysInstrument(John).",
            "EnjoysMusic(John).",
            "Happy(John).",
            "Musician(Mary).",
            "Creative(Mary).",
            "AttendsConcert(Mary)."
        ],
        "premises-FOL": [
            "∀x (Musician(x) → Creative(x)) ::: All musicians are creative.",
            "∃x (Creative(x) ∧ Artist(x)) ::: Some creative people are artists.",
            "∀x (Artist(x) → AttendsConcert(x)) ::: All artists attend concerts.",
            "∃x (Musician(x) ∧ PlaysInstrument(x)) ::: Some musicians play an instrument.",
            "∃x (AttendsConcert(x) ∧ EnjoysMusic(x)) ::: Some people who attend concerts enjoy music.",
            "∀x (EnjoysMusic(x) → Happy(x)) ::: If someone enjoys music, they are happy.",
            "Musician(John) ::: John is a musician.",
            "Creative(John) ::: John is creative.",
            "Artist(John) ::: John is an artist.",
            "AttendsConcert(John) ::: John attends concerts.",
            "PlaysInstrument(John) ::: John plays an instrument.",
            "EnjoysMusic(John) ::: John enjoys music.",
            "Happy(John) ::: John is happy.",
            "Musician(Mary) ::: Mary is a musician.",
            "Creative(Mary) ::: Mary is creative.",
            "AttendsConcert(Mary) ::: Mary attends concerts."
        ],
        "predicates": [
            "Musician(x) ::: x is a musician",
            "Creative(x) ::: x is creative",
            "Artist(x) ::: x is an artist",
            "AttendsConcert(x) ::: x attends concerts",
            "PlaysInstrument(x) ::: x plays an instrument",
            "EnjoysMusic(x) ::: x enjoys music",
            "Happy(x) ::: x is happy"
        ]
    },
    {
        "premises-NL": [
            "Every student studies diligently.",
            "If someone studies diligently, then they pass.",
            "Alice is a student.",
            "Bob is a student.",
            "Charlie is a student.",
            "All students are enrolled in the course.",
            "There are no students who do not study diligently.",
            "Every student has a textbook.",
            "If someone has a textbook, then they study diligently."
        ],
        "premises-FOL": [
            "∀x (Student(x) → StudyDiligently(x)) ::: Every student studies diligently.",
            "∀x (StudyDiligently(x) → Pass(x)) ::: If someone studies diligently, then they pass.",
            "Student(Alice) ::: Alice is a student.",
            "Student(Bob) ::: Bob is a student.",
            "Student(Charlie) ::: Charlie is a student.",
            "∀x (Student(x) → Enrolled(x, Course)) ::: All students are enrolled in the course.",
            "¬∃x (Student(x) ∧ ¬StudyDiligently(x)) ::: There are no students who do not study diligently.",
            "∀x (Student(x) → HasTextbook(x)) ::: Every student has a textbook.",
            "∀x (HasTextbook(x) → StudyDiligently(x)) ::: If someone has a textbook, then they study diligently."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudyDiligently(x) ::: x studies diligently.",
            "Pass(x) ::: x passes."
        ]
    },
    {
        "premises-NL": [
            "Every patient with a fever tests positive for a virus.",
            "If someone tests positive for a virus, they likely have an infection.",
            "If a patient has an infection, they will respond to medication.",
            "All viruses are treatable.",
            "If something is treatable, it can be medicated.",
            "Patient A has a fever.",
            "Patient A tests positive for Virus B.",
            "If a patient has an infection they get medication.",
            "Patient A is a patient.",
            "If someone is medicated, they will respond."
        ],
        "premises-FOL": [
            "∀x ∀y ((Patient(x) ∧ HasFever(x)) ∧ Virus(y) → TestsPositive(x, y)) ::: Every patient with a fever tests positive for a virus.",
            "∀x ∀y (TestsPositive(x, y) → Infection(x)) ::: If someone tests positive for a virus, they likely have an infection.",
            "∀x (Infection(x) → RespondsToMedication(x)) ::: If a patient has an infection, they will respond to medication.",
            "∀y (Virus(y) → Treatable(y)) ::: All viruses are treatable.",
            "∀y (Treatable(y) → CanBeMedicated(y)) ::: If something is treatable, it can be medicated.",
            "HasFever(PatientA) ::: Patient A has a fever.",
            "TestsPositive(PatientA, VirusB) ::: Patient A tests positive for Virus B.",
            "∀x (Infection(x) → ReceivesMedication(x)) ::: If a patient has an infection they get medication.",
            "Patient(PatientA) ::: Patient A is a patient.",
            "∀x (ReceivesMedication(x) → RespondsToMedication(x)) ::: If someone is medicated, they will respond."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient.",
            "HasFever(x) ::: x has a fever.",
            "TestsPositive(x, y) ::: x tests positive for y.",
            "Virus(y) ::: y is a virus.",
            "Infection(x) ::: x has an infection.",
            "ReceivesMedication(x) ::: x receives medication.",
            "Treatable(y) ::: y is treatable.",
            "RespondsToMedication(x) ::: x responds to medication."
        ]
    },
    {
        "premises-NL": [
            "All students who study hard pass the exam.",
            "All students attend classes.",
            "If someone attends classes and studies hard, then they understand the material.",
            "If someone understands the material, then they will pass the exam.",
            "John is a student.",
            "John studies hard.",
            "If someone is smart and studies hard, then they will pass the exam.",
            "If someone gets good grades, then they study hard.",
            "All students are smart or they get good grades.",
            "If someone likes the subject and attends classes, then they study hard.",
            "If someone attends classes then they understand the material.",
            "If someone is a student, then they must attend classes.",
            "If someone attends classes and understands the material, then they pass the exam.",
            "If someone is smart and attends classes then they pass the exam.",
            "If someone likes the subject and studies hard, then they will pass the exam.",
            "If someone gets good grades, then they will pass the exam.",
            "If someone studies hard and understands the material then they will pass the exam.",
            "If someone likes the subject and studies hard, they will pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: All students who study hard pass the exam.",
            "∀x (Student(x) → AttendsClasses(x)) ::: All students attend classes.",
            "∀x (AttendsClasses(x) ∧ StudiesHard(x) → UnderstandsMaterial(x)) ::: If someone attends classes and studies hard, then they understand the material.",
            "∀x (UnderstandsMaterial(x) → PassExam(x)) ::: If someone understands the material, then they will pass the exam.",
            "Student(john) ::: John is a student.",
            "StudiesHard(john) ::: John studies hard.",
            "∀x (IsSmart(x) ∧ StudiesHard(x) → PassExam(x)) ::: If someone is smart and studies hard, then they will pass the exam.",
            "∀x (GetsGoodGrades(x) → StudiesHard(x)) ::: If someone gets good grades, then they study hard.",
            "∀x (Student(x) → (IsSmart(x) ∨ GetsGoodGrades(x))) ::: All students are smart or they get good grades.",
            "∀x (LikesSubject(x, y) ∧ AttendsClasses(x) → StudiesHard(x)) ::: If someone likes the subject and attends classes, then they study hard.",
            "∀x (AttendsClasses(x) → UnderstandsMaterial(x)) ::: If someone attends classes then they understand the material.",
            "∀x (Student(x) → AttendsClasses(x)) ::: If someone is a student, then they must attend classes.",
            "∀x (AttendsClasses(x) ∧ UnderstandsMaterial(x) → PassExam(x)) ::: If someone attends classes and understands the material, then they pass the exam.",
            "∀x (IsSmart(x) ∧ AttendsClasses(x) → PassExam(x)) ::: If someone is smart and attends classes then they pass the exam.",
            "∀x (LikesSubject(x, y) ∧ StudiesHard(x) → PassExam(x)) ::: If someone likes the subject and studies hard, then they will pass the exam.",
            "∀x (GetsGoodGrades(x) → PassExam(x)) ::: If someone gets good grades, then they will pass the exam.",
            "∀x (StudiesHard(x) ∧ UnderstandsMaterial(x) → PassExam(x)) ::: If someone studies hard and understands the material then they will pass the exam.",
            "∀x (LikesSubject(x, y) ∧ StudiesHard(x) → PassExam(x)) ::: If someone likes the subject and studies hard, they will pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "AttendsClasses(x) ::: x attends classes",
            "UnderstandsMaterial(x) ::: x understands the material",
            "IsSmart(x) ::: x is smart",
            "GetsGoodGrades(x) ::: x gets good grades",
            "LikesSubject(x, y) ::: x likes subject y"
        ]
    },
    {
        "premises-NL": [
            "All programmers know Python or Java.",
            "Anyone who knows Python is a programmer.",
            "Anyone who knows Java is a programmer.",
            "If someone knows Python or Java, they have a computer.",
            "Alice is a programmer.",
            "Bob knows Python."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → (KnowsPython(x) ∨ KnowsJava(x))) ::: All programmers know Python or Java.",
            "∀x (KnowsPython(x) → Programmer(x)) ::: Anyone who knows Python is a programmer.",
            "∀x (KnowsJava(x) → Programmer(x)) ::: Anyone who knows Java is a programmer.",
            "∀x ((KnowsPython(x) ∨ KnowsJava(x)) → HasComputer(x)) ::: If someone knows Python or Java, they have a computer.",
            "Programmer(alice) ::: Alice is a programmer.",
            "KnowsPython(bob) ::: Bob knows Python."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "HasComputer(x) ::: x has a computer",
            "KnowsPython(x) ::: x knows Python",
            "KnowsJava(x) ::: x knows Java"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard pass the exam or fail the exam.",
            "If someone passes the exam and does not fail, they graduate.",
            "If a student takes a required course, then the student must study hard or they fail the exam.",
            "Alice is a student and studies hard.",
            "Alice takes a required course.",
            "If someone fails the exam, they do not graduate.",
            "Bob studies hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) → (PassesExam(x) ∨ FailsExam(x))) ::: All students who study hard pass the exam or fail the exam.",
            "∀x ((PassesExam(x) ∧ ¬FailsExam(x)) → Graduates(x)) ::: If someone passes the exam and does not fail, they graduate.",
            "∀x ∀y (Student(x) ∧ TakesCourse(x, y) ∧ CourseRequired(y) → (StudiesHard(x) ∨ FailsExam(x))) ::: If a student takes a required course, then the student must study hard or they fail the exam.",
            "Student(alice) ∧ StudiesHard(alice) ::: Alice is a student and studies hard.",
            "TakesCourse(alice, calculus) ∧ CourseRequired(calculus) ::: Alice takes a required course.",
            "∀x (FailsExam(x) → ¬Graduates(x)) ::: If someone fails the exam, they do not graduate.",
            "StudiesHard(bob) ::: Bob studies hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassesExam(x) ::: x passes the exam",
            "FailsExam(x) ::: x fails the exam",
            "Graduates(x) ::: x graduates",
            "TakesCourse(x, y) ::: x takes course y",
            "CourseRequired(y) ::: course y is required"
        ]
    },
    {
        "premises-NL": [
            "All artists are creative.",
            "David is an artist.",
            "If something is an artist, then it is creative.",
            "The artist always creates art.",
            "David creates art.",
            "The art is always creative.",
            "David wants to be an artist.",
            "David should create art.",
            "David is working on art.",
            "If David is an artist, he will be creative."
        ],
        "premises-FOL": [
            "∀x (Artist(x) → Creative(x)) ::: All artists are creative",
            "Artist(david) ::: David is an artist",
            "∀x (Artist(x) → Creative(x)) ::: If something is an artist, then it is creative",
            "∀x (Artist(x) → CreatesArt(x)) ::: The artist always creates art",
            "CreatesArt(david) ::: David creates art",
            "∀x (CreatesArt(x) → Creative(x)) ::: The art is always creative",
            "WantsToBeArtist(david) ::: David wants to be an artist",
            "ShouldCreateArt(david) ::: David should create art",
            "IsWorkingOnArt(david) ::: David is working on art",
            "Artist(david) → Creative(david) ::: If David is an artist, he will be creative"
        ],
        "predicates": [
            "Artist(x) ::: x is an artist",
            "Creative(x) ::: x is creative"
        ]
    },
    {
        "premises-NL": [
            "All doctors are experts.",
            "All experts are knowledgeable.",
            "A doctor is always knowledgeable.",
            "If someone is a doctor, then they are an expert.",
            "If someone is an expert, they are knowledgeable.",
            "Doctors are dedicated to their work.",
            "Being an expert is crucial in this field.",
            "Knowledge is essential for the job.",
            "A doctor must have expertise to perform the tasks.",
            "Doctors need to be knowledgeable.",
            "An expert has knowledge."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Expert(x)) ::: All doctors are experts",
            "∀x (Expert(x) → Knowledgeable(x)) ::: All experts are knowledgeable",
            "∀x (Doctor(x) → Knowledgeable(x)) ::: A doctor is always knowledgeable",
            "∀x (Doctor(x) → Expert(x)) ::: If someone is a doctor, then they are an expert",
            "∀x (Expert(x) → Knowledgeable(x)) ::: If someone is an expert, they are knowledgeable",
            "∀x (Doctor(x) → Dedicated(x)) ::: Doctors are dedicated to their work",
            "∀x (Expert(x) → Crucial(x)) ::: Being an expert is crucial in this field",
            "∀x (Knowledgeable(x) → Essential(x)) ::: Knowledge is essential for the job",
            "∀x (Doctor(x) → HasExpertise(x)) ::: A doctor must have expertise to perform the tasks",
            "∀x (Doctor(x) → NeedsKnowledge(x)) ::: Doctors need to be knowledgeable",
            "∀x (Expert(x) → HasKnowledge(x)) ::: An expert has knowledge"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Expert(x) ::: x is an expert",
            "Knowledgeable(x) ::: x is knowledgeable"
        ]
    },
    {
        "premises-NL": [
            "All students take the exam.",
            "If someone takes the exam and studies hard, they will pass.",
            "John is a student.",
            "John studies hard.",
            "If someone studies hard, then they take the exam.",
            "John takes the exam.",
            "If someone is a student, then they should study.",
            "If John is a student he must study hard to pass.",
            "Passing is essential for a student.",
            "Those who study hard, pass the exam.",
            "John will be a student.",
            "Passing is the goal."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakesExam(x)) ::: All students take the exam",
            "∀x (TakesExam(x) ∧ StudiesHard(x) → Passes(x)) ::: If someone takes the exam and studies hard, they will pass",
            "Student(john) ::: John is a student",
            "StudiesHard(john) ::: John studies hard",
            "∀x (StudiesHard(x) → TakesExam(x)) ::: If someone studies hard, then they take the exam",
            "TakesExam(john) ::: John takes the exam",
            "∀x (Student(x) → ShouldStudy(x)) ::: If someone is a student, then they should study",
            "Student(john) → (StudiesHard(john) → Passes(john)) ::: If John is a student he must study hard to pass",
            "∀x (Student(x) → Essential(x)) ::: Passing is essential for a student",
            "∀x (StudiesHard(x) → PassesExam(x)) ::: Those who study hard, pass the exam",
            "WillBeStudent(john) ::: John will be a student",
            "∀x (Passes(x) → IsGoal(x)) ::: Passing is the goal"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "Passes(x) ::: x passes",
            "TakesExam(x) ::: x takes the exam"
        ]
    },
    {
        "premises-NL": [
            "John is a doctor.",
            "John studies medicine.",
            "If someone is a doctor and studies medicine, they help patients.",
            "Doctors study medicine.",
            "Medicine is important for doctors.",
            "John knows the medical science.",
            "Medical science is important for doctors.",
            "John is dedicated to medicine.",
            "Doctors should help patients.",
            "John wants to be a good doctor.",
            "If someone helps patients, then they are a doctor.",
            "John always studies medicine.",
            "John will help the patients.",
            "If you want to be a doctor, then you have to study medicine."
        ],
        "premises-FOL": [
            "Doctor(john) ::: John is a doctor",
            "Studies(john, medicine) ::: John studies medicine",
            "∀x (Doctor(x) ∧ Studies(x, medicine) → HelpsPatients(x)) ::: If someone is a doctor and studies medicine, they help patients",
            "∀x (Doctor(x) → Studies(x, medicine)) ::: Doctors study medicine",
            "∀x (Doctor(x) → IsImportant(x, medicine)) ::: Medicine is important for doctors",
            "Knows(john, medicalScience) ::: John knows the medical science",
            "∀x (Doctor(x) → IsImportant(x, medicalScience)) ::: Medical science is important for doctors",
            "DedicatedToMedicine(john) ::: John is dedicated to medicine",
            "∀x (Doctor(x) → ShouldHelpPatients(x)) ::: Doctors should help patients",
            "WantsToBeGoodDoctor(john) ::: John wants to be a good doctor",
            "∀x (HelpsPatients(x) → Doctor(x)) ::: If someone helps patients, then they are a doctor",
            "∀x (Studies(john, medicine)) ::: John always studies medicine",
            "WillHelpPatients(john) ::: John will help the patients",
            "∀x (WantsToBeDoctor(x) → Studies(x, medicine)) ::: If you want to be a doctor, then you have to study medicine"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Studies(x, y) ::: x studies y",
            "HelpsPatients(x) ::: x helps patients",
            "Knows(x, y) ::: x knows y"
        ]
    },
    {
        "premises-NL": [
            "All sparrows are birds.",
            "Some birds cannot fly.",
            "All birds that cannot fly can swim.",
            "Some birds live in water.",
            "Birds that live in water are not sparrows.",
            "Some birds are sparrows.",
            "If something can swim, it is not a sparrow.",
            "Some birds can't fly.",
            "Something that lives in water cannot fly.",
            "All birds can be sparrows, or they cannot swim.",
            "All birds that cannot swim can fly.",
            "Some birds can fly and some of them are sparrows.",
            "All sparrows can fly."
        ],
        "premises-FOL": [
            "∀x (Sparrow(x) → Bird(x)) ::: All sparrows are birds.",
            "∃x (Bird(x) ∧ ¬Fly(x)) ::: Some birds cannot fly.",
            "∀x ((Bird(x) ∧ ¬Fly(x)) → CanSwim(x)) ::: All birds that cannot fly can swim.",
            "∃x (Bird(x) ∧ LivesInWater(x)) ::: Some birds live in water.",
            "∀x (LivesInWater(x) → ¬Sparrow(x)) ::: Birds that live in water are not sparrows.",
            "∃x (Bird(x) ∧ Sparrow(x)) ::: Some birds are sparrows.",
            "∀x (CanSwim(x) → ¬Sparrow(x)) ::: If something can swim, it is not a sparrow.",
            "∃x (Bird(x) ∧ ¬Fly(x)) ::: Some birds can't fly.",
            "∀x (LivesInWater(x) → ¬Fly(x)) ::: Something that lives in water cannot fly.",
            "∀x (Bird(x) → (Sparrow(x) ∨ ¬CanSwim(x))) ::: All birds can be sparrows, or they cannot swim.",
            "∀x ((Bird(x) ∧ ¬CanSwim(x)) → Fly(x)) ::: All birds that cannot swim can fly.",
            "∃x (Bird(x) ∧ Fly(x) ∧ Sparrow(x)) ::: Some birds can fly and some of them are sparrows.",
            "∀x (Sparrow(x) → Fly(x)) ::: All sparrows can fly."
        ],
        "predicates": [
            "Bird(x) ::: x is a bird",
            "Fly(x) ::: x can fly",
            "Sparrow(x) ::: x is a sparrow",
            "CanSwim(x) ::: x can swim",
            "LivesInWater(x) ::: x lives in water"
        ]
    },
    {
        "premises-NL": [
            "Alex is smart.",
            "If someone is smart, they study hard.",
            "Alex reads books.",
            "If someone reads books, they attend all lectures.",
            "If someone studies hard, they will pass the exam.",
            "If someone attends all lectures, they will pass the exam.",
            "Alex either studies hard or reads books.",
            "If someone studies hard and attends all lectures, they will pass the exam."
        ],
        "premises-FOL": [
            "Smart(alex) ::: Alex is smart.",
            "∀x (Smart(x) → StudyHard(x)) ::: If someone is smart, they study hard.",
            "ReadsBooks(alex) ::: Alex reads books.",
            "∀x (ReadsBooks(x) → AttendLectures(x)) ::: If someone reads books, they attend all lectures.",
            "StudyHard(alex) → PassExam(alex) ::: If someone studies hard, they will pass the exam.",
            "AttendLectures(alex) → PassExam(alex) ::: If someone attends all lectures, they will pass the exam.",
            "StudyHard(alex) ∨ ReadsBooks(alex) ::: Alex either studies hard or reads books.",
            "StudyHard(alex) ∧ AttendLectures(alex) → PassExam(alex) ::: If someone studies hard and attends all lectures, they will pass the exam."
        ],
        "predicates": [
            "StudyHard(x) ::: x studies hard",
            "AttendLectures(x) ::: x attends all lectures",
            "PassExam(x) ::: x will pass the exam",
            "Smart(x) ::: x is smart",
            "ReadsBooks(x) ::: x reads books"
        ]
    },
    {
        "premises-NL": [
            "Bob likes cats.",
            "Bob likes dogs.",
            "All cats are animals.",
            "All dogs are animals.",
            "If someone likes cats, then they like pets.",
            "If someone likes dogs, then they like pets.",
            "If someone likes pets, they like animals.",
            "Bob likes cats or dogs.",
            "If someone likes cats and dogs, they like animals."
        ],
        "premises-FOL": [
            "Likes(bob, cats) ::: Bob likes cats.",
            "Likes(bob, dogs) ::: Bob likes dogs.",
            "∀x (Cat(x) → Animal(x)) ::: All cats are animals.",
            "∀x (Dog(x) → Animal(x)) ::: All dogs are animals.",
            "∀x (Likes(x, cats) → Likes(x, IsPet)) ::: If someone likes cats, then they like pets.",
            "∀x (Likes(x, dogs) → Likes(x, IsPet)) ::: If someone likes dogs, then they like pets.",
            "∀x (Likes(x, IsPet) → Likes(x, animals)) ::: If someone likes pets, they like animals.",
            "Likes(bob, cats) ∨ Likes(bob, dogs) ::: Bob likes cats or dogs.",
            "Likes(bob, cats) ∧ Likes(bob, dogs) → Likes(bob, animals) ::: If someone likes cats and dogs, they like animals."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Cat(x) ::: x is a cat",
            "Dog(x) ::: x is a dog",
            "Animal(x) ::: x is an animal",
            "IsPet(x) ::: x is a pet"
        ]
    },
    {
        "premises-NL": [
            "Anyone who owns a car is wealthy or has savings.",
            "Anyone who owns a house is wealthy or has savings.",
            "If someone has savings and no debt, then they are wealthy.",
            "John owns a car.",
            "John owns a house.",
            "If someone owns a car and a house, they have savings.",
            "John either has debt or has savings.",
            "If someone is wealthy, they have savings.",
            "If someone has savings, they either own a car or a house.",
            "John is wealthy or has savings.",
            "If someone is wealthy and has savings, they are wealthy."
        ],
        "premises-FOL": [
            "∀x (Owns(x, car) → Wealthy(x) ∨ HasSavings(x)) ::: Anyone who owns a car is wealthy or has savings.",
            "∀x (Owns(x, house) → Wealthy(x) ∨ HasSavings(x)) ::: Anyone who owns a house is wealthy or has savings.",
            "∀x (HasSavings(x) ∧ ¬HasDebt(x) → Wealthy(x)) ::: If someone has savings and no debt, then they are wealthy.",
            "Owns(john, car) ::: John owns a car.",
            "Owns(john, house) ::: John owns a house.",
            "∀x (Owns(x, car) ∧ Owns(x, house) → HasSavings(x)) ::: If someone owns a car and a house, they have savings.",
            "HasDebt(john) ∨ HasSavings(john) ::: John either has debt or has savings.",
            "∀x (Wealthy(x) → HasSavings(x)) ::: If someone is wealthy, they have savings.",
            "∀x (HasSavings(x) → Owns(x, car) ∨ Owns(x, house)) ::: If someone has savings, they either own a car or a house.",
            "Wealthy(john) ∨ HasSavings(john) ::: John is wealthy or has savings.",
            "Wealthy(x) ∧ HasSavings(x) → Wealthy(x) ::: If someone is wealthy and has savings, they are wealthy."
        ],
        "predicates": [
            "Owns(x, y) ::: x owns y",
            "Car(x) ::: x is a car",
            "House(x) ::: x is a house",
            "Wealthy(x) ::: x is wealthy",
            "HasSavings(x) ::: x has savings",
            "HasDebt(x) ::: x has debt"
        ]
    },
    {
        "premises-NL": [
            "All students who are enrolled in CS101 must take the final exam.",
            "If a student takes the final exam, they will pass the course or fail it.",
            "If a student is enrolled in CS101 and takes the final exam, then they will pass the course.",
            "Anyone who is enrolled in CS101 and takes the final exam, will also pass it.",
            "If someone passes a course, they are not failing it.",
            "If someone is enrolled in CS101, then they either take the final exam or don't take the final exam.",
            "If a student takes the final exam, they either pass the course or fail the course.",
            "If someone is enrolled in CS101 and doesn't take the final exam, they will fail the course.",
            "If a student passes the course or fails it, then they will pass the course.",
            "Anyone who is enrolled in CS101 takes the final exam.",
            "If someone is enrolled in CS101, then they take the final exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ EnrolledIn(x, cs101) → TakesExam(x, finalExam)) ::: All students who are enrolled in CS101 must take the final exam.",
            "∀x (Student(x) ∧ TakesExam(x, finalExam) → PassCourse(x) ∨ FailCourse(x)) ::: If a student takes the final exam, they will pass the course or fail it.",
            "∀x (EnrolledIn(x, cs101) ∧ TakesExam(x, finalExam) → PassCourse(x)) ::: If a student is enrolled in CS101 and takes the final exam, then they will pass the course.",
            "∀x (EnrolledIn(x, cs101) ∧ TakesExam(x, finalExam) → PassCourse(x)) ::: Anyone who is enrolled in CS101 and takes the final exam, will also pass it.",
            "∀x (PassCourse(x) → ¬FailCourse(x)) ::: If someone passes a course, they are not failing it.",
            "∀x (EnrolledIn(x, cs101) → TakesExam(x, finalExam) ∨ ¬TakesExam(x, finalExam)) ::: If someone is enrolled in CS101, then they either take the final exam or don't take the final exam.",
            "∀x (TakesExam(x, finalExam) → PassCourse(x) ∨ FailCourse(x)) ::: If a student takes the final exam, they either pass the course or fail the course.",
            "∀x (EnrolledIn(x, cs101) ∧ ¬TakesExam(x, finalExam) → FailCourse(x)) ::: If someone is enrolled in CS101 and doesn't take the final exam, they will fail the course.",
            "∀x (PassCourse(x) ∨ FailCourse(x) → PassCourse(x)) ::: If a student passes the course or fails it, then they will pass the course.",
            "∀x (Student(x) ∧ EnrolledIn(x, cs101) → TakesExam(x, finalExam)) ::: Anyone who is enrolled in CS101 takes the final exam.",
            "∀x (EnrolledIn(x, cs101) → TakesExam(x, finalExam)) ::: If someone is enrolled in CS101, then they take the final exam."
        ],
        "predicates": [
            "EnrolledIn(x, y) ::: x is enrolled in y",
            "TakesExam(x, y) ::: x takes y",
            "PassCourse(x) ::: x passes the course",
            "Student(x) ::: x is a student",
            "CS101(x) ::: x is CS101",
            "FinalExam(x) ::: x is the final exam"
        ]
    },
    {
        "premises-NL": [
            "All students study something.",
            "Everyone who studies something attends the university.",
            "John is a student.",
            "John studies Mathematics.",
            "If someone studies Mathematics, that person is intelligent.",
            "Every university is an institute of higher education.",
            "The University of California is a university.",
            "If someone studies something, they attend the university.",
            "Mathematics is a subject studied by all.",
            "If someone is a student and studies, then the person attends the university"
        ],
        "premises-FOL": [
            "∀x ∃y (Student(x) → Study(x, y)) ::: All students study something.",
            "∀x ∀y (Study(x, y) → Attends(x, the_university)) ::: Everyone who studies something attends the university.",
            "Student(john) ::: John is a student.",
            "Study(john, mathematics) ::: John studies Mathematics.",
            "∀x (Study(x, mathematics) → Intelligent(x)) ::: If someone studies Mathematics, that person is intelligent.",
            "∀x (University(x) → InstituteOfHigherEducation(x)) ::: Every university is an institute of higher education.",
            "University(the_university) ::: The University of California is a university.",
            "∀x ∀y (Study(x, y) → Attends(x, the_university)) ::: If someone studies something, they attend the university.",
            "∀x Study(x, mathematics) ::: Mathematics is a subject studied by all.",
            "∀x ∀y (Student(x) ∧ Study(x, y) → Attends(x, the_university)) ::: If someone is a student and studies, then the person attends the university"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Attends(x, y) ::: x attends y",
            "University(x) ::: x is a university",
            "Intelligent(x) ::: x is intelligent",
            "Study(x, y) ::: x studies y"
        ]
    },
    {
        "premises-NL": [
            "All people are members of a club if they attend the meetings.",
            "John is a person.",
            "The Hiking Club is a club.",
            "John is a member of the Hiking Club.",
            "The Hiking Club has meetings.",
            "If a club has meetings, then all its members attend those meetings.",
            "If a person is a member, then they are eligible to attend meetings.",
            "Anyone can be a member of any club if they meet the criteria.",
            "If a club has meeting and a person is a member of the club then that person attends the meeting.",
            "If someone is a person then that person is a member.",
            "If someone is a member of a club then that club has a meeting."
        ],
        "premises-FOL": [
            "∀x ∀y (AttendsMeeting(x, y) ∧ Club(y) → MemberOf(x, y)) ::: All people are members of a club if they attend the meetings.",
            "Person(john) ::: John is a person.",
            "Club(hiking_club) ::: The Hiking Club is a club.",
            "MemberOf(john, hiking_club) ::: John is a member of the Hiking Club.",
            "ClubHasMeetings(hiking_club) ::: The Hiking Club has meetings.",
            "∀x ∀y (ClubHasMeetings(x) ∧ MemberOf(y, x) → AttendsMeeting(y, x)) ::: If a club has meetings, then all its members attend those meetings.",
            "∀x ∀y (MemberOf(x, y) → EligibleForMeeting(x, y)) ::: If a person is a member, then they are eligible to attend meetings.",
            "∀x ∀y (MeetsCriteria(x, y) → MemberOf(x, y)) ::: Anyone can be a member of any club if they meet the criteria.",
            "∀x ∀y (ClubHasMeetings(y) ∧ MemberOf(x, y) → AttendsMeeting(x, y)) ::: If a club has meeting and a person is a member of the club then that person attends the meeting.",
            "∀x Person(x) → Member(x) ::: If someone is a person then that person is a member.",
            "∀x ∀y MemberOf(x, y) → ClubHasMeeting(y) ::: If someone is a member of a club then that club has a meeting."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Club(x) ::: x is a club",
            "MemberOf(x, y) ::: x is a member of y",
            "ClubHasMeetings(x) ::: x has meetings",
            "AttendsMeeting(x, y) ::: x attends y",
            "Meeting(x) ::: x is a meeting"
        ]
    },
    {
        "premises-NL": [
            "David is a student.",
            "All students who study hard are likely to pass the exam.",
            "David studies hard.",
            "If a student is smart, they will pass the exam.",
            "David is smart.",
            "If someone studies hard and is smart, then they are likely to pass the exam."
        ],
        "premises-FOL": [
            "Student(david) ::: David is a student.",
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: All students who study hard are likely to pass the exam.",
            "StudiesHard(david) ::: David studies hard.",
            "∀x (Smart(x) → PassExam(x)) ::: If a student is smart, they will pass the exam.",
            "Smart(david) ::: David is smart.",
            "∀x (StudiesHard(x) ∧ Smart(x) → PassExam(x)) ::: If someone studies hard and is smart, then they are likely to pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesHard(x) ::: x studies hard.",
            "Smart(x) ::: x is smart.",
            "PassExam(x) ::: x will pass the exam."
        ]
    },
    {
        "premises-NL": [
            "Sarah is a member of the society.",
            "If someone has a presentation, they are a speaker.",
            "All speakers will attend the conference.",
            "Sarah has a presentation.",
            "If someone is a society member and a speaker, they will attend the conference.",
            "Being a society member and having a presentation is sufficient to be a speaker.",
            "If you are a member of the society and you have a presentation, then you are a speaker."
        ],
        "premises-FOL": [
            "SocietyMember(sarah) ::: Sarah is a member of the society.",
            "∀x (HasPresentation(x) → IsSpeaker(x)) ::: If someone has a presentation, they are a speaker.",
            "∀x (IsSpeaker(x) → AttendConference(x)) ::: All speakers will attend the conference.",
            "HasPresentation(sarah) ::: Sarah has a presentation.",
            "∀x (SocietyMember(x) ∧ IsSpeaker(x) → AttendConference(x)) ::: If someone is a society member and a speaker, they will attend the conference.",
            "∀x (SocietyMember(x) ∧ HasPresentation(x) → IsSpeaker(x)) ::: Being a society member and having a presentation is sufficient to be a speaker.",
            "∀x (SocietyMember(x) ∧ HasPresentation(x) → IsSpeaker(x)) ::: If you are a member of the society and you have a presentation, then you are a speaker."
        ],
        "predicates": [
            "SocietyMember(x) ::: x is a member of the society.",
            "HasPresentation(x) ::: x has a presentation.",
            "AttendConference(x) ::: x will attend the conference.",
            "IsSpeaker(x) ::: x is a speaker at the conference."
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "David is a student.",
            "All smart people study.",
            "If someone studies, they pass the exam.",
            "David studies.",
            "Therefore, if David is a student, then he studies."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "Student(david) ::: David is a student.",
            "∀x (Smart(x) → Studies(x)) ::: All smart people study.",
            "∀x (Studies(x) → PassesExam(x)) ::: If someone studies, they pass the exam.",
            "Studies(david) ::: David studies.",
            "Studies(david) → PassesExam(david) ::: If David studies, then he passes the exam.",
            "Student(david) → Smart(david) ::: If David is a student, then he is smart.",
            "Smart(david) → Studies(david) ::: If David is smart, then he studies.",
            "Student(david) ∨ ¬ Student(david) ::: Either David is a student, or he is not a student.",
            "¬Student(david) ∨ Studies(david) ::: Either David is not a student, or he studies.",
            "Student(david) ∧ Studies(david) ∨ ¬Student(david) ∧ ¬Studies(david) ::: Either David is a student and studies or he is not a student and does not study.",
            "Student(david) ∧ Smart(david) ∧ Studies(david) ∧ PassesExam(david) ::: David is a student, is smart, studies, and passes the exam.",
            "Student(david) ∨ Smart(david) ∨ Studies(david) ∨ PassesExam(david) ::: David is a student, is smart, studies, or passes the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Smart(x) ::: x is smart",
            "Studies(x) ::: x studies",
            "PassesExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "All employees either work hard or are happy.",
            "Some employees work hard.",
            "All employees with good performance receive a bonus.",
            "If an employee works hard and has good performance, then they are happy.",
            "Some employees do not have good performance.",
            "All employees are either happy or not happy."
        ],
        "premises-FOL": [
            "∀x (Employee(x) → (WorksHard(x) ∨ Happy(x))) ::: All employees either work hard or are happy.",
            "∃x (Employee(x) ∧ WorksHard(x)) ::: Some employees work hard.",
            "∀x (Employee(x) ∧ GoodPerformance(x) → ReceivesBonus(x)) ::: All employees with good performance receive a bonus.",
            "∀x ((WorksHard(x) ∧ GoodPerformance(x)) → Happy(x)) ::: If an employee works hard and has good performance, then they are happy.",
            "∃x (Employee(x) ∧ ¬GoodPerformance(x)) ::: Some employees do not have good performance.",
            "∀x (Employee(x) → (Happy(x) ∨ ¬Happy(x))) ::: All employees are either happy or not happy."
        ],
        "predicates": [
            "Employee(x) ::: x is an employee",
            "Happy(x) ::: x is happy",
            "ReceivesBonus(x) ::: x receives a bonus",
            "WorksHard(x) ::: x works hard",
            "GoodPerformance(x) ::: x has good performance"
        ]
    },
    {
        "premises-NL": [
            "All books are either borrowed or available.",
            "Some books are published by the university press.",
            "The university press only publishes available books.",
            "If a book is borrowed, then it is not available.",
            "All books are either a book or not a book.",
            "Some students borrow all the books.",
            "No professors borrow any books."
        ],
        "premises-FOL": [
            "∀x (Book(x) → (Borrowed(x) ∨ Available(x))) ::: All books are either borrowed or available.",
            "∃x ∃y (Book(x) ∧ Published(x, y) ∧ UniversityPress(y)) ::: Some books are published by the university press.",
            "∀x ∀y (Published(x, y) ∧ UniversityPress(y) → Available(x)) ::: The university press only publishes available books.",
            "∀x (Borrowed(x) → ¬Available(x)) ::: If a book is borrowed, then it is not available.",
            "∀x (Book(x) ∨ ¬Book(x)) ::: All books are either a book or not a book.",
            "∃x ∀y (Student(x) → Borrowed(y)) ::: Some students borrow all the books.",
            "∀x ∀y (Professor(x) → ¬Borrowed(y)) ::: No professors borrow any books."
        ],
        "predicates": [
            "Book(x) ::: x is a book",
            "Borrowed(x) ::: x is borrowed",
            "Available(x) ::: x is available",
            "Published(x, y) ::: x is published by y",
            "Student(x) ::: x is a student",
            "Professor(x) ::: x is a professor"
        ]
    },
    {
        "premises-NL": [
            "All artists like art.",
            "All musicians like music.",
            "All students like either art or music.",
            "If someone is a student and an artist, they like art.",
            "If someone is a musician and a student, they like music.",
            "If someone likes art and music, they are neither a musician nor an artist.",
            "All artists like music or math.",
            "All musicians like art or math.",
            "Someone is a student and an artist and a musician."
        ],
        "premises-FOL": [
            "∀x (Artist(x) → Likes(x, art)) ::: All artists like art.",
            "∀x (Musician(x) → Likes(x, music)) ::: All musicians like music.",
            "∀x (Student(x) → (Likes(x, art) ∨ Likes(x, music))) ::: All students like either art or music.",
            "∀x (IsStudentAndArtist(x) → Likes(x, art)) ::: If someone is a student and an artist, they like art.",
            "∀x (IsMusicianAndStudent(x) → Likes(x, music)) ::: If someone is a musician and a student, they like music.",
            "∀x ((Likes(x, art) ∧ Likes(x, music)) → (¬Musician(x) ∧ ¬Artist(x))) ::: If someone likes art and music, they are neither a musician nor an artist.",
            "∀x (Artist(x) → (Likes(x, music) ∨ Likes(x, math))) ::: All artists like music or math.",
            "∀x (Musician(x) → (Likes(x, art) ∨ Likes(x, math))) ::: All musicians like art or math.",
            "∃x (Student(x) ∧ Artist(x) ∧ Musician(x)) ::: Someone is a student and an artist and a musician."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Artist(x) ::: x is an artist",
            "Musician(x) ::: x is a musician",
            "Student(x) ::: x is a student",
            "LikesArt(x) ::: x likes art",
            "LikesMusic(x) ::: x likes music",
            "LikesMath(x) ::: x likes math",
            "IsStudentAndArtist(x) ::: x is a student and artist",
            "IsMusicianAndStudent(x) ::: x is a musician and student"
        ]
    },
    {
        "premises-NL": [
            "All viral diseases are spreadable.",
            "All bacterial diseases are treatable or fatal.",
            "If something is a disease and spreadable, then it's in a human.",
            "If a disease is in a human, then it causes illness or death.",
            "All diseases are treatable or causes symptoms.",
            "If a disease is fatal, it is severe.",
            "If a disease is viral, then it affects a specific organ.",
            "If a disease is bacterial and not curable, then it is fatal.",
            "Some diseases are viral and not bacterial.",
            "If a disease is viral, then it causes illness or death.",
            "If a disease causes death, it is severe.",
            "If a disease is chronic, then it has symptoms.",
            "Every disease is a disease.",
            "If something is a disease and curable, then it's not chronic.",
            "Some diseases affect humans and organs.",
            "If a disease causes illness, it is treatable."
        ],
        "premises-FOL": [
            "∀x (IsViral(x) → Spreadable(x)) ::: All viral diseases are spreadable.",
            "∀x (IsBacterial(x) → (Treatable(x) ∨ Fatal(x))) ::: All bacterial diseases are treatable or fatal.",
            "∀x (Disease(x) ∧ Spreadable(x) → InHuman(x)) ::: If something is a disease and spreadable, then it's in a human.",
            "∀x (InHuman(x) → (CausesIllness(x) ∨ CausesDeath(x))) ::: If a disease is in a human, then it causes illness or death.",
            "∀x (Disease(x) → (Treatable(x) ∨ CausesSymptoms(x))) ::: All diseases are treatable or causes symptoms.",
            "∀x (Fatal(x) → Severe(x)) ::: If a disease is fatal, it is severe.",
            "∀x (IsViral(x) → AffectsOrgan(x, some_organ)) ::: If a disease is viral, then it affects a specific organ.",
            "∀x (IsBacterial(x) ∧ ¬Curable(x) → Fatal(x)) ::: If a disease is bacterial and not curable, then it is fatal.",
            "∃x (IsViral(x) ∧ ¬IsBacterial(x)) ::: Some diseases are viral and not bacterial.",
            "∀x (IsViral(x) → (CausesIllness(x) ∨ CausesDeath(x))) ::: If a disease is viral, then it causes illness or death.",
            "∀x (CausesDeath(x) → Severe(x)) ::: If a disease causes death, it is severe.",
            "∀x (IsChronic(x) → HasSymptoms(x)) ::: If a disease is chronic, then it has symptoms.",
            "∀x (Disease(x) → Disease(x)) ::: Every disease is a disease.",
            "∀x (Disease(x) ∧ Curable(x) → ¬IsChronic(x)) ::: If something is a disease and curable, then it's not chronic.",
            "∃x ∃y (Disease(x) ∧ Affects(x, y) ∧ InHuman(x)) ::: Some diseases affect humans and organs.",
            "∀x (CausesIllness(x) → Treatable(x)) ::: If a disease causes illness, it is treatable."
        ],
        "predicates": [
            "Disease(x) ::: x is a disease",
            "Treatable(x) ::: x is treatable",
            "CausesIllness(x) ::: x causes illness",
            "CausesDeath(x) ::: x causes death",
            "IsViral(x) ::: x is viral",
            "IsBacterial(x) ::: x is bacterial",
            "Affects(x, y) ::: x affects y",
            "InHuman(x) ::: x is in a human",
            "Curable(x) ::: x is curable",
            "Severe(x) ::: x is severe",
            "Spreadable(x) ::: x is spreadable",
            "CausesSymptoms(x, y) ::: x causes symptoms y",
            "HasSymptoms(x) ::: x has symptoms",
            "AffectsOrgan(x, y) ::: x affects organ y",
            "Fatal(x) ::: x is fatal",
            "IsChronic(x) ::: x is chronic"
        ]
    },
    {
        "premises-NL": [
            "All members of the economics club attend economics meetings.",
            "All who attend economics meetings are students or professors.",
            "No professor is a member of the debate club.",
            "All professors give lectures.",
            "Anyone who gives lectures teaches economics.",
            "Everyone who teaches economics is a professor or a TA.",
            "All TAs advise students.",
            "All who advise students are students.",
            "Anyone who studies economics is interested in finance.",
            "All members of the economics club are interested in finance.",
            "All members of the debate club enjoy debate.",
            "Professors and TAs have office hours.",
            "No professor is a student.",
            "All who teaches economics has published a paper.",
            "Someone studies economics and advises student.",
            "Graduate students study economics.",
            "No TA is a member of the economics club."
        ],
        "premises-FOL": [
            "∀x (MemberOfEconomicsClub(x) → AttendsEconomicsMeetings(x)) ::: All members of the economics club attend economics meetings.",
            "∀x (AttendsEconomicsMeetings(x) → (Student(x) ∨ Professor(x))) ::: All who attend economics meetings are students or professors.",
            "∀x (Professor(x) → ¬MemberOfDebateClub(x)) ::: No professor is a member of the debate club.",
            "∀x (Professor(x) → GivesLectures(x)) ::: All professors give lectures.",
            "∀x (GivesLectures(x) → TeachesEconomics(x)) ::: Anyone who gives lectures teaches economics.",
            "∀x (TeachesEconomics(x) → (Professor(x) ∨ TA(x))) ::: Everyone who teaches economics is a professor or a TA.",
            "∀x (TA(x) → AdvisesStudents(x, some_student)) ::: All TAs advise students.",
            "∀x ∀y (AdvisesStudents(x, y) → Student(y)) ::: All who advise students are students.",
            "∀x (StudiesEconomics(x) → IsInterestedInFinance(x)) ::: Anyone who studies economics is interested in finance.",
            "∀x (MemberOfEconomicsClub(x) → IsInterestedInFinance(x)) ::: All members of the economics club are interested in finance.",
            "∀x (MemberOfDebateClub(x) → EnjoysDebate(x)) ::: All members of the debate club enjoy debate.",
            "∀x (Professor(x) ∨ TA(x) → HasOfficeHours(x)) ::: Professors and TAs have office hours.",
            "∀x (Professor(x) → ¬Student(x)) ::: No professor is a student.",
            "∀x (TeachesEconomics(x) → HasPublishedPaper(x)) ::: All who teaches economics has published a paper.",
            "∃x ∃y (StudiesEconomics(x) ∧ AdvisesStudents(x, y)) ::: Someone studies economics and advises student.",
            "∀x (GradStudent(x) → StudiesEconomics(x)) ::: Graduate students study economics.",
            "∀x (TA(x) → ¬MemberOfEconomicsClub(x)) ::: No TA is a member of the economics club."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Professor(x) ::: x is a professor",
            "TA(x) ::: x is a teaching assistant",
            "MemberOfEconomicsClub(x) ::: x is a member of the economics club",
            "MemberOfDebateClub(x) ::: x is a member of the debate club",
            "AttendsEconomicsMeetings(x) ::: x attends economics meetings",
            "GivesLectures(x) ::: x gives lectures",
            "AdvisesStudents(x, y) ::: x advises student y",
            "StudiesEconomics(x) ::: x studies economics",
            "HasOfficeHours(x) ::: x has office hours",
            "EnjoysDebate(x) ::: x enjoys debate",
            "IsInterestedInFinance(x) ::: x is interested in finance",
            "HasPublishedPaper(x) ::: x has published a paper",
            "TeachesEconomics(x) ::: x teaches economics",
            "HasAdvised(x, y) ::: x has advised y",
            "IsResearcher(x) ::: x is a researcher",
            "GradStudent(x) ::: x is a graduate student"
        ]
    },
    {
        "premises-NL": [
            "All scientists study at least one of biology, physics, or chemistry.",
            "All biologists study biology.",
            "All physicists study physics.",
            "All chemists study chemistry.",
            "If someone studies biology and physics, then they are a scientist.",
            "Anyone who works at a university publishes papers or conducts experiments.",
            "All biologists specialize in genetics or studies biochemistry.",
            "Anyone who studies biology uses a microscope or studies ecology.",
            "All physicists know thermodynamics and quantum mechanics.",
            "Scientists either specialize in genetics or study biochemistry.",
            "If someone studies astronomy, then they're not a biologist or a physicist.",
            "If someone studies physics and biology, then they collaborate.",
            "Anyone who studies physics and chemistry writes grants.",
            "All who write grants is a scientist.",
            "All those who collaborate with biologist are a scientist.",
            "Anyone who conducts experiment are scientist.",
            "All scientists works at a university and publish papers.",
            "All chemist studies chemistry and biochemistry.",
            "All physicists also study astrophysics."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → (StudiesBiology(x) ∨ StudiesPhysics(x) ∨ StudiesChemistry(x))) ::: All scientists study at least one of biology, physics, or chemistry.",
            "∀x (Biologist(x) → StudiesBiology(x)) ::: All biologists study biology.",
            "∀x (Physicist(x) → StudiesPhysics(x)) ::: All physicists study physics.",
            "∀x (Chemist(x) → StudiesChemistry(x)) ::: All chemists study chemistry.",
            "∀x ((StudiesBiology(x) ∧ StudiesPhysics(x)) → Scientist(x)) ::: If someone studies biology and physics, then they are a scientist.",
            "∀x (WorksAtUniversity(x) → (PublishesPapers(x) ∨ ConductsExperiments(x))) ::: Anyone who works at a university publishes papers or conducts experiments.",
            "∀x (Biologist(x) → (SpecializesInGenetics(x) ∨ StudiesBiochemistry(x))) ::: All biologists specialize in genetics or studies biochemistry.",
            "∀x (StudiesBiology(x) → (UsesMicroscope(x) ∨ StudiesEcology(x))) ::: Anyone who studies biology uses a microscope or studies ecology.",
            "∀x (Physicist(x) → (KnowsThermodynamics(x) ∧ KnowsQuantumMechanics(x))) ::: All physicists know thermodynamics and quantum mechanics.",
            "∀x (Scientist(x) → (SpecializesInGenetics(x) ∨ StudiesBiochemistry(x))) ::: Scientists either specialize in genetics or study biochemistry.",
            "∀x (StudiesAstronomy(x) → (¬Biologist(x) ∧ ¬Physicist(x))) ::: If someone studies astronomy, then they're not a biologist or a physicist.",
            "∀x ∀y ((StudiesPhysics(x) ∧ StudiesBiology(x)) → CollaboratesWith(x, y)) ::: If someone studies physics and biology, then they collaborate.",
            "∀x (StudiesPhysics(x) ∧ StudiesChemistry(x) → WritesGrants(x)) ::: Anyone who studies physics and chemistry writes grants.",
            "∀x (WritesGrants(x) → Scientist(x)) ::: All who write grants is a scientist.",
            "∀x ∀y (CollaboratesWith(x, y) → Scientist(x)) ::: All those who collaborate with biologist are a scientist.",
            "∀x (ConductsExperiments(x) → Scientist(x)) ::: Anyone who conducts experiment are scientist.",
            "∀x (Scientist(x) → (WorksAtUniversity(x) ∧ PublishesPapers(x))) ::: All scientists works at a university and publish papers.",
            "∀x (Chemist(x) → (StudiesChemistry(x) ∧ StudiesBiochemistry(x))) ::: All chemist studies chemistry and biochemistry.",
            "∀x (Physicist(x) → StudiesAstronomy(x)) ::: All physicists also study astrophysics."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "StudiesBiology(x) ::: x studies biology",
            "StudiesPhysics(x) ::: x studies physics",
            "StudiesChemistry(x) ::: x studies chemistry",
            "Biologist(x) ::: x is a biologist",
            "Physicist(x) ::: x is a physicist",
            "Chemist(x) ::: x is a chemist",
            "WorksAtUniversity(x) ::: x works at a university",
            "PublishesPapers(x) ::: x publishes papers",
            "ConductsExperiments(x) ::: x conducts experiments",
            "SpecializesInGenetics(x) ::: x specializes in genetics",
            "UsesMicroscope(x) ::: x uses a microscope",
            "StudiesAstronomy(x) ::: x studies astronomy",
            "StudiesEcology(x) ::: x studies ecology",
            "KnowsThermodynamics(x) ::: x knows thermodynamics",
            "KnowsQuantumMechanics(x) ::: x knows quantum mechanics",
            "StudiesBiochemistry(x) ::: x studies biochemistry",
            "CollaboratesWith(x, y) ::: x collaborates with y",
            "WritesGrants(x) ::: x writes grants"
        ]
    },
    {
        "premises-NL": [
            "All professors are researchers.",
            "Some professors teach smart students.",
            "All smart students are enrolled in interesting courses.",
            "Anyone who teaches a course is a professor.",
            "All smart students like reading books.",
            "All books are written by authors.",
            "Anyone who is an author has published a paper.",
            "Any book that is interesting is famous.",
            "All famous authors have a PhD.",
            "Some professors are famous.",
            "All researchers are professors.",
            "Some students are smart.",
            "Some courses are interesting.",
            "Some courses are taught by professors."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Researcher(x)) ::: All professors are researchers.",
            "∃x ∃y (Professor(x) ∧ Teaches(x, y) ∧ Smart(y)) ::: Some professors teach smart students.",
            "∀x ∃y (Smart(x) → Enrolled(x, y) ∧ Course(y) ∧ Interesting(y)) ::: All smart students are enrolled in interesting courses.",
            "∀x ∀y (Teaches(x, y) → Professor(x)) ::: Anyone who teaches a course is a professor.",
            "∀x ∃y (Smart(x) → Reads(x, y) ∧ Book(y)) ::: All smart students like reading books.",
            "∀x ∃y (Book(y) → Author(x, y)) ::: All books are written by authors.",
            "∀x ∃y (Author(x, y) → Published(x)) ::: Anyone who is an author has published a paper.",
            "∀y (Interesting(y) → Famous(x)) ::: Any book that is interesting is famous.",
            "∀x (Famous(x) → HasPhD(x)) ::: All famous authors have a PhD.",
            "∃x (Professor(x) ∧ Famous(x)) ::: Some professors are famous.",
            "∀x (Researcher(x) → Professor(x)) ::: All researchers are professors.",
            "∃x (Student(x) ∧ Smart(x)) ::: Some students are smart.",
            "∃y (Course(y) ∧ Interesting(y)) ::: Some courses are interesting.",
            "∃x ∃y (Professor(x) ∧ Teaches(x, y) ∧ Course(y)) ::: Some courses are taught by professors."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "Published(x) ::: x has published a paper",
            "HasPhD(x) ::: x has a PhD",
            "Teaches(x, y) ::: x teaches y",
            "Student(x) ::: x is a student",
            "Smart(x) ::: x is smart",
            "Enrolled(x, y) ::: x is enrolled in y",
            "Course(y) ::: y is a course",
            "Likes(x, y) ::: x likes y",
            "Book(y) ::: y is a book",
            "Reads(x, y) ::: x reads y",
            "Author(x, y) ::: x is the author of y",
            "Interesting(y) ::: y is interesting",
            "Famous(x) ::: x is famous"
        ]
    },
    {
        "premises-NL": [
            "Every student is either smart or studies hard.",
            "All smart students pass the exam.",
            "John is a student.",
            "John is not smart.",
            "If John studies hard, then John passes the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Smart(x) ∨ StudiesHard(x))) ::: Every student is either smart or studies hard.",
            "∀x (Smart(x) → PassesExam(x)) ::: All smart students pass the exam.",
            "Student(john) ::: John is a student.",
            "¬Smart(john) ::: John is not smart.",
            "StudiesHard(john) → PassesExam(john) ::: If John studies hard, then John passes the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassesExam(x) ::: x passes the exam",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All members of the club attend meetings.",
            "Everyone who attends meetings knows the president.",
            "If someone knows the president, they either like the president or are unhappy.",
            "No one is unhappy and happy at the same time.",
            "John is a member of the club.",
            "John is happy.",
            "The president is Mary."
        ],
        "premises-FOL": [
            "∀x (MemberOfClub(x) → AttendsMeetings(x)) ::: All members of the club attend meetings.",
            "∀x (AttendsMeetings(x) → KnowsPresident(x)) ::: Everyone who attends meetings knows the president.",
            "∀x (KnowsPresident(x) → (LikesPresident(x) ∨ ¬Happy(x))) ::: If someone knows the president, they either like the president or are unhappy.",
            "¬∃x (Happy(x) ∧ ¬Happy(x)) ::: No one is unhappy and happy at the same time.",
            "MemberOfClub(john) ::: John is a member of the club.",
            "Happy(john) ::: John is happy.",
            "President(mary) ::: The president is Mary."
        ],
        "predicates": [
            "MemberOfClub(x) ::: x is a member of the club",
            "LikesPresident(x) ::: x likes the president",
            "Happy(x) ::: x is happy",
            "AttendsMeetings(x) ::: x attends meetings",
            "KnowsPresident(x) ::: x knows the president",
            "President(x) ::: x is the president"
        ]
    },
    {
        "premises-NL": [
            "All programmers have programming skills.",
            "All designers have design skills.",
            "If a person has programming skills and design skills, then they are both a programmer and a designer.",
            "If a person works on a project, they are employed.",
            "If a person likes a project and works on that project, then they are happy.",
            "John has programming skills.",
            "John has design skills.",
            "John likes the new software project.",
            "John works on the new software project."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → HasSkill(x, programming)) ::: All programmers have programming skills.",
            "∀x (Designer(x) → HasSkill(x, design)) ::: All designers have design skills.",
            "∀x (HasSkill(x, programming) ∧ HasSkill(x, design) → (Programmer(x) ∧ Designer(x))) ::: If a person has programming skills and design skills, then they are both a programmer and a designer.",
            "∀x ∀y (WorksOn(x, y) → Employed(x)) ::: If a person works on a project, they are employed.",
            "∀x ∀y (LikesProject(x, y) ∧ WorksOn(x, y) → Happy(x)) ::: If a person likes a project and works on that project, then they are happy.",
            "HasSkill(john, programming) ::: John has programming skills.",
            "HasSkill(john, design) ::: John has design skills.",
            "LikesProject(john, new_software) ::: John likes the new software project.",
            "WorksOn(john, new_software) ::: John works on the new software project."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Programmer(x) ::: x is a programmer",
            "Designer(x) ::: x is a designer",
            "Employed(x) ::: x is employed",
            "Productive(x) ::: x is productive",
            "HasSkill(x, y) ::: x has skill y",
            "LikesProject(x, y) ::: x likes project y",
            "WorksOn(x, y) ::: x works on y",
            "Manages(x, y) ::: x manages y"
        ]
    },
    {
        "premises-NL": [
            "All students are either studying or working.",
            "Alice is a student.",
            "Bob is a student.",
            "Bob is working or studying.",
            "If someone is working, they are not studying.",
            "Carol is studying.",
            "If Carol is studying then she is not working",
            "Alice does not work.",
            "If Bob is studying, then Carol works",
            "If Carol is working, then Bob is studying."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Studying(x) ∨ Working(x))) ::: All students are either studying or working",
            "Student(alice) ::: Alice is a student",
            "Student(bob) ::: Bob is a student",
            "Studying(bob) ∨ Working(bob) ::: Bob is working or studying",
            "∀x (Working(x) → ¬Studying(x)) ::: If someone is working, they are not studying",
            "Studying(carol) ::: Carol is studying",
            "Studying(carol) → ¬Working(carol) ::: If Carol is studying then she is not working",
            "¬Working(alice) ::: Alice does not work",
            "Studying(bob) → Working(carol) ::: If Bob is studying, then Carol works",
            "Working(carol) → Studying(bob) ::: If Carol is working, then Bob is studying"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studying(x) ::: x is studying",
            "Working(x) ::: x is working"
        ]
    },
    {
        "premises-NL": [
            "John is a doctor.",
            "Mary is a nurse.",
            "Doctors and nurses are healthcare workers.",
            "All healthcare workers help patients.",
            "John is a man",
            "Mary is a woman",
            "If someone is a patient, they need help.",
            "If someone helps patients, they are a healthcare worker.",
            "Bob is a patient",
            "If Bob is a patient then John helps him",
            "If John helps Bob, then John is a healthcare worker."
        ],
        "premises-FOL": [
            "Doctor(john) ::: John is a doctor",
            "Nurse(mary) ::: Mary is a nurse",
            "∀x (Doctor(x) ∨ Nurse(x) → HealthcareWorker(x)) ::: Doctors and nurses are healthcare workers",
            "∀x (HealthcareWorker(x) → HelpsPatient(x)) ::: All healthcare workers help patients",
            "Man(john) ::: John is a man",
            "Woman(mary) ::: Mary is a woman",
            "∀x (Patient(x) → NeedsHelp(x)) ::: If someone is a patient, they need help",
            "∀x (HelpsPatient(x) → HealthcareWorker(x)) ::: If someone helps patients, they are a healthcare worker",
            "Patient(bob) ::: Bob is a patient",
            "Patient(bob) → HelpsPatient(john) ::: If Bob is a patient then John helps him",
            "HelpsPatient(john) → HealthcareWorker(john) ::: If John helps Bob, then John is a healthcare worker"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Nurse(x) ::: x is a nurse",
            "HealthcareWorker(x) ::: x is a healthcare worker",
            "Patient(x) ::: x is a patient"
        ]
    },
    {
        "premises-NL": [
            "If it is sunny and warm, people are outside.",
            "If people are outside, they are happy.",
            "It is sunny and it is warm.",
            "John is happy.",
            "Mary is outside.",
            "If Mary is outside, then she is happy.",
            "If it is sunny and not warm, then people are sad.",
            "If people are sad, then they are not happy.",
            "It is not sunny.",
            "If something is not sunny, then it is warm.",
            "If something is warm, then it is sunny",
            "If something is happy, then it is warm."
        ],
        "premises-FOL": [
            "∀x ((Sunny(x) ∧ Warm(x)) → Outside(x)) ::: If it is sunny and warm, people are outside",
            "∀x (Outside(x) → Happy(x)) ::: If people are outside, they are happy",
            "Sunny(today) ∧ Warm(today) ::: It is sunny and it is warm",
            "Happy(john) ::: John is happy",
            "Outside(mary) ::: Mary is outside",
            "Outside(mary) → Happy(mary) ::: If Mary is outside, then she is happy",
            "∀x ((Sunny(x) ∧ ¬Warm(x)) → Sad(x)) ::: If it is sunny and not warm, then people are sad",
            "∀x (Sad(x) → ¬Happy(x)) ::: If people are sad, then they are not happy",
            "¬Sunny(today) ::: It is not sunny",
            "∀x (¬Sunny(x) → Warm(x)) ::: If something is not sunny, then it is warm",
            "∀x (Warm(x) → Sunny(x)) ::: If something is warm, then it is sunny",
            "∀x (Happy(x) → Warm(x)) ::: If something is happy, then it is warm"
        ],
        "predicates": [
            "Sunny(x) ::: x is sunny",
            "Warm(x) ::: x is warm",
            "Happy(x) ::: x is happy",
            "Outside(x) ::: x is outside"
        ]
    },
    {
        "premises-NL": [
            "All cats are animals.",
            "All cats are mammals.",
            "Every cat is a carnivore.",
            "All carnivores eat meat.",
            "Some cats are domesticated.",
            "All domesticated animals live in houses.",
            "Some cats live in houses.",
            "All cats are felix",
            "All felix hunt mice."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → Animal(x)) ::: All cats are animals.",
            "∀x (Cat(x) → Mammal(x)) ::: All cats are mammals.",
            "∀x (Cat(x) → Carnivore(x)) ::: Every cat is a carnivore.",
            "∀x (Carnivore(x) → EatsMeat(x)) ::: All carnivores eat meat.",
            "∃x (Cat(x) ∧ Domesticated(x)) ::: Some cats are domesticated.",
            "∀x (Domesticated(x) → LivesInHouse(x)) ::: All domesticated animals live in houses.",
            "∃x (Cat(x) ∧ LivesInHouse(x)) ::: Some cats live in houses.",
            "∀x (Cat(x) → Felis(x)) ::: All cats are felix",
            "∀x (Felis(x) → HuntsMice(x)) ::: All felix hunt mice."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Mammal(x) ::: x is a mammal",
            "Animal(x) ::: x is an animal",
            "Carnivore(x) ::: x is a carnivore",
            "EatsMeat(x) ::: x eats meat",
            "Domesticated(x) ::: x is domesticated",
            "LivesInHouse(x) ::: x lives in a house",
            "Felis(x) ::: x is a felix",
            "HuntsMice(x) ::: x hunts mice"
        ]
    },
    {
        "premises-NL": [
            "If someone is a resident of a city, they often have access to public transportation.",
            "If someone uses public transportation frequently, they likely reduce their carbon footprint.",
            "Anyone who drives a car pollutes.",
            "People in green cities are more likely to breathe fresh air.",
            "Anyone who uses public transportation is green.",
            "If someone reduces their carbon footprint, then they help protect the environment.",
            "John is a resident of a city and uses public transport frequently.",
            "Having a bike, and using public transit means someone is green.",
            "If someone uses public transit, they do not drive their car.",
            "If a person parks their car in the city, they pollute."
        ],
        "premises-FOL": [
            "∀x (ResidentOfCity(x) → HasPublicTransport(x)) ::: If someone is a resident of a city, they often have access to public transportation.",
            "∀x (UsesFrequently(x) → ReduceCarbonFootprint(x)) ::: If someone uses public transportation frequently, they likely reduce their carbon footprint.",
            "∀x (DrivesCar(x) → Pollutes(x)) ::: Anyone who drives a car pollutes.",
            "∀x (City(x) → BreatheFreshAir(x)) ::: People in green cities are more likely to breathe fresh air.",
            "∀x (UsesPublicTransport(x) → IsGreen(x)) ::: Anyone who uses public transportation is green.",
            "∀x (ReduceCarbonFootprint(x) → ProtectsEnvironment(x)) ::: If someone reduces their carbon footprint, then they help protect the environment.",
            "ResidentOfCity(john) ∧ UsesFrequently(john) ::: John is a resident of a city and uses public transport frequently.",
            "∀x ((HasBike(x) ∧ UsesPublicTransport(x)) → IsGreen(x)) ::: Having a bike, and using public transit means someone is green.",
            "∀x (UsesPublicTransport(x) → ¬DrivesCar(x)) ::: If someone uses public transit, they do not drive their car.",
            "∀x (ParksCar(x) → Pollutes(x)) ::: If a person parks their car in the city, they pollute."
        ],
        "predicates": [
            "ResidentOfCity(x) ::: x is a resident of a city",
            "HasPublicTransport(x) ::: x has access to public transportation",
            "UsesFrequently(x) ::: x uses public transportation frequently",
            "ReduceCarbonFootprint(x) ::: x reduces their carbon footprint",
            "Pollutes(x) ::: x pollutes",
            "DrivesCar(x) ::: x drives a car",
            "IsGreen(x) ::: x is green",
            "City(x) ::: x is a city",
            "HasBike(x) ::: x has a bike",
            "ParksCar(x) ::: x parks a car",
            "BreatheFreshAir(x) ::: x breathes fresh air"
        ]
    },
    {
        "premises-NL": [
            "All mammals can give birth or they eat meat.",
            "All animals are either mammals or they do not have fur.",
            "No animal can give birth.",
            "All mammals have fur.",
            "All animals that eat meat are carnivores.",
            "All animals that live in a forest are mammals.",
            "Every animal that has fur lives in a forest.",
            "All carnivores eat meat.",
            "Every mammal feeds milk to its young.",
            "Dog is an animal.",
            "Every animal that has fur can give birth.",
            "All animals are either herbivores or carnivores.",
            "Some of the animals can give birth.",
            "Some animals are not herbivores or carnivores."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → CanGiveBirth(x) ∨ EatsMeat(x)) ::: All mammals can give birth or they eat meat.",
            "∀x (Animal(x) → Mammal(x) ∨ ¬HasFur(x)) ::: All animals are either mammals or they do not have fur.",
            "∀x (Animal(x) → ¬CanGiveBirth(x)) ::: No animal can give birth.",
            "∀x (Mammal(x) → HasFur(x)) ::: All mammals have fur.",
            "∀x (EatsMeat(x) → IsCarnivore(x)) ::: All animals that eat meat are carnivores.",
            "∀x (LivesInForest(x) → Mammal(x)) ::: All animals that live in a forest are mammals.",
            "∀x (HasFur(x) → LivesInForest(x)) ::: Every animal that has fur lives in a forest.",
            "∀x (IsCarnivore(x) → EatsMeat(x)) ::: All carnivores eat meat.",
            "∀x ∃y (Mammal(x) → FeedsMilk(x, y)) ::: Every mammal feeds milk to its young.",
            "Animal(dog) ::: Dog is an animal.",
            "∀x (HasFur(x) → CanGiveBirth(x)) ::: Every animal that has fur can give birth.",
            "∀x (Animal(x) → Herbivore(x) ∨ Carnivore(x)) ::: All animals are either herbivores or carnivores.",
            "∃x CanGiveBirth(x) ::: Some of the animals can give birth.",
            "∃x (¬Herbivore(x) ∧ ¬Carnivore(x)) ::: Some animals are not herbivores or carnivores."
        ],
        "predicates": [
            "Animal(x) ::: x is an animal",
            "Mammal(x) ::: x is a mammal",
            "CanGiveBirth(x) ::: x can give birth",
            "EatsMeat(x) ::: x eats meat",
            "HasFur(x) ::: x has fur",
            "LivesInForest(x) ::: x lives in forest",
            "IsCarnivore(x) ::: x is a carnivore",
            "FeedsMilk(x, y) ::: x feeds milk to y"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "Anyone who treats patients works at a hospital.",
            "Anyone who works at a hospital has a medical degree.",
            "Alice is a doctor.",
            "Bob treats patients.",
            "If Charlie is a doctor, then Charlie works at a hospital.",
            "Doctors work at hospitals.",
            "Every doctor has a medical degree.",
            "Doctors and only doctors treat patients.",
            "If someone is a doctor, then they treat patients.",
            "Those who work at a hospital have medical degree.",
            "If Dave has a medical degree, then he is a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → TreatsPatients(x)) ::: All doctors treat patients.",
            "∀x (TreatsPatients(x) → WorksAtHospital(x)) ::: Anyone who treats patients works at a hospital.",
            "∀x (WorksAtHospital(x) → HasDegree(x)) ::: Anyone who works at a hospital has a medical degree.",
            "Doctor(alice) ::: Alice is a doctor.",
            "TreatsPatients(bob) ::: Bob treats patients.",
            "Doctor(charlie) → WorksAtHospital(charlie) ::: If Charlie is a doctor, then Charlie works at a hospital.",
            "∀x (Doctor(x) → WorksAtHospital(x)) ::: Doctors work at hospitals.",
            "∀x (Doctor(x) → HasDegree(x)) ::: Every doctor has a medical degree.",
            "∀x (Doctor(x) ↔ TreatsPatients(x)) ::: Doctors and only doctors treat patients.",
            "∀x (Doctor(x) → TreatsPatients(x)) ::: If someone is a doctor, then they treat patients.",
            "∀x (WorksAtHospital(x) → HasDegree(x)) ::: Those who work at a hospital have medical degree.",
            "HasDegree(dave) → Doctor(dave) ::: If Dave has a medical degree, then he is a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "HasDegree(x) ::: x has a medical degree",
            "WorksAtHospital(x) ::: x works at a hospital",
            "TreatsPatients(x) ::: x treats patients"
        ]
    },
    {
        "premises-NL": [
            "All researchers attend conferences.",
            "Anyone who attends conferences publishes papers.",
            "If someone publishes papers, then they have funding.",
            "Alice is a researcher.",
            "Bob attends conferences.",
            "Charlie has funding if he publishes papers.",
            "Researchers attend conferences.",
            "Publishing papers implies having funding.",
            "Researchers both attend conferences and publish papers.",
            "If someone is a researcher, then they publish papers.",
            "Anyone who publishes papers is a researcher.",
            "If someone is a researcher, they work at a university.",
            "If Dave attends a conference, then he publishes papers."
        ],
        "premises-FOL": [
            "∀x (Researcher(x) → AttendsConference(x)) ::: All researchers attend conferences.",
            "∀x (AttendsConference(x) → PublishesPapers(x)) ::: Anyone who attends conferences publishes papers.",
            "∀x (PublishesPapers(x) → HasFunding(x)) ::: If someone publishes papers, then they have funding.",
            "Researcher(alice) ::: Alice is a researcher.",
            "AttendsConference(bob) ::: Bob attends conferences.",
            "PublishesPapers(charlie) → HasFunding(charlie) ::: Charlie has funding if he publishes papers.",
            "∀x (Researcher(x) → AttendsConference(x)) ::: Researchers attend conferences.",
            "∀x (PublishesPapers(x) → HasFunding(x)) ::: Publishing papers implies having funding.",
            "∀x (Researcher(x) ↔ (AttendsConference(x) ∧ PublishesPapers(x))) ::: Researchers both attend conferences and publish papers.",
            "∀x (Researcher(x) → PublishesPapers(x)) ::: If someone is a researcher, then they publish papers.",
            "∀x (PublishesPapers(x) → Researcher(x)) ::: Anyone who publishes papers is a researcher.",
            "∀x (Researcher(x) → WorksAtUniversity(x)) ::: If someone is a researcher, they work at a university.",
            "AttendsConference(dave) → PublishesPapers(dave) ::: If Dave attends a conference, then he publishes papers."
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher",
            "PublishesPapers(x) ::: x publishes papers",
            "AttendsConference(x) ::: x attends conferences",
            "HasFunding(x) ::: x has funding",
            "WorksAtUniversity(x) ::: x works at a university"
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled in a course.",
            "Anyone enrolled in a course takes a course.",
            "If someone takes a course, then they have a grade.",
            "Alice is a student.",
            "Bob is enrolled in course C101.",
            "If Charlie takes a course, then Charlie has a grade.",
            "Students take courses.",
            "Taking courses implies having a grade.",
            "Students are enrolled and take courses.",
            "If someone is a student, they take courses.",
            "Taking courses implies a student.",
            "If someone is a student, they are enrolled.",
            "If Dave is enrolled in a course, he takes a course.",
            "All professors are enrolled."
        ],
        "premises-FOL": [
            "∀x (Student(x) → EnrolledIn(x, y)) ::: All students are enrolled in a course.",
            "∀x (EnrolledIn(x, y) → TakesCourse(x)) ::: Anyone enrolled in a course takes a course.",
            "∀x (TakesCourse(x) → HasGrade(x, y)) ::: If someone takes a course, then they have a grade.",
            "Student(alice) ::: Alice is a student.",
            "EnrolledIn(bob, c101) ::: Bob is enrolled in course C101.",
            "TakesCourse(charlie) → HasGrade(charlie, y) ::: If Charlie takes a course, then Charlie has a grade.",
            "∀x (Student(x) → TakesCourse(x)) ::: Students take courses.",
            "∀x (TakesCourse(x) → HasGrade(x, y)) ::: Taking courses implies having a grade.",
            "∀x (Student(x) ↔ (EnrolledIn(x, y) ∧ TakesCourse(x))) ::: Students are enrolled and take courses.",
            "∀x (Student(x) → TakesCourse(x)) ::: If someone is a student, they take courses.",
            "∀x (TakesCourse(x) → Student(x)) ::: Taking courses implies a student.",
            "∀x (Student(x) → EnrolledIn(x, y)) ::: If someone is a student, they are enrolled.",
            "EnrolledIn(dave, y) → TakesCourse(dave) ::: If Dave is enrolled in a course, he takes a course.",
            "∀x (IsProfessor(x) → EnrolledIn(x, y)) ::: All professors are enrolled."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "TakesCourse(x) ::: x takes a course",
            "HasGrade(x, y) ::: x has a grade in y",
            "EnrolledIn(x, y) ::: x is enrolled in y",
            "IsProfessor(x) ::: x is a professor"
        ]
    },
    {
        "premises-NL": [
            "All politicians attend meetings.",
            "Anyone who attends meetings is involved in politics.",
            "If someone is involved in politics, then they give speeches.",
            "Alice is a politician.",
            "Bob attends the budget meeting.",
            "If Charlie is involved in politics, then Charlie gives speeches.",
            "Politicians are involved.",
            "Being involved implies giving speeches.",
            "Politicians both attend meetings and are involved.",
            "If someone is a politician, then they are involved in politics.",
            "If someone gives speeches, then they are involved.",
            "If someone is a politician, they attend meetings.",
            "If Dave attends meeting, he is involved.",
            "Anyone who supports a policy is involved.",
            "Anyone involved in politics supports a policy."
        ],
        "premises-FOL": [
            "∀x (Politician(x) → AttendsMeeting(x, y)) ::: All politicians attend meetings.",
            "∀x (AttendsMeeting(x, y) → InvolvedInPolitics(x)) ::: Anyone who attends meetings is involved in politics.",
            "∀x (InvolvedInPolitics(x) → GivesSpeech(x, y)) ::: If someone is involved in politics, then they give speeches.",
            "Politician(alice) ::: Alice is a politician.",
            "AttendsMeeting(bob, budget) ::: Bob attends the budget meeting.",
            "InvolvedInPolitics(charlie) → GivesSpeech(charlie, y) ::: If Charlie is involved in politics, then Charlie gives speeches.",
            "∀x (Politician(x) → InvolvedInPolitics(x)) ::: Politicians are involved.",
            "∀x (InvolvedInPolitics(x) → GivesSpeech(x, y)) ::: Being involved implies giving speeches.",
            "∀x (Politician(x) ↔ (AttendsMeeting(x, y) ∧ InvolvedInPolitics(x))) ::: Politicians both attend meetings and are involved.",
            "∀x (Politician(x) → InvolvedInPolitics(x)) ::: If someone is a politician, then they are involved in politics.",
            "∀x (GivesSpeech(x, y) → InvolvedInPolitics(x)) ::: If someone gives speeches, then they are involved.",
            "∀x (Politician(x) → AttendsMeeting(x, y)) ::: If someone is a politician, they attend meetings.",
            "AttendsMeeting(dave, y) → InvolvedInPolitics(dave) ::: If Dave attends meeting, he is involved.",
            "∀x (SupportsPolicy(x, y) → InvolvedInPolitics(x)) ::: Anyone who supports a policy is involved.",
            "∀x (InvolvedInPolitics(x) → SupportsPolicy(x, y)) ::: Anyone involved in politics supports a policy."
        ],
        "predicates": [
            "Politician(x) ::: x is a politician",
            "InvolvedInPolitics(x) ::: x is involved in politics",
            "AttendsMeeting(x, y) ::: x attends meeting y",
            "GivesSpeech(x, y) ::: x gives speech y",
            "SupportsPolicy(x, y) ::: x supports policy y"
        ]
    },
    {
        "premises-NL": [
            "All mammals live on land.",
            "Anyone who lives on land breathes air.",
            "If something breathes air, then it is a mammal.",
            "Alice is a mammal.",
            "Bob lives on land.",
            "If Charlie breathes air, then Charlie is a mammal.",
            "Mammals breathe air.",
            "Breathing air implies being a mammal.",
            "Mammals both live on land and breathe air.",
            "If something is a mammal, it breathes air.",
            "If something breathes air, then it lives on land.",
            "If something is a mammal, it has fur.",
            "If something lives on land, then it eats meat.",
            "All mammals have fur.",
            "If Dave lives on land and eats meat, then he is a mammal.",
            "If an animal breathes air and eats meat, it is a mammal."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → LivesOnLand(x)) ::: All mammals live on land.",
            "∀x (LivesOnLand(x) → BreathesAir(x)) ::: Anyone who lives on land breathes air.",
            "∀x (BreathesAir(x) → Mammal(x)) ::: If something breathes air, then it is a mammal.",
            "Mammal(alice) ::: Alice is a mammal.",
            "LivesOnLand(bob) ::: Bob lives on land.",
            "BreathesAir(charlie) → Mammal(charlie) ::: If Charlie breathes air, then Charlie is a mammal.",
            "∀x (Mammal(x) → BreathesAir(x)) ::: Mammals breathe air.",
            "∀x (BreathesAir(x) → Mammal(x)) ::: Breathing air implies being a mammal.",
            "∀x (Mammal(x) ↔ (LivesOnLand(x) ∧ BreathesAir(x))) ::: Mammals both live on land and breathe air.",
            "∀x (Mammal(x) → BreathesAir(x)) ::: If something is a mammal, it breathes air.",
            "∀x (BreathesAir(x) → LivesOnLand(x)) ::: If something breathes air, then it lives on land.",
            "∀x (Mammal(x) → HasFur(x)) ::: If something is a mammal, it has fur.",
            "∀x (LivesOnLand(x) → EatsMeat(x)) ::: If something lives on land, then it eats meat.",
            "∀x (Mammal(x) → HasFur(x)) ::: All mammals have fur.",
            "(LivesOnLand(dave) ∧ EatsMeat(dave)) → Mammal(dave) ::: If Dave lives on land and eats meat, then he is a mammal.",
            "(BreathesAir(x) ∧ EatsMeat(x)) → Mammal(x) ::: If an animal breathes air and eats meat, it is a mammal."
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal",
            "BreathesAir(x) ::: x breathes air",
            "LivesOnLand(x) ::: x lives on land",
            "EatsMeat(x) ::: x eats meat",
            "HasFur(x) ::: x has fur"
        ]
    },
    {
        "premises-NL": [
            "All students are intelligent if they study computer science.",
            "Some students study computer science.",
            "All intelligent students are members of Club1.",
            "All members of Club1 are students.",
            "All students that are in club1 studies computer science.",
            "A student is a member of Club1 if and only if they attend the specific class.",
            "All students that studies computer science attends a specific class.",
            "Professor teaches computer science.",
            "Professor teaches a specific class."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ Studies(x, ComputerScience) → Intelligent(x)) ::: All students are intelligent if they study computer science.",
            "∃x (Student(x) ∧ Studies(x, ComputerScience)) ::: Some students study computer science.",
            "∀x (Intelligent(x) → MemberOf(x, Club1)) ::: All intelligent students are members of Club1.",
            "∀x (MemberOf(x, Club1) → Student(x)) ::: All members of Club1 are students.",
            "∀x (MemberOf(x, Club1) → Studies(x, ComputerScience)) ::: All students that are in club1 studies computer science.",
            "∀x (MemberOf(x, Club1) ↔ Attends(x, Class1)) ::: A student is a member of Club1 if and only if they attend the specific class.",
            "∀x (Studies(x, ComputerScience) → Attends(x, Class1)) ::: All students that studies computer science attends a specific class.",
            "∃x ∃y (Professor(x) ∧ Teaches(x, ComputerScience)) ::: Professor teaches computer science.",
            "∃x ∃y (Professor(x) ∧ Teaches(x, Class1)) ::: Professor teaches a specific class."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x, y) ::: x studies y",
            "MemberOf(x, y) ::: x is a member of club y",
            "Intelligent(x) ::: x is intelligent",
            "Attends(x, y) ::: x attends class y",
            "Likes(x, y) ::: x likes y",
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches y",
            "Class(x) ::: x is a class",
            "Club(x) ::: x is a club"
        ]
    },
    {
        "premises-NL": [
            "All rich people are persons.",
            "Some rich people own a car.",
            "Some rich people own a house.",
            "If someone owns a car and a house, then that person is rich.",
            "David is a rich person.",
            "David owns a car."
        ],
        "premises-FOL": [
            "∀x (Rich(x) → Person(x)) ::: All rich people are persons.",
            "∃x ∃y (Rich(x) ∧ Owns(x, y) ∧ Car(y)) ::: Some rich people own a car.",
            "∃x ∃y (Rich(x) ∧ Owns(x, y) ∧ House(y)) ::: Some rich people own a house.",
            "∀x ∀y ∀z ((Owns(x, y) ∧ Owns(x, z) ∧ Car(y) ∧ House(z)) → Rich(x)) ::: If someone owns a car and a house, then that person is rich.",
            "Rich(david) ::: David is a rich person.",
            "Owns(david, car1) ∧ Car(car1) ::: David owns a car."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "Owns(x, y) ::: x owns y.",
            "Car(x) ::: x is a car.",
            "House(x) ::: x is a house.",
            "Rich(x) ::: x is rich."
        ]
    },
    {
        "premises-NL": [
            "All famous people are actors.",
            "Some actors perform in movies.",
            "Every movie that wins an award is famous.",
            "If someone is a director, then they are famous.",
            "The Godfather is a movie.",
            "The Godfather won an Oscar.",
            "Someone is a director.",
            "Every actor is famous."
        ],
        "premises-FOL": [
            "∀x (Famous(x) → Actor(x)) ::: All famous people are actors.",
            "∃x ∃y (Actor(x) ∧ PerformsIn(x, y) ∧ Movie(y)) ::: Some actors perform in movies.",
            "∀x ∀y (WinsAward(x, y) → Famous(x)) ::: Every movie that wins an award is famous.",
            "∀x (Director(x) → Famous(x)) ::: If someone is a director, then they are famous.",
            "Movie(godfather) ::: The Godfather is a movie.",
            "WinsAward(godfather, oscar) ∧ Award(oscar) ::: The Godfather won an Oscar.",
            "∃x Director(x) ::: Someone is a director.",
            "∀x (Actor(x) → Famous(x)) ::: Every actor is famous."
        ],
        "predicates": [
            "Actor(x) ::: x is an actor.",
            "PerformsIn(x, y) ::: x performs in movie y.",
            "Movie(x) ::: x is a movie.",
            "WinsAward(x, y) ::: movie x wins award y.",
            "Award(x) ::: x is an award.",
            "IsFamous(x) ::: x is famous.",
            "Directs(x, y) ::: x directs movie y.",
            "Director(x) ::: x is a director"
        ]
    },
    {
        "premises-NL": [
            "All members of a club are persons.",
            "Some persons are members of Club1.",
            "If someone is at a party, then they socialize.",
            "If someone is a member of a club, they are at a party.",
            "If someone socializes, then they enjoy socializing.",
            "Club1 is a club.",
            "Everyone who enjoys something, is at that something.",
            "Some people go to a party."
        ],
        "premises-FOL": [
            "∀x ∀y (MemberOf(x, y) → Person(x)) ::: All members of a club are persons.",
            "∃x MemberOf(x, club1) ::: Some persons are members of Club1.",
            "∀x (IsAtParty(x, y) → Socializes(x)) ::: If someone is at a party, then they socialize.",
            "∀x (MemberOf(x, y) → IsAtParty(x, y)) ::: If someone is a member of a club, they are at a party.",
            "∀x (Socializes(x) → EnjoysSocializing(x)) ::: If someone socializes, then they enjoy socializing.",
            "Club(club1) ::: Club1 is a club.",
            "∀x ∀y (Enjoys(x, y) → IsAt(x, y)) ::: Everyone who enjoys something, is at that something.",
            "∃x ∃y IsAtParty(x, y) ::: Some people go to a party."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "MemberOf(x, y) ::: x is a member of club y.",
            "Enjoys(x, y) ::: x enjoys y.",
            "Socializes(x) ::: x socializes.",
            "IsAt(x, y) ::: x is at location y.",
            "Club(x) ::: x is a club.",
            "Party(x) ::: x is a party.",
            "IsAtParty(x, y) ::: x is at party y.",
            "EnjoysSocializing(x) ::: x enjoys socializing"
        ]
    },
    {
        "premises-NL": [
            "If it is cloudy and it is a day, it is not shining.",
            "If it is cloudy then it is not warm.",
            "If it is raining, then it is not cloudy.",
            "If it is not cloudy, then it is shining.",
            "If the day is sunny, it is shining.",
            "If it is not warm it is cloudy.",
            "If it is day, the sun is shining.",
            "Everything is outside.",
            "If it is raining, then it is warm.",
            "If it is shining then it is day.",
            "If it is cloudy then it is outside.",
            "It is not cloudy if it is shining.",
            "The day is always sunny.",
            "If it is not day, the sun is not shining."
        ],
        "premises-FOL": [
            "∀x (Cloudy(x) ∧ Day(x) → ¬Shining(x)) ::: If it is cloudy and it is a day, it is not shining.",
            "∀x (Cloudy(x) → ¬Warm(x)) ::: If it is cloudy then it is not warm.",
            "∀x (Rainy(x) → ¬Cloudy(x)) ::: If it is raining, then it is not cloudy.",
            "∀x (¬Cloudy(x) → Shining(x)) ::: If it is not cloudy, then it is shining.",
            "∀x (Day(x) ∧ Shining(x)) ::: If the day is sunny, it is shining.",
            "∀x (¬Warm(x) → Cloudy(x)) ::: If it is not warm it is cloudy.",
            "∀x (Day(x) → Shining(x)) ::: If it is day, the sun is shining.",
            "∀x (Outside(x)) ::: Everything is outside.",
            "∀x (Rainy(x) → Warm(x)) ::: If it is raining, then it is warm.",
            "∀x (Shining(x) → Day(x)) ::: If it is shining then it is day.",
            "∀x (Cloudy(x) → Outside(x)) ::: If it is cloudy then it is outside.",
            "∀x (Shining(x) → ¬Cloudy(x)) ::: It is not cloudy if it is shining.",
            "∀x (Shining(x) → Day(x)) ::: The day is always sunny.",
            "∀x (¬Day(x) → ¬Shining(x)) ::: If it is not day, the sun is not shining."
        ],
        "predicates": [
            "Cloudy(x) ::: x is cloudy",
            "Shining(x) ::: x is shining",
            "Rainy(x) ::: x is rainy",
            "Warm(x) ::: x is warm",
            "Outside(x) ::: x is outside",
            "Day(x) ::: x is day"
        ]
    },
    {
        "premises-NL": [
            "All students attend class.",
            "Everyone who studies is smart.",
            "If someone is smart and attends class, they pass the exam.",
            "If someone is a teacher, they attend class.",
            "Some students are smart.",
            "If someone studies, they attend class.",
            "Smart students pass the exam.",
            "Some students do not study.",
            "Some people who attend class do not pass the exam.",
            "If someone is a student, they study.",
            "If someone is a teacher, they are smart.",
            "If someone is smart, they attend class.",
            "If someone is a student, they pass the exam.",
            "If someone studies, they pass the exam.",
            "No one attends class."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClass(x)) ::: All students attend class.",
            "∀x (Studies(x) → Smart(x)) ::: Everyone who studies is smart.",
            "∀x (Smart(x) ∧ AttendsClass(x) → PassExam(x)) ::: If someone is smart and attends class, they pass the exam.",
            "∀x (Teacher(x) → AttendsClass(x)) ::: If someone is a teacher, they attend class.",
            "∃x (Student(x) ∧ Smart(x)) ::: Some students are smart.",
            "∀x (Studies(x) → AttendsClass(x)) ::: If someone studies, they attend class.",
            "∀x (Smart(x) → PassExam(x)) ::: Smart students pass the exam.",
            "∃x (Student(x) ∧ ¬Studies(x)) ::: Some students do not study.",
            "∃x (AttendsClass(x) ∧ ¬PassExam(x)) ::: Some people who attend class do not pass the exam.",
            "∀x (Student(x) → Studies(x)) ::: If someone is a student, they study.",
            "∀x (Teacher(x) → Smart(x)) ::: If someone is a teacher, they are smart.",
            "∀x (Smart(x) → AttendsClass(x)) ::: If someone is smart, they attend class.",
            "∀x (Student(x) → PassExam(x)) ::: If someone is a student, they pass the exam.",
            "∀x (Studies(x) → PassExam(x)) ::: If someone studies, they pass the exam.",
            "∀x (¬AttendsClass(x)) ::: No one attends class."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "PassExam(x) ::: x passes the exam",
            "AttendsClass(x) ::: x attends class",
            "Smart(x) ::: x is smart",
            "Teacher(x) ::: x is a teacher"
        ]
    },
    {
        "premises-NL": [
            "All students work hard or don't study.",
            "If a student works hard, they will get good grades.",
            "If a student gets good grades, they are successful.",
            "John is a student.",
            "If John studies, he works hard.",
            "If someone gets good grades, they attend classes.",
            "John studies math.",
            "John is enrolled in a math course.",
            "All courses are subjects.",
            "If someone likes a subject and is enrolled in a course, they study.",
            "If someone studies and attends classes, they are successful.",
            "John likes math."
        ],
        "premises-FOL": [
            "∀x (Student(x) → WorksHard(x) ∨ ¬Studies(x, someSubject)) ::: All students work hard or don't study.",
            "∀x (WorksHard(x) → GetsGoodGrades(x)) ::: If a student works hard, they will get good grades.",
            "∀x (GetsGoodGrades(x) → Successful(x)) ::: If a student gets good grades, they are successful.",
            "Student(john) ::: John is a student.",
            "∀x (Studies(x, someSubject) → WorksHard(x)) ::: If John studies, he works hard.",
            "∀x (GetsGoodGrades(x) → AttendsClasses(x)) ::: If someone gets good grades, they attend classes.",
            "Studies(john, math) ::: John studies math.",
            "Enrolled(john, mathCourse) ::: John is enrolled in a math course.",
            "∀y (Course(y) → Subject(y)) ::: All courses are subjects.",
            "∀x ∀y (Likes(x, y) ∧ Enrolled(x, y) → Studies(x, y)) ::: If someone likes a subject and is enrolled in a course, they study.",
            "∀x (Studies(x, someSubject) ∧ AttendsClasses(x) → Successful(x)) ::: If someone studies and attends classes, they are successful.",
            "Likes(john, math) ::: John likes math."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "WorksHard(x) ::: x works hard",
            "Successful(x) ::: x is successful",
            "Studies(x, y) ::: x studies subject y",
            "Subject(y) ::: y is a subject",
            "HasDegree(x, y) ::: x has a degree in y",
            "Smart(x) ::: x is smart",
            "GetsGoodGrades(x) ::: x gets good grades",
            "AttendsClasses(x) ::: x attends classes",
            "Likes(x, y) ::: x likes subject y",
            "Enrolled(x, y) ::: Student x is enrolled in course y",
            "Course(y) ::: y is a course"
        ]
    },
    {
        "premises-NL": [
            "All doctors are people.",
            "All people are mortal.",
            "Dr. House is a doctor.",
            "Lisa is a patient of Dr. House.",
            "If someone is a patient of a doctor, then the doctor is helping them.",
            "If a doctor helps someone, they are practicing medicine.",
            "If someone practices medicine, they are a doctor.",
            "All doctors have a medical degree.",
            "If someone has a medical degree, they are trained.",
            "If someone is trained, they can prescribe medicine.",
            "If someone prescribes medicine, they are helping someone.",
            "If Dr. House is helping someone, then he is practicing medicine.",
            "If Dr. House is practicing medicine, then he is a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Person(x)) ::: All doctors are people.",
            "∀x (Person(x) → Mortal(x)) ::: All people are mortal.",
            "Doctor(drHouse) ::: Dr. House is a doctor.",
            "Patient(lisa, drHouse) ::: Lisa is a patient of Dr. House.",
            "∀x ∀y (Patient(x, y) → Helps(y, x)) ::: If someone is a patient of a doctor, then the doctor is helping them.",
            "∀x (Helps(x, y) → PracticingMedicine(x)) ::: If a doctor helps someone, they are practicing medicine.",
            "∀x (PracticingMedicine(x) → Doctor(x)) ::: If someone practices medicine, they are a doctor.",
            "∀x (Doctor(x) → HasMedicalDegree(x)) ::: All doctors have a medical degree.",
            "∀x (HasMedicalDegree(x) → Trained(x)) ::: If someone has a medical degree, they are trained.",
            "∀x (Trained(x) → CanPrescribe(x)) ::: If someone is trained, they can prescribe medicine.",
            "∀x (CanPrescribe(x) → Helps(x, y)) ::: If someone prescribes medicine, they are helping someone.",
            "Helps(drHouse, lisa) → PracticingMedicine(drHouse) ::: If Dr. House is helping someone, then he is practicing medicine.",
            "PracticingMedicine(drHouse) → Doctor(drHouse) ::: If Dr. House is practicing medicine, then he is a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Person(x) ::: x is a person.",
            "Mortal(x) ::: x is mortal.",
            "Patient(x, y) ::: x is a patient of doctor y."
        ]
    },
    {
        "premises-NL": [
            "All doctors are employed.",
            "Dr. Smith is a doctor.",
            "All doctors like all patients.",
            "Patient John is a patient.",
            "Dr. Smith treats Patient John.",
            "Anyone who treats someone who likes something is likely to be exposed to something.",
            "Anyone who is exposed to something infectious becomes likely ill.",
            "Something is infectious if John is sick.",
            "If someone is sick, John is a friend of them.",
            "Dr. Smith is a friend of someone.",
            "If someone treats someone, they are a doctor.",
            "If someone is a friend of someone, they like that person."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Employed(x)) ::: All doctors are employed.",
            "Doctor(DrSmith) ::: Dr. Smith is a doctor.",
            "∀x ∀y (Doctor(x) ∧ Patient(y) → Likes(x, y)) ::: All doctors like all patients.",
            "Patient(John) ::: Patient John is a patient.",
            "Treats(DrSmith, John) ::: Dr. Smith treats Patient John.",
            "∀x ∀y ∀z ((Treats(x, y) ∧ Likes(y, z)) → Exposed(x)) ::: Anyone who treats someone who likes something is likely to be exposed to something.",
            "∀x (Exposed(x) ∧ Infectious(y) → LikelyIll(x)) ::: Anyone who is exposed to something infectious becomes likely ill.",
            "Infectious(Something) ↔ Sick(John) ::: Something is infectious if John is sick.",
            "∀x (Sick(x) → IsFriendOf(John, x)) ::: If someone is sick, John is a friend of them.",
            "∃x IsFriendOf(DrSmith, x) ::: Dr. Smith is a friend of someone.",
            "∀x ∀y (Treats(x, y) → Doctor(x)) ::: If someone treats someone, they are a doctor.",
            "∀x ∀y (IsFriendOf(x, y) → Likes(x, y)) ::: If someone is a friend of someone, they like that person."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Employed(x) ::: x is employed",
            "Likes(x, y) ::: x likes y",
            "Patient(x) ::: x is a patient",
            "Treats(x, y) ::: x treats y",
            "Infectious(x) ::: x is infectious",
            "IsFriendOf(x, y) ::: x is a friend of y"
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "Some smart people study hard.",
            "Anyone who studies hard passes the exam.",
            "John is a student.",
            "John likes coffee.",
            "If someone is a student and likes coffee, they study hard.",
            "If someone studies hard, they are smart.",
            "Mary is a student.",
            "Mary likes coffee."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "∃x (Smart(x) ∧ StudyHard(x)) ::: Some smart people study hard.",
            "∀x (StudyHard(x) → PassExam(x)) ::: Anyone who studies hard passes the exam.",
            "Student(john) ::: John is a student.",
            "LikesCoffee(john) ::: John likes coffee.",
            "∀x ((Student(x) ∧ LikesCoffee(x)) → StudyHard(x)) ::: If someone is a student and likes coffee, they study hard.",
            "∀x (StudyHard(x) → Smart(x)) ::: If someone studies hard, they are smart.",
            "Student(mary) ::: Mary is a student.",
            "LikesCoffee(mary) ::: Mary likes coffee."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Smart(x) ::: x is smart",
            "StudyHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "LikesCoffee(x) ::: x likes coffee"
        ]
    },
    {
        "premises-NL": [
            "All researchers have good projects.",
            "Anyone with a good project publishes papers.",
            "Some people who publish papers get funding.",
            "Alice is a researcher.",
            "Bob knows Alice.",
            "If Bob knows Alice, then Alice has a good project.",
            "If Alice has a good project, then Alice publishes papers.",
            "If Alice publishes papers, Alice gets funding.",
            "Not all researchers are funded.",
            "Alice does not know Bob"
        ],
        "premises-FOL": [
            "∀x (Researcher(x) → GoodProject(x)) ::: All researchers have good projects.",
            "∀x (GoodProject(x) → PublishPaper(x)) ::: Anyone with a good project publishes papers.",
            "∃x (PublishPaper(x) ∧ GetFunding(x)) ::: Some people who publish papers get funding.",
            "Researcher(alice) ::: Alice is a researcher.",
            "Knows(bob, alice) ::: Bob knows Alice.",
            "∀x ∀y (Knows(x, y) → GoodProject(y)) ::: If x knows y, then y has a good project.",
            "∀x (GoodProject(x) → PublishPaper(x)) ::: If x has a good project, then x publishes papers.",
            "∀x (PublishPaper(x) → GetFunding(x)) ::: If x publishes papers, x gets funding.",
            "¬∀x (Researcher(x) → GetFunding(x)) ::: Not all researchers are funded.",
            "¬Knows(alice, bob) ::: Alice does not know Bob"
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher",
            "PublishPaper(x) ::: x publishes a paper",
            "GetFunding(x) ::: x gets funding",
            "GoodProject(x) ::: x has a good project",
            "Knows(x, y) ::: x knows y"
        ]
    },
    {
        "premises-NL": [
            "John is friends with everyone.",
            "Mary is friends with everyone.",
            "Everyone is smart if they are a programmer.",
            "If someone is smart, then they either don't like cats or are a programmer.",
            "If someone is a programmer and doesn't like cats, then they are smart.",
            "John is friends with someone.",
            "Mary is friends with someone.",
            "If John is friends with someone, then that someone is not a programmer or likes cats.",
            "If Mary is friends with someone, then that someone is not a programmer or likes cats.",
            "Everyone is friends with someone.",
            "If someone is a programmer, they work at Google.",
            "If someone likes cats, they don't work at Google."
        ],
        "premises-FOL": [
            "∀x (Friends(john, x)) ::: John is friends with everyone.",
            "∀x (Friends(mary, x)) ::: Mary is friends with everyone.",
            "∀x (Programmer(x) → Smart(x)) ::: Everyone is smart if they are a programmer.",
            "∀x (Smart(x) → (¬LikesCats(x) ∨ Programmer(x))) ::: If someone is smart, then they either don't like cats or are a programmer.",
            "∀x ((Programmer(x) ∧ ¬LikesCats(x)) → Smart(x)) ::: If someone is a programmer and doesn't like cats, then they are smart.",
            "∃z Friends(john, z) ::: John is friends with someone.",
            "∃z Friends(mary, z) ::: Mary is friends with someone.",
            "∀z (Friends(john, z) → (¬Programmer(z) ∨ LikesCats(z))) ::: If John is friends with someone, then that someone is not a programmer or likes cats.",
            "∀z (Friends(mary, z) → (¬Programmer(z) ∨ LikesCats(z))) ::: If Mary is friends with someone, then that someone is not a programmer or likes cats.",
            "∀x ∃y Friends(x, y) ::: Everyone is friends with someone.",
            "∀x (Programmer(x) → WorksAt(x, google)) ::: If someone is a programmer, they work at Google.",
            "∀x (LikesCats(x) → ¬WorksAt(x, google)) ::: If someone likes cats, they don't work at Google."
        ],
        "predicates": [
            "Friends(x, y) ::: x is friends with y",
            "Programmer(x) ::: x is a programmer",
            "LikesCats(x) ::: x likes cats",
            "Smart(x) ::: x is smart",
            "WorksAt(x, y) ::: x works at y"
        ]
    },
    {
        "premises-NL": [
            "All scientists study science.",
            "All engineers build things.",
            "Anyone who builds things uses tools.",
            "If someone studies science, they work in a lab.",
            "Anyone who uses tools uses equipment.",
            "If someone uses equipment, they require equipment.",
            "Alice is a scientist.",
            "Bob is an engineer.",
            "If a person specializes in a field, they work in a lab."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → StudiesScience(x)) ::: All scientists study science.",
            "∀x (Engineer(x) → BuildsThings(x)) ::: All engineers build things.",
            "∀x (BuildsThings(x) → UsesTools(x)) ::: Anyone who builds things uses tools.",
            "∀x (StudiesScience(x) → WorksInLab(x)) ::: If someone studies science, they work in a lab.",
            "∀x (UsesTools(x) → UsesEquipment(x)) ::: Anyone who uses tools uses equipment.",
            "∀x (UsesEquipment(x) → RequiresEquipment(x)) ::: If someone uses equipment, they require equipment.",
            "Scientist(alice) ::: Alice is a scientist.",
            "Engineer(bob) ::: Bob is an engineer.",
            "∀x ∀y (SpecializesIn(x, y) → WorksInLab(x)) ::: If a person specializes in a field, they work in a lab."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist.",
            "Engineer(x) ::: x is an engineer.",
            "WorksInLab(x) ::: x works in a lab.",
            "StudiesScience(x) ::: x studies science.",
            "BuildsThings(x) ::: x builds things.",
            "UsesTools(x) ::: x uses tools.",
            "RequiresEquipment(x) ::: x requires equipment.",
            "UsesEquipment(x) ::: x uses equipment.",
            "SpecializesIn(x, y) ::: x specializes in y."
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "Anyone who treats patients is a healthcare professional.",
            "Alice is a doctor.",
            "Doctors have a degree.",
            "Anyone who has a degree studies medicine.",
            "Bob is a doctor.",
            "All those who study medicine are healthcare professionals.",
            "Charlie is a doctor.",
            "Doctors are professionals.",
            "David is a doctor.",
            "Healthcare professionals are trained."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → TreatsPatients(x)) ::: All doctors treat patients.",
            "∀x (TreatsPatients(x) → HealthcareProfessional(x)) ::: Anyone who treats patients is a healthcare professional.",
            "Doctor(alice) ::: Alice is a doctor.",
            "∀x (Doctor(x) → HasDegree(x)) ::: Doctors have a degree.",
            "∀x (HasDegree(x) → StudiesMedicine(x)) ::: Anyone who has a degree studies medicine.",
            "Doctor(bob) ::: Bob is a doctor.",
            "∀x (StudiesMedicine(x) → HealthcareProfessional(x)) ::: All those who study medicine are healthcare professionals.",
            "Doctor(charlie) ::: Charlie is a doctor.",
            "∀x (Doctor(x) → Professional(x)) ::: Doctors are professionals.",
            "Doctor(david) ::: David is a doctor.",
            "∀x (HealthcareProfessional(x) → Trained(x)) ::: Healthcare professionals are trained."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "HealthcareProfessional(x) ::: x is a healthcare professional",
            "TreatsPatients(x) ::: x treats patients",
            "HasDegree(x) ::: x has a degree",
            "StudiesMedicine(x) ::: x studies medicine"
        ]
    },
    {
        "premises-NL": [
            "All students take courses.",
            "All professors teach courses.",
            "Bob is a professor.",
            "Alice is a student.",
            "If someone takes a course and passes, they are smart.",
            "If someone is smart, they are enrolled in courses.",
            "If someone is enrolled, they are a student or a professor.",
            "Bob teaches Physics.",
            "Alice is enrolled in a course.",
            "If Alice takes a course, she passes it.",
            "Bob is a professor and he teaches.",
            "If someone teaches, they are a professor.",
            "If Bob teaches Physics, he is a professor."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakesCourse(x, y)) ::: All students take courses.",
            "∀x (Professor(x) → TeachesCourse(x, y)) ::: All professors teach courses.",
            "Professor(bob) ::: Bob is a professor.",
            "Student(alice) ::: Alice is a student.",
            "∀x (TakesCourse(x, y) ∧ Passes(x, y) → Smart(x)) ::: If someone takes a course and passes, they are smart.",
            "∀x (Smart(x) → EnrolledIn(x, y)) ::: If someone is smart, they are enrolled in courses.",
            "∀x (EnrolledIn(x, y) → (Student(x) ∨ Professor(x))) ::: If someone is enrolled, they are a student or a professor.",
            "TeachesCourse(bob, physics) ::: Bob teaches Physics.",
            "EnrolledIn(alice, course) ::: Alice is enrolled in a course.",
            "∀x (TakesCourse(alice, x) → Passes(alice, x)) ::: If Alice takes a course, she passes it.",
            "Professor(bob) ∧ TeachesCourse(bob, y) ::: Bob is a professor and he teaches.",
            "∀x (TeachesCourse(x, y) → Professor(x)) ::: If someone teaches, they are a professor.",
            "TeachesCourse(bob, physics) → Professor(bob) ::: If Bob teaches Physics, he is a professor."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Professor(x) ::: x is a professor",
            "TakesCourse(x, y) ::: x takes course y",
            "TeachesCourse(x, y) ::: x teaches course y",
            "EnrolledIn(x, y) ::: x is enrolled in y",
            "Passes(x, y) ::: x passes y",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All students are humans.",
            "Some students study physics.",
            "If someone studies physics, then they understand physics.",
            "All humans are rational beings.",
            "Rational beings understand physics."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Human(x)) ::: All students are humans.",
            "∃x (Student(x) ∧ StudiesPhysics(x)) ::: Some students study physics.",
            "∀x (StudiesPhysics(x) → UnderstandsPhysics(x)) ::: If someone studies physics, then they understand physics.",
            "∀x (Human(x) → Rational(x)) ::: All humans are rational beings.",
            "∀x (Rational(x) → UnderstandsPhysics(x)) ::: Rational beings understand physics."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesPhysics(x) ::: x studies physics.",
            "UnderstandsPhysics(x) ::: x understands physics."
        ]
    },
    {
        "premises-NL": [
            "If Carol likes John, John is nice.",
            "If John is nice, then David is nice.",
            "If David is nice, David likes Mary.",
            "Carol likes John or Carol has a gift.",
            "If Carol has a gift, then Mary is happy.",
            "If Mary is happy, then David likes Mary.",
            "John is nice.",
            "Mary is not happy.",
            "Carol is a friend of John.",
            "John is a friend of Carol.",
            "John is David's friend.",
            "If David likes Mary, Mary is not happy.",
            "If John is a friend of Carol, Carol likes John."
        ],
        "premises-FOL": [
            "Likes(carol, john) → IsNice(john) ::: If Carol likes John, John is nice.",
            "IsNice(john) → IsNice(david) ::: If John is nice, then David is nice.",
            "IsNice(david) → Likes(david, mary) ::: If David is nice, David likes Mary.",
            "Likes(carol, john) ∨ HasGift(carol) ::: Carol likes John or Carol has a gift.",
            "HasGift(carol) → Happy(mary) ::: If Carol has a gift, then Mary is happy.",
            "Happy(mary) → Likes(david, mary) ::: If Mary is happy, then David likes Mary.",
            "IsNice(john) ::: John is nice.",
            "¬Happy(mary) ::: Mary is not happy.",
            "IsFriendOf(carol, john) ::: Carol is a friend of John.",
            "IsFriendOf(john, carol) ::: John is a friend of Carol.",
            "IsFriendOf(john, david) ::: John is David's friend.",
            "Likes(david, mary) → ¬Happy(mary) ::: If David likes Mary, Mary is not happy.",
            "IsFriendOf(john, carol) → Likes(carol, john) ::: If John is a friend of Carol, Carol likes John."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "IsNice(x) ::: x is nice",
            "IsFriendOf(x, y) ::: x is a friend of y",
            "Happy(x) ::: x is happy",
            "HasGift(x) ::: x has a gift"
        ]
    },
    {
        "premises-NL": [
            "All doctors are people.",
            "No doctors are students.",
            "Everyone is either a student or a patient.",
            "Some doctors take classes.",
            "No doctors are both students and patients.",
            "Every student takes classes.",
            "If someone takes classes, then they are either a student or a doctor.",
            "Some people are not students.",
            "No patient is a doctor.",
            "All doctors help patients.",
            "If someone is a student, they are not a doctor.",
            "If someone is a doctor, they are not a student.",
            "Some students are not patients."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Person(x)) ::: All doctors are people.",
            "∀x (Doctor(x) → ¬Student(x)) ::: No doctors are students.",
            "∀x (Student(x) ∨ Patient(x)) ::: Everyone is either a student or a patient.",
            "∃x (Doctor(x) ∧ TakesClasses(x)) ::: Some doctors take classes.",
            "∀x (Doctor(x) → ¬(Student(x) ∧ Patient(x))) ::: No doctors are both students and patients.",
            "∀x (Student(x) → TakesClasses(x)) ::: Every student takes classes.",
            "∀x (TakesClasses(x) → (Student(x) ∨ Doctor(x))) ::: If someone takes classes, then they are either a student or a doctor.",
            "∃x ¬Student(x) ::: Some people are not students.",
            "∀x (Patient(x) → ¬Doctor(x)) ::: No patient is a doctor.",
            "∀x (Doctor(x) → Helps(x, y)) ::: All doctors help patients.",
            "∀x (Student(x) → ¬Doctor(x)) ::: If someone is a student, they are not a doctor.",
            "∀x (Doctor(x) → ¬Student(x)) ::: If someone is a doctor, they are not a student.",
            "∃x (Student(x) ∧ ¬Patient(x)) ::: Some students are not patients."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Student(x) ::: x is a student.",
            "Patient(x) ::: x is a patient.",
            "TakesClasses(x) ::: x takes classes."
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled in some course.",
            "Some courses are difficult.",
            "If a student is enrolled in a difficult course, then they must study hard.",
            "Alice is a student.",
            "If Alice is smart, she passes the exam.",
            "Alice is enrolled in course CS101.",
            "Course CS101 is difficult."
        ],
        "premises-FOL": [
            "∀x ∃y (Student(x) → EnrolledInCourse(x, y)) ::: All students are enrolled in some course.",
            "∃y CourseDifficult(y) ::: Some courses are difficult.",
            "∀x ∀y (Student(x) ∧ EnrolledInCourse(x, y) ∧ CourseDifficult(y) → StudiesHard(x)) ::: If a student is enrolled in a difficult course, then they must study hard.",
            "Student(alice) ::: Alice is a student.",
            "∀x (Smart(x) → PassExam(x)) ::: If Alice is smart, she passes the exam.",
            "EnrolledInCourse(alice, cs101) ::: Alice is enrolled in course CS101.",
            "CourseDifficult(cs101) ::: Course CS101 is difficult."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x will pass the exam",
            "EnrolledInCourse(x, y) ::: x is enrolled in course y",
            "CourseDifficult(y) ::: Course y is difficult",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All published papers are papers.",
            "If a paper is well-researched, it is likely to be accepted.",
            "If a paper is well-researched and published by a scientist, the scientist's university gets funding.",
            "If a paper is a high impact factor paper, and the scientist is a part of the university, then the university gets funding.",
            "Some scientists publish papers.",
            "Alice is a scientist.",
            "Alice publishes paper P1.",
            "Paper P1 is well researched.",
            "Alice works for University X.",
            "Paper P1 has high impact factor.",
            "Bob is a scientist."
        ],
        "premises-FOL": [
            "∀x (PublishesPaper(x, y) → Paper(y)) ::: All published papers are papers.",
            "∀y (WellResearched(y) → Accepted(y)) ::: If a paper is well-researched, it is likely to be accepted.",
            "∀x ∀y ∀z (Scientist(x) ∧ PublishesPaper(x, y) ∧ WellResearched(y) ∧ WorksFor(x, z) → GetsFunding(z)) ::: If a paper is well-researched and published by a scientist, the scientist's university gets funding.",
            "∀x ∀y ∀z (Paper(y) ∧ HighImpactFactor(y) ∧ Scientist(x) ∧ WorksFor(x, z) → GetsFunding(z)) ::: If a paper is a high impact factor paper, and the scientist is a part of the university, then the university gets funding.",
            "∃x ∃y (Scientist(x) ∧ PublishesPaper(x, y)) ::: Some scientists publish papers.",
            "Scientist(alice) ::: Alice is a scientist.",
            "PublishesPaper(alice, p1) ::: Alice publishes paper P1.",
            "WellResearched(p1) ::: Paper P1 is well researched.",
            "WorksFor(alice, universityX) ::: Alice works for University X.",
            "HighImpactFactor(p1) ::: Paper P1 has high impact factor.",
            "Scientist(bob) ::: Bob is a scientist."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "PublishesPaper(x, y) ::: Scientist x publishes paper y",
            "Accepted(y) ::: Paper y is accepted",
            "WorksFor(x, z) ::: Scientist x works for organization z",
            "GetsFunding(z) ::: Organization z gets funding",
            "Paper(x) ::: x is a paper",
            "ResearchArea(x, y) ::: Paper x belongs to research area y",
            "WellResearched(y) ::: Research area y is well researched",
            "HighImpactFactor(y) ::: Paper y has a high impact factor"
        ]
    },
    {
        "premises-NL": [
            "All students study hard.",
            "Alex is a student.",
            "If a student studies hard, they will pass the exam.",
            "Alex will not fail the exam.",
            "John is a student.",
            "If John studies hard, then he will get a good grade.",
            "John will get a good grade.",
            "Mary is a student.",
            "Every student will pass the exam.",
            "Students will be rewarded if they study hard.",
            "If a student is rewarded, they will be happy.",
            "Alex is rewarded."
        ],
        "premises-FOL": [
            "∀x (Student(x) → StudiesHard(x)) ::: All students study hard",
            "Student(alex) ::: Alex is a student",
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: If a student studies hard, they will pass the exam",
            "¬FailExam(alex) ::: Alex will not fail the exam",
            "Student(john) ::: John is a student",
            "∀x (Student(john) ∧ StudiesHard(john) → GetGoodGrade(john)) ::: If John studies hard, then he will get a good grade",
            "GetGoodGrade(john) ::: John will get a good grade",
            "Student(mary) ::: Mary is a student",
            "∀x (Student(x) → PassExam(x)) ::: Every student will pass the exam",
            "∀x (Student(x) ∧ StudiesHard(x) → Rewarded(x)) ::: Students will be rewarded if they study hard",
            "∀x (Rewarded(x) → Happy(x)) ::: If a student is rewarded, they will be happy",
            "Rewarded(alex) ::: Alex is rewarded"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard"
        ]
    },
    {
        "premises-NL": [
            "Every student either studies or goes to a party.",
            "John is a student.",
            "John studies.",
            "If someone studies in the library, they will learn.",
            "If a student studies, they are either in the library or at home.",
            "John is in the library.",
            "Students who study, learn.",
            "If you learn, you get good grades.",
            "Mary is a student.",
            "Mary studies in the library.",
            "If someone doesn't study, they fail.",
            "John is not failing.",
            "Every student will eventually graduate.",
            "If a student studies in the library, and John studies, then John learns."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Studies(x) ∨ GoesToParty(x)) ::: Every student either studies or goes to a party",
            "Student(john) ::: John is a student",
            "Studies(john) ::: John studies",
            "∀x (StudiesInLibrary(x) → Learns(x)) ::: If someone studies in the library, they will learn",
            "∀x (Student(x) ∧ Studies(x) → InLibrary(x) ∨ AtHome(x)) ::: If a student studies, they are either in the library or at home",
            "InLibrary(john) ::: John is in the library",
            "∀x (Student(x) ∧ Studies(x) → Learns(x)) ::: Students who study, learn",
            "∀x (Learns(x) → GetGoodGrades(x)) ::: If you learn, you get good grades",
            "Student(mary) ::: Mary is a student",
            "StudiesInLibrary(mary) ::: Mary studies in the library",
            "∀x (¬Studies(x) → Fails(x)) ::: If someone doesn't study, they fail",
            "¬Fails(john) ::: John is not failing",
            "∀x (Student(x) → Graduate(x)) ::: Every student will eventually graduate",
            "∀x (Student(x) ∧ StudiesInLibrary(x) ∧ Studies(john) → Learns(john)) ::: If a student studies in the library, and John studies, then John learns"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "InLibrary(x) ::: x is in the library",
            "Learns(x) ::: x learns"
        ]
    },
    {
        "premises-NL": [
            "All mammals are animals.",
            "All animals that give birth to live young are mammals.",
            "If an animal gives live birth, it is a mammal.",
            "All animals that eat meat are mammals.",
            "Some mammals gives live birth.",
            "All mammals are animals that eat meat or give live birth.",
            "All that gives live birth are warm-blooded.",
            "If anything is a mammal, then it is an animal.",
            "If anything is a mammal it gives birth to live young.",
            "All mammals are warm-blooded.",
            "If an animal eats meat, it is a mammal.",
            "All mammals are warm-blooded or eats meat.",
            "All mammals do not eat meat and give birth to live young.",
            "Some animals eats meat.",
            "All mammals gives birth to live young."
        ],
        "premises-FOL": [
            "∀x(Mammal(x) → Animal(x)) ::: All mammals are animals.",
            "∀x(GivesLiveBirth(x) → Mammal(x)) ::: All animals that give birth to live young are mammals.",
            "∀x(GivesLiveBirth(x) → Mammal(x)) ::: If an animal gives live birth, it is a mammal.",
            "∀x(EatsMeat(x) → Mammal(x)) ::: All animals that eat meat are mammals.",
            "∃x(Mammal(x) ∧ GivesLiveBirth(x)) ::: Some mammals gives live birth.",
            "∀x(Mammal(x) → (EatsMeat(x) ∨ GivesLiveBirth(x))) ::: All mammals are animals that eat meat or give live birth.",
            "∀x(GivesLiveBirth(x) → WarmBlooded(x)) ::: All that gives live birth are warm-blooded.",
            "∀x(Mammal(x) → Animal(x)) ::: If anything is a mammal, then it is an animal.",
            "∀x(Mammal(x) → GivesLiveBirth(x)) ::: If anything is a mammal it gives birth to live young.",
            "∀x(Mammal(x) → WarmBlooded(x)) ::: All mammals are warm-blooded.",
            "∀x(EatsMeat(x) → Mammal(x)) ::: If an animal eats meat, it is a mammal.",
            "∀x(Mammal(x) → (WarmBlooded(x) ∨ EatsMeat(x))) ::: All mammals are warm-blooded or eats meat.",
            "∀x(Mammal(x) → (¬EatsMeat(x) ∧ GivesLiveBirth(x))) ::: All mammals do not eat meat and give birth to live young.",
            "∃x(Animal(x) ∧ EatsMeat(x)) ::: Some animals eats meat.",
            "∀x(Mammal(x) → GivesLiveBirth(x)) ::: All mammals gives birth to live young."
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal.",
            "GivesLiveBirth(x) ::: x gives birth to live young.",
            "WarmBlooded(x) ::: x is warm-blooded.",
            "Animal(x) ::: x is an animal.",
            "EatsMeat(x) ::: x eats meat."
        ]
    },
    {
        "premises-NL": [
            "All students take courses.",
            "If someone takes a required course, then they attend lectures.",
            "John is a student.",
            "All courses are required.",
            "Mary takes Biology.",
            "John takes Calculus.",
            "If someone passes an exam of a course, they pass the course.",
            "If someone is enrolled in a course, then they take it.",
            "If someone is eligible for a scholarship, then they are a student.",
            "If someone has a loan, they are a student.",
            "If someone works part-time, they are a student.",
            "If someone needs financial aid, they are a student.",
            "Mary is a smart student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakesCourse(x, y)) ::: For all x, if x is a student, then x takes course y.",
            "∀x ∀y (TakesCourse(x, y) ∧ CourseIsRequired(y) → AttendsLectures(x)) ::: For all x and y, if x takes course y and course y is required, then x attends lectures.",
            "Student(john) ::: John is a student.",
            "∀y CourseIsRequired(y) ::: All courses are required.",
            "TakesCourse(mary, biology) ::: Mary takes Biology.",
            "TakesCourse(john, calculus) ::: John takes Calculus.",
            "∀x ∀y (PassesExam(x, y) → PassesCourse(x, y)) ::: For all x and y, if x passes exam of course y, they pass the course.",
            "∀x ∀y (EnrolledIn(x, y) → TakesCourse(x, y)) ::: For all x and y, if x is enrolled in course y, then x takes course y.",
            "∀x (IsEligibleForScholarship(x) → Student(x)) ::: For all x, if x is eligible for a scholarship, then x is a student.",
            "∀x (HasLoan(x) → Student(x)) ::: For all x, if x has a loan, then x is a student.",
            "∀x (WorksPartTime(x) → Student(x)) ::: For all x, if x works part-time, then x is a student.",
            "∀x (NeedsFinancialAid(x) → Student(x)) ::: For all x, if x needs financial aid, then x is a student.",
            "IsSmart(mary) ∧ Student(mary) ::: Mary is a smart student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "TakesCourse(x, y) ::: x takes course y",
            "AttendsLectures(x) ::: x attends lectures",
            "CourseIsRequired(y) ::: Course y is required",
            "PassesExam(x, y) ::: x passes exam of course y",
            "EnrolledIn(x, y) ::: x is enrolled in course y",
            "HasGrade(x, g) ::: x has grade g",
            "IsEligibleForScholarship(x) ::: x is eligible for scholarship",
            "HasLoan(x) ::: x has a loan",
            "WorksPartTime(x) ::: x works part-time",
            "NeedsFinancialAid(x) ::: x needs financial aid",
            "IsGoodStudent(x) ::: x is a good student",
            "IsSmart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "Everyone loves their pets.",
            "If someone loves something, they like it.",
            "John owns a cat.",
            "If someone has a cat, they are kind to it.",
            "Mary has a dog.",
            "If someone is kind to something, they feed it.",
            "If someone feeds something, they love it.",
            "Dogs are loyal to their owners.",
            "Cats meow.",
            "If something barks, it is a dog.",
            "If something meows, it is a cat.",
            "Anything that likes something is happy.",
            "Anything that is friendly to something is happy.",
            "Cats are furry."
        ],
        "premises-FOL": [
            "∀x ∀y (HasPet(x, y) → Loves(x, y)) ::: For all x and y, if x has pet y, then x loves y.",
            "∀x ∀y (Loves(x, y) → Likes(x, y)) ::: For all x and y, if x loves y, then x likes y.",
            "HasPet(john, cats) ::: John owns a cat.",
            "∀x (HasPet(x, cats) → KindTo(x, cats)) ::: For all x, if x has a cat, then x is kind to it.",
            "HasPet(mary, dogs) ::: Mary has a dog.",
            "∀x ∀y (KindTo(x, y) → Feeds(x, y)) ::: For all x and y, if x is kind to y, then x feeds y.",
            "∀x ∀y (Feeds(x, y) → Loves(x, y)) ::: For all x and y, if x feeds y, then x loves y.",
            "∀x ∀y (HasPet(x, dogs) → LoyalTo(x, y)) ::: For all x and y, if x has a dog, then x is loyal to y.",
            "Meows(cats) ::: Cats meow.",
            "∀x (Barks(x) → IsDog(x)) ::: For all x, if x barks, then x is a dog.",
            "∀x (Meows(x) → IsCat(x)) ::: For all x, if x meows, then x is a cat.",
            "∀x ∀y (Likes(x, y) → IsHappy(x)) ::: For all x and y, if x likes y, then x is happy.",
            "∀x ∀y (IsFriendly(x, y) → Happy(x)) ::: For all x and y, if x is friendly to y, then x is happy.",
            "∀x (IsCat(x) → IsFurry(x)) ::: For all x, if x is a cat, then x is furry."
        ],
        "predicates": [
            "Loves(x, y) ::: x loves y",
            "HasPet(x, y) ::: x has pet y",
            "IsHappy(x) ::: x is happy",
            "Likes(x, y) ::: x likes y",
            "Owns(x, y) ::: x owns y",
            "KindTo(x, y) ::: x is kind to y",
            "Feeds(x, y) ::: x feeds y",
            "LoyalTo(x, y) ::: x is loyal to y",
            "Barks(x) ::: x barks",
            "Meows(x) ::: x meows",
            "IsFriendly(x) ::: x is friendly",
            "IsFurry(x) ::: x is furry",
            "Chases(x, y) ::: x chases y",
            "IsPlayful(x) ::: x is playful"
        ]
    },
    {
        "premises-NL": [
            "If someone studies philosophy, they read philosophical texts.",
            "If someone reads philosophical texts, they either understand them or they are critical of them.",
            "If someone is knowledgeable and reads philosophical texts, then they attend lectures.",
            "Someone who writes essays is knowledgeable.",
            "If someone loves debate and is intelligent, they are critical.",
            "Anyone who studies philosophy presents arguments.",
            "Anyone who studies philosophy values logic.",
            "Anyone who is open-minded and curious is knowledgeable.",
            "Anyone who is skeptical and passionate is critical.",
            "If someone is open-minded, they will be knowledgeable if they study philosophy.",
            "If someone values logic, they will be critical if they study philosophy.",
            "If someone attends lectures and understands philosophy, then they are knowledgeable.",
            "If someone disagrees with many philosophical texts, they are critical."
        ],
        "premises-FOL": [
            "∀x (Studies(x, philosophy) → Reads(x, philosophicalTexts)) ::: For all x, if x studies philosophy, then x reads philosophical texts.",
            "∀x (Reads(x, philosophicalTexts) → (Understands(x, philosophicalTexts) ∨ Critical(x))) ::: For all x, if x reads philosophical texts, then they either understand them or are critical of them.",
            "∀x (Knowledgeable(x) ∧ Reads(x, philosophicalTexts) → AttendsLectures(x)) ::: For all x, if x is knowledgeable and reads philosophical texts, then they attend lectures.",
            "∀x (WritesEssays(x) → Knowledgeable(x)) ::: For all x, if x writes essays, then they are knowledgeable.",
            "∀x (LovesDebate(x) ∧ IsIntelligent(x) → Critical(x)) ::: For all x, if x loves debate and is intelligent, then they are critical.",
            "∀x (Studies(x, philosophy) → PresentsArguments(x)) ::: For all x, if x studies philosophy, then they present arguments.",
            "∀x (Studies(x, philosophy) → ValuesLogic(x)) ::: For all x, if x studies philosophy, then they value logic.",
            "∀x (IsOpenMinded(x) ∧ IsCurious(x) → Knowledgeable(x)) ::: For all x, if x is open-minded and curious, then they are knowledgeable.",
            "∀x (IsSkeptical(x) ∧ IsPassionate(x) → Critical(x)) ::: For all x, if x is skeptical and passionate, then they are critical.",
            "∀x (IsOpenMinded(x) ∧ Studies(x, philosophy) → Knowledgeable(x)) ::: For all x, if x is open-minded, then they are knowledgeable if they study philosophy.",
            "∀x (ValuesLogic(x) ∧ Studies(x, philosophy) → Critical(x)) ::: For all x, if x values logic, then they are critical if they study philosophy.",
            "∀x (AttendsLectures(x) ∧ Understands(x, philosophy) → Knowledgeable(x)) ::: For all x, if x attends lectures and understands philosophy, then they are knowledgeable.",
            "∀x (DisagreesWith(x, philosophicalTexts) → Critical(x)) ::: For all x, if x disagrees with many philosophical texts, then they are critical."
        ],
        "predicates": [
            "Studies(x, y) ::: x studies y",
            "Knowledgeable(x) ::: x is knowledgeable",
            "Critical(x) ::: x is critical",
            "Reads(x, y) ::: x reads y",
            "Understands(x, y) ::: x understands y",
            "WritesEssays(x) ::: x writes essays",
            "AttendsLectures(x) ::: x attends lectures",
            "IsIntelligent(x) ::: x is intelligent",
            "LovesDebate(x) ::: x loves debate",
            "DisagreesWith(x, y) ::: x disagrees with y",
            "PresentsArguments(x) ::: x presents arguments",
            "IsPassionate(x) ::: x is passionate",
            "IsSkeptical(x) ::: x is skeptical",
            "ValuesLogic(x) ::: x values logic",
            "IsOpenMinded(x) ::: x is open minded",
            "IsCurious(x) ::: x is curious"
        ]
    },
    {
        "premises-NL": [
            "John is a student.",
            "All students who are smart pass the exam.",
            "John is smart.",
            "Students who study are smart.",
            "John likes to study.",
            "If someone likes to study, then they study.",
            "Mary is a student.",
            "Mary likes to study.",
            "Mary studies.",
            "Mary passes the exam."
        ],
        "premises-FOL": [
            "Student(john) ::: John is a student",
            "∀x (Student(x) ∧ Smart(x) → PassesExam(x)) ::: All students who are smart pass the exam",
            "Smart(john) ::: John is smart",
            "∀x (Student(x) ∧ Studies(x) → Smart(x)) ::: Students who study are smart",
            "Likes(john, studying) ::: John likes to study",
            "∀x (Likes(x, studying) → Studies(x)) ::: If someone likes to study, then they study",
            "Student(mary) ::: Mary is a student",
            "Likes(mary, studying) ::: Mary likes to study",
            "Studies(mary) ::: Mary studies",
            "PassesExam(mary) ::: Mary passes the exam"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "Smart(x) ::: x is smart",
            "PassesExam(x) ::: x passes the exam",
            "Likes(x, y) ::: x likes y"
        ]
    },
    {
        "premises-NL": [
            "All doctors have a degree.",
            "Anyone who studies medicine becomes a doctor.",
            "Some people who study medicine smoke.",
            "Not everyone who has a degree is a smoker.",
            "Some doctors are smokers.",
            "Doctors either help patients or they don't.",
            "If someone is a doctor, then they studied medicine.",
            "John is a doctor.",
            "John doesn't help patients."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HasDegree(x)) ::: All doctors have a degree.",
            "∀x (StudiesMedicine(x) → Doctor(x)) ::: Anyone who studies medicine becomes a doctor.",
            "∃x (StudiesMedicine(x) ∧ Smoker(x)) ::: Some people who study medicine smoke.",
            "∃x (HasDegree(x) ∧ ¬Smoker(x)) ::: Not everyone who has a degree is a smoker.",
            "∃x (Doctor(x) ∧ Smoker(x)) ::: Some doctors are smokers.",
            "∀x (Doctor(x) → (HelpsPatients(x) ∨ ¬HelpsPatients(x))) ::: Doctors either help patients or they don't.",
            "∀x (Doctor(x) → StudiesMedicine(x)) ::: If someone is a doctor, then they studied medicine.",
            "Doctor(john) ::: John is a doctor.",
            "¬HelpsPatients(john) ::: John doesn't help patients."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Smoker(x) ::: x is a smoker.",
            "HelpsPatients(x) ::: x helps patients.",
            "HasDegree(x) ::: x has a degree.",
            "StudiesMedicine(x) ::: x studies medicine."
        ]
    },
    {
        "premises-NL": [
            "Everyone who eats fruit likes either apples or bananas.",
            "Someone is vegetarian and eats apples.",
            "No one who eats bananas is vegetarian.",
            "If someone likes bananas, then they eat fruit.",
            "Some vegetarians are healthy.",
            "John likes apples.",
            "If someone eats fruit they are healthy.",
            "If someone is healthy they don't like bananas.",
            "Someone likes apples."
        ],
        "premises-FOL": [
            "∀x (EatsFruit(x) → (LikesApples(x) ∨ LikesBananas(x))) ::: Everyone who eats fruit likes either apples or bananas.",
            "∃x (IsVegetarian(x) ∧ EatsFruit(x) ∧ LikesApples(x)) ::: Someone is vegetarian and eats apples.",
            "∀x (LikesBananas(x) → ¬IsVegetarian(x)) ::: No one who eats bananas is vegetarian.",
            "∀x (LikesBananas(x) → EatsFruit(x)) ::: If someone likes bananas, then they eat fruit.",
            "∃x (IsVegetarian(x) ∧ IsHealthy(x)) ::: Some vegetarians are healthy.",
            "LikesApples(john) ::: John likes apples.",
            "∀x (EatsFruit(x) → IsHealthy(x)) ::: If someone eats fruit they are healthy.",
            "∀x (IsHealthy(x) → ¬LikesBananas(x)) ::: If someone is healthy they don't like bananas.",
            "∃x LikesApples(x) ::: Someone likes apples."
        ],
        "predicates": [
            "LikesApples(x) ::: x likes apples.",
            "LikesBananas(x) ::: x likes bananas.",
            "EatsFruit(x) ::: x eats fruit.",
            "IsHealthy(x) ::: x is healthy.",
            "IsVegetarian(x) ::: x is vegetarian."
        ]
    },
    {
        "premises-NL": [
            "All students attend classes.",
            "Alice is a student.",
            "Anyone who attends classes studies hard.",
            "Alice likes coffee.",
            "Anyone who likes coffee reads books.",
            "Alice has books.",
            "Anyone who has books reads books.",
            "If someone studies hard, they will pass the exam.",
            "If someone reads books, they will study hard.",
            "Students can read books.",
            "Alice attends classes.",
            "Alice reads books.",
            "Alice studies hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClasses(x)) ::: All students attend classes",
            "Student(Alice) ::: Alice is a student",
            "∀x (AttendsClasses(x) → StudiesHard(x)) ::: Anyone who attends classes studies hard",
            "LikesCoffee(Alice) ::: Alice likes coffee",
            "∀x (LikesCoffee(x) → ReadsBooks(x)) ::: Anyone who likes coffee reads books",
            "HasBooks(Alice) ::: Alice has books",
            "∀x (HasBooks(x) → ReadsBooks(x)) ::: Anyone who has books reads books",
            "∀x (StudiesHard(x) → PassExam(x)) ::: If someone studies hard, they will pass the exam",
            "∀x (ReadsBooks(x) → StudiesHard(x)) ::: If someone reads books, they will study hard",
            "∀x (Student(x) → ReadsBooks(x)) ::: Students can read books",
            "AttendsClasses(Alice) ::: Alice attends classes",
            "ReadsBooks(Alice) ::: Alice reads books",
            "StudiesHard(Alice) ::: Alice studies hard"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x will pass the exam",
            "AttendsClasses(x) ::: x attends classes",
            "LikesCoffee(x) ::: x likes coffee",
            "HasBooks(x) ::: x has books",
            "ReadsBooks(x) ::: x reads books"
        ]
    },
    {
        "premises-NL": [
            "All doctors have medical degrees.",
            "Bob has a medical degree or Bob has a PhD.",
            "Anyone with a medical degree works at a hospital.",
            "If someone works at a hospital, then they are a doctor.",
            "All scientists conduct research.",
            "Bob conducts research or Bob has a PhD.",
            "If someone has a PhD and specializes in biology, then they are a scientist.",
            "Bob specializes in biology.",
            "If someone is a doctor, then they don't specialize in biology.",
            "If Bob conducts research and Bob specializes in biology, Bob is a scientist.",
            "Bob does not specialize in biology implies Bob is a doctor.",
            "If Bob is not a doctor, then Bob has a PhD",
            "Bob has a PhD or Bob is a doctor.",
            "If Bob works at a hospital, then Bob is a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HasMedicalDegree(x)) ::: All doctors have medical degrees",
            "HasMedicalDegree(Bob) ∨ HasPhD(Bob) ::: Bob has a medical degree or Bob has a PhD.",
            "∀x (HasMedicalDegree(x) → WorksAtHospital(x)) ::: Anyone with a medical degree works at a hospital",
            "∀x (WorksAtHospital(x) → Doctor(x)) ::: If someone works at a hospital, then they are a doctor",
            "∀x (Scientist(x) → ConductsResearch(x)) ::: All scientists conduct research",
            "ConductsResearch(Bob) ∨ HasPhD(Bob) ::: Bob conducts research or Bob has a PhD.",
            "∀x (HasPhD(x) ∧ SpecializesInBiology(x) → Scientist(x)) ::: If someone has a PhD and specializes in biology, then they are a scientist.",
            "SpecializesInBiology(Bob) ::: Bob specializes in biology",
            "∀x (Doctor(x) → ¬SpecializesInBiology(x)) ::: If someone is a doctor, then they don't specialize in biology.",
            "ConductsResearch(Bob) ∧ SpecializesInBiology(Bob) → Scientist(Bob) ::: If Bob conducts research and Bob specializes in biology, Bob is a scientist.",
            "¬SpecializesInBiology(Bob) → Doctor(Bob) ::: Bob does not specialize in biology implies Bob is a doctor.",
            "¬Doctor(Bob) → HasPhD(Bob) ::: If Bob is not a doctor, then Bob has a PhD",
            "HasPhD(Bob) ∨ Doctor(Bob) ::: Bob has a PhD or Bob is a doctor.",
            "WorksAtHospital(Bob) → Doctor(Bob) ::: If Bob works at a hospital, then Bob is a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Scientist(x) ::: x is a scientist",
            "HasMedicalDegree(x) ::: x has a medical degree",
            "WorksAtHospital(x) ::: x works at a hospital",
            "ConductsResearch(x) ::: x conducts research",
            "HasPhD(x) ::: x has a PhD",
            "SpecializesInBiology(x) ::: x specializes in biology"
        ]
    },
    {
        "premises-NL": [
            "All students attend class.",
            "David is a student.",
            "Anyone who attends class studies hard.",
            "If someone likes to study, then they study hard.",
            "David doesn't like to study.",
            "If someone studies hard, they are smart.",
            "David reads books or David passes exams.",
            "Anyone who passes exams is smart.",
            "If someone is smart, they like to study.",
            "If someone reads books, they study hard.",
            "If David studies hard, he will pass exams.",
            "David attends class or David does not like to study.",
            "David passes exams or David is not smart.",
            "If David reads books, then he likes to study.",
            "If David is not smart, then he does not study hard.",
            "David studies hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClass(x)) ::: All students attend class.",
            "Student(David) ::: David is a student.",
            "∀x (AttendsClass(x) → StudiesHard(x)) ::: Anyone who attends class studies hard.",
            "∀x (LikesToStudy(x) → StudiesHard(x)) ::: If someone likes to study, then they study hard.",
            "¬LikesToStudy(David) ::: David doesn't like to study.",
            "∀x (StudiesHard(x) → Smart(x)) ::: If someone studies hard, they are smart.",
            "ReadsBooks(David) ∨ PassesExams(David) ::: David reads books or David passes exams.",
            "∀x (PassesExams(x) → Smart(x)) ::: Anyone who passes exams is smart.",
            "∀x (Smart(x) → LikesToStudy(x)) ::: If someone is smart, they like to study.",
            "∀x (ReadsBooks(x) → StudiesHard(x)) ::: If someone reads books, they study hard.",
            "StudiesHard(David) → PassesExams(David) ::: If David studies hard, he will pass exams.",
            "AttendsClass(David) ∨ ¬LikesToStudy(David) ::: David attends class or David does not like to study.",
            "PassesExams(David) ∨ ¬Smart(David) ::: David passes exams or David is not smart.",
            "ReadsBooks(David) → LikesToStudy(David) ::: If David reads books, then he likes to study.",
            "¬Smart(David) → ¬StudiesHard(David) ::: If David is not smart, then he does not study hard.",
            "StudiesHard(David) ::: David studies hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "LikesToStudy(x) ::: x likes to study",
            "Smart(x) ::: x is smart",
            "PassesExams(x) ::: x passes exams",
            "StudiesHard(x) ::: x studies hard",
            "AttendsClass(x) ::: x attends class",
            "ReadsBooks(x) ::: x reads books"
        ]
    },
    {
        "premises-NL": [
            "All doctors have medical degrees or have a PhD.",
            "Emma is a doctor.",
            "Anyone who has a medical degree works at a hospital.",
            "If someone works at a hospital, they treat patients.",
            "Emma specializes in surgery.",
            "If someone specializes in surgery and treats patients, they have a medical degree.",
            "Anyone who treats patients has a medical degree or a PhD.",
            "If Emma doesn't have a medical degree, she has a PhD.",
            "Emma does not work at a hospital.",
            "If Emma is a doctor, she specializes in surgery.",
            "If someone has a PhD, they conduct research.",
            "If Emma conducts research, then Emma does not work at a hospital.",
            "If Emma treats patients, then she works at a hospital.",
            "Emma has a medical degree or Emma does not treat patients.",
            "Emma treats patients.",
            "If Emma does not treat patients and is a doctor then she does not work at a hospital.",
            "If Emma has a PhD and works at a hospital then she is a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HasMedicalDegree(x) ∨ HasPhD(x)) ::: All doctors have medical degrees or have a PhD.",
            "Doctor(Emma) ::: Emma is a doctor.",
            "∀x (HasMedicalDegree(x) → WorksAtHospital(x)) ::: Anyone who has a medical degree works at a hospital.",
            "∀x (WorksAtHospital(x) → TreatsPatients(x)) ::: If someone works at a hospital, they treat patients.",
            "SpecializesInSurgery(Emma) ::: Emma specializes in surgery.",
            "∀x (SpecializesInSurgery(x) ∧ TreatsPatients(x) → HasMedicalDegree(x)) ::: If someone specializes in surgery and treats patients, they have a medical degree.",
            "∀x (TreatsPatients(x) → HasMedicalDegree(x) ∨ HasPhD(x)) ::: Anyone who treats patients has a medical degree or a PhD.",
            "¬HasMedicalDegree(Emma) → HasPhD(Emma) ::: If Emma doesn't have a medical degree, she has a PhD.",
            "¬WorksAtHospital(Emma) ::: Emma does not work at a hospital.",
            "Doctor(Emma) → SpecializesInSurgery(Emma) ::: If Emma is a doctor, she specializes in surgery.",
            "∀x (HasPhD(x) → ConductsResearch(x)) ::: If someone has a PhD, they conduct research.",
            "ConductsResearch(Emma) → ¬WorksAtHospital(Emma) ::: If Emma conducts research, then Emma does not work at a hospital.",
            "TreatsPatients(Emma) → WorksAtHospital(Emma) ::: If Emma treats patients, then she works at a hospital.",
            "HasMedicalDegree(Emma) ∨ ¬TreatsPatients(Emma) ::: Emma has a medical degree or Emma does not treat patients.",
            "TreatsPatients(Emma) ::: Emma treats patients.",
            "¬TreatsPatients(Emma) ∧ Doctor(Emma) → ¬WorksAtHospital(Emma) ::: If Emma does not treat patients and is a doctor then she does not work at a hospital.",
            "HasPhD(Emma) ∧ WorksAtHospital(Emma) → Doctor(Emma) ::: If Emma has a PhD and works at a hospital then she is a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "HasMedicalDegree(x) ::: x has a medical degree",
            "WorksAtHospital(x) ::: x works at a hospital",
            "SpecializesInSurgery(x) ::: x specializes in surgery",
            "TreatsPatients(x) ::: x treats patients",
            "HasPhD(x) ::: x has a PhD",
            "ConductsResearch(x) ::: x conducts research"
        ]
    },
    {
        "premises-NL": [
            "All professors are smart.",
            "Anyone who is smart publishes papers.",
            "All those who publish papers are researchers.",
            "Some researchers teach at a university.",
            "John is a professor."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Smart(x)) ::: All professors are smart.",
            "∀x (Smart(x) → PublishesPaper(x)) ::: Anyone who is smart publishes papers.",
            "∀x (PublishesPaper(x) → Researcher(x)) ::: All those who publish papers are researchers.",
            "∃x (Researcher(x) ∧ TeachesAtUniversity(x)) ::: Some researchers teach at a university.",
            "Professor(john) ::: John is a professor."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "Smart(x) ::: x is smart",
            "TeachesAtUniversity(x) ::: x teaches at a university",
            "PublishesPaper(x) ::: x publishes a paper",
            "Researcher(x) ::: x is a researcher"
        ]
    },
    {
        "premises-NL": [
            "All patients with a fever and a cough are likely to have the flu.",
            "Some patients with the flu take medicine.",
            "Anyone who takes medicine and is vaccinated gets better.",
            "Patient A has a fever.",
            "Patient A has a cough.",
            "Patient B takes medicine."
        ],
        "premises-FOL": [
            "∀x ((PatientHasFever(x) ∧ PatientHasCough(x)) → HasFlu(x)) ::: All patients with a fever and a cough are likely to have the flu.",
            "∃x (HasFlu(x) ∧ TakesMedicine(x, y)) ::: Some patients with the flu take medicine.",
            "∀x ∀y ((TakesMedicine(x, y) ∧ IsVaccinated(x)) → GetsBetter(x)) ::: Anyone who takes medicine and is vaccinated gets better.",
            "PatientHasFever(a) ::: Patient A has a fever.",
            "PatientHasCough(a) ::: Patient A has a cough.",
            "TakesMedicine(b, z) ::: Patient B takes medicine."
        ],
        "predicates": [
            "PatientHasFever(x) ::: x is a patient who has a fever",
            "PatientHasCough(x) ::: x is a patient who has a cough",
            "HasFlu(x) ::: x has the flu",
            "TakesMedicine(x, y) ::: x takes medicine y",
            "GetsBetter(x) ::: x gets better",
            "IsVaccinated(x) ::: x is vaccinated"
        ]
    },
    {
        "premises-NL": [
            "If the price of good A increases, then consumer buys good B.",
            "If the price of good B increases, then overall inflation increases.",
            "The price of good A increases.",
            "If the price of good A decreases, then the price of good B does not increase.",
            "The price of good B increases.",
            "If a good is expensive then it impacts overall inflation",
            "If the Production cost increases, then the price of good will increase"
        ],
        "premises-FOL": [
            "∀x (PriceIncrease(a) → ConsumerBuys(x, b)) ::: If the price of good A increases, then consumer buys good B.",
            "∀x (PriceIncrease(b) → OverallInflationIncrease(x)) ::: If the price of good B increases, then overall inflation increases.",
            "PriceIncrease(a) ::: The price of good A increases.",
            "∀x (PriceDecrease(a) → ¬PriceIncrease(b)) ::: If the price of good A decreases, then the price of good B does not increase.",
            "PriceIncrease(b) ::: The price of good B increases.",
            "∀x (GoodIsExpensive(x) → OverallInflationIncrease(x)) ::: If a good is expensive then it impacts overall inflation",
            "∀x (ProductionCostIncrease(x) → PriceIncrease(x)) ::: If the Production cost increases, then the price of good will increase"
        ],
        "predicates": [
            "PriceIncrease(x) ::: The price of x increases",
            "PriceDecrease(x) ::: The price of x decreases",
            "ConsumerBuys(x, y) ::: Consumer x buys good y",
            "GoodIsExpensive(x) ::: Good x is expensive",
            "OverallInflationIncrease(x) ::: Overall inflation increases",
            "ProductionCostIncrease(x) ::: Production cost of x increases",
            "SupplierIsBusy(x) ::: Supplier x is busy"
        ]
    },
    {
        "premises-NL": [
            "All doctors are licensed.",
            "Some doctors are surgeons.",
            "Doctors can be surgeons.",
            "John is a doctor.",
            "John is licensed.",
            "Jane is a doctor.",
            "Jane is a surgeon.",
            "All surgeons are doctors.",
            "John is both a doctor and a surgeon.",
            "If someone is a surgeon, they are a doctor.",
            "If someone is a doctor, they are licensed.",
            "There exists a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Licensed(x)) ::: All doctors are licensed.",
            "∃x (Doctor(x) ∧ Surgeon(x)) ::: Some doctors are surgeons.",
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "Doctor(john) ::: John is a doctor.",
            "Licensed(john) ::: John is licensed.",
            "Doctor(jane) ::: Jane is a doctor.",
            "Surgeon(jane) ::: Jane is a surgeon.",
            "Surgeon(john) ::: John is a surgeon.",
            "∀x (Surgeon(x) → Doctor(x)) ::: If someone is a surgeon, they are a doctor.",
            "∀x (Doctor(x) → Licensed(x)) ::: If someone is a doctor, they are licensed.",
            "∃x Doctor(x) ::: There exists a doctor.",
            "Surgeon(john) ∧ Licensed(john) ::: John is a licensed surgeon."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Licensed(x) ::: x is licensed",
            "Surgeon(x) ::: x is a surgeon"
        ]
    },
    {
        "premises-NL": [
            "All products are either available or not available.",
            "Some products are bestsellers.",
            "If a product is a bestseller, it's popular.",
            "If a product is popular and available, it gets sold.",
            "Product A is a product.",
            "Product A is available.",
            "Product A is a bestseller.",
            "Product B is not available.",
            "Product B is a bestseller.",
            "If a product is not available, it is not sold.",
            "If a product is available and a bestseller, it will be sold.",
            "A product is only sold if it is available and a bestseller.",
            "If a product is sold, then it is available and a bestseller.",
            "Some products are not sold."
        ],
        "premises-FOL": [
            "∀x (Product(x) → (Available(x) ∨ ¬Available(x))) ::: All products are either available or not.",
            "∃x (Product(x) ∧ Bestseller(x)) ::: Some products are bestsellers.",
            "∀x (Bestseller(x) → Popular(x)) ::: If a product is a bestseller, it is popular.",
            "∀x ((Popular(x) ∧ Available(x)) → Sold(x)) ::: If a product is popular and available, it gets sold.",
            "Product(a) ::: Product A is a product.",
            "Available(a) ::: Product A is available.",
            "Bestseller(a) ::: Product A is a bestseller.",
            "¬Available(b) ::: Product B is not available.",
            "Bestseller(b) ::: Product B is a bestseller.",
            "∀x (¬Available(x) → ¬Sold(x)) ::: If a product is not available, it is not sold.",
            "∀x ((Available(x) ∧ Bestseller(x)) → Sold(x)) ::: If available and bestseller, it's sold.",
            "∀x (Sold(x) → (Available(x) ∧ Bestseller(x))) ::: A product is sold only if available and bestseller.",
            "∀x (Sold(x) → (Available(x) ∧ Bestseller(x))) ::: If a product is sold, then it is available and a bestseller.",
            "∃x ¬Sold(x) ::: Some products are not sold."
        ],
        "predicates": [
            "Product(x) ::: x is a product",
            "Available(x) ::: x is available",
            "Bestseller(x) ::: x is a bestseller",
            "Sold(x) ::: x is sold"
        ]
    },
    {
        "premises-NL": [
            "All programmers are employees.",
            "Some employees work remotely.",
            "If someone works remotely, they may not attend the office.",
            "Programmers can be employees.",
            "If an employee has a meeting with the manager, they must attend the office.",
            "John is a programmer.",
            "John works remotely.",
            "John is an employee.",
            "Mary is a programmer.",
            "Mary has a meeting with the manager.",
            "Mary is an employee.",
            "If an employee is a programmer and works remotely, then they may not have to go to the office.",
            "If John is a programmer and works remotely, he doesn't have to go to the office.",
            "Mary must attend the office."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → Employee(x)) ::: All programmers are employees.",
            "∃x (Employee(x) ∧ WorksRemotely(x)) ::: Some employees work remotely.",
            "∀x (WorksRemotely(x) → ¬AttendsOffice(x)) ::: If someone works remotely, they may not attend the office.",
            "∀x (Programmer(x) → Employee(x)) ::: Programmers can be employees.",
            "∀x (Employee(x) ∧ HasMeeting(x,manager) → AttendsOffice(x)) ::: If an employee has a meeting with the manager, they must attend the office.",
            "Programmer(john) ::: John is a programmer.",
            "WorksRemotely(john) ::: John works remotely.",
            "Employee(john) ::: John is an employee.",
            "Programmer(mary) ::: Mary is a programmer.",
            "HasMeeting(mary, manager) ::: Mary has a meeting with the manager.",
            "Employee(mary) ::: Mary is an employee.",
            "∀x ((Programmer(x) ∧ WorksRemotely(x)) → ¬AttendsOffice(x)) ::: If someone is a programmer and works remotely, then they may not have to go to the office.",
            "¬AttendsOffice(john) ::: If John is a programmer and works remotely, he doesn't have to go to the office.",
            "AttendsOffice(mary) ::: Mary must attend the office."
        ],
        "predicates": [
            "Employee(x) ::: x is an employee",
            "Programmer(x) ::: x is a programmer",
            "WorksRemotely(x) ::: x works remotely",
            "AttendsOffice(x) ::: x attends the office",
            "HasMeeting(x, y) ::: x has a meeting with y"
        ]
    },
    {
        "premises-NL": [
            "Every student either passed or failed the exam.",
            "If someone is a student, then they took the exam.",
            "David is a student.",
            "If a student failed the exam, then they did not study.",
            "David studied.",
            "If someone studies, then they will pass the exam.",
            "No students failed and passed the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (PassedExam(x) ∨ ¬PassedExam(x))) ::: Every student either passed or failed the exam",
            "∀x (Student(x) → TookExam(x)) ::: If someone is a student, then they took the exam",
            "Student(david) ::: David is a student",
            "∀x (Student(x) ∧ ¬PassedExam(x) → ¬Studied(x)) ::: If a student failed the exam, then they did not study",
            "Studied(david) ::: David studied",
            "∀x (Studied(x) → PassedExam(x)) ::: If someone studies, then they will pass the exam",
            "¬∃x (Student(x) ∧ PassedExam(x) ∧ ¬PassedExam(x)) ::: No students failed and passed the exam"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PassedExam(x) ::: x passed the exam"
        ]
    },
    {
        "premises-NL": [
            "All doctors are helpful or they like their job.",
            "If someone is a doctor, then they have patients.",
            "If a doctor is helpful, they care about patients.",
            "If someone has patients, then they work in a hospital.",
            "Some doctors don't care about patients.",
            "If someone works in a hospital, then they are a doctor.",
            "Doctors care about their patients or they don't like their job.",
            "If someone is a doctor and likes their job, then they care about patients.",
            "Some doctors do not like their job."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → (Helpful(x) ∨ LikesJob(x))) ::: All doctors are helpful or they like their job",
            "∀x (Doctor(x) → HasPatients(x)) ::: If someone is a doctor, then they have patients",
            "∀x (Helpful(x) → CaresAboutPatients(x)) ::: If a doctor is helpful, they care about patients",
            "∀x (HasPatients(x) → WorksInHospital(x)) ::: If someone has patients, then they work in a hospital",
            "∃x (Doctor(x) ∧ ¬CaresAboutPatients(x)) ::: Some doctors don't care about patients",
            "∀x (WorksInHospital(x) → Doctor(x)) ::: If someone works in a hospital, then they are a doctor",
            "∀x (Doctor(x) → (CaresAboutPatients(x) ∨ ¬LikesJob(x))) ::: Doctors care about their patients or they don't like their job",
            "∀x ((Doctor(x) ∧ LikesJob(x)) → CaresAboutPatients(x)) ::: If someone is a doctor and likes their job, then they care about patients",
            "∃x (Doctor(x) ∧ ¬LikesJob(x)) ::: Some doctors do not like their job"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "LikesJob(x) ::: x likes their job",
            "Helpful(x) ::: x is helpful",
            "Patient(x) ::: x is a patient"
        ]
    },
    {
        "premises-NL": [
            "If someone enjoys reading, then they like to read.",
            "If someone enjoys writing, then they like to write.",
            "If someone likes to read, they read books.",
            "Someone enjoys both reading and writing.",
            "If someone reads books, they are educated.",
            "If someone is educated, then they write.",
            "If someone writes, they write stories.",
            "If someone enjoys reading, then they like writing.",
            "Someone enjoys reading and writing.",
            "If someone likes to write stories, they write books.",
            "If someone writes stories and writes books, they like writing."
        ],
        "premises-FOL": [
            "∀x (Enjoys(x, reading) → LikesToRead(x)) ::: If someone enjoys reading, then they like to read",
            "∀x (Enjoys(x, writing) → LikesToWrite(x)) ::: If someone enjoys writing, then they like to write",
            "∀x (LikesToRead(x) → ReadsBooks(x)) ::: If someone likes to read, they read books",
            "∃x (Enjoys(x, reading) ∧ Enjoys(x, writing)) ::: Someone enjoys both reading and writing",
            "∀x (ReadsBooks(x) → Educated(x)) ::: If someone reads books, they are educated",
            "∀x (Educated(x) → Writes(x)) ::: If someone is educated, then they write",
            "∀x (Writes(x) → WritesStories(x)) ::: If someone writes, they write stories",
            "∀x (Enjoys(x, reading) → LikesToWrite(x)) ::: If someone enjoys reading, then they like writing",
            "∃x (Enjoys(x, reading) ∧ Enjoys(x, writing)) ::: Someone enjoys reading and writing",
            "∀x (WritesStories(x) → WritesBooks(x)) ::: If someone likes to write stories, they write books",
            "∀x ((WritesStories(x) ∧ WritesBooks(x)) → LikesToWrite(x)) ::: If someone writes stories and writes books, they like writing"
        ],
        "predicates": [
            "Enjoys(x, y) ::: x enjoys y",
            "Reading(x) ::: x is reading",
            "Writing(x) ::: x is writing",
            "LikesToRead(x) ::: x likes to read",
            "LikesToWrite(x) ::: x likes to write"
        ]
    },
    {
        "premises-NL": [
            "All students are taking an exam.",
            "If a student is smart, then they will pass the exam.",
            "Some students are not studying.",
            "If a student is not studying, they will either fail or pass.",
            "Some students are smart.",
            "If a student passes the exam, then they are studying.",
            "Every student either fails or passes the exam.",
            "No smart student fails the exam.",
            "There is a student who is not studying.",
            "If a student is not studying, they will fail."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakingExam(x)) ::: All students are taking an exam.",
            "∀x (Smart(x) → PassExam(x)) ::: If a student is smart, then they will pass the exam.",
            "∃x (Student(x) ∧ ¬Studying(x)) ::: Some students are not studying.",
            "∀x (¬Studying(x) → (FailExam(x) ∨ PassExam(x))) ::: If a student is not studying, they will either fail or pass.",
            "∃x (Student(x) ∧ Smart(x)) ::: Some students are smart.",
            "∀x (PassExam(x) → Studying(x)) ::: If a student passes the exam, then they are studying.",
            "∀x (Student(x) → (FailExam(x) ∨ PassExam(x))) ::: Every student either fails or passes the exam.",
            "¬∃x (Smart(x) ∧ FailExam(x)) ::: No smart student fails the exam.",
            "∃x (Student(x) ∧ ¬Studying(x)) ::: There is a student who is not studying.",
            "∀x (Student(x) ∧ ¬Studying(x) → FailExam(x)) ::: If a student is not studying, they will fail."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studying(x) ::: x is studying",
            "PassExam(x) ::: x passes the exam",
            "FailExam(x) ::: x fails the exam",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All cats like milk.",
            "If something likes milk, then it's friendly or chases mice.",
            "If something is friendly, it also likes milk.",
            "Some cats eat fish.",
            "Everything that eats fish is a cat or chases mice.",
            "If something is a cat, it likes milk.",
            "Some cats chase mice.",
            "If something chases mice, then it's not friendly.",
            "Something is friendly or chases mice.",
            "All cats are mammals.",
            "If something is not friendly, it doesn't like milk."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → LikesMilk(x)) ::: All cats like milk.",
            "∀x (LikesMilk(x) → (Friendly(x) ∨ ChasesMice(x))) ::: If something likes milk, then it's friendly or chases mice.",
            "∀x (Friendly(x) → LikesMilk(x)) ::: If something is friendly, it also likes milk.",
            "∃x (Cat(x) ∧ EatsFish(x)) ::: Some cats eat fish.",
            "∀x (EatsFish(x) → (Cat(x) ∨ ChasesMice(x))) ::: Everything that eats fish is a cat or chases mice.",
            "∀x (Cat(x) → LikesMilk(x)) ::: If something is a cat, it likes milk.",
            "∃x (Cat(x) ∧ ChasesMice(x)) ::: Some cats chase mice.",
            "∀x (ChasesMice(x) → ¬Friendly(x)) ::: If something chases mice, then it's not friendly.",
            "∀x (Friendly(x) ∨ ChasesMice(x)) ::: Something is friendly or chases mice.",
            "∀x (Cat(x) → Mammal(x)) ::: All cats are mammals.",
            "∀x (¬Friendly(x) → ¬LikesMilk(x)) ::: If something is not friendly, it doesn't like milk."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Friendly(x) ::: x is friendly",
            "LikesMilk(x) ::: x likes milk",
            "EatsFish(x) ::: x eats fish",
            "ChasesMice(x) ::: x chases mice"
        ]
    },
    {
        "premises-NL": [
            "All scientists work hard.",
            "If someone is rich, then they are happy.",
            "If someone works hard and is not rich, they are not happy.",
            "Some scientists are rich.",
            "Some scientists are not successful.",
            "Everyone who works hard is either rich or successful.",
            "If someone is not rich, they work hard.",
            "All successful people are happy.",
            "If someone is a scientist, they work hard.",
            "Some scientists do not work hard and are not rich.",
            "Everyone who is rich is a scientist.",
            "If someone is not successful, they aren't happy."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → WorksHard(x)) ::: All scientists work hard.",
            "∀x (Rich(x) → Happy(x)) ::: If someone is rich, then they are happy.",
            "∀x ((WorksHard(x) ∧ ¬Rich(x)) → ¬Happy(x)) ::: If someone works hard and is not rich, they are not happy.",
            "∃x (Scientist(x) ∧ Rich(x)) ::: Some scientists are rich.",
            "∃x (Scientist(x) ∧ ¬Successful(x)) ::: Some scientists are not successful.",
            "∀x (WorksHard(x) → (Rich(x) ∨ Successful(x))) ::: Everyone who works hard is either rich or successful.",
            "∀x (¬Rich(x) → WorksHard(x)) ::: If someone is not rich, they work hard.",
            "∀x (Successful(x) → Happy(x)) ::: All successful people are happy.",
            "∀x (Scientist(x) → WorksHard(x)) ::: If someone is a scientist, they work hard.",
            "∃x (Scientist(x) ∧ ¬WorksHard(x) ∧ ¬Rich(x)) ::: Some scientists do not work hard and are not rich.",
            "∀x (Rich(x) → Scientist(x)) ::: Everyone who is rich is a scientist.",
            "∀x (¬Successful(x) → ¬Happy(x)) ::: If someone is not successful, they aren't happy."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Happy(x) ::: x is happy",
            "Rich(x) ::: x is rich",
            "WorksHard(x) ::: x works hard",
            "Successful(x) ::: x is successful"
        ]
    },
    {
        "premises-NL": [
            "All students who receive loans are in debt.",
            "All students must pay fees.",
            "If someone is employed, then they can pay fees.",
            "John receives a loan.",
            "Anyone who has a scholarship doesn't need to pay fees.",
            "If someone studies economics, then they are a student.",
            "Some students are employed.",
            "No one who has a scholarship is in debt.",
            "John is a student.",
            "Students studying economics receive loans.",
            "John is employed.",
            "Some students study economics."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ ReceivesLoan(x) → InDebt(x)) ::: All students who receive loans are in debt.",
            "∀x (Student(x) → PaysFee(x)) ::: All students must pay fees.",
            "∀x (Employed(x) → PaysFee(x)) ::: If someone is employed, then they can pay fees.",
            "ReceivesLoan(John) ::: John receives a loan.",
            "∀x (HasScholarship(x) → ¬PaysFee(x)) ::: Anyone who has a scholarship doesn't need to pay fees.",
            "∀x (StudiesEconomics(x) → Student(x)) ::: If someone studies economics, then they are a student.",
            "∃x (Student(x) ∧ Employed(x)) ::: Some students are employed.",
            "∀x (HasScholarship(x) → ¬InDebt(x)) ::: No one who has a scholarship is in debt.",
            "Student(John) ::: John is a student.",
            "∀x (StudiesEconomics(x) → ReceivesLoan(x)) ::: Students studying economics receive loans.",
            "Employed(John) ::: John is employed.",
            "∃x (Student(x) ∧ StudiesEconomics(x)) ::: Some students study economics."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "InDebt(x) ::: x is in debt",
            "ReceivesLoan(x) ::: x receives a loan",
            "PaysFee(x) ::: x pays a fee",
            "Employed(x) ::: x is employed",
            "HasScholarship(x) ::: x has a scholarship",
            "StudiesEconomics(x) ::: x studies economics"
        ]
    },
    {
        "premises-NL": [
            "All programmers know logic.",
            "Anyone who knows logic is smart.",
            "Alice is a programmer.",
            "Bob is a programmer.",
            "Programmers love coding."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → KnowsLogic(x)) ::: All programmers know logic.",
            "∀x (KnowsLogic(x) → Smart(x)) ::: Anyone who knows logic is smart.",
            "Programmer(alice) ::: Alice is a programmer.",
            "Programmer(bob) ::: Bob is a programmer.",
            "∀x (Programmer(x) → LovesCoding(x)) ::: Programmers love coding."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "KnowsLogic(x) ::: x knows logic",
            "Smart(x) ::: x is smart",
            "LovesCoding(x) ::: x loves coding"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard will pass the exam.",
            "Amelia is a student.",
            "Amelia studies hard.",
            "All smart students like coffee.",
            "No one who enjoys music is smart.",
            "If someone likes coffee, then they do not enjoy music.",
            "Bob is a student.",
            "Bob studies hard.",
            "If Bob studies hard, then he will pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: All students who study hard will pass the exam.",
            "Student(amelia) ::: Amelia is a student.",
            "StudiesHard(amelia) ::: Amelia studies hard.",
            "∀x (Smart(x) → LikesCoffee(x)) ::: All smart students like coffee.",
            "∀x (EnjoysMusic(x) → ¬Smart(x)) ::: No one who enjoys music is smart.",
            "∀x (LikesCoffee(x) → ¬EnjoysMusic(x)) ::: If someone likes coffee, then they do not enjoy music.",
            "Student(bob) ::: Bob is a student.",
            "StudiesHard(bob) ::: Bob studies hard.",
            "StudiesHard(bob) → PassExam(bob) ::: If Bob studies hard, then he will pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesHard(x) ::: x studies hard.",
            "PassExam(x) ::: x passes the exam.",
            "Smart(x) ::: x is smart.",
            "LikesCoffee(x) ::: x likes coffee.",
            "EnjoysMusic(x) ::: x enjoys music."
        ]
    },
    {
        "premises-NL": [
            "All wealthy people are not poor.",
            "David invests in stocks.",
            "All who invest in stocks are wealthy.",
            "Everyone who owns property has savings.",
            "David does not have savings.",
            "If someone is employed, they work hard.",
            "If someone works hard, they are not poor.",
            "All who are wealthy have property.",
            "David works hard.",
            "If someone has savings, they are wealthy.",
            "David is employed."
        ],
        "premises-FOL": [
            "∀x (Wealthy(x) → ¬Poor(x)) ::: All wealthy people are not poor.",
            "InvestsInStocks(david) ::: David invests in stocks.",
            "∀x (InvestsInStocks(x) → Wealthy(x)) ::: All who invest in stocks are wealthy.",
            "∀x (OwnsProperty(x) → HasSavings(x)) ::: Everyone who owns property has savings.",
            "¬HasSavings(david) ::: David does not have savings.",
            "∀x (IsEmployed(x) → WorksHard(x)) ::: If someone is employed, they work hard.",
            "∀x (WorksHard(x) → ¬Poor(x)) ::: If someone works hard, they are not poor.",
            "∀x (Wealthy(x) → OwnsProperty(x)) ::: All who are wealthy have property.",
            "WorksHard(david) ::: David works hard.",
            "∀x (HasSavings(x) → Wealthy(x)) ::: If someone has savings, they are wealthy.",
            "IsEmployed(david) ::: David is employed."
        ],
        "predicates": [
            "Wealthy(x) ::: x is wealthy.",
            "Poor(x) ::: x is poor.",
            "InvestsInStocks(x) ::: x invests in stocks.",
            "OwnsProperty(x) ::: x owns property.",
            "HasSavings(x) ::: x has savings.",
            "WorksHard(x) ::: x works hard.",
            "IsEmployed(x) ::: x is employed."
        ]
    },
    {
        "premises-NL": [
            "Every doctor sees a patient or owns a house.",
            "All doctors own cars.",
            "Some doctors are wealthy.",
            "John is a doctor.",
            "If someone is a doctor, they owns a car.",
            "If someone owns a car, they see a patient.",
            "If someone is a doctor, they see a patient.",
            "Sarah is a doctor.",
            "Sarah owns a car.",
            "John owns a car.",
            "John is a patient.",
            "Sarah is a patient.",
            "Some doctors owns a car.",
            "Everyone who is a doctor owns a car or owns a house.",
            "If someone is a doctor then they sees a patient."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → SeesPatient(x) ∨ OwnsHouse(x)) ::: Every doctor sees a patient or owns a house.",
            "∀x (Doctor(x) → OwnsCar(x)) ::: All doctors own cars.",
            "∃x (Doctor(x) ∧ Wealthy(x)) ::: Some doctors are wealthy.",
            "Doctor(john) ::: John is a doctor.",
            "∀x (Doctor(x) → OwnsCar(x)) ::: If someone is a doctor, they owns a car.",
            "∀x (OwnsCar(x) → SeesPatient(x)) ::: If someone owns a car, they see a patient.",
            "∀x (Doctor(x) → SeesPatient(x)) ::: If someone is a doctor, they see a patient.",
            "Doctor(sarah) ::: Sarah is a doctor.",
            "OwnsCar(sarah) ::: Sarah owns a car.",
            "OwnsCar(john) ::: John owns a car.",
            "Patient(john) ::: John is a patient.",
            "Patient(sarah) ::: Sarah is a patient.",
            "∃x (Doctor(x) ∧ OwnsCar(x)) ::: Some doctors owns a car.",
            "∀x (Doctor(x) → OwnsCar(x) ∨ OwnsHouse(x)) ::: Everyone who is a doctor owns a car or owns a house.",
            "∀x (Doctor(x) → SeesPatient(x)) ::: If someone is a doctor then they sees a patient."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "OwnsCar(x) ::: x owns a car",
            "OwnsHouse(x) ::: x owns a house",
            "Patient(x) ::: x is a patient"
        ]
    },
    {
        "premises-NL": [
            "No programmer is a doctor.",
            "John is a programmer.",
            "Sarah is a doctor.",
            "If someone is a doctor, they sees patients.",
            "If someone is a programmer, they are wealthy.",
            "No doctor is wealthy.",
            "John is wealthy.",
            "Sarah sees patients.",
            "If someone is a programmer, they are not a doctor.",
            "If someone is a programmer, they don't sees patients.",
            "If someone is a doctor, they don't a programmer.",
            "If someone sees patients, then they are a doctor.",
            "If someone doesn't sees patients, they are a programmer.",
            "John is not a doctor.",
            "If someone is a doctor they don't sees patients.",
            "Programmers are not doctors."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → ¬Doctor(x)) ::: No programmer is a doctor.",
            "Programmer(john) ::: John is a programmer.",
            "Doctor(sarah) ::: Sarah is a doctor.",
            "∀x (Doctor(x) → SeesPatient(x)) ::: If someone is a doctor, they sees patients.",
            "∀x (Programmer(x) → Wealthy(x)) ::: If someone is a programmer, they are wealthy.",
            "∀x (Doctor(x) → ¬Wealthy(x)) ::: No doctor is wealthy.",
            "Wealthy(john) ::: John is wealthy.",
            "SeesPatient(sarah) ::: Sarah sees patients.",
            "∀x (Programmer(x) → ¬Doctor(x)) ::: If someone is a programmer, they are not a doctor.",
            "∀x (Programmer(x) → ¬SeesPatient(x)) ::: If someone is a programmer, they don't sees patients.",
            "∀x (Doctor(x) → ¬Programmer(x)) ::: If someone is a doctor, they don't a programmer.",
            "∀x (SeesPatient(x) → Doctor(x)) ::: If someone sees patients, then they are a doctor.",
            "∀x (¬SeesPatient(x) → Programmer(x)) ::: If someone doesn't sees patients, they are a programmer.",
            "¬Doctor(john) ::: John is not a doctor.",
            "∀x (Doctor(x) → ¬SeesPatient(x)) ::: If someone is a doctor they don't sees patients.",
            "∀x (Programmer(x) → ¬Doctor(x)) ::: Programmers are not doctors."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "Doctor(x) ::: x is a doctor",
            "Patient(x) ::: x is a patient",
            "Wealthy(x) ::: x is wealthy"
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled.",
            "No student takes both history and math.",
            "If someone is a student, then they take either math or science or both.",
            "If someone is a student, they do not take history.",
            "John is a student and takes math.",
            "Sarah takes science.",
            "If someone is a student, they take science or math.",
            "Anyone who takes math is a student.",
            "No one takes both history and science.",
            "John takes math or science.",
            "If someone takes math, then they do not take history.",
            "If someone takes science, then they do not take history.",
            "If someone is a student, then they take math or science.",
            "Anyone who is enrolled is a student.",
            "Sarah is a student.",
            "If someone is a student and take either math or science, then that person does not take history.",
            "No one takes history."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x)) ::: All students are enrolled.",
            "∀x ¬(TakesHistory(x) ∧ TakesMath(x)) ::: No student takes both history and math.",
            "∀x (Student(x) → (TakesMath(x) ∨ TakesScience(x))) ::: If someone is a student, then they take either math or science or both.",
            "∀x (Student(x) → ¬TakesHistory(x)) ::: If someone is a student, they do not take history.",
            "Student(john) ∧ TakesMath(john) ::: John is a student and takes math.",
            "TakesScience(sarah) ::: Sarah takes science.",
            "∀x (Student(x) → (TakesScience(x) ∨ TakesMath(x))) ::: If someone is a student, they take science or math.",
            "∀x (TakesMath(x) → Student(x)) ::: Anyone who takes math is a student.",
            "∀x ¬(TakesHistory(x) ∧ TakesScience(x)) ::: No one takes both history and science.",
            "TakesMath(john) ∨ TakesScience(john) ::: John takes math or science.",
            "∀x (TakesMath(x) → ¬TakesHistory(x)) ::: If someone takes math, then they do not take history.",
            "∀x (TakesScience(x) → ¬TakesHistory(x)) ::: If someone takes science, then they do not take history.",
            "∀x (Student(x) → (TakesMath(x) ∨ TakesScience(x))) ::: If someone is a student, then they take math or science.",
            "∀x (Enrolled(x) → Student(x)) ::: Anyone who is enrolled is a student.",
            "Student(sarah) ::: Sarah is a student.",
            "∀x ((Student(x) ∧ (TakesMath(x) ∨ TakesScience(x))) → ¬TakesHistory(x)) ::: If someone is a student and take either math or science, then that person does not take history.",
            "∀x ¬TakesHistory(x) ::: No one takes history."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "TakesMath(x) ::: x takes Math",
            "TakesScience(x) ::: x takes Science",
            "TakesHistory(x) ::: x takes History",
            "Enrolled(x) ::: x is enrolled"
        ]
    },
    {
        "premises-NL": [
            "All students are members of group A.",
            "All students are members of group B.",
            "If someone is in group A and likes pizza, they are also in group C.",
            "If someone is in group B and likes pizza, they are also in group C.",
            "All students like pizza.",
            "John is a student.",
            "John likes pizza."
        ],
        "premises-FOL": [
            "∀x (IsStudent(x) → MemberA(x)) ::: All students are members of group A.",
            "∀x (IsStudent(x) → MemberB(x)) ::: All students are members of group B.",
            "∀x (MemberA(x) ∧ Likes(x, pizza) → MemberC(x)) ::: If someone is in group A and likes pizza, they are also in group C.",
            "∀x (MemberB(x) ∧ Likes(x, pizza) → MemberC(x)) ::: If someone is in group B and likes pizza, they are also in group C.",
            "∀x (IsStudent(x) → Likes(x, pizza)) ::: All students like pizza.",
            "IsStudent(john) ::: John is a student.",
            "Likes(john, pizza) ::: John likes pizza.",
            "MemberA(john) ::: John is a member of group A.",
            "MemberB(john) ::: John is a member of group B.",
            "MemberA(john) ∧ Likes(john, pizza) ::: John is a member of group A and likes pizza.",
            "MemberB(john) ∧ Likes(john, pizza) ::: John is a member of group B and likes pizza.",
            "MemberC(john) ::: John is a member of group C.",
            "∀x ((MemberA(x) ∧ MemberB(x)) → MemberC(x)) ::: If someone is a member of both groups, then they are also a member of group C."
        ],
        "predicates": [
            "MemberA(x) ::: x is a member of group A",
            "MemberB(x) ::: x is a member of group B",
            "MemberC(x) ::: x is a member of group C",
            "IsStudent(x) ::: x is a student",
            "Likes(x, y) ::: x likes y"
        ]
    },
    {
        "premises-NL": [
            "All athletes take sports classes.",
            "John is an athlete.",
            "All sports classes are in the university.",
            "John is enrolled in a sports class.",
            "If someone is enrolled in a class in the university, then they are a student."
        ],
        "premises-FOL": [
            "∀x (Athlete(x) → Takes(x, y)) ::: For all x, if x is an athlete, then x takes y.",
            "Athlete(john) ::: John is an athlete.",
            "∀y (SportsClass(y) → EnrolledIn(y, university)) ::: For all y, if y is a sports class, then y is enrolled in university.",
            "Takes(john, sportsClass1) ::: John takes sportsClass1.",
            "∀x ∀y (EnrolledIn(x, y) → Student(x)) ::: For all x and y, if x is enrolled in y, then x is a student."
        ],
        "predicates": [
            "Athlete(x) ::: x is an athlete",
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in y",
            "SportsClass(y) ::: y is a sports class",
            "Takes(x, y) ::: x takes y"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All surgeons know medical facts.",
            "Anyone who knows medical facts is well-informed.",
            "Surgery is a medical field.",
            "Every doctor is either a surgeon or specializes in a medical field.",
            "If someone specializes in a medical field, they are a doctor."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: For all x, if x is a surgeon, then x is a doctor.",
            "∀x (Surgeon(x) → KnowsMedicalFacts(x)) ::: For all x, if x is a surgeon, then x knows medical facts.",
            "∀x (KnowsMedicalFacts(x) → WellInformed(x)) ::: For all x, if x knows medical facts, then x is well-informed.",
            "MedicalField(surgery) ::: Surgery is a medical field.",
            "∀x (Doctor(x) → (Surgeon(x) ∨ SpecializedIn(x, surgery))) ::: For all x, if x is a doctor, then x is a surgeon or specializes in surgery.",
            "∀x ∀y (SpecializedIn(x, y) → Doctor(x)) ::: For all x and y, if x specializes in y, then x is a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "KnowsMedicalFacts(x) ::: x knows medical facts",
            "WellInformed(x) ::: x is well-informed",
            "SpecializedIn(x, y) ::: x is specialized in y",
            "MedicalField(y) ::: y is a medical field"
        ]
    },
    {
        "premises-NL": [
            "All students attend classes.",
            "Everyone who likes to study studies hard.",
            "Anyone who does not study hard fails the exam.",
            "If someone fails the exam, they do not pass it.",
            "Some students do not like to study.",
            "Anyone who takes the exam and attends the classes gets a good grade.",
            "If someone gets a good grade, they pass the exam.",
            "Not all students study hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClasses(x)) ::: For all x, if x is a student, then x attends classes.",
            "∀x (LikesToStudy(x) → StudiesHard(x)) ::: For all x, if x likes to study, then x studies hard.",
            "∀x (¬StudiesHard(x) → FailsExam(x)) ::: For all x, if x does not study hard, then x fails the exam.",
            "∀x (FailsExam(x) → ¬PassesExam(x)) ::: For all x, if x fails the exam, then x does not pass the exam.",
            "∃x (Student(x) ∧ ¬LikesToStudy(x)) ::: There exists an x such that x is a student and x does not like to study.",
            "∀x (TakesExam(x) ∧ AttendsClasses(x) → GoodGrade(x)) ::: For all x, if x takes the exam and attends classes, then x gets a good grade.",
            "∀x (GoodGrade(x) → PassesExam(x)) ::: For all x, if x gets a good grade, then x passes the exam.",
            "¬∀x (StudiesHard(x) ∧ Student(x)) ::: It is not the case that for all x, x studies hard and x is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "LikesToStudy(x) ::: x likes to study",
            "PassesExam(x) ::: x passes the exam",
            "AttendsClasses(x) ::: x attends classes",
            "StudiesHard(x) ::: x studies hard",
            "FailsExam(x) ::: x fails the exam",
            "TakesExam(x) ::: x takes the exam",
            "GoodGrade(x) ::: x gets a good grade"
        ]
    },
    {
        "premises-NL": [
            "All doctors have studied medicine.",
            "Anyone who studies medicine takes exams.",
            "If someone takes exams, they will pass.",
            "Doctors are researchers.",
            "Researchers publish papers.",
            "If you study something, you have knowledge about it.",
            "Scientists study nature.",
            "If you study nature, you become a scientist.",
            "If you publish papers, you are considered intelligent.",
            "If someone is a doctor, they study medicine.",
            "If someone passes an exam, they are intelligent.",
            "Some doctors study nature.",
            "If someone is a scientist, they publish papers.",
            "Someone is a doctor and a scientist.",
            "Scientists are researchers.",
            "If someone is a doctor, they are considered intelligent.",
            "If someone is a researcher, they study nature.",
            "Some doctors publish papers."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Studies(x, Medicine)) ::: All doctors have studied medicine.",
            "∀x (Studies(x, Medicine) → TakesExam(x)) ::: Anyone who studies medicine takes exams.",
            "∀x (TakesExam(x) → PassExam(x, y)) ::: If someone takes exams, they will pass.",
            "∀x (Doctor(x) → Researcher(x)) ::: Doctors are researchers.",
            "∀x (Researcher(x) → Publishes(x, y)) ::: Researchers publish papers.",
            "∀x ∀y (Studies(x, y) → KnowsAbout(x, y)) ::: If you study something, you have knowledge about it.",
            "∀x (Scientist(x) → Studies(x, Nature)) ::: Scientists study nature.",
            "∀x (Studies(x, Nature) → Scientist(x)) ::: If you study nature, you become a scientist.",
            "∀x (Publishes(x, y) → Intelligent(x)) ::: If you publish papers, you are considered intelligent.",
            "∀x (Doctor(x) → Studies(x, Medicine)) ::: If someone is a doctor, they study medicine.",
            "∀x (PassExam(x, y) → Intelligent(x)) ::: If someone passes an exam, they are intelligent.",
            "∃x (Doctor(x) ∧ Studies(x, Nature)) ::: Some doctors study nature.",
            "∀x (Scientist(x) → Publishes(x, y)) ::: If someone is a scientist, they publish papers.",
            "∃x (Doctor(x) ∧ Scientist(x)) ::: Someone is a doctor and a scientist.",
            "∀x (Scientist(x) → Researcher(x)) ::: Scientists are researchers.",
            "∀x (Doctor(x) → Intelligent(x)) ::: If someone is a doctor, they are considered intelligent.",
            "∀x (Researcher(x) → Studies(x, Nature)) ::: If someone is a researcher, they study nature.",
            "∃x (Doctor(x) ∧ Publishes(x, y)) ::: Some doctors publish papers."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Scientist(x) ::: x is a scientist",
            "Intelligent(x) ::: x is intelligent",
            "Studies(x, y) ::: x studies y",
            "PassExam(x, y) ::: x passes exam y",
            "Researcher(x) ::: x is a researcher",
            "Publishes(x, y) ::: x publishes y"
        ]
    },
    {
        "premises-NL": [
            "Alex studies or he likes coffee.",
            "If Alex likes coffee, then he will not pass the exam.",
            "Alex knows Bob.",
            "If Alex knows Bob, then he studies.",
            "Alex likes coffee or Alex knows Bob.",
            "If Alex studies, then Alex will pass the exam."
        ],
        "premises-FOL": [
            "Study(Alex) ∨ LikesCoffee(Alex) ::: Alex studies or he likes coffee",
            "LikesCoffee(Alex) → ¬PassExam(Alex) ::: If Alex likes coffee, then he will not pass the exam",
            "Knows(Alex, Bob) ::: Alex knows Bob",
            "Knows(Alex, Bob) → Study(Alex) ::: If Alex knows Bob, then he studies",
            "LikesCoffee(Alex) ∨ Knows(Alex, Bob) ::: Alex likes coffee or Alex knows Bob",
            "Study(Alex) → PassExam(Alex) ::: If Alex studies, then Alex will pass the exam"
        ],
        "predicates": [
            "Study(x) ::: x studies",
            "PassExam(x) ::: x passes the exam",
            "LikesCoffee(x) ::: x likes coffee",
            "Knows(x,y) ::: x knows y"
        ]
    },
    {
        "premises-NL": [
            "All doctors are specialists.",
            "John is a doctor.",
            "If someone is a specialist, then they know how to treat the patient.",
            "Either John is a doctor or John treats the patient.",
            "If John treats the patient, then he is a doctor.",
            "If John is a specialist, then John knows how to treat the patient.",
            "John treats the patient."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Specialist(x)) ::: All doctors are specialists",
            "Doctor(John) ::: John is a doctor",
            "∀x (Specialist(x) → KnowsTreatment(x, Patient)) ::: If someone is a specialist, then they know how to treat the patient",
            "Doctor(John) ∨ TreatsPatient(John, Patient) ::: Either John is a doctor or John treats the patient",
            "TreatsPatient(John, Patient) → Doctor(John) ::: If John treats the patient, then he is a doctor",
            "Specialist(John) → KnowsTreatment(John, Patient) ::: If John is a specialist, then John knows how to treat the patient",
            "TreatsPatient(John, Patient) ::: John treats the patient"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Specialist(x) ::: x is a specialist",
            "KnowsTreatment(x, y) ::: x knows how to treat y",
            "TreatsPatient(x,y) ::: x treats y",
            "Patient(x) ::: x is a patient"
        ]
    },
    {
        "premises-NL": [
            "John likes Mary or John attends the event.",
            "Mary likes John.",
            "If John attends the event, then Mary studies.",
            "If Mary studies, then she is smart.",
            "If Mary is smart, then she likes John.",
            "If Mary likes John, then she reads a book.",
            "John likes Mary.",
            "If John reads a book, then he gets good grades.",
            "John and Mary enjoy the event.",
            "If John gets good grades, then he is smart."
        ],
        "premises-FOL": [
            "Likes(John, Mary) ∨ Attends(John, Event) ::: John likes Mary or John attends the event",
            "Likes(Mary, John) ::: Mary likes John",
            "Attends(John, Event) → Studies(Mary, Subject) ::: If John attends the event, then Mary studies",
            "Studies(Mary, Subject) → Smart(Mary) ::: If Mary studies, then she is smart",
            "Smart(Mary) → Likes(John, Mary) ::: If Mary is smart, then she likes John",
            "Likes(Mary, John) → Reads(Mary, Book) ::: If Mary likes John, then she reads a book",
            "Likes(John, Mary) ::: John likes Mary",
            "Reads(John, Book) → GoodGrades(John) ::: If John reads a book, then he gets good grades",
            "Enjoys(John, Event) ∧ Enjoys(Mary, Event) ::: John and Mary enjoy the event",
            "GoodGrades(John) → Smart(John) ::: If John gets good grades, then he is smart"
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Friends(x, y) ::: x and y are friends",
            "Attends(x, y) ::: x attends y",
            "Studies(x, y) ::: x studies y",
            "Smart(x) ::: x is smart",
            "Enjoys(x, y) ::: x enjoys y",
            "Reads(x, y) ::: x reads y",
            "IsBook(x) ::: x is a book",
            "GoodGrades(x) ::: x gets good grades"
        ]
    },
    {
        "premises-NL": [
            "All students who attend classes study hard.",
            "John is a student.",
            "Anyone who attends classes has a chance to pass the exam.",
            "John attends classes.",
            "If someone studies hard, they might pass the exam.",
            "Some students have a chance to pass the exam.",
            "Students who study hard are a subset of students."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ AttendsClasses(x) → StudyHard(x)) ::: All students who attend classes study hard.",
            "Student(John) ::: John is a student.",
            "∀x (AttendsClasses(x) → PassExam(x)) ::: Anyone who attends classes has a chance to pass the exam.",
            "AttendsClasses(John) ::: John attends classes.",
            "∀x (StudyHard(x) → PassExam(x)) ::: If someone studies hard, they might pass the exam.",
            "∃x (Student(x) ∧ PassExam(x)) ::: Some students have a chance to pass the exam.",
            "∀x (StudyHard(x) → Student(x)) ::: Students who study hard are a subset of students."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudyHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "AttendsClasses(x) ::: x attends classes"
        ]
    },
    {
        "premises-NL": [
            "All managers are employees.",
            "All managers are efficient.",
            "Some employees are managers.",
            "If someone is a manager, then they are smart.",
            "If someone is smart, then they are efficient.",
            "All efficient people work at CompanyA.",
            "John is an employee.",
            "John is a manager.",
            "All employees either work at CompanyA or CompanyB.",
            "If someone is not efficient, they are not a manager.",
            "No managers work at CompanyB.",
            "Some employees are not smart.",
            "Everyone who works at company A, is a manager.",
            "If someone is a manager and employee, they are efficient.",
            "Every manager is an employee who either works at Company A or Company B."
        ],
        "premises-FOL": [
            "∀x (Manager(x) → Employee(x)) ::: All managers are employees.",
            "∀x (Manager(x) → Efficient(x)) ::: All managers are efficient.",
            "∃x (Employee(x) ∧ Manager(x)) ::: Some employees are managers.",
            "∀x (Manager(x) → Smart(x)) ::: If someone is a manager, then they are smart.",
            "∀x (Smart(x) → Efficient(x)) ::: If someone is smart, then they are efficient.",
            "∀x (Efficient(x) → WorksAt(x, CompanyA)) ::: All efficient people work at CompanyA.",
            "Employee(John) ::: John is an employee.",
            "Manager(John) ::: John is a manager.",
            "∀x (Employee(x) → (WorksAt(x, CompanyA) ∨ WorksAt(x, CompanyB))) ::: All employees either work at CompanyA or CompanyB.",
            "∀x (¬Efficient(x) → ¬Manager(x)) ::: If someone is not efficient, they are not a manager.",
            "∀x (Manager(x) → ¬WorksAt(x, CompanyB)) ::: No managers work at CompanyB.",
            "∃x (Employee(x) ∧ ¬Smart(x)) ::: Some employees are not smart.",
            "∀x (WorksAt(x, CompanyA) → Manager(x)) ::: Everyone who works at company A, is a manager.",
            "∀x (Manager(x) ∧ Employee(x) → Efficient(x)) ::: If someone is a manager and employee, they are efficient.",
            "∀x (Manager(x) → (Employee(x) ∧ (WorksAt(x, CompanyA) ∨ WorksAt(x, CompanyB)))) ::: Every manager is an employee who either works at Company A or Company B."
        ],
        "predicates": [
            "Employee(x) ::: x is an employee",
            "Manager(x) ::: x is a manager",
            "Efficient(x) ::: x is efficient",
            "Smart(x) ::: x is smart",
            "WorksAt(x, y) ::: x works at y"
        ]
    },
    {
        "premises-NL": [
            "Alice likes everyone who is a friend of Bob.",
            "If someone is a friend of Bob, then Bob likes them.",
            "Carol is a friend of Bob.",
            "Alice is a student.",
            "Bob is a student.",
            "Carol is a student.",
            "Alice likes Bob."
        ],
        "premises-FOL": [
            "∀x (Friends(bob, x) → Likes(alice, x)) ::: For all x, if x is a friend of Bob, then Alice likes x.",
            "∀x (Friends(bob, x) → Likes(bob, x)) ::: For all x, if x is a friend of Bob, then Bob likes x.",
            "Friends(bob, carol) ::: Carol is a friend of Bob.",
            "Student(alice) ::: Alice is a student.",
            "Student(bob) ::: Bob is a student.",
            "Student(carol) ::: Carol is a student.",
            "Likes(alice, bob) ::: Alice likes Bob."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Friends(x, y) ::: x and y are friends",
            "Student(x) ::: x is a student"
        ]
    },
    {
        "premises-NL": [
            "Every student either studies hard or doesn't study hard.",
            "All students attend class.",
            "Anyone who attends class and studies hard gets good grades.",
            "Anyone who gets good grades passes the exam.",
            "John is a student.",
            "John studies hard.",
            "John attends class.",
            "If someone studies hard, then they have homework.",
            "Anyone who has homework is a student.",
            "Anyone who is a student and studies hard, gets good grades.",
            "John has homework."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (StudiesHard(x) ∨ ¬StudiesHard(x))) ::: Every student either studies hard or doesn't study hard.",
            "∀x (Student(x) → AttendsClass(x)) ::: All students attend class.",
            "∀x ((AttendsClass(x) ∧ StudiesHard(x)) → GetsGoodGrades(x)) ::: Anyone who attends class and studies hard gets good grades.",
            "∀x (GetsGoodGrades(x) → PassesExam(x)) ::: Anyone who gets good grades passes the exam.",
            "Student(john) ::: John is a student.",
            "StudiesHard(john) ::: John studies hard.",
            "AttendsClass(john) ::: John attends class.",
            "∀x (StudiesHard(x) → HasHomework(x)) ::: If someone studies hard, then they have homework.",
            "∀x (HasHomework(x) → Student(x)) ::: Anyone who has homework is a student.",
            "∀x ((Student(x) ∧ StudiesHard(x)) → GetsGoodGrades(x)) ::: Anyone who is a student and studies hard, gets good grades.",
            "HasHomework(john) ::: John has homework."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassesExam(x) ::: x passes the exam",
            "AttendsClass(x) ::: x attends the class",
            "GetsGoodGrades(x) ::: x gets good grades",
            "HasHomework(x) ::: x has homework"
        ]
    },
    {
        "premises-NL": [
            "All scientists need funding.",
            "If a scientist needs funding, they apply for a grant.",
            "If a scientist applies for a grant and has significant results, then they get funded.",
            "If a scientist is funded and works in the lab, then they will conduct experiments.",
            "If a scientist conducts an experiment, and gets significant results, then they publish a paper.",
            "All scientists analyze data.",
            "All scientists know math.",
            "If a scientist uses a microscope, then they are working in a lab.",
            "Dr. Smith is a scientist.",
            "Dr. Smith applies for a grant.",
            "Dr. Smith gets significant results.",
            "If Dr. Smith is funded, then she will conduct an experiment.",
            "Dr. Smith is funded."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → NeedsFunding(x)) ::: All scientists need funding.",
            "∀x (NeedsFunding(x) → AppliesForGrant(x)) ::: If a scientist needs funding, they apply for a grant.",
            "∀x ((AppliesForGrant(x) ∧ SignificantResults(x)) → IsFunded(x)) ::: If a scientist applies for a grant and has significant results, then they get funded.",
            "∀x ((IsFunded(x) ∧ WorksInLab(x)) → ConductsExperiment(x)) ::: If a scientist is funded and works in the lab, then they will conduct experiments.",
            "∀x ((ConductsExperiment(x) ∧ SignificantResults(x)) → PublishesPaper(x)) ::: If a scientist conducts an experiment, and gets significant results, then they publish a paper.",
            "∀x (Scientist(x) → AnalyzesData(x)) ::: All scientists analyze data.",
            "∀x (Scientist(x) → KnowsMath(x)) ::: All scientists know math.",
            "∀x (UsesMicroscope(x) → WorksInLab(x)) ::: If a scientist uses a microscope, then they are working in a lab.",
            "Scientist(smith) ::: Dr. Smith is a scientist.",
            "AppliesForGrant(smith) ::: Dr. Smith applies for a grant.",
            "SignificantResults(smith) ::: Dr. Smith gets significant results.",
            "∀x (IsFunded(x) → ConductsExperiment(x)) ::: If Dr. Smith is funded, then she will conduct an experiment.",
            "IsFunded(smith) ::: Dr. Smith is funded."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "ConductsExperiment(x) ::: x conducts an experiment",
            "SignificantResults(x) ::: x gets significant results",
            "PublishesPaper(x) ::: x publishes a paper",
            "ReceivesGrant(x) ::: x receives a grant",
            "NeedsFunding(x) ::: x needs funding",
            "WorksInLab(x) ::: x works in a lab",
            "UsesMicroscope(x) ::: x uses a microscope",
            "AnalyzesData(x) ::: x analyzes data",
            "KnowsMath(x) ::: x knows math",
            "AppliesForGrant(x) ::: x applies for a grant",
            "IsFunded(x) ::: x is funded"
        ]
    },
    {
        "premises-NL": [
            "All doctors have a degree.",
            "If someone has a degree, then they studied medicine.",
            "If someone studies medicine, they know medical jargon.",
            "If someone is a doctor and sees patients, then they treat patients.",
            "If someone is a doctor and works at a hospital, then they see patients.",
            "Dr. Jones is a doctor.",
            "Dr. Jones works at a hospital.",
            "Dr. Jones prescribes medication.",
            "If a doctor prescribes medication, then they treat patients.",
            "If someone treats patients, then they will get paid.",
            "Dr. Jones sees patients.",
            "If Dr. Jones diagnoses an illness, then Dr. Jones is a doctor.",
            "If a doctor diagnoses an illness, then they prescribe medication."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HasDegree(x)) ::: All doctors have a degree.",
            "∀x (HasDegree(x) → StudiesMedicine(x)) ::: If someone has a degree, then they studied medicine.",
            "∀x (StudiesMedicine(x) → KnowsMedicalJargon(x)) ::: If someone studies medicine, they know medical jargon.",
            "∀x ((Doctor(x) ∧ SeesPatients(x)) → TreatsPatients(x)) ::: If someone is a doctor and sees patients, then they treat patients.",
            "∀x ((Doctor(x) ∧ WorksAtHospital(x)) → SeesPatients(x)) ::: If someone is a doctor and works at a hospital, then they see patients.",
            "Doctor(jones) ::: Dr. Jones is a doctor.",
            "WorksAtHospital(jones) ::: Dr. Jones works at a hospital.",
            "PrescribesMedication(jones) ::: Dr. Jones prescribes medication.",
            "∀x (PrescribesMedication(x) → TreatsPatients(x)) ::: If a doctor prescribes medication, then they treat patients.",
            "∀x (TreatsPatients(x) → GetsPaid(x)) ::: If someone treats patients, then they will get paid.",
            "SeesPatients(jones) ::: Dr. Jones sees patients.",
            "∀x (DiagnosesIllness(x) → Doctor(x)) ::: If Dr. Jones diagnoses an illness, then Dr. Jones is a doctor.",
            "∀x (DiagnosesIllness(x) → PrescribesMedication(x)) ::: If a doctor diagnoses an illness, then they prescribe medication."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "TreatsPatients(x) ::: x treats patients",
            "GetsPaid(x) ::: x gets paid",
            "HasDegree(x) ::: x has a degree",
            "WorksAtHospital(x) ::: x works at a hospital",
            "PrescribesMedication(x) ::: x prescribes medication",
            "DiagnosesIllness(x) ::: x diagnoses illness",
            "AttendsConference(x) ::: x attends a conference",
            "KnowsMedicalJargon(x) ::: x knows medical jargon",
            "WritesPrescription(x) ::: x writes a prescription",
            "OrdersTest(x) ::: x orders a test",
            "SeesPatients(x) ::: x sees patients",
            "StudiesMedicine(x) ::: x studies medicine"
        ]
    },
    {
        "premises-NL": [
            "All plants photosynthesize.",
            "If something photosynthesizes, it needs sunlight.",
            "If something photosynthesizes, it has roots.",
            "If something has roots, it grows in soil.",
            "If something grows in soil, it needs water.",
            "Plants are green.",
            "All plants produce oxygen.",
            "A flower is a plant.",
            "Roses and lilies are flowers.",
            "If something is a plant, it has leaves.",
            "If something is a lily, it is beautiful.",
            "If something has a stem, it grows in soil.",
            "Roses require pollination.",
            "If something requires pollination, it is a plant.",
            "If something is a flower, then it has a stem."
        ],
        "premises-FOL": [
            "∀x (Plant(x) → Photosynthesizes(x)) ::: All plants photosynthesize.",
            "∀x (Photosynthesizes(x) → NeedsSunlight(x)) ::: If something photosynthesizes, it needs sunlight.",
            "∀x (Photosynthesizes(x) → HasRoots(x)) ::: If something photosynthesizes, it has roots.",
            "∀x (HasRoots(x) → GrowsInSoil(x)) ::: If something has roots, it grows in soil.",
            "∀x (GrowsInSoil(x) → NeedsWater(x)) ::: If something grows in soil, it needs water.",
            "∀x (Plant(x) → IsGreen(x)) ::: Plants are green.",
            "∀x (Plant(x) → ProducesOxygen(x)) ::: All plants produce oxygen.",
            "∀x (Flower(x) → Plant(x)) ::: A flower is a plant.",
            "∀x (Rose(x) ∨ Lily(x) → Flower(x)) ::: Roses and lilies are flowers.",
            "∀x (Plant(x) → HasLeaves(x)) ::: If something is a plant, it has leaves.",
            "∀x (Lily(x) → IsBeautiful(x)) ::: If something is a lily, it is beautiful.",
            "∀x (HasStem(x) → GrowsInSoil(x)) ::: If something has a stem, it grows in soil.",
            "∀x (Rose(x) → RequiresPollination(x)) ::: Roses require pollination.",
            "∀x (RequiresPollination(x) → Plant(x)) ::: If something requires pollination, it is a plant.",
            "∀x (Flower(x) → HasStem(x)) ::: If something is a flower, then it has a stem."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "NeedsSunlight(x) ::: x needs sunlight",
            "NeedsWater(x) ::: x needs water",
            "Photosynthesizes(x) ::: x photosynthesizes",
            "HasRoots(x) ::: x has roots",
            "GrowsInSoil(x) ::: x grows in soil",
            "IsGreen(x) ::: x is green",
            "ProducesOxygen(x) ::: x produces oxygen",
            "Flower(x) ::: x is a flower",
            "HasLeaves(x) ::: x has leaves",
            "IsBeautiful(x) ::: x is beautiful",
            "HasStem(x) ::: x has a stem",
            "Lily(x) ::: x is a lily",
            "Rose(x) ::: x is a rose",
            "RequiresPollination(x) ::: x requires pollination"
        ]
    },
    {
        "premises-NL": [
            "All professors are smart.",
            "Anyone who is smart either studies or teaches a class.",
            "Some professors are not studying.",
            "No one teaches a class without being a professor.",
            "John is a professor.",
            "Everyone is either a professor or smart.",
            "If someone studies they are not smart.",
            "Mary is not a professor.",
            "If someone is not smart, they study.",
            "If someone is a professor they are not studying.",
            "If someone teaches a class they are smart."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Smart(x)) ::: All professors are smart.",
            "∀x (Smart(x) → (Studies(x) ∨ TeachesClass(x))) ::: Anyone who is smart either studies or teaches a class.",
            "∃x (Professor(x) ∧ ¬Studies(x)) ::: Some professors are not studying.",
            "∀x (TeachesClass(x) → Professor(x)) ::: No one teaches a class without being a professor.",
            "Professor(john) ::: John is a professor.",
            "∀x (Professor(x) ∨ Smart(x)) ::: Everyone is either a professor or smart.",
            "∀x (Studies(x) → ¬Smart(x)) ::: If someone studies they are not smart.",
            "¬Professor(mary) ::: Mary is not a professor.",
            "∀x (¬Smart(x) → Studies(x)) ::: If someone is not smart, they study.",
            "∀x (Professor(x) → ¬Studies(x)) ::: If someone is a professor they are not studying.",
            "∀x (TeachesClass(x) → Smart(x)) ::: If someone teaches a class they are smart."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "Smart(x) ::: x is smart",
            "TeachesClass(x) ::: x teaches a class",
            "Studies(x) ::: x studies"
        ]
    },
    {
        "premises-NL": [
            "All doctors are employed.",
            "Some employed people are wealthy.",
            "Doctor(john) is True."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Employed(x)) ::: If x is a doctor, then x is employed.",
            "∃x (Employed(x) ∧ Wealthy(x)) ::: There exists someone who is employed and wealthy.",
            "Doctor(john) ::: John is a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Employed(x) ::: x is employed",
            "Wealthy(x) ::: x is wealthy"
        ]
    },
    {
        "premises-NL": [
            "If someone likes cats, then that person does not like dogs.",
            "John likes something that is both a cat and a dog.",
            "Someone likes cats or dogs.",
            "John likes cats."
        ],
        "premises-FOL": [
            "∀x (Likes(x, cats) → ¬Likes(x, dogs)) ::: If x likes cats, then x does not like dogs.",
            "∃x (Cat(x) ∧ Dog(x) ∧ Likes(john, x)) ::: There exists something that is a cat and a dog and John likes it.",
            "∃x (Likes(x, cats) ∨ Likes(x, dogs)) ::: There exists someone who likes cats or dogs.",
            "Likes(john, cats) ::: John likes cats."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Cat(x) ::: x is a cat",
            "Dog(x) ::: x is a dog"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard are successful.",
            "John is a student.",
            "If John studies hard, he is successful.",
            "John studies hard.",
            "If someone is a student and studies hard, then that person is successful.",
            "No one is both successful and a student."
        ],
        "premises-FOL": [
            "∀x ((Student(x) ∧ StudiesHard(x)) → Successful(x)) ::: If x is a student and x studies hard, then x is successful.",
            "Student(john) ::: John is a student.",
            "(StudiesHard(john) → Successful(john)) ::: If John studies hard, then he is successful.",
            "StudiesHard(john) ::: John studies hard.",
            "∀x ((Student(x) ∧ StudiesHard(x)) → Successful(x)) ::: If x is a student and studies hard then x is successful.",
            "¬∃x (Successful(x) ∧ Student(x)) ::: There is no one who is both successful and a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "Successful(x) ::: x is successful"
        ]
    },
    {
        "premises-NL": [
            "Everyone who owns a car is employed.",
            "If anyone is employed, then that person does not have debt.",
            "John owns a car.",
            "Anyone who is employed has no debt.",
            "If someone does not have debt, they are happy.",
            "No one is both happy and has debt.",
            "John is employed."
        ],
        "premises-FOL": [
            "∀x (OwnsCar(x) → Employed(x)) ::: If x owns a car, then x is employed.",
            "∀x (Employed(x) → ¬HasDebt(x)) ::: If x is employed, then x does not have debt.",
            "OwnsCar(john) ::: John owns a car.",
            "∀x (Employed(x) → ¬HasDebt(x)) ::: If x is employed, then x does not have debt.",
            "∀x (¬HasDebt(x) → Happy(x)) ::: If x does not have debt, then x is happy.",
            "¬∃x (Happy(x) ∧ HasDebt(x)) ::: No one is both happy and has debt.",
            "Employed(john) ::: John is employed."
        ],
        "predicates": [
            "OwnsCar(x) ::: x owns a car",
            "Employed(x) ::: x is employed",
            "HasDebt(x) ::: x has debt"
        ]
    },
    {
        "premises-NL": [
            "All musicians play an instrument.",
            "Anyone who plays an instrument is artistic.",
            "John is a musician.",
            "If someone is a musician, then they play an instrument.",
            "No one is both a musician and not artistic.",
            "If someone is artistic, then they are creative.",
            "Anyone who does not play an instrument is not a musician.",
            "John plays an instrument.",
            "Someone plays an instrument."
        ],
        "premises-FOL": [
            "∀x (Musician(x) → PlaysInstrument(x)) ::: If x is a musician, then x plays an instrument.",
            "∀x (PlaysInstrument(x) → Artistic(x)) ::: If x plays an instrument, then x is artistic.",
            "Musician(john) ::: John is a musician.",
            "∀x (Musician(x) → PlaysInstrument(x)) ::: If x is a musician, then x plays an instrument.",
            "¬∃x (Musician(x) ∧ ¬Artistic(x)) ::: No one is both a musician and not artistic.",
            "∀x (Artistic(x) → Creative(x)) ::: If x is artistic, then x is creative.",
            "∀x (¬PlaysInstrument(x) → ¬Musician(x)) ::: If x does not play an instrument, then x is not a musician.",
            "PlaysInstrument(john) ::: John plays an instrument.",
            "∃x PlaysInstrument(x) ::: Someone plays an instrument."
        ],
        "predicates": [
            "Musician(x) ::: x is a musician",
            "PlaysInstrument(x) ::: x plays an instrument",
            "Artistic(x) ::: x is artistic"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All surgeons treat patients.",
            "Some doctors are surgeons.",
            "Anyone who treats patients must be empathetic.",
            "Every doctor who treats patients is a surgeon."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: For all x, if x is a surgeon, then x is a doctor.",
            "∀x (Surgeon(x) → TreatsPatients(x)) ::: For all x, if x is a surgeon, then x treats patients.",
            "∃x (Doctor(x) ∧ Surgeon(x)) ::: There exists someone who is a doctor and a surgeon.",
            "∀x (TreatsPatients(x) → Empathetic(x)) ::: For all x, if x treats patients, then x is empathetic.",
            "∀x (Doctor(x) ∧ TreatsPatients(x) → Surgeon(x)) ::: For all x, if x is a doctor and treats patients, then x is a surgeon."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "TreatsPatients(x) ::: x treats patients",
            "Empathetic(x) ::: x is empathetic",
            "Surgeon(x) ::: x is a surgeon",
            "SpecializesIn(x, y) ::: x specializes in y",
            "Patient(x) ::: x is a patient"
        ]
    },
    {
        "premises-NL": [
            "All professors teach courses.",
            "Some professors are researchers.",
            "All researchers conduct research.",
            "Anyone who conducts research publishes articles.",
            "If someone teaches a course, they are a professor.",
            "Some researchers are professors.",
            "Some professors teach courses."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → TeachesCourse(x, y)) ::: For all x, if x is a professor, then x teaches a course.",
            "∃x (Professor(x) ∧ Researcher(x)) ::: There exists someone who is a professor and a researcher.",
            "∀x (Researcher(x) → ConductsResearch(x)) ::: For all x, if x is a researcher, then x conducts research.",
            "∀x (ConductsResearch(x) → PublishesArticle(x)) ::: For all x, if x conducts research, then x publishes an article.",
            "∀x (TeachesCourse(x, y) → Professor(x)) ::: For all x, if x teaches a course, then x is a professor.",
            "∃x (Researcher(x) ∧ Professor(x)) ::: There exists someone who is a researcher and a professor.",
            "∃x (Professor(x) ∧ TeachesCourse(x, y)) ::: There exists someone who is a professor and teaches a course."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "Researcher(x) ::: x is a researcher",
            "PublishesArticle(x) ::: x publishes an article",
            "TeachesCourse(x, y) ::: x teaches course y",
            "Course(x) ::: x is a course",
            "ConductsResearch(x) ::: x conducts research",
            "Article(x) ::: x is an article"
        ]
    },
    {
        "premises-NL": [
            "All swimmers are athletes.",
            "All athletes participate in competitions.",
            "Anyone who participates in a competition trains.",
            "All swimmers train.",
            "Anyone who trains and eats healthy is physically fit.",
            "Some athletes are swimmers.",
            "All athletes run.",
            "Anyone who runs is an athlete."
        ],
        "premises-FOL": [
            "∀x (Swimmer(x) → Athlete(x)) ::: For all x, if x is a swimmer, then x is an athlete.",
            "∀x (Athlete(x) → ParticipatesIn(x, y)) ::: For all x, if x is an athlete, then x participates in a competition.",
            "∀x (ParticipatesIn(x, y) → Trains(x)) ::: For all x, if x participates in a competition, then x trains.",
            "∀x (Swimmer(x) → Trains(x)) ::: For all x, if x is a swimmer, then x trains.",
            "∀x (Trains(x) ∧ EatsHealthy(x) → PhysicallyFit(x)) ::: For all x, if x trains and eats healthy, then x is physically fit.",
            "∃x (Athlete(x) ∧ Swimmer(x)) ::: There exists someone who is an athlete and a swimmer.",
            "∀x (Athlete(x) → Runs(x)) ::: For all x, if x is an athlete, then x runs.",
            "∀x (Runs(x) → Athlete(x)) ::: For all x, if x runs, then x is an athlete."
        ],
        "predicates": [
            "Athlete(x) ::: x is an athlete",
            "Swimmer(x) ::: x is a swimmer",
            "PhysicallyFit(x) ::: x is physically fit",
            "ParticipatesIn(x, y) ::: x participates in y",
            "Competition(x) ::: x is a competition",
            "Trains(x) ::: x trains",
            "EatsHealthy(x) ::: x eats healthy",
            "Runs(x) ::: x runs"
        ]
    },
    {
        "premises-NL": [
            "Anyone who likes dogs also likes cats.",
            "Some people like dogs.",
            "Everyone who likes cats owns cats.",
            "Someone likes dogs.",
            "Everything that owns cats is a pet.",
            "Some people like cats.",
            "Everyone who is a pet is friendly.",
            "Some people own cats."
        ],
        "premises-FOL": [
            "∀x (LikesDogs(x) → LikesCats(x)) ::: Anyone who likes dogs also likes cats.",
            "∃x LikesDogs(x) ::: Some people like dogs.",
            "∀x (LikesCats(x) → OwnsCats(x)) ::: Everyone who likes cats owns cats.",
            "∃x LikesDogs(x) ::: Someone likes dogs.",
            "∀x (OwnsCats(x) → IsPet(x)) ::: Everything that owns cats is a pet.",
            "∃x LikesCats(x) ::: Some people like cats.",
            "∀x (IsPet(x) → Friendly(x)) ::: Everyone who is a pet is friendly.",
            "∃x OwnsCats(x) ::: Some people own cats."
        ],
        "predicates": [
            "LikesDogs(x) ::: x likes dogs",
            "LikesCats(x) ::: x likes cats",
            "OwnsCats(x) ::: x owns cats",
            "OwnsDogs(x) ::: x owns dogs",
            "IsPet(x) ::: x is a pet",
            "Friendly(x) ::: x is friendly",
            "IsDog(x) ::: x is a dog",
            "IsCat(x) ::: x is a cat"
        ]
    },
    {
        "premises-NL": [
            "If Alice and Bob are happy, Charlie is not and Alice likes dancing, then Alice goes to the party.",
            "Alice is happy.",
            "Bob is happy.",
            "Charlie is not happy.",
            "Alice likes dancing.",
            "If Alice goes to the party then she is at the party.",
            "If Alice is at the party she has a gift.",
            "Alice goes to the party."
        ],
        "premises-FOL": [
            "(Happy(alice) ∧ Happy(bob) ∧ ¬Happy(charlie) ∧ LikesDancing(alice)) → GoesToParty(alice) ::: If Alice and Bob are happy, Charlie is not and Alice likes dancing, then Alice goes to the party.",
            "Happy(alice) ::: Alice is happy.",
            "Happy(bob) ::: Bob is happy.",
            "¬Happy(charlie) ::: Charlie is not happy.",
            "LikesDancing(alice) ::: Alice likes dancing.",
            "GoesToParty(alice) → IsAtParty(alice) ::: If Alice goes to the party then she is at the party.",
            "IsAtParty(alice) → HasGift(alice) ::: If Alice is at the party she has a gift.",
            "GoesToParty(alice) ::: Alice goes to the party."
        ],
        "predicates": [
            "Happy(x) ::: x is happy",
            "GoesToParty(x) ::: x goes to the party",
            "HasGift(x) ::: x has a gift",
            "LikesDancing(x) ::: x likes dancing",
            "IsAtParty(x) ::: x is at the party",
            "IsInvited(x) ::: x is invited",
            "Smart(x) ::: x is smart",
            "LikesFood(x) ::: x likes food"
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "Alex is a student.",
            "If someone is smart, then they study hard.",
            "If someone studies hard and is smart, then they will pass the exam.",
            "Alex is smart.",
            "Alex studies hard.",
            "If Alex studies hard, then Alex will pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "Student(alex) ::: Alex is a student.",
            "∀x (Smart(x) → HardStudy(x)) ::: If someone is smart, then they study hard.",
            "∀x ((HardStudy(x) ∧ Smart(x)) → PassExam(x)) ::: If someone studies hard and is smart, then they will pass the exam.",
            "Smart(alex) ::: Alex is smart.",
            "HardStudy(alex) ::: Alex studies hard.",
            "HardStudy(alex) → PassExam(alex) ::: If Alex studies hard, then Alex will pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "HardStudy(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All students attend class.",
            "Anyone who attends class and studies hard has a good grade.",
            "Some students study hard.",
            "If a student has a good grade, they will pass the exam.",
            "Dr. Smith is a professor.",
            "All professors help students.",
            "John is a student.",
            "John attends class.",
            "John studies hard.",
            "John has a good grade.",
            "Anyone who studies hard receives help.",
            "John receives help from Dr. Smith.",
            "Anyone who receives help passes the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClass(x)) ::: All students attend class.",
            "∀x (AttendsClass(x) ∧ StudiesHard(x) → HasGoodGrade(x)) ::: Anyone who attends class and studies hard has a good grade.",
            "∃x (Student(x) ∧ StudiesHard(x)) ::: Some students study hard.",
            "∀x (Student(x) ∧ HasGoodGrade(x) → PassExam(x)) ::: If a student has a good grade, they will pass the exam.",
            "Professor(smith) ::: Dr. Smith is a professor.",
            "∀x ∀y (Professor(y) ∧ Student(x) → ReceivesHelp(x, y)) ::: All professors help students.",
            "Student(john) ::: John is a student.",
            "AttendsClass(john) ::: John attends class.",
            "StudiesHard(john) ::: John studies hard.",
            "HasGoodGrade(john) ::: John has a good grade.",
            "∀x (StudiesHard(x) → ReceivesHelp(x,y)) ::: Anyone who studies hard receives help.",
            "ReceivesHelp(john, smith) ::: John receives help from Dr. Smith.",
            "∀x (ReceivesHelp(x,y) → PassExam(x)) ::: Anyone who receives help passes the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesHard(x) ::: x studies hard.",
            "HasGoodGrade(x) ::: x has a good grade.",
            "PassExam(x) ::: x passes the exam.",
            "AttendsClass(x) ::: x attends class.",
            "ReceivesHelp(x, y) ::: x receives help from y.",
            "Professor(x) ::: x is a professor."
        ]
    },
    {
        "premises-NL": [
            "All customers are people.",
            "If a customer purchases a product, then the customer receives a discount.",
            "If a product is popular, then the customer uses it often.",
            "John is a customer.",
            "Product A is a product.",
            "John purchases Product A.",
            "Product A is advertised.",
            "Product A needs repair.",
            "If a product is advertised, then it is popular.",
            "If a product needs repair, then it is not popular.",
            "If John purchases Product A, then he gets a discount.",
            "John uses product A.",
            "If the customer is John, then the customer uses the product often.",
            "If the product is not popular, the customer does not use it often.",
            "John receives a discount.",
            "Product A is popular."
        ],
        "premises-FOL": [
            "∀x (Customer(x) → Person(x)) ::: All customers are people.",
            "∀x ∀y (PurchasesProduct(x, y) → ReceivesDiscount(x)) ::: If a customer purchases a product, then the customer receives a discount.",
            "∀x ∀y (PopularProduct(y) → UsesOften(x, y)) ::: If a product is popular, then the customer uses it often.",
            "Customer(john) ::: John is a customer.",
            "Product(productA) ::: Product A is a product.",
            "PurchasesProduct(john, productA) ::: John purchases Product A.",
            "Advertised(productA) ::: Product A is advertised.",
            "NeedsRepair(productA) ::: Product A needs repair.",
            "∀x (Advertised(x) → PopularProduct(x)) ::: If a product is advertised, then it is popular.",
            "∀x (NeedsRepair(x) → ¬PopularProduct(x)) ::: If a product needs repair, then it is not popular.",
            "PurchasesProduct(john, productA) → ReceivesDiscount(john) ::: If John purchases Product A, then he gets a discount.",
            "UsesOften(john, productA) ::: John uses product A.",
            "∀x ∀y (Customer(x) ∧ Product(y) → UsesOften(x, y)) ::: If the customer is John, then the customer uses the product often.",
            "∀x ∀y (¬PopularProduct(y) → ¬UsesOften(x, y)) ::: If the product is not popular, the customer does not use it often.",
            "ReceivesDiscount(john) ::: John receives a discount.",
            "PopularProduct(productA) ::: Product A is popular."
        ],
        "predicates": [
            "PurchasesProduct(x, y) ::: Customer x purchases product y",
            "ReceivesDiscount(x) ::: Customer x receives a discount",
            "PopularProduct(x) ::: Product x is popular",
            "UsesOften(x, y) ::: Customer x uses product y often",
            "Customer(x) ::: x is a customer",
            "Product(x) ::: x is a product",
            "Advertised(x) ::: Product x is advertised",
            "NeedsRepair(x) ::: Product x needs repair"
        ]
    },
    {
        "premises-NL": [
            "If someone is in a group and the group is connected, then they are a member of the group.",
            "If someone is a member of a group, they like the group.",
            "If someone likes a group, then they influence people.",
            "John is in Group A.",
            "Group A is connected.",
            "John is a friend.",
            "If John is in Group A and Group A is connected, then John is a member of Group A.",
            "John likes Group A.",
            "John influences someone.",
            "If John likes a group, then John influences that group.",
            "If John influences John, then they are in the group.",
            "If John is a friend, then John is in the group.",
            "If John is in the group, then he influences the group.",
            "If someone likes the group, they are in the group.",
            "If John likes Group A, he is in Group A.,",
            "John is in Group A or the group is connected."
        ],
        "premises-FOL": [
            "∀x ∀y ((InGroup(x, y) ∧ ConnectedGroup(y)) → MemberOf(x, y)) ::: If someone is in a group and the group is connected, then they are a member of the group.",
            "∀x ∀y (MemberOf(x, y) → Likes(x, y)) ::: If someone is a member of a group, they like the group.",
            "∀x ∀y (Likes(x, y) → Influences(x, y)) ::: If someone likes a group, then they influence people.",
            "InGroup(john, groupA) ::: John is in Group A.",
            "ConnectedGroup(groupA) ::: Group A is connected.",
            "Friend(john) ::: John is a friend.",
            "(InGroup(john, groupA) ∧ ConnectedGroup(groupA)) → MemberOf(john, groupA) ::: If John is in Group A and Group A is connected, then John is a member of Group A.",
            "Likes(john, groupA) ::: John likes Group A.",
            "Influences(john, someone) ::: John influences someone.",
            "∀x ∀y (Likes(x, y) → Influences(x, y)) ::: If John likes a group, then John influences that group.",
            "Influences(john, john) → InGroup(john, groupA) ::: If John influences John, then they are in the group.",
            "Friend(john) → InGroup(john, groupA) ::: If John is a friend, then John is in the group.",
            "InGroup(john, groupA) → Influences(john, groupA) ::: If John is in the group, then he influences the group.",
            "∀x ∀y (Likes(x, y) → InGroup(x, y)) ::: If someone likes the group, they are in the group.",
            "Likes(john, groupA) → InGroup(john, groupA) ::: If John likes Group A, he is in Group A.,",
            "InGroup(john, groupA) ∨ ConnectedGroup(groupA) ::: John is in Group A or the group is connected."
        ],
        "predicates": [
            "InGroup(x, y) ::: x is in group y",
            "ConnectedGroup(x) ::: Group x is connected",
            "Friend(x) ::: x is a friend",
            "MemberOf(x, y) ::: x is a member of y",
            "Likes(x, y) ::: x likes y",
            "Influences(x, y) ::: x influences y",
            "Group(x) ::: x is a group"
        ]
    },
    {
        "premises-NL": [
            "All doctors are employed.",
            "Some doctors are specialists.",
            "x is a doctor if x is a specialist.",
            "If x is a specialist, then x is a doctor.",
            "If x is employed and a doctor, then x is helping patients.",
            "There is no x such that x is a doctor and not employed."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Employed(x)) ::: All doctors are employed",
            "∃x (Doctor(x) ∧ Specialist(x)) ::: Some doctors are specialists",
            "∀x (Specialist(x) → Doctor(x)) ::: x is a doctor if x is a specialist",
            "∀x (Doctor(x) → Specialist(x)) ::: If x is a specialist, then x is a doctor",
            "∀x ((Employed(x) ∧ Doctor(x)) → HelpingPatients(x)) ::: If x is employed and a doctor, then x is helping patients",
            "¬∃x (Doctor(x) ∧ ¬Employed(x)) ::: There is no x such that x is a doctor and not employed"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Employed(x) ::: x is employed",
            "Specialist(x) ::: x is a specialist"
        ]
    },
    {
        "premises-NL": [
            "All people who like pizza also like pasta.",
            "Someone likes pizza.",
            "Someone does not like burgers.",
            "If someone likes pizza, then the person likes pasta.",
            "If someone likes pizza, then they eat pizza.",
            "If someone doesn't like burgers, then they are sad.",
            "If someone likes pizza and burgers, they like everything."
        ],
        "premises-FOL": [
            "∀x (LikesPizza(x) → LikesPasta(x)) ::: All who like pizza also like pasta",
            "∃x LikesPizza(x) ::: Someone likes pizza",
            "∃x ¬LikesBurgers(x) ::: Someone does not like burgers",
            "∀x (LikesPizza(x) → LikesPasta(x)) ::: If someone likes pizza, then the person likes pasta",
            "∀x (LikesPizza(x) → EatsPizza(x)) ::: If someone likes pizza, then they eat pizza",
            "∀x (¬LikesBurgers(x) → Sad(x)) ::: If someone doesn't like burgers, then they are sad",
            "∀x ((LikesPizza(x) ∧ LikesBurgers(x)) → LikesEverything(x)) ::: If someone likes pizza and burgers, they like everything"
        ],
        "predicates": [
            "LikesPizza(x) ::: x likes pizza",
            "LikesPasta(x) ::: x likes pasta",
            "LikesBurgers(x) ::: x likes burgers"
        ]
    },
    {
        "premises-NL": [
            "Some students study logic.",
            "Some students study programming.",
            "All students study either logic or programming.",
            "If someone studies logic, then they are smart.",
            "If someone studies programming, then they are good.",
            "If someone is smart and good, then they are a genius.",
            "If a student studies logic and programming, then the student is enrolled.",
            "If a student is enrolled, then the student is in university.",
            "If a student studies either logic or programming, then the student is learning."
        ],
        "premises-FOL": [
            "∃x (Student(x) ∧ StudiesLogic(x)) ::: Some students study logic",
            "∃x (Student(x) ∧ StudiesProgramming(x)) ::: Some students study programming",
            "∀x (Student(x) → (StudiesLogic(x) ∨ StudiesProgramming(x))) ::: All students study either logic or programming",
            "∀x (StudiesLogic(x) → Smart(x)) ::: If someone studies logic, then they are smart",
            "∀x (StudiesProgramming(x) → Good(x)) ::: If someone studies programming, then they are good",
            "∀x ((Smart(x) ∧ Good(x)) → Genius(x)) ::: If someone is smart and good, then they are a genius",
            "∀x ((StudiesLogic(x) ∧ StudiesProgramming(x)) → Enrolled(x)) ::: If a student studies logic and programming, then the student is enrolled",
            "∀x (Enrolled(x) → InUniversity(x)) ::: If a student is enrolled, then the student is in university",
            "∀x ((StudiesLogic(x) ∨ StudiesProgramming(x)) → Learning(x)) ::: If a student studies either logic or programming, then the student is learning"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesLogic(x) ::: x studies logic",
            "StudiesProgramming(x) ::: x studies programming"
        ]
    },
    {
        "premises-NL": [
            "All doctors are healthcare workers.",
            "Surgeons and specialists are doctors.",
            "Surgeons can prescribe medicine.",
            "Specialists can prescribe medicine.",
            "Doctors prescribe medicine, too.",
            "If someone is a healthcare worker, they either have a degree or a specific certification.",
            "Doctors have a degree."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HealthcareWorker(x)) ::: All doctors are healthcare workers.",
            "∀x ((Surgeon(x) ∨ Specialist(x)) → Doctor(x)) ::: Surgeons and specialists are doctors.",
            "∀x (Surgeon(x) → PrescribesMedicine(x)) ::: Surgeons can prescribe medicine.",
            "∀x (Specialist(x) → PrescribesMedicine(x)) ::: Specialists can prescribe medicine.",
            "∀x (Doctor(x) → PrescribesMedicine(x)) ::: Doctors prescribe medicine, too.",
            "∀x (HealthcareWorker(x) → (HasDegree(x) ∨ HasCertification(x))) ::: If someone is a healthcare worker, they either have a degree or a specific certification.",
            "∀x (Doctor(x) → HasDegree(x)) ::: Doctors have a degree."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "HealthcareWorker(x) ::: x is a healthcare worker",
            "PrescribesMedicine(x) ::: x prescribes medicine",
            "Surgeon(x) ::: x is a surgeon",
            "Specialist(x) ::: x is a specialist"
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "Some students study.",
            "Student(Alice)."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "∃x (Student(x) ∧ Study(x)) ::: Some students study.",
            "Student(Alice) ::: Alice is a student.",
            "Smart(Alice) ::: Alice is smart.",
            "Study(Alice) ::: Alice studies.",
            "Student(Bob) ::: Bob is a student.",
            "Smart(Bob) ::: Bob is smart.",
            "∀x (Study(x) → ¬Sleep(x)) ::: All who study don't sleep.",
            "Study(Charlie) ::: Charlie studies.",
            "¬Sleep(Charlie) ::: Charlie does not sleep.",
            "∀x (Write(x) → Educated(x)) ::: All writers are educated.",
            "Write(David) ::: David writes.",
            "Educated(David) ::: David is educated.",
            "∀x (Educated(x) → Succeed(x)) ::: All educated people succeed."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Smart(x) ::: x is smart",
            "Study(x) ::: x studies"
        ]
    },
    {
        "premises-NL": [
            "All doctors are rich.",
            "Some doctors help people.",
            "Doctor(Alice)."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Rich(x)) ::: All doctors are rich.",
            "∃x ∃y (Doctor(x) ∧ Help(x, y)) ::: Some doctors help people.",
            "Doctor(Alice) ::: Alice is a doctor.",
            "Rich(Alice) ::: Alice is rich.",
            "Doctor(Bob) ::: Bob is a doctor.",
            "∀x (Help(x, Bob) → Kind(x)) ::: All who help Bob are kind.",
            "Help(Alice, Bob) ::: Alice helps Bob.",
            "Kind(Alice) ::: Alice is kind.",
            "∀x (Teach(x) → Smart(x)) ::: All teachers are smart.",
            "Teach(Charlie) ::: Charlie teaches.",
            "Smart(Charlie) ::: Charlie is smart.",
            "∀x (Smart(x) → Succeed(x)) ::: All smart people succeed.",
            "Succeed(Charlie) ::: Charlie succeeds.",
            "∀x (Rich(x) → Owns(x, 'House')) ::: All rich people own a house.",
            "Rich(David) ::: David is rich."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Rich(x) ::: x is rich",
            "Help(x, y) ::: x helps y"
        ]
    },
    {
        "premises-NL": [
            "All lawyers are educated.",
            "All educated people are successful.",
            "Some lawyers are ethical."
        ],
        "premises-FOL": [
            "∀x (Lawyer(x) → Educated(x)) ::: All lawyers are educated.",
            "∀x (Educated(x) → Successful(x)) ::: All educated people are successful.",
            "∃x (Lawyer(x) ∧ Ethical(x)) ::: Some lawyers are ethical.",
            "Lawyer(Alice) ::: Alice is a lawyer.",
            "Educated(Alice) ::: Alice is educated.",
            "Successful(Alice) ::: Alice is successful.",
            "Ethical(Alice) ::: Alice is ethical.",
            "Lawyer(Bob) ::: Bob is a lawyer.",
            "∀x (Ethical(x) → Trustworthy(x)) ::: All ethical people are trustworthy.",
            "Ethical(Bob) ::: Bob is ethical.",
            "Trustworthy(Bob) ::: Bob is trustworthy.",
            "∀x (Teach(x) → Skilled(x)) ::: All teachers are skilled.",
            "Teach(Charlie) ::: Charlie teaches.",
            "Skilled(Charlie) ::: Charlie is skilled.",
            "∀x (Skilled(x) → Employed(x)) ::: All skilled people are employed.",
            "Employed(Charlie) ::: Charlie is employed.",
            "∀x (Owns(x, 'Car') → Rich(x)) ::: All who own a car are rich."
        ],
        "predicates": [
            "Lawyer(x) ::: x is a lawyer",
            "Educated(x) ::: x is educated",
            "Successful(x) ::: x is successful",
            "Ethical(x) ::: x is ethical"
        ]
    },
    {
        "premises-NL": [
            "All scientists are curious.",
            "All curious people ask questions.",
            "Some scientists work in labs."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Curious(x)) ::: All scientists are curious.",
            "∀x (Curious(x) → AskQuestions(x)) ::: All curious people ask questions.",
            "∃x (Scientist(x) ∧ WorkIn(x, 'Lab')) ::: Some scientists work in labs.",
            "Scientist(Alice) ::: Alice is a scientist.",
            "Curious(Alice) ::: Alice is curious.",
            "AskQuestions(Alice) ::: Alice asks questions.",
            "WorkIn(Alice, 'Lab') ::: Alice works in a lab.",
            "Scientist(Bob) ::: Bob is a scientist.",
            "∀x (WorkIn(x, 'Office') → WriteReports(x)) ::: All who work in an office write reports.",
            "WorkIn(Bob, 'Office') ::: Bob works in an office.",
            "WriteReports(Bob) ::: Bob writes reports.",
            "∀x (WriteReports(x) → Productive(x)) ::: All who write reports are productive.",
            "Productive(Bob) ::: Bob is productive.",
            "∀x (Productive(x) → EarnMoney(x)) ::: All productive people earn money.",
            "EarnMoney(Bob) ::: Bob earns money.",
            "∀x (EarnMoney(x) → PayTaxes(x)) ::: All who earn money pay taxes.",
            "PayTaxes(Bob) ::: Bob pays taxes."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Curious(x) ::: x is curious",
            "AskQuestions(x) ::: x asks questions",
            "WorkIn(x, y) ::: x works in y"
        ]
    },
    {
        "premises-NL": [
            "All programmers are good at logic.",
            "Some programmers use computers.",
            "All people who use computers create software."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → GoodAtLogic(x)) ::: All programmers are good at logic.",
            "∃x (Programmer(x) ∧ UseComputer(x)) ::: Some programmers use computers.",
            "∀x (UseComputer(x) → CreateSoftware(x)) ::: All people who use computers create software.",
            "Programmer(Alice) ::: Alice is a programmer.",
            "GoodAtLogic(Alice) ::: Alice is good at logic.",
            "UseComputer(Alice) ::: Alice uses a computer.",
            "CreateSoftware(Alice) ::: Alice creates software.",
            "Programmer(Bob) ::: Bob is a programmer.",
            "∀x (CreateSoftware(x) → Smart(x)) ::: All who create software are smart.",
            "CreateSoftware(Bob) ::: Bob creates software.",
            "Smart(Bob) ::: Bob is smart.",
            "∀x (Smart(x) → Educated(x)) ::: All smart people are educated.",
            "Educated(Bob) ::: Bob is educated.",
            "∀x (Educated(x) → Succeed(x)) ::: All educated people succeed.",
            "Succeed(Bob) ::: Bob succeeds.",
            "∀x (Succeed(x) → Happy(x)) ::: All successful people are happy.",
            "Happy(Bob) ::: Bob is happy.",
            "∀x (UseComputer(x) → Skilled(x)) ::: All who use computer are skilled."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "GoodAtLogic(x) ::: x is good at logic",
            "UseComputer(x) ::: x uses a computer",
            "CreateSoftware(x) ::: x creates software"
        ]
    },
    {
        "premises-NL": [
            "All students like chess.",
            "Anyone who likes chess is smart.",
            "All smart people are good strategists.",
            "John is a student.",
            "John likes chess.",
            "John is a member of the chess club.",
            "Mary is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → LikesChess(x)) ::: All students like chess.",
            "∀x (LikesChess(x) → Smart(x)) ::: Anyone who likes chess is smart.",
            "∀x (Smart(x) → GoodStrategist(x)) ::: All smart people are good strategists.",
            "Student(john) ::: John is a student.",
            "LikesChess(john) ::: John likes chess.",
            "ChessClubMember(john) ::: John is a member of the chess club.",
            "Student(mary) ::: Mary is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "ChessClubMember(x) ::: x is a member of the chess club",
            "LikesChess(x) ::: x likes chess",
            "Smart(x) ::: x is smart",
            "GoodStrategist(x) ::: x is a good strategist",
            "PlaysChess(x) ::: x plays chess"
        ]
    },
    {
        "premises-NL": [
            "If Alex is smart, then Alex studies.",
            "Alex is smart.",
            "If Alex studies, Alex works hard.",
            "Alex works hard.",
            "If Alex is smart, then Alex passes.",
            "If Alex passes, then Alex is happy.",
            "Alex is happy.",
            "If Alex studies, then Alex is not lazy.",
            "Alex is not lazy.",
            "If Alex is not lazy, then Alex will pass."
        ],
        "premises-FOL": [
            "Smart(Alex) → Studies(Alex) ::: If Alex is smart, then Alex studies.",
            "Smart(Alex) ::: Alex is smart.",
            "Studies(Alex) → WorksHard(Alex) ::: If Alex studies, Alex works hard.",
            "WorksHard(Alex) ::: Alex works hard.",
            "Smart(Alex) → Pass(Alex) ::: If Alex is smart, then Alex passes.",
            "Pass(Alex) → Happy(Alex) ::: If Alex passes, then Alex is happy.",
            "Happy(Alex) ::: Alex is happy.",
            "Studies(Alex) → ¬Lazy(Alex) ::: If Alex studies, then Alex is not lazy.",
            "¬Lazy(Alex) ::: Alex is not lazy.",
            "¬Lazy(Alex) → Pass(Alex) ::: If Alex is not lazy, then Alex will pass."
        ],
        "predicates": [
            "Studies(x) ::: x studies.",
            "Pass(x) ::: x passes.",
            "Smart(x) ::: x is smart.",
            "WorksHard(x) ::: x works hard."
        ]
    },
    {
        "premises-NL": [
            "If Bob likes Alice, then Bob is a friend of Alice.",
            "Bob likes Alice.",
            "If Bob is a friend of Alice, then Alice likes Bob.",
            "Alice likes Bob.",
            "If Bob plays with Charlie, then Bob likes Charlie.",
            "Bob plays with Charlie.",
            "If Bob likes Charlie, then Charlie likes Bob.",
            "Charlie likes Bob.",
            "If Alice likes Bob, then Bob likes Alice.",
            "If Charlie likes Bob, then Bob likes Charlie.",
            "Bob is smart."
        ],
        "premises-FOL": [
            "Likes(Bob, Alice) → IsFriendOf(Bob, Alice) ::: If Bob likes Alice, then Bob is a friend of Alice.",
            "Likes(Bob, Alice) ::: Bob likes Alice.",
            "IsFriendOf(Bob, Alice) → Likes(Alice, Bob) ::: If Bob is a friend of Alice, then Alice likes Bob.",
            "Likes(Alice, Bob) ::: Alice likes Bob.",
            "Plays(Bob, Charlie) → Likes(Bob, Charlie) ::: If Bob plays with Charlie, then Bob likes Charlie.",
            "Plays(Bob, Charlie) ::: Bob plays with Charlie.",
            "Likes(Bob, Charlie) → Likes(Charlie, Bob) ::: If Bob likes Charlie, then Charlie likes Bob.",
            "Likes(Charlie, Bob) ::: Charlie likes Bob.",
            "Likes(Alice, Bob) → Likes(Bob, Alice) ::: If Alice likes Bob, then Bob likes Alice.",
            "Likes(Charlie, Bob) → Likes(Bob, Charlie) ::: If Charlie likes Bob, then Bob likes Charlie.",
            "Smart(Bob) ::: Bob is smart."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y.",
            "Plays(x, y) ::: x plays with y.",
            "IsFriendOf(x, y) ::: x is a friend of y.",
            "Smart(x) ::: x is smart."
        ]
    },
    {
        "premises-NL": [
            "All students who take Calculus also study.",
            "All students who study get an A.",
            "All students who take Physics also study.",
            "Alex takes Calculus.",
            "Alex takes Physics.",
            "Bob is a student.",
            "If Bob is smart, then Bob gets an A.",
            "If Bob studies, then Bob is smart.",
            "All students who get an A like math.",
            "All students who like math study.",
            "Alice is a student.",
            "If Alice takes Calculus and Physics, then Alice is a student."
        ],
        "premises-FOL": [
            "∀x (Takes(x, Calculus) → Studies(x)) ::: All students who take Calculus also study.",
            "∀x (Studies(x) → GetsGrade(x, A)) ::: All students who study get an A.",
            "∀x (Takes(x, Physics) → Studies(x)) ::: All students who take Physics also study.",
            "Takes(Alex, Calculus) ::: Alex takes Calculus.",
            "Takes(Alex, Physics) ::: Alex takes Physics.",
            "IsStudent(Bob) ::: Bob is a student.",
            "Smart(Bob) → GetsGrade(Bob, A) ::: If Bob is smart, then Bob gets an A.",
            "Studies(Bob) → Smart(Bob) ::: If Bob studies, then Bob is smart.",
            "∀x (GetsGrade(x, A) → Likes(x, Math)) ::: All students who get an A like math.",
            "∀x (Likes(x, Math) → Studies(x)) ::: All students who like math study.",
            "IsStudent(Alice) ::: Alice is a student.",
            "(Takes(Alice, Calculus) ∧ Takes(Alice, Physics)) → IsStudent(Alice) ::: If Alice takes Calculus and Physics, then Alice is a student."
        ],
        "predicates": [
            "Takes(x, y) ::: x takes the course y.",
            "GetsGrade(x, y) ::: x gets grade y.",
            "IsStudent(x) ::: x is a student.",
            "Likes(x, y) ::: x likes y.",
            "Smart(x) ::: x is smart.",
            "Studies(x) ::: x studies."
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "Anyone who treats patients helps them.",
            "All doctors work at the hospital.",
            "If someone is sick, they are a patient.",
            "If someone is a doctor, they treat anyone with a disease.",
            "Bob is a doctor.",
            "Alice has a disease.",
            "If someone helps patients, they must be a nurse.",
            "All nurses work in the hospital.",
            "If someone works at the hospital and is a doctor, then they help patients.",
            "Bob works at the hospital.",
            "If someone is a doctor, then they work at the hospital.",
            "If a person is a nurse, they help patients."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Treats(x, Patients)) ::: All doctors treat patients.",
            "∀x (Treats(x, Patients) → Helps(x, Patients)) ::: Anyone who treats patients helps them.",
            "∀x (Doctor(x) → WorksAt(x, Hospital)) ::: All doctors work at the hospital.",
            "∀x (IsSick(x) → Patient(x)) ::: If someone is sick, they are a patient.",
            "∀x ∀y (Doctor(x) → Treats(x, y)) ::: If someone is a doctor, they treat anyone with a disease.",
            "Doctor(Bob) ::: Bob is a doctor.",
            "HasDisease(Alice) ::: Alice has a disease.",
            "∀x (Helps(x, Patients) → IsNurse(x)) ::: If someone helps patients, they must be a nurse.",
            "∀x (IsNurse(x) → WorksAt(x, Hospital)) ::: All nurses work in the hospital.",
            "∀x ((WorksAt(x, Hospital) ∧ Doctor(x)) → Helps(x, Patients)) ::: If someone works at the hospital and is a doctor, then they help patients.",
            "WorksAt(Bob, Hospital) ::: Bob works at the hospital.",
            "∀x (Doctor(x) → WorksAt(x, Hospital)) ::: If someone is a doctor, then they work at the hospital.",
            "∀x (IsNurse(x) → Helps(x, Patients)) ::: If a person is a nurse, they help patients."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "WorksAt(x, y) ::: x works at y.",
            "Helps(x, y) ::: x helps y.",
            "IsSick(x) ::: x is sick.",
            "HasDisease(x, y) ::: x has disease y.",
            "Treats(x, y) ::: x treats y.",
            "IsNurse(x) ::: x is a nurse."
        ]
    },
    {
        "premises-NL": [
            "All students take Math or Chemistry.",
            "If John is a student, he likes Chemistry.",
            "If John likes Chemistry, he takes Chemistry.",
            "John is a student.",
            "If John studies hard, he passes the exam.",
            "If John takes Math, he studies hard.",
            "If John takes Chemistry, he has a friend.",
            "If John has a friend, he studies hard or is smart.",
            "If John studies hard or is smart, he passes the exam.",
            "Anyone who passes the exam goes to the university.",
            "If John goes to the university and is a student, he takes both Math and Chemistry.",
            "If John is a student, he likes Math.",
            "If John likes Math, he takes Math.",
            "If John takes both Math and Chemistry, he passes the exam."
        ],
        "premises-FOL": [
            "∀x (IsStudent(x) → (Takes(x, Math) ∨ Takes(x, Chemistry))) ::: All students take Math or Chemistry.",
            "IsStudent(John) → Likes(John, Chemistry) ::: If John is a student, he likes Chemistry.",
            "Likes(John, Chemistry) → Takes(John, Chemistry) ::: If John likes Chemistry, he takes Chemistry.",
            "IsStudent(John) ::: John is a student.",
            "StudiesHard(John) → PassesExam(John, Math) ::: If John studies hard, he passes the exam.",
            "Takes(John, Math) → StudiesHard(John) ::: If John takes Math, he studies hard.",
            "Takes(John, Chemistry) → HasFriend(John, Bob) ::: If John takes Chemistry, he has a friend.",
            "HasFriend(John, Bob) → (StudiesHard(John) ∨ Smart(John)) ::: If John has a friend, he studies hard or is smart.",
            "(StudiesHard(John) ∨ Smart(John)) → PassesExam(John, Math) ::: If John studies hard or is smart, he passes the exam.",
            "∀x (PassesExam(x, Math) → GoesTo(x, University)) ::: Anyone who passes the exam goes to the university.",
            "(GoesTo(John, University) ∧ IsStudent(John)) → (Takes(John, Math) ∧ Takes(John, Chemistry)) ::: If John goes to the university and is a student, he takes both Math and Chemistry.",
            "IsStudent(John) → Likes(John, Math) ::: If John is a student, he likes Math.",
            "Likes(John, Math) → Takes(John, Math) ::: If John likes Math, he takes Math.",
            "(Takes(John, Math) ∧ Takes(John, Chemistry)) → PassesExam(John, Math) ::: If John takes both Math and Chemistry, he passes the exam."
        ],
        "predicates": [
            "IsStudent(x) ::: x is a student.",
            "Takes(x, y) ::: x takes y.",
            "Smart(x) ::: x is smart.",
            "StudiesHard(x) ::: x studies hard.",
            "Likes(x, y) ::: x likes y.",
            "PassesExam(x, y) ::: x passes exam y.",
            "HasFriend(x, y) ::: x has y as a friend.",
            "GoesTo(x, y) ::: x goes to y."
        ]
    },
    {
        "premises-NL": [
            "All students like coffee.",
            "John is a student.",
            "John attends a lecture.",
            "If someone likes coffee, then they study hard or they attend a lecture.",
            "If a student attends a lecture, then they like coffee.",
            "All those who attend a lecture are students.",
            "Mary is a student.",
            "If Mary attends a lecture, then she studies hard.",
            "If Mary is a student, then she likes coffee.",
            "Some students attend a lecture.",
            "If someone is a student, they either attend a lecture or don't like coffee.",
            "If someone studies hard, then they are a student.",
            "Mary attends a lecture."
        ],
        "premises-FOL": [
            "∀x (Student(x) → LikesCoffee(x)) ::: All students like coffee.",
            "Student(John) ::: John is a student.",
            "AttendLecture(John) ::: John attends a lecture.",
            "∀x (LikesCoffee(x) → StudyHard(x) ∨ AttendLecture(x)) ::: If someone likes coffee, then they study hard or they attend a lecture.",
            "∀x (AttendLecture(x) → LikesCoffee(x)) ::: If a student attends a lecture, then they like coffee.",
            "∀x (AttendLecture(x) → Student(x)) ::: All those who attend a lecture are students.",
            "Student(Mary) ::: Mary is a student.",
            "∀x (AttendLecture(x) → StudyHard(x)) ::: If Mary attends a lecture, then she studies hard.",
            "∀x (Student(x) → LikesCoffee(x)) ::: If Mary is a student, then she likes coffee.",
            "∃x (Student(x) ∧ AttendLecture(x)) ::: Some students attend a lecture.",
            "∀x (Student(x) → AttendLecture(x) ∨ ¬LikesCoffee(x)) ::: If someone is a student, they either attend a lecture or don't like coffee.",
            "∀x (StudyHard(x) → Student(x)) ::: If someone studies hard, then they are a student.",
            "AttendLecture(Mary) ::: Mary attends a lecture."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendLecture(x) ::: x attends a lecture",
            "StudyHard(x) ::: x studies hard",
            "LikesCoffee(x) ::: x likes coffee"
        ]
    },
    {
        "premises-NL": [
            "All green plants are plants.",
            "Some plants need sunlight.",
            "All plants that need sunlight produce oxygen.",
            "If something is a green plant, then it is alive.",
            "All green plants need sunlight.",
            "If something is a plant, it is alive or it needs sunlight.",
            "No plant that produces oxygen doesn't need sunlight.",
            "Something is a green plant.",
            "If something is a plant and is alive, then it produces oxygen.",
            "All plants need sunlight if they are alive.",
            "If something is a green plant, then it needs sunlight or produces oxygen.",
            "Something is a plant.",
            "All plants are alive or produce oxygen.",
            "If something needs sunlight, then it's a green plant."
        ],
        "premises-FOL": [
            "∀x (GreenPlant(x) → IsPlant(x)) ::: All green plants are plants.",
            "∃x (IsPlant(x) ∧ NeedsSunlight(x)) ::: Some plants need sunlight.",
            "∀x (NeedsSunlight(x) ∧ IsPlant(x) → ProducesOxygen(x)) ::: All plants that need sunlight produce oxygen.",
            "∀x (GreenPlant(x) → IsAlive(x)) ::: If something is a green plant, then it is alive.",
            "∀x (GreenPlant(x) → NeedsSunlight(x)) ::: All green plants need sunlight.",
            "∀x (IsPlant(x) → IsAlive(x) ∨ NeedsSunlight(x)) ::: If something is a plant, it is alive or it needs sunlight.",
            "¬∃x (IsPlant(x) ∧ ProducesOxygen(x) ∧ ¬NeedsSunlight(x)) ::: No plant that produces oxygen doesn't need sunlight.",
            "∃x GreenPlant(x) ::: Something is a green plant.",
            "∀x ((IsPlant(x) ∧ IsAlive(x)) → ProducesOxygen(x)) ::: If something is a plant and is alive, then it produces oxygen.",
            "∀x (IsPlant(x) ∧ IsAlive(x) → NeedsSunlight(x)) ::: All plants need sunlight if they are alive.",
            "∀x (GreenPlant(x) → NeedsSunlight(x) ∨ ProducesOxygen(x)) ::: If something is a green plant, then it needs sunlight or produces oxygen.",
            "∃x IsPlant(x) ::: Something is a plant.",
            "∀x (IsPlant(x) → IsAlive(x) ∨ ProducesOxygen(x)) ::: All plants are alive or produce oxygen.",
            "∀x (NeedsSunlight(x) → GreenPlant(x)) ::: If something needs sunlight, then it's a green plant."
        ],
        "predicates": [
            "GreenPlant(x) ::: x is a green plant",
            "ProducesOxygen(x) ::: x produces oxygen",
            "NeedsSunlight(x) ::: x needs sunlight",
            "IsAlive(x) ::: x is alive",
            "IsPlant(x) ::: x is a plant"
        ]
    },
    {
        "premises-NL": [
            "All students are either taking Calculus or Physics.",
            "Some students are smart.",
            "No smart student is struggling.",
            "If a student is taking Calculus, then they are not smart.",
            "If a student is taking Physics, they are struggling.",
            "John is taking Calculus.",
            "John is taking Physics.",
            "All students taking physics are struggling.",
            "All the students are either struggling or smart.",
            "Some students are not struggling."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (TakingCalculus(x) ∨ TakingPhysics(x))) ::: Every student is taking calculus or physics.",
            "∃x (Student(x) ∧ Smart(x)) ::: There exists a student who is smart.",
            "¬∃x (Smart(x) ∧ Struggling(x)) ::: No smart student is struggling.",
            "∀x (TakingCalculus(x) → ¬Smart(x)) ::: If a student is taking calculus, then they are not smart.",
            "∀x (TakingPhysics(x) → Struggling(x)) ::: If a student is taking physics, then they are struggling.",
            "TakingCalculus(john) ::: John is taking Calculus.",
            "TakingPhysics(john) ::: John is taking Physics.",
            "∀x (TakingPhysics(x) → Struggling(x)) ::: All the students taking physics are struggling.",
            "∀x (Student(x) → (Struggling(x) ∨ Smart(x))) ::: All the students are either struggling or smart.",
            "∃x (Student(x) ∧ ¬Struggling(x)) ::: Some students are not struggling."
        ],
        "predicates": [
            "TakingCalculus(x) ::: x is taking Calculus.",
            "TakingPhysics(x) ::: x is taking Physics.",
            "Smart(x) ::: x is smart.",
            "Struggling(x) ::: x is struggling."
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "Some doctors are not surgeons.",
            "No surgeon is friendly.",
            "All patients are friendly.",
            "Dr. Smith is a doctor.",
            "Dr. Smith is not a surgeon.",
            "If someone is a doctor, then they treat patients.",
            "If someone is a patient, they are friendly."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∃x (Doctor(x) ∧ ¬Surgeon(x)) ::: Some doctors are not surgeons.",
            "∀x (Surgeon(x) → ¬Friendly(x)) ::: No surgeon is friendly.",
            "∀x (Patient(x) → Friendly(x)) ::: All patients are friendly.",
            "Doctor(smith) ::: Dr. Smith is a doctor.",
            "¬Surgeon(smith) ::: Dr. Smith is not a surgeon.",
            "∀x (Doctor(x) → TreatsPatient(x)) ::: If someone is a doctor, then they treat patients.",
            "∀x (Patient(x) → Friendly(x)) ::: If someone is a patient, they are friendly."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "Friendly(x) ::: x is friendly",
            "Patient(x) ::: x is a patient"
        ]
    },
    {
        "premises-NL": [
            "All students are eligible to study.",
            "John is a student.",
            "If someone is eligible and studies, they will pass.",
            "John is eligible."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Eligible(x)) ::: All students are eligible to study.",
            "Student(john) ::: John is a student.",
            "∀x (Eligible(x) ∧ Studies(x) → Passes(x)) ::: If someone is eligible and studies, they will pass.",
            "Eligible(john) ::: John is eligible."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "Passes(x) ::: x passes"
        ]
    },
    {
        "premises-NL": [
            "All herbivores eat plants.",
            "All carnivores eat meat.",
            "All omnivores eat meat or plants.",
            "Some animals are herbivores.",
            "Some animals are carnivores.",
            "Some animals are omnivores.",
            "Plants is a type of food.",
            "Meat is a type of food.",
            "Herbivores do not eat meat.",
            "If an animal eats meat, it is a carnivore or an omnivore.",
            "If an animal is not a carnivore and is not an omnivore, it is a herbivore."
        ],
        "premises-FOL": [
            "∀x (Herbivore(x) → Eats(x, plants)) ::: For all x, if x is a herbivore, then x eats plants.",
            "∀x (Carnivore(x) → Eats(x, meat)) ::: For all x, if x is a carnivore, then x eats meat.",
            "∀x (Omnivore(x) → (Eats(x, meat) ∨ Eats(x, plants))) ::: For all x, if x is an omnivore, then x eats meat or plants.",
            "∃x Animal(x) ∧ Herbivore(x) ::: Some animals are herbivores.",
            "∃x Animal(x) ∧ Carnivore(x) ::: Some animals are carnivores.",
            "∃x Animal(x) ∧ Omnivore(x) ::: Some animals are omnivores.",
            "Food(plants) ::: plants is food.",
            "Food(meat) ::: meat is food.",
            "∀x (Herbivore(x) → ¬Eats(x, meat)) ::: Herbivores do not eat meat.",
            "∀x (Eats(x, meat) → (Carnivore(x) ∨ Omnivore(x))) ::: If an animal eats meat, it is a carnivore or an omnivore.",
            "∀x (Animal(x) ∧ ¬Carnivore(x) ∧ ¬Omnivore(x) → Herbivore(x)) ::: If an animal is neither carnivore nor omnivore, it is a herbivore."
        ],
        "predicates": [
            "Animal(x) ::: x is an animal",
            "Herbivore(x) ::: x is a herbivore",
            "Eats(x, y) ::: x eats y",
            "Carnivore(x) ::: x is a carnivore",
            "Omnivore(x) ::: x is an omnivore"
        ]
    },
    {
        "premises-NL": [
            "Every member of the marketing team is proficient in advertising.",
            "Every member of the sales team is proficient in client communication.",
            "The marketing team is a team.",
            "The sales team is a team.",
            "John is a member of the marketing team.",
            "John reports to Alice.",
            "Alice is a manager.",
            "If someone reports to Alice, they are also a member of the sales team.",
            "The advertising budget is a resource.",
            "The client database is a resource.",
            "If someone is proficient in advertising, they have access to the advertising budget.",
            "If someone is proficient in client communication, they have access to the client database.",
            "Alice is a member of the marketing team.",
            "If John is a member of the sales team, then John is also a member of the client relationship team."
        ],
        "premises-FOL": [
            "∀x (MemberOf(x, marketing) → ProficientIn(x, advertising)) ::: Every member of the marketing team is proficient in advertising.",
            "∀x (MemberOf(x, sales) → ProficientIn(x, clientCommunication)) ::: Every member of the sales team is proficient in client communication.",
            "Team(marketing) ::: The marketing team is a team.",
            "Team(sales) ::: The sales team is a team.",
            "MemberOf(john, marketing) ::: John is a member of the marketing team.",
            "ReportsTo(john, alice) ::: John reports to Alice.",
            "Manager(alice) ::: Alice is a manager.",
            "∀x (ReportsTo(x, alice) → MemberOf(x, sales)) ::: If someone reports to Alice, they are also a member of the sales team.",
            "Resource(advertisingBudget) ::: The advertising budget is a resource.",
            "Resource(clientDatabase) ::: The client database is a resource.",
            "∀x (ProficientIn(x, advertising) → HasAccess(x, advertisingBudget)) ::: If someone is proficient in advertising, they have access to the advertising budget.",
            "∀x (ProficientIn(x, clientCommunication) → HasAccess(x, clientDatabase)) ::: If someone is proficient in client communication, they have access to the client database.",
            "MemberOf(alice, marketing) ::: Alice is a member of the marketing team.",
            "∀x (MemberOf(john, sales) → MemberOf(john, clientRelationshipTeam)) ::: If John is a member of the sales team, then John is also a member of the client relationship team."
        ],
        "predicates": [
            "MemberOf(x, y) ::: x is a member of team y",
            "ProficientIn(x, y) ::: x is proficient in skill y",
            "Team(x) ::: x is a team",
            "HasAccess(x, y) ::: x has access to resource y",
            "ReportsTo(x, y) ::: x reports to y"
        ]
    },
    {
        "premises-NL": [
            "All students are either diligent or not diligent.",
            "Some students take a course.",
            "If a student is diligent, they pass all exams.",
            "John is a student.",
            "Math101 is a course.",
            "John takes Math101.",
            "John is diligent or not diligent."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Diligent(x) ∨ ¬Diligent(x))) ::: For all x, if x is a student, then x is diligent or not diligent.",
            "∃x ∃y (Student(x) ∧ TakesCourse(x, y)) ::: There exists x and y such that x is a student and x takes course y.",
            "∀x (Diligent(x) → PassExam(x)) ::: For all x, if x is diligent, then x passes all exams.",
            "Student(John) ::: John is a student",
            "Course(Math101) ::: Math101 is a course.",
            "TakesCourse(John, Math101) ::: John takes Math101.",
            "Diligent(John) ∨ ¬Diligent(John) ::: John is diligent or not diligent."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Diligent(x) ::: x is diligent",
            "PassExam(x) ::: x passes all exams",
            "TakesCourse(x, y) ::: x takes course y",
            "Course(y) ::: y is a course"
        ]
    },
    {
        "premises-NL": [
            "All artists are either talented or not talented.",
            "Some artists know a technique.",
            "If someone is talented, then they have a portfolio.",
            "If someone is a painter, they are an artist.",
            "Mary is a painter.",
            "Mary is talented.",
            "All painters are artists.",
            "Mary knows a technique."
        ],
        "premises-FOL": [
            "∀x (Artist(x) → (Talented(x) ∨ ¬Talented(x))) ::: For all x, if x is an artist, then x is talented or not talented.",
            "∃x ∃y (Artist(x) ∧ Knows(x, y)) ::: There exists x and y such that x is an artist and x knows y.",
            "∀x (Talented(x) → HasPortfolio(x)) ::: For all x, if x is talented, then x has a portfolio.",
            "∀x (IsPainter(x) → Artist(x)) ::: For all x, if x is a painter, then x is an artist.",
            "IsPainter(Mary) ::: Mary is a painter.",
            "Talented(Mary) ::: Mary is talented.",
            "∀x (IsPainter(x) → Artist(x)) ::: For all x, if x is a painter, then x is an artist.",
            "Knows(Mary, Technique) ::: Mary knows a technique."
        ],
        "predicates": [
            "Artist(x) ::: x is an artist",
            "Talented(x) ::: x is talented",
            "HasPortfolio(x) ::: x has a portfolio",
            "Knows(x, y) ::: x knows y",
            "IsPainter(x) ::: x is a painter"
        ]
    },
    {
        "premises-NL": [
            "All people like something.",
            "John likes apples.",
            "If someone likes apples, then they eat apples.",
            "If someone likes oranges, then they eat oranges.",
            "All people eat something.",
            "John is a person.",
            "If someone eats apples and eats oranges, then they like both.",
            "John eats apples.",
            "John eats oranges."
        ],
        "premises-FOL": [
            "∀x ∃y (Person(x) → Likes(x, y)) ::: For all x, there exists y such that if x is a person, then x likes y.",
            "Likes(John, Apple) ::: John likes apples.",
            "∀x (Likes(x, Apple) → Eats(x, Apple)) ::: For all x, if x likes apples, then x eats apples.",
            "∀x (Likes(x, Orange) → Eats(x, Orange)) ::: For all x, if x likes oranges, then x eats oranges.",
            "∀x ∃y (Person(x) → Eats(x, y)) ::: For all x, there exists y such that if x is a person, then x eats y.",
            "Person(John) ::: John is a person.",
            "∀x ∀y (Eats(x, Apple) ∧ Eats(x, Orange) → Likes(x, Apple) ∧ Likes(x, Orange)) ::: For all x and y, if x eats apples and x eats oranges, then x likes apples and x likes oranges.",
            "Eats(John, Apple) ::: John eats apples.",
            "Eats(John, Orange) ::: John eats oranges."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Person(x) ::: x is a person",
            "Apple(y) ::: y is an apple",
            "Orange(y) ::: y is an orange",
            "Eats(x, y) ::: x eats y"
        ]
    },
    {
        "premises-NL": [
            "All programmers either write code or do not.",
            "Some programmers are skilled.",
            "If someone writes code, then they are good at coding.",
            "If someone is good at coding, they will get a job.",
            "John is a programmer.",
            "John is skilled.",
            "All skilled people are good at coding.",
            "John writes code.",
            "If someone does not get a job, they are not skilled.",
            "If someone writes code, they are either skilled or they will not get the job."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → (WritesCode(x, y) ∨ ¬WritesCode(x, y))) ::: For all x, if x is a programmer, then they write code or not.",
            "∃x Skilled(x) ::: There exists x such that x is skilled.",
            "∀x ∀y (WritesCode(x, y) → GoodAtCoding(x)) ::: For all x and y, if x writes code y, then x is good at coding.",
            "∀x (GoodAtCoding(x) → GetJob(x)) ::: For all x, if x is good at coding, then they will get the job.",
            "Programmer(John) ::: John is a programmer.",
            "Skilled(John) ::: John is skilled.",
            "∀x (Skilled(x) → GoodAtCoding(x)) ::: For all x, if x is skilled, then x is good at coding.",
            "WritesCode(John, Code) ::: John writes code.",
            "∀x (¬GetJob(x) → ¬Skilled(x)) ::: For all x, if x does not get a job, then they are not skilled.",
            "∀x (WritesCode(x, y) → (Skilled(x) ∨ ¬GetJob(x))) ::: For all x and y, if x writes code y, then x is skilled or they will not get the job."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "Skilled(x) ::: x is skilled",
            "GetJob(x) ::: x gets a job",
            "WritesCode(x, y) ::: x writes code y",
            "GoodAtCoding(x) ::: x is good at coding"
        ]
    },
    {
        "premises-NL": [
            "Everyone likes a car if they own it.",
            "Alice owns the red car.",
            "The red car and the blue car are cars.",
            "The color of the blue car is blue.",
            "If someone owns a car and that car is a car of a specific color, then they like that car.",
            "If someone likes a car, then that car is a car.",
            "If Alice owns something, she likes it.",
            "Alice is a person.",
            "Alice owns the red car and the blue car.",
            "If a car is blue, then it is a car.",
            "Every car has a color.",
            "Alice likes the red car."
        ],
        "premises-FOL": [
            "∀x ∀y (Owns(x, y) ∧ Car(y) → Likes(x, y)) ::: Everyone likes a car if they own it.",
            "Owns(alice, redCar) ::: Alice owns the red car.",
            "Car(redCar) ∧ Car(blueCar) ::: The red car and the blue car are cars.",
            "Color(blueCar, blue) ::: The color of the blue car is blue.",
            "∀x ∀y ∀z (Owns(x, y) ∧ Color(y, z) → Likes(x, y)) ::: If someone owns a car and that car is a car of a specific color, then they like that car.",
            "∀x (Likes(x, y) → Car(y)) ::: If someone likes a car, then that car is a car.",
            "∀x ∀y (Owns(x, y) → Likes(x, y)) ::: If Alice owns something, she likes it.",
            "Person(alice) ::: Alice is a person.",
            "Owns(alice, redCar) ∧ Owns(alice, blueCar) ::: Alice owns the red car and the blue car.",
            "∀x (Color(x, blue) → Car(x)) ::: If a car is blue, then it is a car.",
            "∀x ∃y Color(x, y) ::: Every car has a color.",
            "Likes(alice, redCar) ::: Alice likes the red car."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y.",
            "Car(x) ::: x is a car.",
            "Color(x, y) ::: x has color y.",
            "Person(x) ::: x is a person.",
            "Owns(x, y) ::: x owns y."
        ]
    },
    {
        "premises-NL": [
            "All doctors are employed.",
            "John is a doctor.",
            "If someone is a student, then they are not a doctor.",
            "Some students study hard.",
            "If someone studies hard, then they will pass exams.",
            "If John passes the exam then he will get a job.",
            "Every student must pass exams.",
            "Some doctors are not surgeons.",
            "If a student gets a job, they are employed",
            "John is not a student.",
            "If someone is employed, they have a salary.",
            "No one has a salary and is unemployed.",
            "If John is not employed, then John is a student.",
            "John is not a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Employed(x)) ::: All doctors are employed",
            "Doctor(john) ::: John is a doctor",
            "∀x (Student(x) → ¬Doctor(x)) ::: If someone is a student, then they are not a doctor",
            "∃x (Student(x) ∧ StudyHard(x)) ::: Some students study hard",
            "∀x (StudyHard(x) → PassExams(x)) ::: If someone studies hard, then they will pass exams",
            "∀x (PassExams(x) → GetJob(x)) ::: If someone passes the exam then he will get a job",
            "∀x (Student(x) → PassExams(x)) ::: Every student must pass exams",
            "∃x (Doctor(x) ∧ ¬Surgeon(x)) ::: Some doctors are not surgeons",
            "∀x (GetJob(x) → Employed(x)) ::: If a student gets a job, they are employed",
            "¬Student(john) ::: John is not a student",
            "∀x (Employed(x) → HasSalary(x)) ::: If someone is employed, they have a salary",
            "¬∃x (HasSalary(x) ∧ ¬Employed(x)) ::: No one has a salary and is unemployed",
            "(¬Employed(john) → Student(john)) ::: If John is not employed, then John is a student.",
            "¬Doctor(john) ::: John is not a doctor"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Employed(x) ::: x is employed",
            "Student(x) ::: x is a student"
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "Alice is a student.",
            "If Alice is smart, then Alice is a friend of Bob.",
            "If Bob is a friend of Carol, then Carol is a friend of Alice.",
            "Bob is a friend of Carol.",
            "Everyone who is a friend is a friend.",
            "Anyone who is a friend of Carol is smart."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "Student(alice) ::: Alice is a student.",
            "Smart(alice) → Friend(alice, bob) ::: If Alice is smart, then Alice is a friend of Bob.",
            "Friend(bob, carol) → Friend(carol, alice) ::: If Bob is a friend of Carol, then Carol is a friend of Alice.",
            "Friend(bob, carol) ::: Bob is a friend of Carol.",
            "∀x ∀y (Friend(x, y) → Friend(x, y)) ::: Everyone who is a friend is a friend.",
            "∀x (Friend(x, carol) → Smart(x)) ::: Anyone who is a friend of Carol is smart."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Smart(x) ::: x is smart.",
            "Friend(x, y) ::: x is a friend of y."
        ]
    },
    {
        "premises-NL": [
            "All cats are black.",
            "All black things are pretty.",
            "If something is pretty, then it is fluffy.",
            "If something is fluffy, then it is a cat.",
            "All cats are black or fluffy.",
            "If something is black, then it is a cat.",
            "No cat is black.",
            "Some cats are fluffy.",
            "If all cats are black and all black things are pretty, then all cats are pretty.",
            "If all fluffy things are pretty and all pretty things are black, then all fluffy things are black."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → Black(x)) ::: All cats are black.",
            "∀x (Black(x) → Pretty(x)) ::: All black things are pretty.",
            "∀x (Pretty(x) → Fluffy(x)) ::: If something is pretty, then it is fluffy.",
            "∀x (Fluffy(x) → Cat(x)) ::: If something is fluffy, then it is a cat.",
            "∀x (Cat(x) → (Black(x) ∨ Fluffy(x))) ::: All cats are black or fluffy.",
            "∀x (Black(x) → Cat(x)) ::: If something is black, then it is a cat.",
            "¬∃x (Cat(x) ∧ Black(x)) ::: No cat is black.",
            "∃x (Cat(x) ∧ Fluffy(x)) ::: Some cats are fluffy.",
            "∀x (Cat(x) → Pretty(x)) ::: If all cats are black and all black things are pretty, then all cats are pretty.",
            "∀x (Fluffy(x) → Black(x)) ::: If all fluffy things are pretty and all pretty things are black, then all fluffy things are black."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat.",
            "Black(x) ::: x is black.",
            "Pretty(x) ::: x is pretty.",
            "Fluffy(x) ::: x is fluffy."
        ]
    },
    {
        "premises-NL": [
            "All doctors are either residents or they conduct research.",
            "All residents study medicine.",
            "Dr. Smith is a doctor.",
            "All doctors who conduct research also help patients.",
            "Dr. Smith is not conducting research.",
            "Anyone who studies medicine is a doctor.",
            "All residents are doctors.",
            "All residents help patients.",
            "There is someone who is a patient."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → (IsResident(x) ∨ ConductsResearch(x))) ::: All doctors are either residents or they conduct research",
            "∀x (IsResident(x) → IsStudying(x, medicine)) ::: All residents study medicine",
            "Doctor(smith) ::: Dr. Smith is a doctor",
            "∀x (Doctor(x) ∧ ConductsResearch(x) → Helps(x, y)) ::: All doctors who conduct research also help patients",
            "¬ConductsResearch(smith) ::: Dr. Smith is not conducting research",
            "∀x (IsStudying(x, medicine) → Doctor(x)) ::: Anyone who studies medicine is a doctor",
            "∀x (IsResident(x) → Doctor(x)) ::: All residents are doctors",
            "∀x (IsResident(x) → Helps(x, y)) ::: All residents help patients",
            "∃x Patient(x) ::: There is someone who is a patient"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Helps(x, y) ::: x helps y",
            "Patient(x) ::: x is a patient",
            "ConductsResearch(x) ::: x conducts research",
            "IsResident(x) ::: x is a resident",
            "IsStudying(x, y) ::: x is studying y"
        ]
    },
    {
        "premises-NL": [
            "All cats are animals.",
            "All cats have fur.",
            "All animals with fur are mammals.",
            "All cats eat mice.",
            "All cats are either black or white.",
            "If something eats a mouse, it is a cat.",
            "There exists an animal",
            "All mice are animals."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → Animal(x)) ::: All cats are animals.",
            "∀x (Cat(x) → HasFur(x)) ::: All cats have fur.",
            "∀x (HasFur(x) → Mammal(x)) ::: All animals with fur are mammals.",
            "∀x ∃y (Cat(x) → (Eats(x, y) ∧ Mouse(y))) ::: All cats eat mice.",
            "∀x (Cat(x) → (Black(x) ∨ White(x))) ::: All cats are either black or white.",
            "∀x ∀y (Eats(x, y) ∧ Mouse(y) → Cat(x)) ::: If something eats a mouse, it is a cat.",
            "∃x Animal(x) ::: There exists an animal",
            "∀x (Mouse(x) → Animal(x)) ::: All mice are animals."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Mammal(x) ::: x is a mammal",
            "Black(x) ::: x is black",
            "White(x) ::: x is white",
            "HasFur(x) ::: x has fur",
            "Animal(x) ::: x is an animal",
            "Eats(x, y) ::: x eats y",
            "Mouse(x) ::: x is a mouse"
        ]
    },
    {
        "premises-NL": [
            "All economists are smart.",
            "All who are smart either have a degree or work at a bank.",
            "No one who works at a bank has a degree.",
            "Some economists study economics.",
            "If someone studies economics, then they are an economist.",
            "All economists are bankers.",
            "If someone is a banker, then they do not have a degree."
        ],
        "premises-FOL": [
            "∀x (Economist(x) → IsSmart(x)) ::: All economists are smart.",
            "∀x (IsSmart(x) → (HasDegree(x) ∨ WorksAtBank(x))) ::: All who are smart either have a degree or work at a bank.",
            "∀x (WorksAtBank(x) → ¬HasDegree(x)) ::: No one who works at a bank has a degree.",
            "∃x (Economist(x) ∧ StudiesEconomics(x)) ::: Some economists study economics.",
            "∀x (StudiesEconomics(x) → Economist(x)) ::: If someone studies economics, then they are an economist.",
            "∀x (Economist(x) → Banker(x)) ::: All economists are bankers.",
            "∀x (Banker(x) → ¬HasDegree(x)) ::: If someone is a banker, then they do not have a degree."
        ],
        "predicates": [
            "Economist(x) ::: x is an economist",
            "HasDegree(x) ::: x has a degree",
            "StudiesEconomics(x) ::: x studies economics",
            "IsSmart(x) ::: x is smart",
            "WorksAtBank(x) ::: x works at a bank",
            "Banker(x) ::: x is a banker"
        ]
    },
    {
        "premises-NL": [
            "All people who take medicine are not happy.",
            "Everyone who takes medicine is sick.",
            "Everyone who feels pain takes medicine.",
            "If someone has a disease, then they feel pain.",
            "If someone is healthy and enjoys life, then they are happy.",
            "Someone has a good diet and does not take medicine.",
            "Anyone who has a good diet is healthy.",
            "If someone is not sick, then they are healthy.",
            "Some people enjoy life."
        ],
        "premises-FOL": [
            "∀x (TakesMedicine(x) → ¬Happy(x)) ::: All people who take medicine are not happy.",
            "∀x (TakesMedicine(x) → Sick(x)) ::: Everyone who takes medicine is sick.",
            "∀x (FeelsPain(x) → TakesMedicine(x)) ::: Everyone who feels pain takes medicine.",
            "∀x (HasDisease(x) → FeelsPain(x)) ::: If someone has a disease, then they feel pain.",
            "∀x ((IsHealthy(x) ∧ EnjoysLife(x)) → Happy(x)) ::: If someone is healthy and enjoys life, then they are happy.",
            "∃x (GoodDiet(x) ∧ ¬TakesMedicine(x)) ::: Someone has a good diet and does not take medicine.",
            "∀x (GoodDiet(x) → IsHealthy(x)) ::: Anyone who has a good diet is healthy.",
            "∀x (¬Sick(x) → IsHealthy(x)) ::: If someone is not sick, then they are healthy.",
            "∃x EnjoysLife(x) ::: Some people enjoy life."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Happy(x) ::: x is happy",
            "Sick(x) ::: x is sick",
            "TakesMedicine(x) ::: x takes medicine",
            "FeelsPain(x) ::: x feels pain",
            "HasDisease(x) ::: x has a disease",
            "IsHealthy(x) ::: x is healthy",
            "GoodDiet(x) ::: x has a good diet",
            "EnjoysLife(x) ::: x enjoys life"
        ]
    },
    {
        "premises-NL": [
            "All students study.",
            "If someone studies, then they pass the exam.",
            "If someone passes the exam, then they know the material.",
            "John is a student.",
            "Everyone who studies likes to learn.",
            "If someone knows the material and likes to learn, then they pass the exam.",
            "All teachers know the material.",
            "John studies.",
            "If someone is a student, they study.",
            "If someone knows the material, then they are a teacher.",
            "If John is a student, then John passes the exam.",
            "If John knows the material, then John is a teacher.",
            "All students pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Study(x)) ::: All students study.",
            "∀x (Study(x) → PassExam(x)) ::: If someone studies, then they pass the exam.",
            "∀x (PassExam(x) → Knows(x, material)) ::: If someone passes the exam, then they know the material.",
            "Student(john) ::: John is a student.",
            "∀x (Study(x) → Likes(x, learning)) ::: Everyone who studies likes to learn.",
            "∀x (Knows(x, material) ∧ Likes(x, learning) → PassExam(x)) ::: If someone knows the material and likes to learn, then they pass the exam.",
            "∀x (Teacher(x) → Knows(x, material)) ::: All teachers know the material.",
            "Study(john) ::: John studies.",
            "∀x (Student(x) → Study(x)) ::: If someone is a student, they study.",
            "∀x (Knows(x, material) → Teacher(x)) ::: If someone knows the material, then they are a teacher.",
            "Student(john) → PassExam(john) ::: If John is a student, then John passes the exam.",
            "Knows(john, material) → Teacher(john) ::: If John knows the material, then John is a teacher.",
            "∀x (Student(x) → PassExam(x)) ::: All students pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PassExam(x) ::: x passes the exam",
            "Study(x) ::: x studies",
            "Likes(x, y) ::: x likes y",
            "Knows(x, y) ::: x knows y",
            "Teacher(x) ::: x is a teacher"
        ]
    },
    {
        "premises-NL": [
            "Everyone in the class has a book.",
            "If someone has a book, then they study.",
            "Alice is in the class.",
            "If someone studies, they understand the material.",
            "If someone understands the material, they finish the assignment.",
            "If someone has a book, then they read.",
            "If someone reads, then they know.",
            "Alice has a book.",
            "If someone has a book, they understand it.",
            "If someone is in the class, they finish the assignment.",
            "If someone studies, they finish the assignment.",
            "If someone knows then they have finished the assignment.",
            "Alice reads."
        ],
        "premises-FOL": [
            "∀x (InClass(x) → HasBook(x)) ::: Everyone in the class has a book.",
            "∀x (HasBook(x) → Studies(x)) ::: If someone has a book, then they study.",
            "InClass(alice) ::: Alice is in the class.",
            "∀x (Studies(x) → Understands(x, material)) ::: If someone studies, they understand the material.",
            "∀x (Understands(x, material) → FinishedAssignment(x)) ::: If someone understands the material, they finish the assignment.",
            "∀x (HasBook(x) → Reads(x, book)) ::: If someone has a book, then they read.",
            "∀x (Reads(x, book) → Knows(x)) ::: If someone reads, then they know.",
            "HasBook(alice) ::: Alice has a book.",
            "∀x (HasBook(x) → Understands(x, book)) ::: If someone has a book, they understand it.",
            "∀x (InClass(x) → FinishedAssignment(x)) ::: If someone is in the class, they finish the assignment.",
            "∀x (Studies(x) → FinishedAssignment(x)) ::: If someone studies, they finish the assignment.",
            "∀x (Knows(x) → FinishedAssignment(x)) ::: If someone knows then they have finished the assignment.",
            "Reads(alice, book) ::: Alice reads."
        ],
        "predicates": [
            "InClass(x) ::: x is in the class",
            "FinishedAssignment(x) ::: x has finished the assignment",
            "HasBook(x) ::: x has a book",
            "Studies(x) ::: x studies",
            "Understands(x, y) ::: x understands y",
            "Reads(x, y) ::: x reads y",
            "Knows(x) ::: x knows"
        ]
    },
    {
        "premises-NL": [
            "Anyone who is a member of the group votes.",
            "If someone speaks at the meeting, they attend it.",
            "John attends the meeting.",
            "Anyone who agrees with the policy supports the policy.",
            "Anyone who supports the policy votes.",
            "Everyone who attends the meeting is a member of the group.",
            "If someone is a member of the group, they speak at the meeting.",
            "If someone is a leader, they agree with the policy.",
            "John speaks at the meeting.",
            "John is a member of the group.",
            "John agrees with the policy.",
            "John is a leader.",
            "All who attend the meeting vote.",
            "If someone supports the policy, they vote."
        ],
        "premises-FOL": [
            "∀x (MemberOf(x, group) → Votes(x)) ::: Anyone who is a member of the group votes.",
            "∀x (Speaks(x, meeting) → Attends(x, meeting)) ::: If someone speaks at the meeting, they attend it.",
            "Attends(john, meeting) ::: John attends the meeting.",
            "∀x (AgreesWith(x, policy) → Supports(x, policy)) ::: Anyone who agrees with the policy supports the policy.",
            "∀x (Supports(x, policy) → Votes(x)) ::: Anyone who supports the policy votes.",
            "∀x (Attends(x, meeting) → MemberOf(x, group)) ::: Everyone who attends the meeting is a member of the group.",
            "∀x (MemberOf(x, group) → Speaks(x, meeting)) ::: If someone is a member of the group, they speak at the meeting.",
            "∀x (LeaderOf(x, group) → AgreesWith(x, policy)) ::: If someone is a leader, they agree with the policy.",
            "Speaks(john, meeting) ::: John speaks at the meeting.",
            "MemberOf(john, group) ::: John is a member of the group.",
            "AgreesWith(john, policy) ::: John agrees with the policy.",
            "LeaderOf(john, group) ::: John is a leader.",
            "∀x (Attends(x, meeting) → Votes(x)) ::: All who attend the meeting vote.",
            "∀x (Supports(x, policy) → Votes(x)) ::: If someone supports the policy, they vote."
        ],
        "predicates": [
            "Attends(x, y) ::: x attends y",
            "Votes(x) ::: x votes",
            "MemberOf(x, y) ::: x is a member of y",
            "Speaks(x, y) ::: x speaks at y",
            "AgreesWith(x, y) ::: x agrees with y",
            "Supports(x, y) ::: x supports y",
            "LeaderOf(x, y) ::: x is a leader of y"
        ]
    },
    {
        "premises-NL": [
            "All companies are entities.",
            "If a company is profitable, it has good management.",
            "If a company has high customer satisfaction, it has satisfied customers.",
            "Companies with satisfied customers and excellent products tend to have market share growth.",
            "Companies with good management are more likely to be profitable.",
            "Market share growth often leads to increased stock prices.",
            "If a company has low debt, it's more likely to be profitable.",
            "Company A is profitable.",
            "Company A has high customer satisfaction.",
            "If a company is profitable, it will likely experience market share growth.",
            "If a company has satisfied customers, it will also have high customer satisfaction.",
            "If a company has excellent products, then the customers are satisfied.",
            "Company A has excellent products.",
            "If the company has low debt, they are profitable and have good management.",
            "If the company has low debt and the customers are satisfied, the company has good management."
        ],
        "premises-FOL": [
            "∀x (Company(x) → Entity(x)) ::: All companies are entities.",
            "∀x (Profitable(x) → GoodManagement(x)) ::: If a company is profitable, it has good management.",
            "∀x (HighCustomerSatisfaction(x) → SatisfiedCustomers(x)) ::: If a company has high customer satisfaction, it has satisfied customers.",
            "∀x (SatisfiedCustomers(x) ∧ ExcellentProducts(x) → MarketShareGrowth(x)) ::: Companies with satisfied customers and excellent products tend to have market share growth.",
            "∀x (GoodManagement(x) → Profitable(x)) ::: Companies with good management are more likely to be profitable.",
            "∀x (MarketShareGrowth(x) → StockPriceIncrease(x)) ::: Market share growth often leads to increased stock prices.",
            "∀x (LowDebt(x) → Profitable(x)) ::: If a company has low debt, it's more likely to be profitable.",
            "Profitable(CompanyA) ::: Company A is profitable.",
            "HighCustomerSatisfaction(CompanyA) ::: Company A has high customer satisfaction.",
            "∀x (Profitable(x) → MarketShareGrowth(x)) ::: If a company is profitable, it will likely experience market share growth.",
            "∀x (SatisfiedCustomers(x) → HighCustomerSatisfaction(x)) ::: If a company has satisfied customers, it will also have high customer satisfaction.",
            "∀x (ExcellentProducts(x) → SatisfiedCustomers(x)) ::: If a company has excellent products, then the customers are satisfied.",
            "ExcellentProducts(CompanyA) ::: Company A has excellent products.",
            "∀x (LowDebt(x) → (Profitable(x) ∧ GoodManagement(x))) ::: If the company has low debt, they are profitable and have good management.",
            "∀x (LowDebt(x) ∧ SatisfiedCustomers(x) → GoodManagement(x)) ::: If the company has low debt and the customers are satisfied, the company has good management."
        ],
        "predicates": [
            "Company(x) ::: x is a company",
            "Profitable(x) ::: x is profitable",
            "HighCustomerSatisfaction(x) ::: x has high customer satisfaction",
            "MarketShareGrowth(x) ::: x has market share growth",
            "StockPriceIncrease(x) ::: The stock price increases",
            "ExcellentProducts(x) ::: x has excellent products",
            "GoodManagement(x) ::: x has good management",
            "SatisfiedCustomers(x) ::: x has satisfied customers",
            "LowDebt(x) ::: x has low debt"
        ]
    },
    {
        "premises-NL": [
            "All patients are human.",
            "If a patient is diagnosed with a serious illness, they are under doctor care.",
            "Patients who are under doctor care will receive medication.",
            "Patients who receive medication and follow treatment have a positive outcome.",
            "Patients who follow treatment, they do not have side effects.",
            "Patients who are treated effectively have a positive outcome.",
            "Patients who have a positive outcome are likely to recover.",
            "If a treatment is effective, then it has a positive outcome.",
            "If a patient has a serious illness, then they are diagnosed with a serious illness.",
            "Patient A is diagnosed with a serious illness.",
            "Patient A receives medication.",
            "Patient A follows treatment.",
            "If a patient receives medication, and follows treatment, they do not have side effects.",
            "If the treatment has a positive outcome, then the patients recover.",
            "If the patient has a positive outcome, they are under doctor care.",
            "If the patient has a serious illness and receives a positive outcome, then they recover."
        ],
        "premises-FOL": [
            "∀x (Patient(x) → Human(x)) ::: All patients are human.",
            "∀x (DiagnosedWithSeriousIllness(x) → UnderDoctorCare(x)) ::: If a patient is diagnosed with a serious illness, they are under doctor care.",
            "∀x (UnderDoctorCare(x) → ReceivesMedication(x)) ::: Patients who are under doctor care will receive medication.",
            "∀x (ReceivesMedication(x) ∧ FollowsTreatment(x) → PositiveOutcome(x)) ::: Patients who receive medication and follow treatment have a positive outcome.",
            "∀x (FollowsTreatment(x) → ¬HasSideEffects(x)) ::: Patients who follow treatment, they do not have side effects.",
            "∀x (TreatedEffectively(x) → PositiveOutcome(x)) ::: Patients who are treated effectively have a positive outcome.",
            "∀x (PositiveOutcome(x) → Recovers(x)) ::: Patients who have a positive outcome are likely to recover.",
            "∀x (TreatedEffectively(x) → PositiveOutcome(x)) ::: If a treatment is effective, then it has a positive outcome.",
            "∀x (SeriousIllness(x) → DiagnosedWithSeriousIllness(x)) ::: If a patient has a serious illness, then they are diagnosed with a serious illness.",
            "DiagnosedWithSeriousIllness(PatientA) ::: Patient A is diagnosed with a serious illness.",
            "ReceivesMedication(PatientA) ::: Patient A receives medication.",
            "FollowsTreatment(PatientA) ::: Patient A follows treatment.",
            "∀x (ReceivesMedication(x) ∧ FollowsTreatment(x) → ¬HasSideEffects(x)) ::: If a patient receives medication, and follows treatment, they do not have side effects.",
            "∀x (PositiveOutcome(x) → Recovers(x)) ::: If the treatment has a positive outcome, then the patients recover.",
            "∀x (PositiveOutcome(x) → UnderDoctorCare(x)) ::: If the patient has a positive outcome, they are under doctor care.",
            "∀x (SeriousIllness(x) ∧ PositiveOutcome(x) → Recovers(x)) ::: If the patient has a serious illness and receives a positive outcome, then they recover."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient",
            "DiagnosedWithSeriousIllness(x) ::: x is diagnosed with a serious illness",
            "TreatedEffectively(x) ::: x is treated effectively",
            "ReceivesMedication(x) ::: x receives medication",
            "UnderDoctorCare(x) ::: x is under doctor's care",
            "HasHighRecoveryRate(x) ::: x has a high recovery rate",
            "SeriousIllness(x) ::: x is a serious illness",
            "Doctor(x) ::: x is a doctor",
            "FollowsTreatment(x) ::: x follows treatment",
            "PositiveOutcome(x) ::: x has a positive outcome",
            "HasSideEffects(x) ::: x has side effects"
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled in courses.",
            "Students who study hard do their homework.",
            "Students who attend all classes participate in class.",
            "Students who do homework and participate in class are prepared.",
            "If a student is prepared, they are likely to pass their exams.",
            "Students who pass exams get good grades.",
            "Studying hard involves reading textbooks.",
            "Attending classes involves taking notes.",
            "Doing homework involves following instructions.",
            "If a student studies hard, then they are likely to read textbooks and do homework.",
            "If a student attends all classes, then they will take notes and participate in class.",
            "If a student is prepared and they follow instructions, then they get good grades.",
            "Student X studies hard.",
            "Student X attends all classes.",
            "If a student is enrolled in a course, and gets good grades, they are a successful student.",
            "A successful student has a great future."
        ],
        "premises-FOL": [
            "∀x (Student(x) → EnrolledInCourse(x)) ::: All students are enrolled in courses.",
            "∀x (StudiesHard(x) → DoesHomework(x)) ::: Students who study hard do their homework.",
            "∀x (AttendsClasses(x) → ParticipatesInClass(x)) ::: Students who attend all classes participate in class.",
            "∀x (DoesHomework(x) ∧ ParticipatesInClass(x) → IsPrepared(x)) ::: Students who do homework and participate in class are prepared.",
            "∀x (IsPrepared(x) → PassesExams(x)) ::: If a student is prepared, they are likely to pass their exams.",
            "∀x (PassesExams(x) → GetsGoodGrades(x)) ::: Students who pass exams get good grades.",
            "∀x (StudiesHard(x) → ReadsTextbooks(x)) ::: Studying hard involves reading textbooks.",
            "∀x (AttendsClasses(x) → TakesNotes(x)) ::: Attending classes involves taking notes.",
            "∀x (DoesHomework(x) → FollowsInstructions(x)) ::: Doing homework involves following instructions.",
            "∀x (StudiesHard(x) → (ReadsTextbooks(x) ∧ DoesHomework(x))) ::: If a student studies hard, then they are likely to read textbooks and do homework.",
            "∀x (AttendsClasses(x) → (TakesNotes(x) ∧ ParticipatesInClass(x))) ::: If a student attends all classes, then they will take notes and participate in class.",
            "∀x (IsPrepared(x) ∧ FollowsInstructions(x) → GetsGoodGrades(x)) ::: If a student is prepared and they follow instructions, then they get good grades.",
            "StudiesHard(StudentX) ::: Student X studies hard.",
            "AttendsClasses(StudentX) ::: Student X attends all classes.",
            "∀x (EnrolledInCourse(x) ∧ GetsGoodGrades(x) → SuccessfulStudent(x)) ::: If a student is enrolled in a course, and gets good grades, they are a successful student.",
            "∀x (SuccessfulStudent(x) → GreatFuture(x)) ::: A successful student has a great future."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "AttendsClasses(x) ::: x attends classes",
            "GetsGoodGrades(x) ::: x gets good grades",
            "PassesExams(x) ::: x passes exams",
            "DoesHomework(x) ::: x does homework",
            "ParticipatesInClass(x) ::: x participates in class",
            "IsPrepared(x) ::: x is prepared",
            "ReadsTextbooks(x) ::: x reads textbooks",
            "TakesNotes(x) ::: x takes notes",
            "FollowsInstructions(x) ::: x follows instructions"
        ]
    },
    {
        "premises-NL": [
            "All employees with good performance will be promoted.",
            "Sarah is an employee and has good performance.",
            "David is an employee.",
            "If David has good performance, then David will be promoted.",
            "Sarah is an employee.",
            "If Sarah is promoted, then David isn't."
        ],
        "premises-FOL": [
            "∀x (Employee(x) ∧ GoodPerformance(x) → Promoted(x)) ::: All employees with good performance will be promoted.",
            "Employee(Sarah) ∧ GoodPerformance(Sarah) ::: Sarah is an employee and has good performance.",
            "Employee(David) ::: David is an employee.",
            "GoodPerformance(David) → Promoted(David) ::: If David has good performance, then David will be promoted.",
            "Employee(Sarah) ::: Sarah is an employee.",
            "Promoted(Sarah) → ¬Promoted(David) ::: If Sarah is promoted, then David isn't."
        ],
        "predicates": [
            "Employee(x) ::: x is an employee.",
            "GoodPerformance(x) ::: x has good performance.",
            "Promoted(x) ::: x is promoted.",
            "Sarah(x) ::: x is Sarah.",
            "David(x) ::: x is David."
        ]
    },
    {
        "premises-NL": [
            "All doctors study medicine.",
            "Anyone who studies medicine enjoys reading.",
            "If someone enjoys reading, they are well-informed.",
            "John is a doctor.",
            "John studies medicine.",
            "All well-informed people are doctors.",
            "Anyone who enjoys reading is a doctor.",
            "Anyone who studies medicine is a doctor.",
            "Doctors who are well-informed enjoy reading.",
            "If someone is a doctor, they are well-informed.",
            "If someone studies medicine, they are well-informed.",
            "John is a doctor who studies medicine.",
            "John is a well-informed doctor.",
            "Doctors always enjoy reading and are well-informed.",
            "If a doctor enjoys reading, they are well-informed.",
            "If someone is a doctor and well informed, they are a doctor.",
            "If someone enjoys reading and is a doctor, then they are well informed.",
            "If someone is a doctor, they are well-informed or they enjoy reading."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → StudiesMedicine(x)) ::: All doctors study medicine.",
            "∀x (StudiesMedicine(x) → EnjoysReading(x)) ::: Anyone who studies medicine enjoys reading.",
            "∀x (EnjoysReading(x) → WellInformedDoctor(x)) ::: If someone enjoys reading, they are well-informed.",
            "Doctor(John) ::: John is a doctor.",
            "StudiesMedicine(John) ::: John studies medicine.",
            "∀x (WellInformedDoctor(x) → Doctor(x)) ::: All well-informed people are doctors.",
            "∀x (EnjoysReading(x) → Doctor(x)) ::: Anyone who enjoys reading is a doctor.",
            "∀x (StudiesMedicine(x) → Doctor(x)) ::: Anyone who studies medicine is a doctor.",
            "∀x ((Doctor(x) ∧ WellInformedDoctor(x)) → EnjoysReading(x)) ::: Doctors who are well-informed enjoy reading.",
            "∀x (Doctor(x) → WellInformedDoctor(x)) ::: If someone is a doctor, they are well-informed.",
            "∀x (StudiesMedicine(x) → WellInformedDoctor(x)) ::: If someone studies medicine, they are well-informed.",
            "Doctor(John) ∧ StudiesMedicine(John) ::: John is a doctor who studies medicine.",
            "WellInformedDoctor(John) ::: John is a well-informed doctor.",
            "∀x (Doctor(x) → (EnjoysReading(x) ∧ WellInformedDoctor(x))) ::: Doctors always enjoy reading and are well-informed.",
            "∀x ((Doctor(x) ∧ EnjoysReading(x)) → WellInformedDoctor(x)) ::: If a doctor enjoys reading, they are well-informed.",
            "∀x ((Doctor(x) ∧ WellInformedDoctor(x)) → Doctor(x)) ::: If someone is a doctor and well informed, they are a doctor.",
            "∀x ((EnjoysReading(x) ∧ Doctor(x)) → WellInformedDoctor(x)) ::: If someone enjoys reading and is a doctor, then they are well informed.",
            "∀x (Doctor(x) → (WellInformedDoctor(x) ∨ EnjoysReading(x))) ::: If someone is a doctor, they are well-informed or they enjoy reading."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "EnjoysReading(x) ::: x enjoys reading.",
            "WellInformedDoctor(x) ::: x is a well-informed doctor.",
            "StudiesMedicine(x) ::: x studies medicine."
        ]
    },
    {
        "premises-NL": [
            "All students either study computer science or mathematics.",
            "John is a student.",
            "If a student studies computer science, then they like it.",
            "If a student studies mathematics, they like it.",
            "John likes computer science.",
            "John likes mathematics.",
            "If a student likes a subject and studies it, then they are interested in it.",
            "Some students like mathematics.",
            "Professor teaches mathematics.",
            "Professor teaches computer science.",
            "If a student likes something, they will study it.",
            "If someone studies a subject, then they have an interest in it.",
            "All students are smart.",
            "The student studies something."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Studies(x, computerScience) ∨ Studies(x, mathematics))) ::: All students either study computer science or mathematics.",
            "Student(john) ::: John is a student.",
            "∀x (Studies(x, computerScience) → Likes(x, computerScience)) ::: If a student studies computer science, then they like it.",
            "∀x (Studies(x, mathematics) → Likes(x, mathematics)) ::: If a student studies mathematics, they like it.",
            "Likes(john, computerScience) ::: John likes computer science.",
            "Likes(john, mathematics) ::: John likes mathematics.",
            "∀x ∀y ((Likes(x, y) ∧ Studies(x, y)) → Interested(x, y)) ::: If a student likes a subject and studies it, then they are interested in it.",
            "∃x (Student(x) ∧ Likes(x, mathematics)) ::: Some students like mathematics.",
            "Teaches(professor, mathematics) ::: Professor teaches mathematics.",
            "Teaches(professor, computerScience) ::: Professor teaches computer science.",
            "∀x ∀y (Likes(x, y) → Studies(x, y)) ::: If a student likes something, they will study it.",
            "∀x ∀y (Studies(x, y) → Interested(x, y)) ::: If someone studies a subject, then they have an interest in it.",
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "∃x ∃y (Student(x) ∧ Studies(x,y)) ::: The student studies something."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Studies(x, y) ::: x studies subject y.",
            "Likes(x, y) ::: x likes subject y.",
            "Teaches(x, y) ::: x teaches subject y.",
            "ComputerScience(x) ::: x is computer science.",
            "Mathematics(x) ::: x is mathematics."
        ]
    },
    {
        "premises-NL": [
            "Every student studies hard.",
            "John is a student.",
            "If someone studies hard, then they pass the exam.",
            "All students like coffee.",
            "If someone likes coffee and attends lectures, then they studies hard.",
            "John attends lectures."
        ],
        "premises-FOL": [
            "∀x (Student(x) → StudiesHard(x)) ::: All students study hard.",
            "Student(john) ::: John is a student.",
            "∀x (StudiesHard(x) → PassesExam(x)) ::: If someone studies hard, then they pass the exam.",
            "∀x (Student(x) → LikesCoffee(x)) ::: All students like coffee.",
            "∀x (LikesCoffee(x) ∧ AttendsLecture(x) → StudiesHard(x)) ::: If someone likes coffee and attends lectures, then they study hard.",
            "AttendsLecture(john) ::: John attends lectures."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassesExam(x) ::: x passes the exam",
            "LikesCoffee(x) ::: x likes coffee",
            "AttendsLecture(x) ::: x attends the lecture"
        ]
    },
    {
        "premises-NL": [
            "All researchers work at a university.",
            "Anyone who works at a university, if they are a scientist, has published a paper in Nature.",
            "John is a researcher.",
            "John is a scientist.",
            "John has published a paper in Nature.",
            "If someone publishes a paper, they receive a grant.",
            "Grants are available."
        ],
        "premises-FOL": [
            "∀x (Researcher(x) → WorksAtUniversity(x)) ::: All researchers work at a university.",
            "∀x (WorksAtUniversity(x) ∧ IsScientist(x) → PublishedInNature(x)) ::: Anyone who works at a university, if they are a scientist, has published a paper in Nature.",
            "Researcher(john) ::: John is a researcher.",
            "IsScientist(john) ::: John is a scientist.",
            "PublishedInNature(john) ::: John has published a paper in Nature.",
            "∀x (PublishedInNature(x) → ReceivedGrant(x)) ::: If someone publishes a paper, they receive a grant.",
            "∃x GrantAvailable(x) ::: Grants are available."
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher",
            "PublishedInNature(x) ::: x is published in Nature",
            "ReceivedGrant(x) ::: x received a grant",
            "WorksAtUniversity(x) ::: x works at a university",
            "PublishesPaper(x, y) ::: x publishes paper y",
            "IsScientist(x) ::: x is a scientist",
            "GrantAvailable(x) ::: x is a grant that is available"
        ]
    },
    {
        "premises-NL": [
            "All students either study hard or are lazy.",
            "No one is both smart and lazy.",
            "All students who study hard have a lot of friends.",
            "John is a student.",
            "John is smart.",
            "If someone is smart and has a lot of friends, then they like coffee.",
            "If John is smart, then John studies hard.",
            "If someone does not like coffee, then they don't play sports.",
            "All students play sports or do not have a lot of friends."
        ],
        "premises-FOL": [
            "∀x (Student(x) → StudiesHard(x) ∨ IsLazy(x)) ::: All students either study hard or are lazy.",
            "¬∃x (IsSmart(x) ∧ IsLazy(x)) ::: No one is both smart and lazy.",
            "∀x (Student(x) ∧ StudiesHard(x) → HasALotOfFriends(x)) ::: All students who study hard have a lot of friends.",
            "Student(john) ::: John is a student.",
            "IsSmart(john) ::: John is smart.",
            "∀x (IsSmart(x) ∧ HasALotOfFriends(x) → LikesCoffee(x)) ::: If someone is smart and has a lot of friends, then they like coffee.",
            "∀x (IsSmart(x) → StudiesHard(x)) ::: If John is smart, then John studies hard.",
            "∀x (¬LikesCoffee(x) → ¬PlaysSports(x)) ::: If someone does not like coffee, then they don't play sports.",
            "∀x (Student(x) → PlaysSports(x) ∨ ¬HasALotOfFriends(x)) ::: All students play sports or do not have a lot of friends."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "HasALotOfFriends(x) ::: x has a lot of friends",
            "LikesCoffee(x) ::: x likes coffee",
            "StudiesHard(x) ::: x studies hard",
            "AttendsLecture(x) ::: x attends lectures",
            "IsSmart(x) ::: x is smart",
            "IsLazy(x) ::: x is lazy",
            "HasFriends(x, y) ::: x has y as friend",
            "PlaysSports(x) ::: x plays sports"
        ]
    },
    {
        "premises-NL": [
            "All students are diligent.",
            "Some students are successful.",
            "If someone is a student, then they are either diligent or not.",
            "If someone is a student and not diligent, they cannot be successful.",
            "If someone is diligent then they are a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Diligence(x)) ::: All students are diligent.",
            "∃x (Student(x) ∧ Successful(x)) ::: Some students are successful.",
            "∀x (Student(x) → (Diligence(x) ∨ ¬Diligence(x))) ::: If someone is a student, then they are either diligent or not.",
            "∀x ((Student(x) ∧ ¬Diligence(x)) → ¬Successful(x)) ::: If someone is a student and not diligent, they cannot be successful.",
            "∀x (Diligence(x) → Student(x)) ::: If someone is diligent then they are a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Diligence(x) ::: x is diligent",
            "Successful(x) ::: x is successful"
        ]
    },
    {
        "premises-NL": [
            "All patients are people.",
            "All patients with a disease are not vaccinated.",
            "If someone is not vaccinated, then they get sick.",
            "Alice is a patient.",
            "Alice has a disease.",
            "If someone is a patient and has a disease, then the patient is not vaccinated.",
            "Bob is a doctor.",
            "Bob prescribes medication to Charlie.",
            "Charlie is a patient."
        ],
        "premises-FOL": [
            "∀x (IsPatientOf(x, y) → Person(x)) ::: All patients are people.",
            "∀x (HasDisease(x) ∧ IsPatientOf(x, y) → ¬Vaccinated(x)) ::: All patients with a disease are not vaccinated.",
            "∀x (¬Vaccinated(x) → GetsSick(x)) ::: If someone is not vaccinated, then they get sick.",
            "IsPatientOf(alice, bob) ::: Alice is a patient.",
            "HasDisease(alice) ::: Alice has a disease.",
            "∀x (IsPatientOf(x, y) ∧ HasDisease(x) → ¬Vaccinated(x)) ::: If someone is a patient and has a disease, then the patient is not vaccinated.",
            "Doctor(bob) ::: Bob is a doctor.",
            "PrescribesMedication(bob, charlie) ::: Bob prescribes medication to Charlie.",
            "IsPatientOf(charlie, bob) ::: Charlie is a patient."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "HasDisease(x) ::: x has a disease.",
            "Vaccinated(x) ::: x is vaccinated.",
            "GetsSick(x) ::: x gets sick.",
            "IsPatientOf(x, y) ::: x is a patient of doctor y.",
            "Doctor(x) ::: x is a doctor.",
            "PrescribesMedication(x, y) ::: doctor x prescribes medication to patient y."
        ]
    },
    {
        "premises-NL": [
            "All apples are fruits.",
            "All apples are sweet and red.",
            "If a fruit is an apple, then it grows on a tree.",
            "If a fruit is sweet and red, then it's likely an apple.",
            "A certain fruit is sweet.",
            "This fruit is red.",
            "This fruit grows on a tree.",
            "All berries are fruits.",
            "All berries are eatable.",
            "If something is a berry, then it is not an apple."
        ],
        "premises-FOL": [
            "∀x (IsApple(x) → Fruit(x)) ::: All apples are fruits.",
            "∀x (IsApple(x) → Sweet(x) ∧ Red(x)) ::: All apples are sweet and red.",
            "∀x (IsApple(x) → GrowsOnTree(x)) ::: If a fruit is an apple, then it grows on a tree.",
            "∀x (Sweet(x) ∧ Red(x) → LikelyApple(x)) ::: If a fruit is sweet and red, it is likely an apple.",
            "∃x Sweet(x) ::: A certain fruit is sweet.",
            "∃x Red(x) ::: This fruit is red.",
            "∃x GrowsOnTree(x) ::: This fruit grows on a tree.",
            "∀x (IsBerry(x) → Fruit(x)) ::: All berries are fruits.",
            "∀x (IsBerry(x) → Eatable(x)) ::: All berries are eatable.",
            "∀x (IsBerry(x) → ¬IsApple(x)) ::: If something is a berry, then it is not an apple."
        ],
        "predicates": [
            "Fruit(x) ::: x is a fruit.",
            "Sweet(x) ::: x is sweet.",
            "Red(x) ::: x is red.",
            "LikelyApple(x) ::: x is likely an apple.",
            "GrowsOnTree(x) ::: x grows on a tree.",
            "IsApple(x) ::: x is an apple.",
            "Eatable(x) ::: x is eatable.",
            "IsBerry(x) ::: x is a berry."
        ]
    },
    {
        "premises-NL": [
            "All publicly traded companies are companies.",
            "Profitable companies tend to attract investors.",
            "Companies with high employee satisfaction tend to attract investors.",
            "If a company is profitable and has high employee satisfaction, it will likely attract investors.",
            "Company A is a publicly traded company.",
            "Company A is profitable.",
            "Company A has good management.",
            "Company B is profitable.",
            "Company B offers stock options.",
            "If a company offers stock options, then it has high employee satisfaction.",
            "Company C is a tech company."
        ],
        "premises-FOL": [
            "∀x (PubliclyTraded(x) → Company(x)) ::: All publicly traded companies are companies.",
            "∀x (Profitable(x) → LikelyAttractInvestors(x)) ::: Profitable companies tend to attract investors.",
            "∀x (HighEmployeeSatisfaction(x) → LikelyAttractInvestors(x)) ::: Companies with high employee satisfaction tend to attract investors.",
            "∀x (Profitable(x) ∧ HighEmployeeSatisfaction(x) → LikelyAttractInvestors(x)) ::: If a company is profitable and has high employee satisfaction, it will likely attract investors.",
            "PubliclyTraded(companyA) ::: Company A is a publicly traded company.",
            "Profitable(companyA) ::: Company A is profitable.",
            "GoodManagement(companyA) ::: Company A has good management.",
            "Profitable(companyB) ::: Company B is profitable.",
            "OffersStockOptions(companyB) ::: Company B offers stock options.",
            "∀x (OffersStockOptions(x) → HighEmployeeSatisfaction(x)) ::: If a company offers stock options, then it has high employee satisfaction.",
            "IsTechCompany(companyC) ::: Company C is a tech company."
        ],
        "predicates": [
            "Company(x) ::: x is a company.",
            "Profitable(x) ::: x is profitable.",
            "HighEmployeeSatisfaction(x) ::: x has high employee satisfaction.",
            "LikelyAttractInvestors(x) ::: x likely attracts investors.",
            "PubliclyTraded(x) ::: x is publicly traded.",
            "GoodManagement(x) ::: x has good management.",
            "PaysDividends(x) ::: x pays dividends.",
            "HasDebt(x) ::: x has debt.",
            "OffersStockOptions(x) ::: x offers stock options.",
            "IsTechCompany(x) ::: x is a tech company.",
            "Innovates(x) ::: x innovates."
        ]
    },
    {
        "premises-NL": [
            "All mammals are organisms.",
            "All mammals have fur.",
            "All mammals give live birth.",
            "If an organism is a mammal, has fur, and gives live birth, then it is an animal.",
            "A certain animal is a herbivore.",
            "Herbivores eat plants.",
            "Some mammals are herbivores.",
            "All animals have teeth.",
            "Some mammals are carnivores.",
            "Carnivores eat meat.",
            "If something is a mammal and aquatic, then it is not a carnivore.",
            "A whale is a mammal and aquatic."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → Organism(x)) ::: All mammals are organisms.",
            "∀x (Mammal(x) → HasFur(x)) ::: All mammals have fur.",
            "∀x (Mammal(x) → GivesLiveBirth(x)) ::: All mammals give live birth.",
            "∀x (Mammal(x) ∧ HasFur(x) ∧ GivesLiveBirth(x) → Animal(x)) ::: If an organism is a mammal, has fur, and gives live birth, then it is an animal.",
            "∃x (Animal(x) ∧ IsHerbivore(x)) ::: A certain animal is a herbivore.",
            "∀x (IsHerbivore(x) → EatsPlants(x)) ::: Herbivores eat plants.",
            "∃x (Mammal(x) ∧ IsHerbivore(x)) ::: Some mammals are herbivores.",
            "∀x (Animal(x) → HasTeeth(x)) ::: All animals have teeth.",
            "∃x (Mammal(x) ∧ IsCarnivore(x)) ::: Some mammals are carnivores.",
            "∀x (IsCarnivore(x) → EatsMeat(x)) ::: Carnivores eat meat.",
            "∀x ∀y (Mammal(x) ∧ Aquatic(x) → ¬IsCarnivore(x)) ::: If something is a mammal and aquatic, then it is not a carnivore.",
            "Mammal(whale) ∧ Aquatic(whale) ::: A whale is a mammal and aquatic."
        ],
        "predicates": [
            "Organism(x) ::: x is an organism.",
            "Mammal(x) ::: x is a mammal.",
            "HasFur(x) ::: x has fur.",
            "GivesLiveBirth(x) ::: x gives live birth.",
            "Animal(x) ::: x is an animal.",
            "IsHerbivore(x) ::: x is a herbivore.",
            "EatsPlants(x) ::: x eats plants.",
            "HasTeeth(x) ::: x has teeth.",
            "IsCarnivore(x) ::: x is a carnivore.",
            "EatsMeat(x) ::: x eats meat.",
            "LivesInHabitat(x, y) ::: x lives in habitat y.",
            "Aquatic(x) ::: x is aquatic."
        ]
    },
    {
        "premises-NL": [
            "John is a student.",
            "All students who study hard will pass the exam.",
            "John studies hard.",
            "If someone is a student and studies hard, they will pass the exam.",
            "Being a student is a necessary condition to study hard."
        ],
        "premises-FOL": [
            "Student(john) ::: John is a student",
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: All students who study hard will pass the exam",
            "StudiesHard(john) ::: John studies hard",
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: If someone is a student and studies hard, they will pass the exam",
            "∀x (StudiesHard(x) → Student(x)) ::: Being a student is a necessary condition to study hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x will pass the exam"
        ]
    },
    {
        "premises-NL": [
            "If two people are friends, one likes the other.",
            "Alice and Bob are friends.",
            "If someone likes someone, they are also friends.",
            "If Alice and Bob are friends, then Alice likes Bob.",
            "If Alice likes Bob, they are friends.",
            "Alice and Bob are not the same age."
        ],
        "premises-FOL": [
            "∀x ∀y (Friend(x, y) → Likes(x, y)) ::: If two people are friends, one likes the other.",
            "Friend(alice, bob) ::: Alice and Bob are friends.",
            "∀x ∀y (Likes(x, y) → Friend(x, y)) ::: If someone likes someone, they are also friends.",
            "∀x ∀y (Friend(x, y) → Likes(x, y)) ::: If Alice and Bob are friends, then Alice likes Bob.",
            "∀x ∀y (Likes(x, y) → Friend(x, y)) ::: If Alice likes Bob, they are friends.",
            "¬SameAge(alice, bob) ::: Alice and Bob are not the same age."
        ],
        "predicates": [
            "Friend(x, y) ::: x and y are friends",
            "Likes(x, y) ::: x likes y",
            "SameAge(x, y) ::: x and y are the same age"
        ]
    },
    {
        "premises-NL": [
            "All students are either lazy or study hard.",
            "Some students are lazy.",
            "If someone is lazy, they do not study.",
            "If someone studies, then they pass the exam.",
            "All students who do not pass the exam are lazy.",
            "There is a student.",
            "If a student does not study, he is lazy"
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Lazy(x) ∨ Studies(x))) ::: All students are either lazy or study hard.",
            "∃x (Student(x) ∧ Lazy(x)) ::: Some students are lazy.",
            "∀x (Lazy(x) → ¬Studies(x)) ::: If someone is lazy, they do not study.",
            "∀x (Studies(x) → PassExam(x)) ::: If someone studies, then they pass the exam.",
            "∀x (Student(x) ∧ ¬PassExam(x) → Lazy(x)) ::: All students who do not pass the exam are lazy.",
            "∃x Student(x) ::: There is a student.",
            "∀x (Student(x) ∧ ¬Studies(x) → Lazy(x)) ::: If a student does not study, he is lazy"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Lazy(x) ::: x is lazy",
            "PassExam(x) ::: x passes the exam",
            "Studies(x) ::: x studies"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard will pass the exam.",
            "Anyone who passes the exam will graduate.",
            "Some students study hard.",
            "Everyone who studies hard attends class.",
            "All who attend class have books.",
            "Anyone with books reads books.",
            "Some students get good grades.",
            "Anyone who gets good grades does their homework.",
            "If a student does their homework and studies hard, they pass the exam."
        ],
        "premises-FOL": [
            "∀x ((Student(x) ∧ StudiesHard(x)) → PassExam(x)) ::: All students who study hard will pass the exam.",
            "∀x (PassExam(x) → Graduates(x)) ::: Anyone who passes the exam will graduate.",
            "∃x (Student(x) ∧ StudiesHard(x)) ::: Some students study hard.",
            "∀x (StudiesHard(x) → AttendsClass(x)) ::: Everyone who studies hard attends class.",
            "∀x (AttendsClass(x) → HasBooks(x)) ::: All who attend class have books.",
            "∀x (HasBooks(x) → ReadsBooks(x)) ::: Anyone with books reads books.",
            "∃x (Student(x) ∧ GetsGoodGrades(x)) ::: Some students get good grades.",
            "∀x (GetsGoodGrades(x) → DoesHomework(x)) ::: Anyone who gets good grades does their homework.",
            "∀x ((Student(x) ∧ DoesHomework(x) ∧ StudiesHard(x)) → PassExam(x)) ::: If a student does their homework and studies hard, they pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "Graduates(x) ::: x graduates",
            "AttendsClass(x) ::: x attends class",
            "HasBooks(x) ::: x has books",
            "ReadsBooks(x) ::: x reads books",
            "GetsGoodGrades(x) ::: x gets good grades",
            "DoesHomework(x) ::: x does homework"
        ]
    },
    {
        "premises-NL": [
            "All doctors help people.",
            "Alice is a doctor.",
            "Bob is a student.",
            "If someone is a student, they do not help people.",
            "Alice is not a student.",
            "Anyone is either a student or a doctor.",
            "Alice is a person"
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Helps(x, people)) ::: All doctors help people.",
            "Doctor(alice) ::: Alice is a doctor.",
            "Student(bob) ::: Bob is a student.",
            "∀x (Student(x) → ¬Helps(x, people)) ::: If someone is a student, they do not help people.",
            "¬Student(alice) ::: Alice is not a student.",
            "∀x (Student(x) ∨ Doctor(x)) ::: Anyone is either a student or a doctor.",
            "Person(alice) ::: Alice is a person.",
            "Happy(alice) ::: Alice is happy.",
            "∀x (Happy(x) → Helps(x, people)) ::: If someone is happy, they help people.",
            "¬Helps(bob, people) ::: Bob does not help people."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Student(x) ::: x is a student",
            "Helps(x, y) ::: x helps y"
        ]
    },
    {
        "premises-NL": [
            "John is a student.",
            "All students who study hard pass the exam.",
            "John studies hard.",
            "If John likes pizza, then John studies hard.",
            "John likes pizza.",
            "Mary is a student.",
            "Mary studies hard.",
            "If Mary studies hard, then Mary passes the exam.",
            "All students who like pizza study hard.",
            "If someone passes the exam, then they're happy."
        ],
        "premises-FOL": [
            "Student(John) ::: John is a student",
            "∀x (Student(x) ∧ StudiesHard(x) → PassesExam(x)) ::: All students who study hard pass the exam",
            "StudiesHard(John) ::: John studies hard",
            "LikesPizza(John) → StudiesHard(John) ::: If John likes pizza, then John studies hard",
            "LikesPizza(John) ::: John likes pizza",
            "Student(Mary) ::: Mary is a student",
            "StudiesHard(Mary) ::: Mary studies hard",
            "StudiesHard(Mary) → PassesExam(Mary) ::: If Mary studies hard, then Mary passes the exam",
            "∀x (Student(x) ∧ LikesPizza(x) → StudiesHard(x)) ::: All students who like pizza study hard",
            "∀x (PassesExam(x) → Happy(x)) ::: If someone passes the exam, then they're happy"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassesExam(x) ::: x passes the exam",
            "LikesPizza(x) ::: x likes pizza"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "Sarah is a surgeon.",
            "All doctors help patients.",
            "If someone is a doctor, then they are kind.",
            "If someone is kind, then they help patients.",
            "All surgeons like surgery.",
            "John is a surgeon.",
            "John is kind.",
            "If John likes surgery, then he helps patients.",
            "If Sarah is a doctor and likes surgery, then Sarah helps patients.",
            "Sarah is a doctor."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors",
            "Surgeon(Sarah) ::: Sarah is a surgeon",
            "∀x (Doctor(x) → HelpsPatients(x)) ::: All doctors help patients",
            "∀x (Doctor(x) → IsKind(x)) ::: If someone is a doctor, then they are kind",
            "∀x (IsKind(x) → HelpsPatients(x)) ::: If someone is kind, then they help patients",
            "∀x (Surgeon(x) → LikesSurgery(x)) ::: All surgeons like surgery",
            "Surgeon(John) ::: John is a surgeon",
            "IsKind(John) ::: John is kind",
            "LikesSurgery(John) → HelpsPatients(John) ::: If John likes surgery, then he helps patients",
            "(Doctor(Sarah) ∧ LikesSurgery(Sarah)) → HelpsPatients(Sarah) ::: If Sarah is a doctor and likes surgery, then Sarah helps patients",
            "Doctor(Sarah) ::: Sarah is a doctor"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "HelpsPatients(x) ::: x helps patients",
            "LikesSurgery(x) ::: x likes surgery",
            "IsKind(x) ::: x is kind"
        ]
    },
    {
        "premises-NL": [
            "All painters are artists.",
            "All sculptors are artists.",
            "If someone is a painter or a sculptor, then they are creative.",
            "If someone is creative, then they are talented.",
            "All talented people like art.",
            "John is a painter.",
            "Mary is a sculptor.",
            "John and Mary are artists.",
            "If someone likes art, they are talented.",
            "If someone is an artist, they are creative.",
            "At least one person is a painter and a sculptor.",
            "Everyone who is both a painter and a sculptor is an artist."
        ],
        "premises-FOL": [
            "∀x (Painter(x) → Artist(x)) ::: All painters are artists",
            "∀x (Sculptor(x) → Artist(x)) ::: All sculptors are artists",
            "∀x ((Painter(x) ∨ Sculptor(x)) → Creative(x)) ::: If someone is a painter or a sculptor, then they are creative",
            "∀x (Creative(x) → IsTalented(x)) ::: If someone is creative, then they are talented",
            "∀x (IsTalented(x) → LikesArt(x)) ::: All talented people like art",
            "Painter(John) ::: John is a painter",
            "Sculptor(Mary) ::: Mary is a sculptor",
            "Artist(John) ∧ Artist(Mary) ::: John and Mary are artists",
            "∀x (LikesArt(x) → IsTalented(x)) ::: If someone likes art, they are talented",
            "∀x (Artist(x) → Creative(x)) ::: If someone is an artist, they are creative",
            "∃x (Painter(x) ∧ Sculptor(x)) ::: At least one person is a painter and a sculptor",
            "∀x ((Painter(x) ∧ Sculptor(x)) → Artist(x)) ::: Everyone who is both a painter and a sculptor is an artist"
        ],
        "predicates": [
            "Artist(x) ::: x is an artist",
            "Painter(x) ::: x is a painter",
            "Sculptor(x) ::: x is a sculptor",
            "LikesArt(x) ::: x likes art",
            "Creative(x) ::: x is creative",
            "IsTalented(x) ::: x is talented"
        ]
    },
    {
        "premises-NL": [
            "All students are either diligent or lazy.",
            "All lazy students fail.",
            "Some students are successful.",
            "Anyone who is not diligent fails.",
            "Every student is a student.",
            "If a student is not lazy, then he/she is diligent."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Diligent(x) ∨ Lazy(x))) ::: All students are either diligent or lazy.",
            "∀x (Lazy(x) → ¬Successful(x)) ::: All lazy students fail.",
            "∃x (Student(x) ∧ Successful(x)) ::: Some students are successful.",
            "∀x (¬Diligent(x) → ¬Successful(x)) ::: Anyone who is not diligent fails.",
            "∀x (Student(x) → Student(x)) ::: Every student is a student.",
            "∀x (Student(x) ∧ ¬Lazy(x) → Diligent(x)) ::: If a student is not lazy, then he/she is diligent."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Diligent(x) ::: x is diligent",
            "Successful(x) ::: x is successful"
        ]
    },
    {
        "premises-NL": [
            "All patients either have the disease or do not have the disease.",
            "If a patient has the disease and is treated with medicine A, then they receive medicine A.",
            "Medicine A treats the disease.",
            "Any patient treated by medicine A is either helped or not helped.",
            "No patient is immune to medicine A.",
            "If a patient is not immune, then administering medicine A to the patient will treat the disease.",
            "If a patient has the disease and receives medicine A, then the patient is treated by A."
        ],
        "premises-FOL": [
            "∀x (Patient(x) → (HasDisease(x) ∨ ¬HasDisease(x))) ::: All patients either have the disease or do not have the disease.",
            "∀x (Patient(x) ∧ HasDisease(x) ∧ TreatedByA(x) → TreatedByA(x)) ::: If a patient has the disease and is treated with medicine A, then they receive medicine A.",
            "∀x (HasDisease(x) → TreatedByA(x)) ::: Medicine A treats the disease.",
            "∀x (TreatedByA(x) → (Helps(x) ∨ ¬Helps(x))) ::: Any patient treated by medicine A is either helped or not helped.",
            "∀x (¬Immune(x)) ::: No patient is immune to medicine A.",
            "∀x (Patient(x) ∧ ¬Immune(x) → TreatedByA(x)) ::: If a patient is not immune, then administering medicine A to the patient will treat the disease.",
            "∀x (Patient(x) ∧ HasDisease(x) ∧ TreatedByA(x) → TreatedByA(x)) ::: If a patient has the disease and receives medicine A, then the patient is treated by A."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient",
            "HasDisease(x) ::: x has the disease",
            "TreatedByA(x) ::: x is treated by medicine A",
            "Immune(x) ::: x is immune",
            "Helps(x) ::: medicine helps x"
        ]
    },
    {
        "premises-NL": [
            "All species either exist or are extinct.",
            "If a species reproduces and exists, then it is not extinct.",
            "If a species evolves, it is a species.",
            "Some species have evolved.",
            "If a species exists, then it reproduces.",
            "A species that reproduces is not extinct.",
            "If a species has evolved and is not extinct, then it exists.",
            "A species that is extinct doesn't evolve."
        ],
        "premises-FOL": [
            "∀x (Species(x) → (Exists(x) ∨ Extinct(x))) ::: All species either exist or are extinct.",
            "∀x (Species(x) ∧ Reproduces(x) → ¬Extinct(x)) ::: If a species reproduces and exists, then it is not extinct.",
            "∀x (Evolved(x) → Species(x)) ::: If a species evolves, it is a species.",
            "∃x (Species(x) ∧ Evolved(x)) ::: Some species have evolved.",
            "∀x (Exists(x) → Reproduces(x)) ::: If a species exists, then it reproduces.",
            "∀x (Reproduces(x) → ¬Extinct(x)) ::: A species that reproduces is not extinct.",
            "∀x (Species(x) ∧ Evolved(x) ∧ ¬Extinct(x) → Exists(x)) ::: If a species has evolved and is not extinct, then it exists.",
            "∀x (Extinct(x) → ¬Evolved(x)) ::: A species that is extinct doesn't evolve."
        ],
        "predicates": [
            "Species(x) ::: x is a species",
            "Extinct(x) ::: x is extinct",
            "Evolved(x) ::: x has evolved",
            "Exists(x) ::: x exists",
            "Reproduces(x) ::: x reproduces"
        ]
    },
    {
        "premises-NL": [
            "All students attend class.",
            "If someone studies hard, then they pass exams.",
            "If someone attends class, then they study hard or do not pass exams.",
            "If someone does not pass exams, then they are not successful.",
            "Some students are not successful.",
            "Every student studies hard if and only if they pass all exams.",
            "All students are either successful or attend classes.",
            "If x attends class, then x is a student.",
            "If someone studies hard, then they are successful.",
            "All students either study hard or are successful.",
            "John is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClass(x)) ::: All students attend class.",
            "∀x (StudiesHard(x) → PassesExam(x)) ::: If someone studies hard, then they pass exams.",
            "∀x (AttendsClass(x) → (StudiesHard(x) ∨ ¬PassesExam(x))) ::: If someone attends class, then they study hard or do not pass exams.",
            "∀x (¬PassesExam(x) → ¬Successful(x)) ::: If someone does not pass exams, then they are not successful.",
            "∃x (Student(x) ∧ ¬Successful(x)) ::: Some students are not successful.",
            "∀x (StudiesHard(x) ↔ PassesExam(x)) ::: Every student studies hard if and only if they pass all exams.",
            "∀x (Student(x) → (Successful(x) ∨ AttendsClass(x))) ::: All students are either successful or attend classes.",
            "∀x (AttendsClass(x) → Student(x)) ::: If x attends class, then x is a student.",
            "∀x (StudiesHard(x) → Successful(x)) ::: If someone studies hard, then they are successful.",
            "∀x (Student(x) → (StudiesHard(x) ∨ Successful(x))) ::: All students either study hard or are successful.",
            "Student(John) ::: John is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesHard(x) ::: x studies hard.",
            "Successful(x) ::: x is successful.",
            "AttendsClass(x) ::: x attends class.",
            "PassesExam(x) ::: x passes exam."
        ]
    },
    {
        "premises-NL": [
            "All researchers either publish papers or need equipment.",
            "If someone needs equipment, then they don't receive funding.",
            "All researchers are collaborators of someone.",
            "Some researchers publish papers.",
            "If someone is a collaborator of someone who receives funding, then they receive funding.",
            "If someone publishes a paper, then they are a researcher.",
            "Some researchers need equipment.",
            "If x needs equipment, then x is a researcher.",
            "All researchers receive funding or do not publish a paper.",
            "If x is a researcher, then x publishes a paper or needs equipment.",
            "Some researchers collaborate with someone who receives funding.",
            "All who publish a paper receive funding."
        ],
        "premises-FOL": [
            "∀x (Researcher(x) → (PublishesPaper(x) ∨ NeedsEquipment(x))) ::: All researchers either publish papers or need equipment.",
            "∀x (NeedsEquipment(x) → ¬ReceivesFunding(x)) ::: If someone needs equipment, then they don't receive funding.",
            "∀x ∃y IsCollaboratorOf(x, y) ::: All researchers are collaborators of someone.",
            "∃x (Researcher(x) ∧ PublishesPaper(x)) ::: Some researchers publish papers.",
            "∀x ∀y ((IsCollaboratorOf(x, y) ∧ ReceivesFunding(y)) → ReceivesFunding(x)) ::: If someone is a collaborator of someone who receives funding, then they receive funding.",
            "∀x (PublishesPaper(x) → Researcher(x)) ::: If someone publishes a paper, then they are a researcher.",
            "∃x (Researcher(x) ∧ NeedsEquipment(x)) ::: Some researchers need equipment.",
            "∀x (NeedsEquipment(x) → Researcher(x)) ::: If x needs equipment, then x is a researcher.",
            "∀x (Researcher(x) → (ReceivesFunding(x) ∨ ¬PublishesPaper(x))) ::: All researchers receive funding or do not publish a paper.",
            "∀x (Researcher(x) → (PublishesPaper(x) ∨ NeedsEquipment(x))) ::: If x is a researcher, then x publishes a paper or needs equipment.",
            "∃x ∃y (Researcher(x) ∧ IsCollaboratorOf(x, y) ∧ ReceivesFunding(y)) ::: Some researchers collaborate with someone who receives funding.",
            "∀x (PublishesPaper(x) → ReceivesFunding(x)) ::: All who publish a paper receive funding."
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher.",
            "ReceivesFunding(x) ::: x receives funding.",
            "PublishesPaper(x) ::: x publishes a paper.",
            "NeedsEquipment(x) ::: x needs equipment.",
            "IsCollaboratorOf(x, y) ::: x is a collaborator of y."
        ]
    },
    {
        "premises-NL": [
            "All programmers are skilled.",
            "Some skilled people earn a lot.",
            "If someone earns a lot, then they are skilled.",
            "If someone is a programmer, they develop software.",
            "If someone is skilled, then they read books or develop software.",
            "If someone reads books, they are not a programmer.",
            "If someone develops software, they are skilled.",
            "If someone is a programmer and skilled, they are reading books.",
            "If someone earns a lot, then they are reading books."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → Skilled(x)) ::: All programmers are skilled.",
            "∃x (Skilled(x) ∧ EarnsALot(x)) ::: Some skilled people earn a lot.",
            "∀x (EarnsALot(x) → Skilled(x)) ::: If someone earns a lot, then they are skilled.",
            "∀x (Programmer(x) → DevelopsSoftware(x)) ::: If someone is a programmer, they develop software.",
            "∀x (Skilled(x) → (ReadsBooks(x) ∨ DevelopsSoftware(x))) ::: If someone is skilled, then they read books or develop software.",
            "∀x (ReadsBooks(x) → ¬Programmer(x)) ::: If someone reads books, they are not a programmer.",
            "∀x (DevelopsSoftware(x) → Skilled(x)) ::: If someone develops software, they are skilled.",
            "∀x ((Programmer(x) ∧ Skilled(x)) → ReadsBooks(x)) ::: If someone is a programmer and skilled, they are reading books.",
            "∀x (EarnsALot(x) → ReadsBooks(x)) ::: If someone earns a lot, then they are reading books."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "Skilled(x) ::: x is skilled",
            "EarnsALot(x) ::: x earns a lot",
            "DevelopsSoftware(x) ::: x develops software",
            "ReadsBooks(x) ::: x reads books"
        ]
    },
    {
        "premises-NL": [
            "All engineers are skilled.",
            "If someone is an engineer, then they are skilled.",
            "Some skilled people are good managers.",
            "For all x, if x is an engineer, then x is a person.",
            "If a person is skilled, then that person is a good manager.",
            "If x is a good manager, then x is employed.",
            "If someone is employed, then they are skilled."
        ],
        "premises-FOL": [
            "∀x Engineer(x) → Skilled(x) ::: All engineers are skilled",
            "∀x Engineer(x) → Skilled(x) ::: If someone is an engineer, then they are skilled",
            "∃x Skilled(x) ∧ GoodManager(x) ::: Some skilled people are good managers",
            "∀x Engineer(x) → Person(x) ::: For all x, if x is an engineer, then x is a person",
            "∀x Person(x) ∧ Skilled(x) → GoodManager(x) ::: If a person is skilled, then that person is a good manager",
            "∀x GoodManager(x) → Employed(x) ::: If x is a good manager, then x is employed",
            "∀x Employed(x) → Skilled(x) ::: If someone is employed, then they are skilled"
        ],
        "predicates": [
            "Engineer(x) ::: x is an engineer",
            "Skilled(x) ::: x is skilled",
            "GoodManager(x) ::: x is a good manager"
        ]
    },
    {
        "premises-NL": [
            "All smokers are affected by pollution.",
            "If someone is healthy, then they eat vegetables.",
            "If someone eats vegetables, then they are not smokers.",
            "If someone lives in a city, they are affected by pollution.",
            "Some healthy people live in the city.",
            "Everyone who lives in a city is affected by pollution.",
            "If someone is not a smoker and eats vegetables, they are healthy.",
            "If someone is not a smoker, they are not affected by pollution."
        ],
        "premises-FOL": [
            "∀x Smoker(x) → PollutionAffected(x) ::: All smokers are affected by pollution",
            "∀x Healthy(x) → EatsVegetables(x) ::: If someone is healthy, then they eat vegetables",
            "∀x EatsVegetables(x) → ¬Smoker(x) ::: If someone eats vegetables, then they are not smokers",
            "∀x LivesInCity(x) → PollutionAffected(x) ::: If someone lives in a city, they are affected by pollution",
            "∃x Healthy(x) ∧ LivesInCity(x) ::: Some healthy people live in the city",
            "∀x LivesInCity(x) → PollutionAffected(x) ::: Everyone who lives in a city is affected by pollution",
            "∀x ¬Smoker(x) ∧ EatsVegetables(x) → Healthy(x) ::: If someone is not a smoker and eats vegetables, they are healthy",
            "∀x ¬Smoker(x) → ¬PollutionAffected(x) ::: If someone is not a smoker, they are not affected by pollution"
        ],
        "predicates": [
            "Healthy(x) ::: x is healthy",
            "Smoker(x) ::: x is a smoker",
            "PollutionAffected(x) ::: x is affected by pollution",
            "EatsVegetables(x) ::: x eats vegetables",
            "LivesInCity(x) ::: x lives in a city"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard pass the exam.",
            "If someone passes the exam, they get a good grade.",
            "Some students study hard and attend classes.",
            "Students who attend classes read books.",
            "If someone reads books and is smart, then they study hard.",
            "Some smart students read books.",
            "If a student studies hard, they will pass the exam.",
            "If someone is smart and attends classes they study hard.",
            "Anyone that passes the exam gets a good grade."
        ],
        "premises-FOL": [
            "∀x Student(x) ∧ StudyHard(x) → PassExam(x) ::: All students who study hard pass the exam",
            "∀x PassExam(x) → GoodGrade(x) ::: If someone passes the exam, they get a good grade",
            "∃x Student(x) ∧ StudyHard(x) ∧ AttendsClasses(x) ::: Some students study hard and attend classes",
            "∀x AttendsClasses(x) → ReadsBooks(x) ::: Students who attend classes read books",
            "∀x ReadsBooks(x) ∧ IsSmart(x) → StudyHard(x) ::: If someone reads books and is smart, then they study hard",
            "∃x IsSmart(x) ∧ ReadsBooks(x) ::: Some smart students read books",
            "∀x StudyHard(x) → PassExam(x) ::: If a student studies hard, they will pass the exam",
            "∀x IsSmart(x) ∧ AttendsClasses(x) → StudyHard(x) ::: If someone is smart and attends classes they study hard",
            "∀x PassExam(x) → GoodGrade(x) ::: Anyone that passes the exam gets a good grade"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudyHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "GoodGrade(x) ::: x gets a good grade",
            "AttendsClasses(x) ::: x attends classes",
            "ReadsBooks(x) ::: x reads books",
            "IsSmart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All authors who write fiction are popular.",
            "If an author is popular, they get royalties.",
            "If an author gets royalties, they are famous.",
            "Some authors who are famous publish books.",
            "If an author sells well and publishes books, they are popular.",
            "Some authors write fiction and sell well.",
            "Authors who get royalties have positive reviews.",
            "If an author has positive reviews, they are famous.",
            "If an author is popular, they sell well.",
            "All authors who publish books are famous."
        ],
        "premises-FOL": [
            "∀x Author(x) ∧ WritesFiction(x) → Popular(x) ::: All authors who write fiction are popular",
            "∀x Popular(x) → GetsRoyalties(x) ::: If an author is popular, they get royalties",
            "∀x GetsRoyalties(x) → Famous(x) ::: If an author gets royalties, they are famous",
            "∃x Famous(x) ∧ PublishesBooks(x) ::: Some authors who are famous publish books",
            "∀x SellsWell(x) ∧ PublishesBooks(x) → Popular(x) ::: If an author sells well and publishes books, they are popular",
            "∃x Author(x) ∧ WritesFiction(x) ∧ SellsWell(x) ::: Some authors write fiction and sell well",
            "∀x GetsRoyalties(x) → ReviewsPositive(x) ::: Authors who get royalties have positive reviews",
            "∀x ReviewsPositive(x) → Famous(x) ::: If an author has positive reviews, they are famous",
            "∀x Popular(x) → SellsWell(x) ::: If an author is popular, they sell well",
            "∀x PublishesBooks(x) → Famous(x) ::: All authors who publish books are famous"
        ],
        "predicates": [
            "Author(x) ::: x is an author",
            "WritesFiction(x) ::: x writes fiction",
            "Popular(x) ::: x is popular",
            "GetsRoyalties(x) ::: x gets royalties",
            "Famous(x) ::: x is famous",
            "PublishesBooks(x) ::: x publishes books",
            "ReviewsPositive(x) ::: x has positive reviews",
            "SellsWell(x) ::: x sells well"
        ]
    },
    {
        "premises-NL": [
            "Every plant needs sunlight.",
            "Every plant needs water.",
            "If a plant is not a desert plant, it will grow.",
            "Some plants are located in a forest.",
            "If something contains water, it will grow.",
            "If something is edible, it provides food.",
            "If something is pollinated then it produces seeds.",
            "If a plant has a flower, then it will grow.",
            "If a plant produces fruit then it's a tree.",
            "If an animal eats a plant then it is an herbivore.",
            "If a plant provides food for an animal, then it is edible.",
            "A plant has seeds.",
            "If a plant needs sunlight and water, and it is not a desert plant, then it will grow.",
            "If a plant has seeds then it has a flower.",
            "If something is a tree, it produces fruit.",
            "If a plant is located in the forest and it is a desert plant, then it needs sunlight."
        ],
        "premises-FOL": [
            "∀x (Plant(x) → NeedsSunlight(x)) ::: Every plant needs sunlight.",
            "∀x (Plant(x) → NeedsWater(x)) ::: Every plant needs water.",
            "∀x (¬DesertPlant(x) → Grows(x)) ::: If a plant is not a desert plant, it will grow.",
            "∃x ∃y (Plant(x) ∧ LocatedIn(x, y)) ::: Some plants are located in a forest.",
            "∀x ∀y (Contains(x, y) → Grows(x)) ::: If something contains water, it will grow.",
            "∀x (Edible(x) → ProvidesFoodFor(x, x)) ::: If something is edible, it provides food.",
            "∀x ∀y (PollinatedBy(x, y) → Produces(x, y)) ::: If something is pollinated then it produces seeds.",
            "∀x (HasFlower(x) → Grows(x)) ::: If a plant has a flower, then it will grow.",
            "∀x ∀y (IsFruitOf(x, y) → IsTree(x)) ::: If a plant produces fruit then it's a tree.",
            "∀x ∀y (Eats(x, y) → IsHerbivore(x)) ::: If an animal eats a plant then it is an herbivore.",
            "∀x ∀y (ProvidesFoodFor(x, y) → Edible(x)) ::: If a plant provides food for an animal, then it is edible.",
            "∃x HasSeeds(x) ::: A plant has seeds.",
            "∀x ((NeedsSunlight(x) ∧ NeedsWater(x) ∧ ¬DesertPlant(x)) → Grows(x)) ::: If a plant needs sunlight and water, and it is not a desert plant, then it will grow.",
            "∀x (HasSeeds(x) → HasFlower(x)) ::: If a plant has seeds then it has a flower.",
            "∀x ∀y (IsTree(x) → Produces(x, y)) ::: If something is a tree, it produces fruit.",
            "∀x ∀y (LocatedIn(x, y) ∧ DesertPlant(x) → NeedsSunlight(x)) ::: If a plant is located in the forest and it is a desert plant, then it needs sunlight."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "NeedsSunlight(x) ::: x needs sunlight",
            "NeedsWater(x) ::: x needs water",
            "Grows(x) ::: x grows",
            "DesertPlant(x) ::: x is a desert plant",
            "LocatedIn(x, y) ::: x is located in y",
            "Contains(x, y) ::: x contains y",
            "Edible(x) ::: x is edible",
            "PollinatedBy(x, y) ::: x is pollinated by y",
            "HasFlower(x) ::: x has a flower",
            "IsFruitOf(x, y) ::: x is a fruit of y",
            "Eats(x, y) ::: x eats y",
            "ProvidesFoodFor(x, y) ::: x provides food for y",
            "Produces(x, y) ::: x produces y",
            "HasSeeds(x) ::: x has seeds",
            "IsTree(x) ::: x is a tree",
            "IsHerbivore(x) ::: x is an herbivore"
        ]
    },
    {
        "premises-NL": [
            "All teachers are employed.",
            "Anyone employed has a degree or is a teacher.",
            "Someone studies something and is a teacher.",
            "If someone has a degree, they are educated.",
            "A teacher always studies something.",
            "Anyone who studies something is educated.",
            "John is a teacher."
        ],
        "premises-FOL": [
            "∀x (Teacher(x) → Employed(x)) ::: All teachers are employed.",
            "∀x (Employed(x) → (HasDegree(x) ∨ Teacher(x))) ::: Anyone employed has a degree or is a teacher.",
            "∃x ∃y (Studies(x, y) ∧ Teacher(x)) ::: Someone studies something and is a teacher.",
            "∀x (HasDegree(x) → Educated(x)) ::: If someone has a degree, they are educated.",
            "∀x ∃y (Teacher(x) → Studies(x, y)) ::: A teacher always studies something.",
            "∀x ∃y (Studies(x, y) → Educated(x)) ::: Anyone who studies something is educated.",
            "Teacher(John) ::: John is a teacher."
        ],
        "predicates": [
            "Teacher(x) ::: x is a teacher",
            "Educated(x) ::: x is educated",
            "HasDegree(x) ::: x has a degree",
            "Employed(x) ::: x is employed",
            "Studies(x, y) ::: x studies y"
        ]
    },
    {
        "premises-NL": [
            "All products that are sold are in demand.",
            "If a product is in demand, it is also popular.",
            "Products are expensive if they are sold or manufactured.",
            "If a product is expensive and popular, it is profitable.",
            "All manufactured products are sold.",
            "If something is not in demand then it is not sold.",
            "Product A is manufactured.",
            "Product B is sold to someone."
        ],
        "premises-FOL": [
            "∀x (Sold(x, y) → InDemand(x)) ::: All products that are sold are in demand.",
            "∀x (InDemand(x) → Popular(x)) ::: If a product is in demand, it is also popular.",
            "∀x (Sold(x, y) ∨ Manufactured(x) → Expensive(x)) ::: Products are expensive if they are sold or manufactured.",
            "∀x ((Expensive(x) ∧ Popular(x)) → Profitable(x)) ::: If a product is expensive and popular, it is profitable.",
            "∀x (Manufactured(x) → Sold(x, y)) ::: All manufactured products are sold.",
            "∀x (¬InDemand(x) → ¬Sold(x, y)) ::: If something is not in demand then it is not sold.",
            "Manufactured(ProductA) ::: Product A is manufactured.",
            "∃y Sold(ProductB, y) ::: Product B is sold to someone."
        ],
        "predicates": [
            "Product(x) ::: x is a product",
            "InDemand(x) ::: x is in demand",
            "Profitable(x) ::: x is profitable",
            "Sold(x, y) ::: x is sold to y",
            "Expensive(x) ::: x is expensive",
            "Manufactured(x) ::: x is manufactured",
            "Popular(x) ::: x is popular",
            "UsedBy(x,y) ::: product x is used by y"
        ]
    },
    {
        "premises-NL": [
            "All animals eat plants or meat or both.",
            "An animal eats meat if and only if it is a carnivore.",
            "If something is an omnivore then it eats both plants and meat.",
            "No herbivore eats meat.",
            "An animal is a carnivore or a herbivore or an omnivore.",
            "If something eats plants, it is not a carnivore.",
            "Animals live in habitats.",
            "Some animals eat plants.",
            "John is an animal."
        ],
        "premises-FOL": [
            "∀x (Animal(x) → (Eats(x, plants) ∨ Eats(x, meat))) ::: All animals eat plants or meat or both.",
            "∀x (Eats(x, meat) ↔ Carnivore(x)) ::: An animal eats meat if and only if it is a carnivore.",
            "∀x (Omnivore(x) → (Eats(x, plants) ∧ Eats(x, meat))) ::: If something is an omnivore then it eats both plants and meat.",
            "∀x (Herbivore(x) → ¬Eats(x, meat)) ::: No herbivore eats meat.",
            "∀x (Animal(x) → (Carnivore(x) ∨ Herbivore(x) ∨ Omnivore(x))) ::: An animal is a carnivore or a herbivore or an omnivore.",
            "∀x (Eats(x, plants) → ¬Carnivore(x)) ::: If something eats plants, it is not a carnivore.",
            "∀x ∃y LivesIn(x, y) ::: Animals live in habitats.",
            "∃x Eats(x, plants) ::: Some animals eat plants.",
            "Animal(John) ::: John is an animal."
        ],
        "predicates": [
            "Animal(x) ::: x is an animal",
            "Eats(x, y) ::: x eats y",
            "Plants(x) ::: x is a plant",
            "Herbivore(x) ::: x is a herbivore",
            "Meat(x) ::: x is meat",
            "Carnivore(x) ::: x is a carnivore",
            "Omnivore(x) ::: x is an omnivore",
            "LivesIn(x, y) ::: animal x lives in habitat y",
            "Habitat(x) ::: x is a habitat"
        ]
    },
    {
        "premises-NL": [
            "All athletes are healthy.",
            "All healthy people are young.",
            "No one who is young is old.",
            "Every athlete runs a marathon.",
            "Every athlete is a fast runner.",
            "Everyone who is a fast runner lives in New York.",
            "Everyone in New York is successful.",
            "All doctors work hard.",
            "Anyone who works hard is wealthy.",
            "Every wealthy person has a car.",
            "If someone has a car, they buys a car",
            "All doctors are not fast runners.",
            "All injured people do not run a marathon.",
            "No athlete is a doctor."
        ],
        "premises-FOL": [
            "∀x (Athlete(x) → Healthy(x)) ::: All athletes are healthy.",
            "∀x (Healthy(x) → Young(x)) ::: All healthy people are young.",
            "∀x (Young(x) → ¬Old(x)) ::: No one who is young is old.",
            "∀x (Athlete(x) → RunsMarathon(x)) ::: Every athlete runs a marathon.",
            "∀x (Athlete(x) → FastRunner(x)) ::: Every athlete is a fast runner.",
            "∀x (FastRunner(x) → LivesIn(x, NewYork)) ::: Everyone who is a fast runner lives in New York.",
            "∀x (LivesIn(x, NewYork) → Successful(x)) ::: Everyone in New York is successful.",
            "∀x (Doctor(x) → WorksHard(x)) ::: All doctors work hard.",
            "∀x (WorksHard(x) → Wealthy(x)) ::: Anyone who works hard is wealthy.",
            "∀x (Wealthy(x) → HasCar(x)) ::: Every wealthy person has a car.",
            "∀x (HasCar(x) → BuysCar(x, x)) ::: If someone has a car, they buys a car",
            "∀x (Doctor(x) → ¬FastRunner(x)) ::: All doctors are not fast runners.",
            "∀x (Injured(x) → ¬RunsMarathon(x)) ::: All injured people do not run a marathon.",
            "∀x (Athlete(x) → ¬Doctor(x)) ::: No athlete is a doctor."
        ],
        "predicates": [
            "Athlete(x) ::: x is an athlete",
            "Doctor(x) ::: x is a doctor",
            "Young(x) ::: x is young",
            "Old(x) ::: x is old",
            "Healthy(x) ::: x is healthy",
            "Injured(x) ::: x is injured",
            "RunsMarathon(x) ::: x runs a marathon",
            "FastRunner(x) ::: x is a fast runner",
            "LivesIn(x, y) ::: x lives in y",
            "NewYork(x) ::: x is from New York",
            "Successful(x) ::: x is successful",
            "WorksHard(x) ::: x works hard",
            "Wealthy(x) ::: x is wealthy",
            "HasCar(x) ::: x has a car",
            "BuysCar(x, y) ::: x buys the car y"
        ]
    },
    {
        "premises-NL": [
            "Everyone who is a student is smart.",
            "Some students study.",
            "If someone is a student and studies, then they are smart and study.",
            "If someone is not smart, then they don't study.",
            "If someone studies, they are not lazy.",
            "Everyone is either a student or is not a student.",
            "Someone is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "∃x (Student(x) ∧ Studies(x)) ::: Some students study.",
            "∀x ((Student(x) ∧ Studies(x)) → (Smart(x) ∧ Studies(x))) ::: If someone is a student and studies, then they are smart and study.",
            "∀x (¬Smart(x) → ¬Studies(x)) ::: If someone is not smart, then they don't study.",
            "∀x (Studies(x) → ¬Lazy(x)) ::: If someone studies, they are not lazy.",
            "∀x (Student(x) ∨ ¬Student(x)) ::: Everyone is either a student or is not a student.",
            "∃x Student(x) ::: Someone is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Smart(x) ::: x is smart.",
            "Studies(x) ::: x studies."
        ]
    },
    {
        "premises-NL": [
            "All projects are either successful or not.",
            "Some projects are successful.",
            "Every successful project is funded.",
            "If a project is successful, then it's a Project.",
            "If a project is not successful, then it's not funded.",
            "A project is either funded or not funded.",
            "If a project is funded, it is a project.",
            "If a project is a project, then its successful or its not successful.",
            "Some projects are not funded."
        ],
        "premises-FOL": [
            "∀x (Project(x) → (Successful(x) ∨ ¬Successful(x))) ::: All projects are either successful or not.",
            "∃x (Project(x) ∧ Successful(x)) ::: Some projects are successful.",
            "∀x (Successful(x) → Funded(x)) ::: Every successful project is funded.",
            "∀x (Successful(x) → Project(x)) ::: If a project is successful, then it's a Project.",
            "∀x (¬Successful(x) → ¬Funded(x)) ::: If a project is not successful, then it's not funded.",
            "∀x (Funded(x) ∨ ¬Funded(x)) ::: A project is either funded or not funded.",
            "∀x (Funded(x) → Project(x)) ::: If a project is funded, it is a project.",
            "∀x (Project(x) → (Successful(x) ∨ ¬Successful(x))) ::: If a project is a project, then its successful or its not successful.",
            "∃x (Project(x) ∧ ¬Funded(x)) ::: Some projects are not funded."
        ],
        "predicates": [
            "Project(x) ::: x is a project.",
            "Successful(x) ::: x is successful.",
            "Funded(x) ::: x is funded."
        ]
    },
    {
        "premises-NL": [
            "All scientists are either respected or not respected.",
            "Some scientists publish often.",
            "Scientists who publish often are respected.",
            "All respected scientists receive grants.",
            "A scientist who is respected also publishes often.",
            "If a scientist is not respected, then they don't publish often.",
            "Some scientists do not receive grants.",
            "If someone publishes often and is a scientist, then they are Respected",
            "A scientist publishes often if and only if they are Respected.",
            "Every Scientist either publishes often or they do not.",
            "A scientist either publishes often or is not a scientist."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → (Respected(x) ∨ ¬Respected(x))) ::: All scientists are either respected or not respected.",
            "∃x (Scientist(x) ∧ PublishOften(x)) ::: Some scientists publish often.",
            "∀x ((Scientist(x) ∧ PublishOften(x)) → Respected(x)) ::: Scientists who publish often are respected.",
            "∀x (Respected(x) → ReceivesGrants(x)) ::: All respected scientists receive grants.",
            "∀x (Respected(x) → PublishOften(x)) ::: A scientist who is respected also publishes often.",
            "∀x (¬Respected(x) → ¬PublishOften(x)) ::: If a scientist is not respected, then they don't publish often.",
            "∃x (Scientist(x) ∧ ¬ReceivesGrants(x)) ::: Some scientists do not receive grants.",
            "∀x ((PublishOften(x) ∧ Scientist(x)) → Respected(x)) ::: If someone publishes often and is a scientist, then they are Respected",
            "∀x (PublishOften(x) ↔ Respected(x)) ::: A scientist publishes often if and only if they are Respected.",
            "∀x (Scientist(x) → (PublishOften(x) ∨ ¬PublishOften(x))) ::: Every Scientist either publishes often or they do not.",
            "∀x (Scientist(x) ∨ ¬Scientist(x)) ::: A scientist either publishes often or is not a scientist."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist.",
            "PublishOften(x) ::: x publishes often.",
            "Respected(x) ::: x is respected.",
            "ReceivesGrants(x) ::: x receives grants."
        ]
    },
    {
        "premises-NL": [
            "Every programmer is either a friend or not.",
            "Every designer is either a friend or not.",
            "Some programmer and designer collaborate.",
            "If a programmer and designer collaborate, they will create a good product.",
            "If a product is good, then it is successful.",
            "If a programmer and a designer collaborate, they are friends.",
            "If someone is not a programmer then they are not a friend.",
            "If x and y collaborate, then its either a programmer or a designer.",
            "Every programmer and designer either collaborates or does not collaborate.",
            "If a programmer and designer create a good product, then the product is successful.",
            "A product can only be good if its created by a programmer and a designer.",
            "If a programmer and designer collaborate, then they create a good product that is successful.",
            "If x is a programmer and y is a designer, then x and y collaborate only if they are friends."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → (Friends(x,y) ∨ ¬Friends(x,y))) ::: Every programmer is either a friend or not.",
            "∀x (Designer(x) → (Friends(x,y) ∨ ¬Friends(x,y))) ::: Every designer is either a friend or not.",
            "∃x ∃y (Programmer(x) ∧ Designer(y) ∧ Collaborates(x, y)) ::: Some programmer and designer collaborate.",
            "∀x ∀y ((Programmer(x) ∧ Designer(y) ∧ Collaborates(x, y)) → GoodProduct(x, y)) ::: If a programmer and designer collaborate, they will create a good product.",
            "∀x ∀y (GoodProduct(x, y) → Successful(x, y)) ::: If a product is good, then it is successful.",
            "∀x ∀y ((Programmer(x) ∧ Designer(y) ∧ Collaborates(x, y)) → Friends(x, y)) ::: If a programmer and a designer collaborate, they are friends.",
            "∀x (¬Programmer(x) → ¬Friends(x,y)) ::: If someone is not a programmer then they are not a friend.",
            "∀x ∀y (Collaborates(x, y) → (Programmer(x) ∨ Designer(y))) ::: If x and y collaborate, then its either a programmer or a designer.",
            "∀x ∀y (Collaborates(x, y) ∨ ¬Collaborates(x, y)) ::: Every programmer and designer either collaborates or does not collaborate.",
            "∀x ∀y (GoodProduct(x, y) → Successful(x, y)) ::: If a programmer and designer create a good product, then the product is successful.",
            "∀x ∀y (GoodProduct(x, y) → (Programmer(x) ∧ Designer(y))) ::: A product can only be good if its created by a programmer and a designer.",
            "∀x ∀y ((Programmer(x) ∧ Designer(y) ∧ Collaborates(x, y)) → (GoodProduct(x, y) ∧ Successful(x, y))) ::: If a programmer and designer collaborate, then they create a good product that is successful.",
            "∀x ∀y ((Programmer(x) ∧ Designer(y) ∧ Collaborates(x, y)) ↔ Friends(x, y)) ::: If x is a programmer and y is a designer, then x and y collaborate only if they are friends."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer.",
            "Designer(x) ::: x is a designer.",
            "Collaborates(x, y) ::: x and y collaborate.",
            "GoodProduct(x, y) ::: x and y create a good product.",
            "Successful(x, y) ::: The product of x and y is successful.",
            "Friends(x, y) ::: x and y are friends."
        ]
    },
    {
        "premises-NL": [
            "All doctors prescribe medications to patients.",
            "Some patients are allergic to some medications.",
            "If a doctor prescribes a medication to a patient, then the patient is supposed to take the medication.",
            "If a patient takes a medication and is not allergic to it, then the patient will improve.",
            "Dr. Smith is a doctor.",
            "Dr. Smith prescribes medication A to John.",
            "John is a patient.",
            "John is not allergic to medication A.",
            "Dr. Brown is a doctor.",
            "Dr. Brown prescribes medication B to Mary.",
            "Mary is a patient.",
            "Mary takes medication B.",
            "If a patient takes a medication and they're not allergic to it, then they will improve.",
            "If a patient is prescribed medication, they should take it."
        ],
        "premises-FOL": [
            "∀x ∀y ∃z (Doctor(x) ∧ Patient(y) → Prescribes(x, y, z)) ::: All doctors prescribe medications to patients.",
            "∃x ∃y ∃z (Patient(x) ∧ Medication(y) ∧ Allergic(x, y)) ::: Some patients are allergic to some medications.",
            "∀x ∀y ∀z (Prescribes(x, y, z) → Takes(y, z)) ::: If a doctor prescribes a medication to a patient, then the patient is supposed to take the medication.",
            "∀x ∀y (Takes(x, y) ∧ ¬Allergic(x, y) → Improves(x)) ::: If a patient takes a medication and is not allergic to it, then the patient will improve.",
            "Doctor(Smith) ::: Dr. Smith is a doctor.",
            "Prescribes(Smith, John, A) ::: Dr. Smith prescribes medication A to John.",
            "Patient(John) ::: John is a patient.",
            "¬Allergic(John, A) ::: John is not allergic to medication A.",
            "Doctor(Brown) ::: Dr. Brown is a doctor.",
            "Prescribes(Brown, Mary, B) ::: Dr. Brown prescribes medication B to Mary.",
            "Patient(Mary) ::: Mary is a patient.",
            "Takes(Mary, B) ::: Mary takes medication B.",
            "∀x ∀y (Takes(x, y) ∧ ¬Allergic(x, y) → Improves(x)) ::: If a patient takes a medication and they're not allergic to it, then they will improve.",
            "∀x ∀y ∀z (Prescribes(x, y, z) → Takes(y, z)) ::: If a patient is prescribed medication, they should take it."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Patient(x) ::: x is a patient",
            "Medication(x) ::: x is a medication",
            "Prescribes(x, y, z) ::: x prescribes z to y",
            "Takes(x, y) ::: x takes y",
            "Allergic(x, y) ::: x is allergic to y",
            "Improves(x) ::: x improves"
        ]
    },
    {
        "premises-NL": [
            "All cars are vehicles.",
            "If two people are friends, then they have similar interests.",
            "If someone owns a car, they like cars.",
            "John and Mary are friends.",
            "John owns a car.",
            "If someone drives a car, then they own a car.",
            "Anyone who owns a car, likes cars.",
            "People with similar interests like the same things.",
            "If someone likes something, and they are friends, the other likes it too.",
            "Mary drives a car.",
            "If someone is friends with someone who likes cars, then they like cars.",
            "If someone is friends with someone who likes something, they like that thing.",
            "Anyone that has a car likes it.",
            "If John likes something, then Mary likes it."
        ],
        "premises-FOL": [
            "∀x (Car(x) → Vehicle(x)) ::: All cars are vehicles.",
            "∀x ∀y (Friends(x, y) → SimilarInterests(x, y)) ::: If two people are friends, then they have similar interests.",
            "∀x ∀y (Owns(x, y) ∧ Car(y) → Likes(x, y)) ::: If someone owns a car, they like cars.",
            "Friends(John, Mary) ::: John and Mary are friends.",
            "∃x (Owns(John, x) ∧ Car(x)) ::: John owns a car.",
            "∀x ∀y (Drives(x, y) → Owns(x, y)) ::: If someone drives a car, then they own a car.",
            "∀x ∀y (Owns(x, y) ∧ Car(y) → Likes(x, y)) ::: Anyone who owns a car, likes cars.",
            "∀x ∀y ∀z (SimilarInterests(x, y) ∧ Likes(x, z) → Likes(y, z)) ::: People with similar interests like the same things.",
            "∀x ∀y ∀z (Friends(x, y) ∧ Likes(x, z) → Likes(y, z)) ::: If someone likes something, and they are friends, the other likes it too.",
            "∃x (Drives(Mary, x) ∧ Car(x)) ::: Mary drives a car.",
            "∀x ∀y (Friends(x, y) ∧ Likes(y, z) → Likes(x, z)) ::: If someone is friends with someone who likes cars, then they like cars.",
            "∀x ∀y ∀z (Friends(x, y) ∧ Likes(y, z) → Likes(x, z)) ::: If someone is friends with someone who likes something, they like that thing.",
            "∀x ∀y (Owns(x, y) ∧ Car(y) → Likes(x, y)) ::: Anyone that has a car likes it.",
            "∀x ∀y (Likes(John, y) → Likes(Mary, y)) ::: If John likes something, then Mary likes it."
        ],
        "predicates": [
            "Friends(x, y) ::: x and y are friends",
            "Owns(x, y) ::: x owns y",
            "Likes(x, y) ::: x likes y",
            "Car(x) ::: x is a car",
            "Drives(x, y) ::: x drives y",
            "HasHouse(x) ::: x has a house",
            "SimilarInterests(x,y) ::: x and y have similar interests"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard attend class.",
            "All students who attend class like pizza.",
            "Some students study hard.",
            "All who like pizza are smart.",
            "All smart people pass the exam.",
            "There is a student.",
            "All students take a course."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) → AttendsClass(x)) ::: All students who study hard attend class.",
            "∀x (AttendsClass(x) → LikesPizza(x)) ::: All students who attend class like pizza.",
            "∃x (Student(x) ∧ StudiesHard(x)) ::: Some students study hard.",
            "∀x (LikesPizza(x) → Smart(x)) ::: All who like pizza are smart.",
            "∀x (Smart(x) → PassesExam(x)) ::: All smart people pass the exam.",
            "∃x Student(x) ::: There is a student.",
            "∀x ∃y TakesCourse(x, y) ::: All students take a course."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassesExam(x) ::: x passes the exam",
            "AttendsClass(x) ::: x attends class",
            "LikesPizza(x) ::: x likes pizza",
            "Smart(x) ::: x is smart",
            "TakesCourse(x, y) ::: x takes course y"
        ]
    },
    {
        "premises-NL": [
            "All students take either math or physics.",
            "All students who take physics enjoy science.",
            "Some students do not like math.",
            "All students who take math like math.",
            "All students are smart if they take a hard course.",
            "All students who enjoy science like physics.",
            "Some students study hard.",
            "A student takes math if the student likes math.",
            "All happy people like physics.",
            "All those who study hard pass the exam.",
            "All who pass the exam are happy.",
            "Some students take a hard course."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (TakesCourse(x, \"Math\") ∨ TakesCourse(x, \"Physics\"))) ::: All students take either math or physics.",
            "∀x (Student(x) ∧ TakesCourse(x, \"Physics\") → EnjoysScience(x)) ::: All students who take physics enjoy science.",
            "∃x (Student(x) ∧ ¬LikesMath(x)) ::: Some students do not like math.",
            "∀x (Student(x) ∧ TakesCourse(x, \"Math\") → LikesMath(x)) ::: All students who take math like math.",
            "∀x (Student(x) ∧ TakesCourse(x, \"Hard\") → IsSmart(x)) ::: All students are smart if they take a hard course.",
            "∀x (EnjoysScience(x) → LikesPhysics(x)) ::: All students who enjoy science like physics.",
            "∃x (Student(x) ∧ StudiesHard(x)) ::: Some students study hard.",
            "∀x (Student(x) ∧ LikesMath(x) → TakesCourse(x, \"Math\")) ::: A student takes math if the student likes math.",
            "∀x (IsHappy(x) → LikesPhysics(x)) ::: All happy people like physics.",
            "∀x (StudiesHard(x) → PassesExam(x)) ::: All those who study hard pass the exam.",
            "∀x (PassesExam(x) → IsHappy(x)) ::: All who pass the exam are happy.",
            "∃x (Student(x) ∧ TakesCourse(x, \"Hard\")) ::: Some students take a hard course."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "LikesMath(x) ::: x likes math",
            "LikesPhysics(x) ::: x likes physics",
            "TakesCourse(x, y) ::: x takes course y",
            "IsSmart(x) ::: x is smart",
            "StudiesHard(x) ::: x studies hard",
            "PassesExam(x) ::: x passes the exam",
            "IsHappy(x) ::: x is happy",
            "EnjoysScience(x) ::: x enjoys science"
        ]
    },
    {
        "premises-NL": [
            "All students study hard.",
            "If someone studies hard, they pass the exam.",
            "John is a student.",
            "If x is a student, then x studies hard.",
            "If x studies hard and x is a student, then x passes the exam.",
            "If someone is a student, they study hard.",
            "If x is a student, then x is enrolled.",
            "If x is enrolled, x studies hard.",
            "If John is a student, then he studies hard.",
            "If John studies hard, then John passes the exam.",
            "John is enrolled.",
            "If John is enrolled, he studies hard.",
            "If John studies hard, then he is enrolled."
        ],
        "premises-FOL": [
            "∀x (Student(x) → StudiesHard(x)) ::: All students study hard.",
            "∀x (StudiesHard(x) → PassesExam(x)) ::: If someone studies hard, they pass the exam.",
            "Student(John) ::: John is a student.",
            "∀x (Student(x) → StudiesHard(x)) ::: If x is a student, then x studies hard.",
            "∀x (Student(x) ∧ StudiesHard(x) → PassesExam(x)) ::: If x studies hard and x is a student, then x passes the exam.",
            "∀x (Student(x) → StudiesHard(x)) ::: If someone is a student, they study hard.",
            "∀x (Student(x) → Enrolled(x)) ::: If x is a student, then x is enrolled.",
            "∀x (Enrolled(x) → StudiesHard(x)) ::: If x is enrolled, x studies hard.",
            "Student(John) → StudiesHard(John) ::: If John is a student, then he studies hard.",
            "StudiesHard(John) → PassesExam(John) ::: If John studies hard, then John passes the exam.",
            "Enrolled(John) ::: John is enrolled.",
            "Enrolled(John) → StudiesHard(John) ::: If John is enrolled, he studies hard.",
            "StudiesHard(John) → Enrolled(John) ::: If John studies hard, then he is enrolled."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "PassesExam(x) ::: x passes the exam."
        ]
    },
    {
        "premises-NL": [
            "Everyone who likes both cats and dogs is happy.",
            "Some people like cats.",
            "If someone likes both cats and dogs, then they are happy.",
            "If x likes cats and x likes dogs, then x is happy.",
            "Everyone who likes cats and dogs is happy.",
            "If x likes cats, x likes dogs.",
            "If x likes dogs, then x is happy.",
            "If x likes cats, then x is happy.",
            "If x likes cats, then x likes dogs.",
            "If x likes both cats and dogs, x is happy.",
            "If someone likes cats, they also like dogs.",
            "If someone likes dogs, they are happy.",
            "If someone likes cats, they are happy.",
            "If someone likes cats, they like both cats and dogs.",
            "If someone likes dogs, then they also like cats."
        ],
        "premises-FOL": [
            "∀x ((LikesCats(x) ∧ LikesDogs(x)) → Happy(x)) ::: Everyone who likes both cats and dogs is happy.",
            "∃x LikesCats(x) ::: Some people like cats.",
            "∀x ((LikesCats(x) ∧ LikesDogs(x)) → Happy(x)) ::: If someone likes both cats and dogs, then they are happy.",
            "∀x ((LikesCats(x) ∧ LikesDogs(x)) → Happy(x)) ::: If x likes cats and x likes dogs, then x is happy.",
            "∀x ((LikesCats(x) ∧ LikesDogs(x)) → Happy(x)) ::: Everyone who likes cats and dogs is happy.",
            "∀x (LikesCats(x) → LikesDogs(x)) ::: If x likes cats, x likes dogs.",
            "∀x (LikesDogs(x) → Happy(x)) ::: If x likes dogs, then x is happy.",
            "∀x (LikesCats(x) → Happy(x)) ::: If x likes cats, then x is happy.",
            "∀x (LikesCats(x) → LikesDogs(x)) ::: If x likes cats, then x likes dogs.",
            "∀x ((LikesCats(x) ∧ LikesDogs(x)) → Happy(x)) ::: If x likes both cats and dogs, x is happy.",
            "∀x (LikesCats(x) → LikesDogs(x)) ::: If someone likes cats, they also like dogs.",
            "∀x (LikesDogs(x) → Happy(x)) ::: If someone likes dogs, they are happy.",
            "∀x (LikesCats(x) → Happy(x)) ::: If someone likes cats, they are happy.",
            "∀x (LikesCats(x) → (LikesCats(x) ∧ LikesDogs(x))) ::: If someone likes cats, they like both cats and dogs.",
            "∀x (LikesDogs(x) → LikesCats(x)) ::: If someone likes dogs, then they also like cats."
        ],
        "predicates": [
            "LikesCats(x) ::: x likes cats.",
            "LikesDogs(x) ::: x likes dogs.",
            "Happy(x) ::: x is happy."
        ]
    },
    {
        "premises-NL": [
            "All doctors have a medical degree.",
            "All doctors are caring.",
            "If someone studies medicine, they have a medical degree.",
            "Anyone who practices medicine studies medicine.",
            "If someone is qualified and practices medicine, they are a doctor.",
            "Surgeons are doctors.",
            "All surgeons are qualified.",
            "If someone has a medical degree, then they are qualified.",
            "Every doctor practices medicine.",
            "Some doctors are surgeons.",
            "If someone studies medicine and is caring, they are a doctor.",
            "If someone practices medicine, they must be caring.",
            "If someone is a doctor, they are caring or they do not have a medical degree."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → MedicalDegree(x)) ::: All doctors have a medical degree.",
            "∀x (Doctor(x) → Caring(x)) ::: All doctors are caring.",
            "∀x (StudiesMedicine(x) → MedicalDegree(x)) ::: If someone studies medicine, they have a medical degree.",
            "∀x (PracticesMedicine(x) → StudiesMedicine(x)) ::: Anyone who practices medicine studies medicine.",
            "∀x ((Qualified(x) ∧ PracticesMedicine(x)) → Doctor(x)) ::: If someone is qualified and practices medicine, they are a doctor.",
            "∀x (Surgeon(x) → Doctor(x)) ::: Surgeons are doctors.",
            "∀x (Surgeon(x) → Qualified(x)) ::: All surgeons are qualified.",
            "∀x (MedicalDegree(x) → Qualified(x)) ::: If someone has a medical degree, then they are qualified.",
            "∀x (Doctor(x) → PracticesMedicine(x)) ::: Every doctor practices medicine.",
            "∃x (Doctor(x) ∧ Surgeon(x)) ::: Some doctors are surgeons.",
            "∀x ((StudiesMedicine(x) ∧ Caring(x)) → Doctor(x)) ::: If someone studies medicine and is caring, they are a doctor.",
            "∀x (PracticesMedicine(x) → Caring(x)) ::: If someone practices medicine, they must be caring.",
            "∀x (Doctor(x) → (Caring(x) ∨ ¬MedicalDegree(x))) ::: If someone is a doctor, they are caring or they do not have a medical degree."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "MedicalDegree(x) ::: x has a medical degree",
            "Caring(x) ::: x is caring",
            "StudiesMedicine(x) ::: x studies medicine",
            "PracticesMedicine(x) ::: x practices medicine",
            "Qualified(x) ::: x is qualified",
            "Surgeon(x) ::: x is a surgeon"
        ]
    },
    {
        "premises-NL": [
            "If something is expensive, then it is valuable.",
            "If something is rare, it is expensive.",
            "If two items are related, and one is valuable, the other is also valuable.",
            "If something is part of an antique, it is related to that antique.",
            "All antiques are collectible.",
            "If something is collectible and rare, then it is valuable.",
            "If something is part of something and is valuable, that something is valuable.",
            "If something is antique, then it is expensive.",
            "If two items are related, then the first is related to the second and the second is related to the first.",
            "If something is not valuable, then it is not rare.",
            "If something is valuable, then it is either expensive or not rare.",
            "If something is part of an antique and the antique is valuable, then the part is valuable.",
            "If something is not rare, then it is not expensive.",
            "If something is not expensive, then it is not valuable."
        ],
        "premises-FOL": [
            "∀x (Expensive(x) → Valuable(x)) ::: If something is expensive, then it is valuable.",
            "∀x (Rare(x) → Expensive(x)) ::: If something is rare, it is expensive.",
            "∀x ∀y ((Related(x, y) ∧ Valuable(y)) → Valuable(x)) ::: If two items are related, and one is valuable, the other is also valuable.",
            "∀x ∀y (Partof(x, y) → Related(x, y)) ::: If something is part of an antique, it is related to that antique.",
            "∀x (Antique(x) → Collectible(x)) ::: All antiques are collectible.",
            "∀x ((Collectible(x) ∧ Rare(x)) → Valuable(x)) ::: If something is collectible and rare, then it is valuable.",
            "∀x ∀y ((Partof(x, y) ∧ Valuable(y)) → Valuable(x)) ::: If something is part of something and is valuable, that something is valuable.",
            "∀x (Antique(x) → Expensive(x)) ::: If something is antique, then it is expensive.",
            "∀x ∀y (Related(x, y) → Related(y, x)) ::: If two items are related, then the first is related to the second and the second is related to the first.",
            "∀x (¬Valuable(x) → ¬Rare(x)) ::: If something is not valuable, then it is not rare.",
            "∀x (Valuable(x) → (Expensive(x) ∨ ¬Rare(x))) ::: If something is valuable, then it is either expensive or not rare.",
            "∀x ∀y ((Partof(x, y) ∧ Valuable(y)) → Valuable(x)) ::: If something is part of an antique and the antique is valuable, then the part is valuable.",
            "∀x (¬Rare(x) → ¬Expensive(x)) ::: If something is not rare, then it is not expensive.",
            "∀x (¬Expensive(x) → ¬Valuable(x)) ::: If something is not expensive, then it is not valuable."
        ],
        "predicates": [
            "Related(x, y) ::: x is related to y",
            "Valuable(x) ::: x is valuable",
            "Expensive(x) ::: x is expensive",
            "Rare(x) ::: x is rare",
            "Partof(x, y) ::: x is part of y",
            "Collectible(x) ::: x is collectible",
            "Antique(x) ::: x is an antique"
        ]
    },
    {
        "premises-NL": [
            "All members of the club are invited to the event.",
            "Everyone who is invited to the event and likes the event, is going to the event.",
            "If someone is going to the event, they will attend the event.",
            "Some people like the event.",
            "x is a member of the club.",
            "x likes the event.",
            "y is invited to the event.",
            "z is going to the event.",
            "All people that are going to the event attend the event."
        ],
        "premises-FOL": [
            "∀x (MemberOfClub(x) → InvitedToEvent(x)) ::: For all x, if x is a member of the club, then x is invited to the event.",
            "∀x (InvitedToEvent(x) ∧ LikesEvent(x) → GoingToEvent(x)) ::: For all x, if x is invited to the event and likes the event, then x is going to the event.",
            "∀x (GoingToEvent(x) → AttendsEvent(x)) ::: For all x, if x is going to the event, then x attends the event.",
            "∃x LikesEvent(x) ::: There exists an x who likes the event.",
            "MemberOfClub(x) ::: x is a member of the club.",
            "LikesEvent(x) ::: x likes the event.",
            "InvitedToEvent(y) ::: y is invited to the event.",
            "GoingToEvent(z) ::: z is going to the event.",
            "∀x (GoingToEvent(x) → AttendsEvent(x)) ::: For all x, if x is going to the event, then x attends the event."
        ],
        "predicates": [
            "MemberOfClub(x) ::: x is a member of the club.",
            "LikesEvent(x) ::: x likes the event.",
            "GoingToEvent(x) ::: x is going to the event.",
            "AttendsEvent(x) ::: x attends the event.",
            "InvitedToEvent(x) ::: x is invited to the event."
        ]
    },
    {
        "premises-NL": [
            "All students who take the course also study.",
            "Anyone who studies is prepared.",
            "If someone is prepared, they will pass the exam.",
            "x is a student.",
            "x takes the course.",
            "y studies.",
            "If someone takes the course, then they are a student.",
            "Everyone is either taking the course or not.",
            "If a student studies, then they take the course.",
            "z is prepared.",
            "Student x is taking the course."
        ],
        "premises-FOL": [
            "∀x (TakesCourse(x) → Studies(x)) ::: For all x, if x takes the course, then x studies.",
            "∀x (Studies(x) → IsPrepared(x)) ::: For all x, if x studies, then x is prepared.",
            "∀x (IsPrepared(x) → PassExam(x)) ::: For all x, if x is prepared, then x will pass the exam.",
            "Student(x) ::: x is a student.",
            "TakesCourse(x) ::: x takes the course.",
            "Studies(y) ::: y studies.",
            "∀x (TakesCourse(x) → Student(x)) ::: For all x, if x takes the course, then they are a student.",
            "∀x (TakesCourse(x) ∨ ¬TakesCourse(x)) ::: For all x, they take the course or they do not take the course.",
            "∀x (Studies(x) → TakesCourse(x)) ::: For all x, if x studies, then they take the course.",
            "IsPrepared(z) ::: z is prepared.",
            "Student(x) ∧ TakesCourse(x) ::: x is a student and takes the course."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "TakesCourse(x) ::: x takes the course.",
            "PassExam(x) ::: x will pass the exam.",
            "Studies(x) ::: x studies.",
            "IsPrepared(x) ::: x is prepared for the exam."
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "Anyone who treats patients is a healthcare worker.",
            "All doctors work at the hospital.",
            "x is a doctor.",
            "y treats patients.",
            "Doctors are not scientists.",
            "If someone is a healthcare worker, they either treat patients or work at the hospital.",
            "Someone who works at the hospital is a healthcare worker.",
            "If x is a healthcare worker and treats patients, then x is a doctor.",
            "All doctors are doctors.",
            "All healthcare workers works at the hospital."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → TreatsPatients(x)) ::: For all x, if x is a doctor, then x treats patients.",
            "∀x (TreatsPatients(x) → HealthcareWorker(x)) ::: For all x, if x treats patients, then x is a healthcare worker.",
            "∀x (Doctor(x) → WorksAtHospital(x)) ::: For all x, if x is a doctor, then x works at a hospital.",
            "Doctor(x) ::: x is a doctor.",
            "TreatsPatients(y) ::: y treats patients.",
            "∀x (¬(Doctor(x) ∧ IsScientist(x))) ::: For all x, it's not the case that x is a doctor and a scientist.",
            "∀x (HealthcareWorker(x) → (TreatsPatients(x) ∨ WorksAtHospital(x))) ::: For all x, if x is a healthcare worker, then x treats patients or works at the hospital.",
            "∀x (WorksAtHospital(x) → HealthcareWorker(x)) ::: For all x, if x works at the hospital, then x is a healthcare worker.",
            "∀x (HealthcareWorker(x) ∧ TreatsPatients(x) → Doctor(x)) ::: For all x, if x is a healthcare worker and treats patients, then x is a doctor.",
            "∀x Doctor(x) → Doctor(x) ::: For all x, if x is a doctor, then x is a doctor.",
            "∀x (HealthcareWorker(x) → WorksAtHospital(x)) ::: For all x, if x is a healthcare worker, then x works at the hospital."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "HealthcareWorker(x) ::: x is a healthcare worker.",
            "TreatsPatients(x) ::: x treats patients.",
            "WorksAtHospital(x) ::: x works at a hospital.",
            "IsScientist(x) ::: x is a scientist."
        ]
    },
    {
        "premises-NL": [
            "All doctors are scientists.",
            "All surgeons are doctors.",
            "If someone is a surgeon, they are a doctor.",
            "If someone is a doctor, they are a scientist.",
            "Some researchers are surgeons.",
            "All scientists are researchers.",
            "If someone is a researcher, then they are a scientist.",
            "All surgeons are scientists.",
            "If someone is a surgeon, then they are a researcher.",
            "If someone is a doctor, then they are a researcher.",
            "Some doctors are researchers.",
            "All researchers are doctors."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Scientist(x)) ::: All doctors are scientists",
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors",
            "∀x (Surgeon(x) → Doctor(x)) ::: If someone is a surgeon, they are a doctor",
            "∀x (Doctor(x) → Scientist(x)) ::: If someone is a doctor, they are a scientist",
            "∃x (Researcher(x) ∧ Surgeon(x)) ::: Some researchers are surgeons",
            "∀x (Scientist(x) → Researcher(x)) ::: All scientists are researchers",
            "∀x (Researcher(x) → Scientist(x)) ::: If someone is a researcher, then they are a scientist",
            "∀x (Surgeon(x) → Scientist(x)) ::: All surgeons are scientists",
            "∀x (Surgeon(x) → Researcher(x)) ::: If someone is a surgeon, then they are a researcher",
            "∀x (Doctor(x) → Researcher(x)) ::: If someone is a doctor, then they are a researcher",
            "∃x (Doctor(x) ∧ Researcher(x)) ::: Some doctors are researchers",
            "∀x (Researcher(x) → Doctor(x)) ::: All researchers are doctors"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Scientist(x) ::: x is a scientist",
            "Surgeon(x) ::: x is a surgeon",
            "Researcher(x) ::: x is a researcher"
        ]
    },
    {
        "premises-NL": [
            "John studies hard.",
            "If someone studies hard, they will pass the exam.",
            "John likes reading.",
            "If someone likes reading, they study hard.",
            "If someone likes reading, they are smart.",
            "If someone is smart, they will pass the exam.",
            "John is smart.",
            "If someone passes the exam, they are happy.",
            "John is happy.",
            "If someone is happy they will have good grades.",
            "If someone studies hard, they have good grades.",
            "John has good grades.",
            "If someone does not study hard, they fail the exam.",
            "John does not fail the exam."
        ],
        "premises-FOL": [
            "StudiesHard(john) ::: John studies hard.",
            "∀x (StudiesHard(x) → PassExam(x)) ::: If someone studies hard, they will pass the exam.",
            "LikesReading(john) ::: John likes reading.",
            "∀x (LikesReading(x) → StudiesHard(x)) ::: If someone likes reading, they study hard.",
            "∀x (LikesReading(x) → IsSmart(x)) ::: If someone likes reading, they are smart.",
            "∀x (IsSmart(x) → PassExam(x)) ::: If someone is smart, they will pass the exam.",
            "IsSmart(john) ::: John is smart.",
            "∀x (PassExam(x) → Happy(x)) ::: If someone passes the exam, they are happy.",
            "Happy(john) ::: John is happy.",
            "∀x (Happy(x) → GoodGrades(x)) ::: If someone is happy they will have good grades.",
            "∀x (StudiesHard(x) → GoodGrades(x)) ::: If someone studies hard, they have good grades.",
            "GoodGrades(john) ::: John has good grades.",
            "∀x (¬StudiesHard(x) → FailExam(x)) ::: If someone does not study hard, they fail the exam.",
            "¬FailExam(john) ::: John does not fail the exam."
        ],
        "predicates": [
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "LikesReading(x) ::: x likes reading",
            "IsSmart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All doctors have a medical degree.",
            "All people with a medical degree treat patients.",
            "Everyone who treats patients helps patients.",
            "No smokers are healthy.",
            "All doctors are healthy or smokers.",
            "If someone is healthy they can treat patients.",
            "If someone treats patients they work at a hospital.",
            "All doctors work at hospitals.",
            "Some people are doctors.",
            "Some doctors are not smokers.",
            "If someone works at a hospital, they help patients.",
            "If someone is a doctor, they treat patients.",
            "If someone has a medical degree, they can treat patients.",
            "Someone is a doctor.",
            "Someone is a smoker."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HasMedicalDegree(x)) ::: All doctors have a medical degree.",
            "∀x (HasMedicalDegree(x) → TreatsPatients(x)) ::: All people with a medical degree treat patients.",
            "∀x (TreatsPatients(x) → HelpsPatients(x)) ::: Everyone who treats patients helps patients.",
            "∀x (Smoker(x) → ¬IsHealthy(x)) ::: No smokers are healthy.",
            "∀x (Doctor(x) → (IsHealthy(x) ∨ Smoker(x))) ::: All doctors are healthy or smokers.",
            "∀x (IsHealthy(x) → TreatsPatients(x)) ::: If someone is healthy they can treat patients.",
            "∀x (TreatsPatients(x) → WorksAtHospital(x)) ::: If someone treats patients they work at a hospital.",
            "∀x (Doctor(x) → WorksAtHospital(x)) ::: All doctors work at hospitals.",
            "∃x Doctor(x) ::: Some people are doctors.",
            "∃x (Doctor(x) ∧ ¬Smoker(x)) ::: Some doctors are not smokers.",
            "∀x (WorksAtHospital(x) → HelpsPatients(x)) ::: If someone works at a hospital, they help patients.",
            "∀x (Doctor(x) → TreatsPatients(x)) ::: If someone is a doctor, they treat patients.",
            "∀x (HasMedicalDegree(x) → TreatsPatients(x)) ::: If someone has a medical degree, they can treat patients.",
            "∃x Doctor(x) ::: Someone is a doctor.",
            "∃x Smoker(x) ::: Someone is a smoker."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Smoker(x) ::: x is a smoker",
            "HelpsPatients(x) ::: x helps patients",
            "HasMedicalDegree(x) ::: x has a medical degree",
            "TreatsPatients(x) ::: x treats patients",
            "IsHealthy(x) ::: x is healthy",
            "WorksAtHospital(x) ::: x works at a hospital"
        ]
    },
    {
        "premises-NL": [
            "All members of the club like sports.",
            "Anyone who likes sports is an athlete.",
            "All athletes play in water.",
            "Everyone who plays in water enjoys water.",
            "Some people are members of the club.",
            "Some members of the club are swimmers.",
            "Everyone who is a swimmer enjoys water.",
            "If someone likes sports, they play tennis.",
            "If someone plays tennis, they are a swimmer.",
            "If someone is an athlete, they are a swimmer.",
            "Someone is a swimmer.",
            "If someone enjoys water, they swim.",
            "Someone likes sports.",
            "Someone is an athlete.",
            "If someone plays tennis, they like sports.",
            "If someone is a swimmer and likes sports, they play in water."
        ],
        "premises-FOL": [
            "∀x (MemberOfClub(x) → LikesSports(x)) ::: All members of the club like sports.",
            "∀x (LikesSports(x) → IsAthlete(x)) ::: Anyone who likes sports is an athlete.",
            "∀x (IsAthlete(x) → PlaysInWater(x)) ::: All athletes play in water.",
            "∀x (PlaysInWater(x) → EnjoysWater(x)) ::: Everyone who plays in water enjoys water.",
            "∃x MemberOfClub(x) ::: Some people are members of the club.",
            "∃x (MemberOfClub(x) ∧ Swimmer(x)) ::: Some members of the club are swimmers.",
            "∀x (Swimmer(x) → EnjoysWater(x)) ::: Everyone who is a swimmer enjoys water.",
            "∀x (LikesSports(x) → PlaysTennis(x)) ::: If someone likes sports, they play tennis.",
            "∀x (PlaysTennis(x) → Swimmer(x)) ::: If someone plays tennis, they are a swimmer.",
            "∀x (IsAthlete(x) → Swimmer(x)) ::: If someone is an athlete, they are a swimmer.",
            "∃x Swimmer(x) ::: Someone is a swimmer.",
            "∀x (EnjoysWater(x) → Swim(x)) ::: If someone enjoys water, they swim.",
            "∃x LikesSports(x) ::: Someone likes sports.",
            "∃x IsAthlete(x) ::: Someone is an athlete.",
            "∀x (PlaysTennis(x) → LikesSports(x)) ::: If someone plays tennis, they like sports.",
            "∀x ((Swimmer(x) ∧ LikesSports(x)) → PlaysInWater(x)) ::: If someone is a swimmer and likes sports, they play in water."
        ],
        "predicates": [
            "MemberOfClub(x) ::: x is a member of the club",
            "Swimmer(x) ::: x is a swimmer",
            "EnjoysWater(x) ::: x enjoys water",
            "LikesSports(x) ::: x likes sports",
            "PlaysTennis(x) ::: x plays tennis",
            "PlaysInWater(x) ::: x plays in water",
            "IsAthlete(x) ::: x is an athlete"
        ]
    },
    {
        "premises-NL": [
            "If someone has a good income, they receive a salary.",
            "If someone receives a salary, they pay taxes.",
            "If someone saves money, they do not spend money.",
            "If someone spends money, they do not save money.",
            "Everyone who saves money has assets.",
            "No one who has assets is poor.",
            "Anyone with a good income saves money or spends money.",
            "If someone saves money, they have a good income.",
            "Someone saves money.",
            "If someone has a good income, they are not poor.",
            "Someone does not spend money.",
            "If someone does not save money, they are poor.",
            "If someone is poor, they spend money.",
            "Someone receives a salary.",
            "Someone pays taxes.",
            "Someone is not poor.",
            "If someone spends money and has a good income, then they are not poor."
        ],
        "premises-FOL": [
            "∀x (GoodIncome(x) → ReceivesSalary(x)) ::: If someone has a good income, they receive a salary.",
            "∀x (ReceivesSalary(x) → PaysTaxes(x)) ::: If someone receives a salary, they pay taxes.",
            "∀x (SavesMoney(x) → ¬SpendsMoney(x)) ::: If someone saves money, they do not spend money.",
            "∀x (SpendsMoney(x) → ¬SavesMoney(x)) ::: If someone spends money, they do not save money.",
            "∀x (SavesMoney(x) → HasAssets(x)) ::: Everyone who saves money has assets.",
            "∀x (HasAssets(x) → ¬Poor(x)) ::: No one who has assets is poor.",
            "∀x (GoodIncome(x) → (SavesMoney(x) ∨ SpendsMoney(x))) ::: Anyone with a good income saves money or spends money.",
            "∀x (SavesMoney(x) → GoodIncome(x)) ::: If someone saves money, they have a good income.",
            "∃x SavesMoney(x) ::: Someone saves money.",
            "∀x (GoodIncome(x) → ¬Poor(x)) ::: If someone has a good income, they are not poor.",
            "∃x ¬SpendsMoney(x) ::: Someone does not spend money.",
            "∀x (¬SavesMoney(x) → Poor(x)) ::: If someone does not save money, they are poor.",
            "∀x (Poor(x) → SpendsMoney(x)) ::: If someone is poor, they spend money.",
            "∃x ReceivesSalary(x) ::: Someone receives a salary.",
            "∃x PaysTaxes(x) ::: Someone pays taxes.",
            "∃x ¬Poor(x) ::: Someone is not poor.",
            "∀x ((SpendsMoney(x) ∧ GoodIncome(x)) → ¬Poor(x)) ::: If someone spends money and has a good income, then they are not poor."
        ],
        "predicates": [
            "GoodIncome(x) ::: x has a good income",
            "SavesMoney(x) ::: x saves money",
            "Poor(x) ::: x is poor",
            "SpendsMoney(x) ::: x spends money",
            "HasAssets(x) ::: x has assets",
            "ReceivesSalary(x) ::: x receives a salary",
            "PaysTaxes(x) ::: x pays taxes"
        ]
    },
    {
        "premises-NL": [
            "All tools are used if they are not broken.",
            "If something is sharp, then it cuts something.",
            "No tools are broken if they are made of metal.",
            "If something is used and cuts something, then it is a tool.",
            "All tools are sharp or have a handle.",
            "If something is not broken, it is used.",
            "If something is a tool and not sharp, then it is wooden.",
            "If something is a tool, it is made of metal.",
            "If something has a handle, then it is used.",
            "If something is wooden, then it does not cut something.",
            "Something is a tool.",
            "If something is a tool, it is used or it is not broken.",
            "If something is made of metal, then it is not broken.",
            "If something is not broken, then it is not wooden.",
            "If something is not used and it has a handle, then it is not broken.",
            "If something is a tool and not broken, then it is sharp.",
            "If something is broken it is not used.",
            "Something is not broken."
        ],
        "premises-FOL": [
            "∀x ((Tool(x) ∧ ¬Broken(x)) → Used(x)) ::: All tools are used if they are not broken.",
            "∀x (Sharp(x) → CutsSomething(x)) ::: If something is sharp, then it cuts something.",
            "∀x ((Tool(x) ∧ MadeOfMetal(x)) → ¬Broken(x)) ::: No tools are broken if they are made of metal.",
            "∀x ((Used(x) ∧ CutsSomething(x)) → Tool(x)) ::: If something is used and cuts something, then it is a tool.",
            "∀x (Tool(x) → (Sharp(x) ∨ HasHandle(x))) ::: All tools are sharp or have a handle.",
            "∀x (¬Broken(x) → Used(x)) ::: If something is not broken, it is used.",
            "∀x ((Tool(x) ∧ ¬Sharp(x)) → IsWooden(x)) ::: If something is a tool and not sharp, then it is wooden.",
            "∀x (Tool(x) → MadeOfMetal(x)) ::: If something is a tool, it is made of metal.",
            "∀x (HasHandle(x) → Used(x)) ::: If something has a handle, then it is used.",
            "∀x (IsWooden(x) → ¬CutsSomething(x)) ::: If something is wooden, then it does not cut something.",
            "∃x Tool(x) ::: Something is a tool.",
            "∀x (Tool(x) → (Used(x) ∨ ¬Broken(x))) ::: If something is a tool, it is used or it is not broken.",
            "∀x (MadeOfMetal(x) → ¬Broken(x)) ::: If something is made of metal, then it is not broken.",
            "∀x (¬Broken(x) → ¬IsWooden(x)) ::: If something is not broken, then it is not wooden.",
            "∀x ((¬Used(x) ∧ HasHandle(x)) → ¬Broken(x)) ::: If something is not used and it has a handle, then it is not broken.",
            "∀x ((Tool(x) ∧ ¬Broken(x)) → Sharp(x)) ::: If something is a tool and not broken, then it is sharp.",
            "∀x (Broken(x) → ¬Used(x)) ::: If something is broken it is not used.",
            "∃x ¬Broken(x) ::: Something is not broken."
        ],
        "predicates": [
            "Tool(x) ::: x is a tool",
            "Used(x) ::: x is used",
            "Broken(x) ::: x is broken",
            "CutsSomething(x) ::: x cuts something",
            "Sharp(x) ::: x is sharp",
            "MadeOfMetal(x) ::: x is made of metal",
            "HasHandle(x) ::: x has a handle",
            "IsWooden(x) ::: x is wooden"
        ]
    },
    {
        "premises-NL": [
            "All students take exams.",
            "If someone takes an exam, they either study hard or fail.",
            "No student fails and succeeds at the same time.",
            "If a student does not study hard, they fail.",
            "All students are intelligent.",
            "Sarah is a student.",
            "Sarah studies hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakesExam(x)) ::: All students take exams.",
            "∀x (TakesExam(x) → (StudiesHard(x) ∨ Fail(x))) ::: If someone takes an exam, they either study hard or fail.",
            "¬∃x (Fail(x) ∧ Succeed(x)) ::: No student fails and succeeds at the same time.",
            "∀x (Student(x) ∧ ¬StudiesHard(x) → Fail(x)) ::: If a student does not study hard, they fail.",
            "∀x (Student(x) → Intelligent(x)) ::: All students are intelligent.",
            "Student(sarah) ::: Sarah is a student.",
            "StudiesHard(sarah) ::: Sarah studies hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "TakesExam(x) ::: x takes an exam",
            "Succeed(x) ::: x succeeds"
        ]
    },
    {
        "premises-NL": [
            "All members of the group like to work.",
            "Anyone who likes to work is not a lazy person.",
            "John is a member of the group.",
            "If someone likes to work, they work hard.",
            "If someone does not work hard, they are lazy.",
            "No one is both a member of the group and lazy.",
            "John likes to work."
        ],
        "premises-FOL": [
            "∀x (MemberOfGroup(x) → LikesToWork(x)) ::: All members of the group like to work.",
            "∀x (LikesToWork(x) → ¬LazyPerson(x)) ::: Anyone who likes to work is not a lazy person.",
            "MemberOfGroup(john) ::: John is a member of the group.",
            "∀x (LikesToWork(x) → WorksHard(x)) ::: If someone likes to work, they work hard.",
            "∀x (¬WorksHard(x) → LazyPerson(x)) ::: If someone does not work hard, they are lazy.",
            "¬∃x (MemberOfGroup(x) ∧ LazyPerson(x)) ::: No one is both a member of the group and lazy.",
            "LikesToWork(john) ::: John likes to work."
        ],
        "predicates": [
            "MemberOfGroup(x) ::: x is a member of the group",
            "LikesToWork(x) ::: x likes to work",
            "LazyPerson(x) ::: x is a lazy person",
            "WorksHard(x) ::: x works hard"
        ]
    },
    {
        "premises-NL": [
            "All people with a high income have property.",
            "If someone has property, they live in comfort.",
            "If someone lives in comfort, they have a good quality of life.",
            "John has a high income.",
            "If someone has a high income, they are wealthy.",
            "If a person is wealthy, they have property.",
            "All wealthy people live in comfort.",
            "No one can have a low income and a good quality of life.",
            "If someone does not have a good quality of life, they are not happy."
        ],
        "premises-FOL": [
            "∀x (HighIncome(x) → HasProperty(x)) ::: All people with a high income have property.",
            "∀x (HasProperty(x) → LivesInComfort(x)) ::: If someone has property, they live in comfort.",
            "∀x (LivesInComfort(x) → GoodQualityOfLife(x)) ::: If someone lives in comfort, they have a good quality of life.",
            "HighIncome(john) ::: John has a high income.",
            "∀x (HighIncome(x) → Wealthy(x)) ::: If someone has a high income, they are wealthy.",
            "∀x (Wealthy(x) → HasProperty(x)) ::: If a person is wealthy, they have property.",
            "∀x (Wealthy(x) → LivesInComfort(x)) ::: All wealthy people live in comfort.",
            "¬∃x (LowIncome(x) ∧ GoodQualityOfLife(x)) ::: No one can have a low income and a good quality of life.",
            "∀x (¬GoodQualityOfLife(x) → ¬Happy(x)) ::: If someone does not have a good quality of life, they are not happy."
        ],
        "predicates": [
            "HighIncome(x) ::: x has a high income",
            "HasProperty(x,y) ::: x has property y",
            "LivesInComfort(x) ::: x lives in comfort",
            "GoodQualityOfLife(x) ::: x has a good quality of life"
        ]
    },
    {
        "premises-NL": [
            "All doctors study medicine.",
            "Anyone who studies medicine knows a lot about medicine or is not a doctor.",
            "If someone treats patients, they are helpful.",
            "All doctors treat patients.",
            "Doctors help people.",
            "If someone helps people, they are helpful.",
            "John is a doctor.",
            "If someone studies medicine, they know medicine.",
            "If someone is not a doctor, they are not helpful.",
            "If John studies medicine, then he is helpful."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → StudiesMedicine(x)) ::: All doctors study medicine.",
            "∀x (StudiesMedicine(x) → KnowsMedicine(x) ∨ ¬Doctor(x)) ::: Anyone who studies medicine knows a lot about medicine or is not a doctor.",
            "∀x (TreatsPatients(x) → Helpful(x)) ::: If someone treats patients, they are helpful.",
            "∀x (Doctor(x) → TreatsPatients(x)) ::: All doctors treat patients.",
            "∀x (Doctor(x) → HelpsPeople(x)) ::: Doctors help people.",
            "∀x (HelpsPeople(x) → Helpful(x)) ::: If someone helps people, they are helpful.",
            "Doctor(john) ::: John is a doctor.",
            "∀x (StudiesMedicine(x) → KnowsMedicine(x)) ::: If someone studies medicine, they know medicine.",
            "∀x (¬Doctor(x) → ¬Helpful(x)) ::: If someone is not a doctor, they are not helpful.",
            "∀x (StudiesMedicine(john) → Helpful(john)) ::: If John studies medicine, then he is helpful."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "KnowsMedicine(x) ::: x knows a lot about medicine",
            "TreatsPatients(x) ::: x treats patients",
            "HelpsPeople(x) ::: x helps people",
            "Helpful(x) ::: x is helpful",
            "StudiesMedicine(x) ::: x studies medicine"
        ]
    },
    {
        "premises-NL": [
            "All students take classes.",
            "If someone takes classes and studies, they pass exams.",
            "If someone passes exams, they eventually graduate.",
            "All students attend university.",
            "If someone studies and is smart, they pass exams.",
            "John is a student.",
            "John studies.",
            "If John is a student, he takes classes.",
            "If John attends university, he is a student.",
            "If someone studies, they are smart.",
            "If a student studies they pass exams."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakesClasses(x)) ::: All students take classes.",
            "∀x (TakesClasses(x) ∧ Studies(x) → PassesExams(x)) ::: If someone takes classes and studies, they pass exams.",
            "∀x (PassesExams(x) → EventuallyGraduate(x)) ::: If someone passes exams, they eventually graduate.",
            "∀x (Student(x) → AttendsUniversity(x)) ::: All students attend university.",
            "∀x (Studies(x) ∧ Smart(x) → PassesExams(x)) ::: If someone studies and is smart, they pass exams.",
            "Student(john) ::: John is a student.",
            "Studies(john) ::: John studies.",
            "∀x (Student(john) → TakesClasses(john)) ::: If John is a student, he takes classes.",
            "∀x (AttendsUniversity(john) → Student(john)) ::: If John attends university, he is a student.",
            "∀x (Studies(x) → Smart(x)) ::: If someone studies, they are smart.",
            "∀x (Student(x) ∧ Studies(x) → PassesExams(x)) ::: If a student studies they pass exams."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "TakesClasses(x) ::: x takes classes",
            "Studies(x) ::: x studies",
            "PassesExams(x) ::: x passes exams",
            "EventuallyGraduate(x) ::: x eventually graduates",
            "AttendsUniversity(x) ::: x attends university",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All students who are in a study group have passed the exam.",
            "Some students are in a study group.",
            "Anyone who has passed the exam is diligent.",
            "Not everyone is diligent.",
            "Students are not the only ones who passed the exam."
        ],
        "premises-FOL": [
            "∀x ∀y ((Student(x) ∧ StudyGroup(x, y)) → PassedExam(x)) ::: If a student is in a study group, they have passed the exam.",
            "∃x ∃y (Student(x) ∧ StudyGroup(x, y)) ::: Some students are in a study group.",
            "∀x (PassedExam(x) → Diligence(x)) ::: Anyone who has passed the exam is diligent.",
            "¬∀x Diligence(x) ::: Not everyone is diligent.",
            "∃x (PassedExam(x) ∧ ¬Student(x)) ::: Students are not the only ones who passed the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Diligence(x) ::: x is diligent",
            "StudyGroup(x, y) ::: x and y are in a study group",
            "PassedExam(x) ::: x has passed the exam"
        ]
    },
    {
        "premises-NL": [
            "All birds are winged creatures.",
            "Some winged creatures cannot fly.",
            "All large birds eat fish.",
            "If something eats fish, then it is large.",
            "Some birds are large.",
            "Large things cannot fly."
        ],
        "premises-FOL": [
            "∀x (Bird(x) → WingedCreature(x)) ::: All birds are winged creatures.",
            "∃x (WingedCreature(x) ∧ ¬CanFly(x)) ::: Some winged creatures cannot fly.",
            "∀x ((Bird(x) ∧ Large(x)) → EatsFish(x)) ::: All large birds eat fish.",
            "∀x (EatsFish(x) → Large(x)) ::: If something eats fish, then it is large.",
            "∃x (Bird(x) ∧ Large(x)) ::: Some birds are large.",
            "∀x (Large(x) → ¬CanFly(x)) ::: Large things cannot fly."
        ],
        "predicates": [
            "Bird(x) ::: x is a bird",
            "CanFly(x) ::: x can fly",
            "WingedCreature(x) ::: x is a winged creature",
            "Large(x) ::: x is large",
            "EatsFish(x) ::: x eats fish"
        ]
    },
    {
        "premises-NL": [
            "All students attend the university.",
            "Some students attend the university.",
            "If someone is a student and attends the university, then they are registered."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendUniversity(x)) ::: All students attend the university.",
            "∃x (Student(x)) ::: Some students exist.",
            "∀x (Student(x) ∧ AttendUniversity(x) → Registered(x)) ::: If someone is a student and attends the university, then they are registered."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendUniversity(x) ::: x attends the university"
        ]
    },
    {
        "premises-NL": [
            "All teachers know logic.",
            "Anyone who knows logic enjoys coding.",
            "Anyone who enjoys coding is not happy.",
            "If someone is a teacher, they enjoy coding.",
            "If someone is a programmer, they do not enjoy coding.",
            "All teachers are happy.",
            "Some teachers are happy.",
            "If a teacher is happy, they are not a programmer.",
            "If someone knows logic they are a teacher."
        ],
        "premises-FOL": [
            "∀x (Teacher(x) → KnowsLogic(x)) ::: All teachers know logic.",
            "∀x (KnowsLogic(x) → EnjoysCoding(x)) ::: Anyone who knows logic enjoys coding.",
            "∀x (EnjoysCoding(x) → ¬Happy(x)) ::: Anyone who enjoys coding is not happy.",
            "∀x (Teacher(x) → EnjoysCoding(x)) ::: If someone is a teacher, they enjoy coding.",
            "∀x (Programmer(x) → ¬EnjoysCoding(x)) ::: If someone is a programmer, they do not enjoy coding.",
            "∀x (Teacher(x) → Happy(x)) ::: All teachers are happy.",
            "∃x (Teacher(x) ∧ Happy(x)) ::: Some teachers are happy.",
            "∀x (Teacher(x) ∧ Happy(x) → ¬Programmer(x)) ::: If a teacher is happy, they are not a programmer.",
            "∀x (KnowsLogic(x) → Teacher(x)) ::: If someone knows logic they are a teacher."
        ],
        "predicates": [
            "Teacher(x) ::: x is a teacher.",
            "Happy(x) ::: x is happy.",
            "Programmer(x) ::: x is a programmer.",
            "KnowsLogic(x) ::: x knows logic",
            "EnjoysCoding(x) ::: x enjoys coding."
        ]
    },
    {
        "premises-NL": [
            "Alice knows anyone who likes her.",
            "Bob is a friend of Alice.",
            "If someone is a friend of Alice, then Alice knows them.",
            "Charlie likes Alice.",
            "If someone likes Alice and Alice knows them, then Alice knows them.",
            "Bob likes Alice.",
            "Alice knows Bob.",
            "If Alice knows someone and someone likes Alice, then Alice knows that person."
        ],
        "premises-FOL": [
            "∀x (Likes(x, Alice) → Knows(Alice, x)) ::: Alice knows anyone who likes her",
            "Friend(Bob, Alice) ::: Bob is a friend of Alice",
            "∀x (Friend(x, Alice) → Knows(Alice, x)) ::: If someone is a friend of Alice, then Alice knows them",
            "Likes(Charlie, Alice) ::: Charlie likes Alice",
            "∀x ((Likes(x, Alice) ∧ Knows(Alice, x)) → Knows(Alice, x)) ::: If someone likes Alice and Alice knows them, then Alice knows them",
            "Likes(Bob, Alice) ::: Bob likes Alice",
            "Knows(Alice, Bob) ::: Alice knows Bob",
            "∀x ((Knows(Alice, x) ∧ Likes(x, Alice)) → Knows(Alice, x)) ::: If Alice knows someone and someone likes Alice, then Alice knows that person"
        ],
        "predicates": [
            "Knows(x, y) ::: x knows y",
            "Friend(x, y) ::: x is a friend of y",
            "Likes(x, y) ::: x likes y"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All surgeons can operate.",
            "If a doctor is a specialist, then they are skilled.",
            "If a doctor is not skilled, then they are experienced.",
            "If someone can operate, they have experience.",
            "All specialists are doctors.",
            "If someone is a surgeon and has experience, then they are a specialist.",
            "Every doctor is either skilled or experienced.",
            "Being a doctor implies being skilled or experienced.",
            "If someone is a specialist, they are skilled or experienced."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors",
            "∀x (Surgeon(x) → CanOperate(x)) ::: All surgeons can operate",
            "∀x (Specialist(x) → Skilled(x)) ::: If a doctor is a specialist, then they are skilled",
            "∀x (Doctor(x) ∧ ¬Skilled(x) → Experienced(x)) ::: If a doctor is not skilled, then they are experienced",
            "∀x (CanOperate(x) → Experienced(x)) ::: If someone can operate, they have experience",
            "∀x (Specialist(x) → Doctor(x)) ::: All specialists are doctors",
            "∀x ((Surgeon(x) ∧ Experienced(x)) → Specialist(x)) ::: If someone is a surgeon and has experience, then they are a specialist",
            "∀x (Doctor(x) → (Skilled(x) ∨ Experienced(x))) ::: Every doctor is either skilled or experienced",
            "∀x (Doctor(x) → (Skilled(x) ∨ Experienced(x))) ::: Being a doctor implies being skilled or experienced.",
            "∀x (Specialist(x) → (Skilled(x) ∨ Experienced(x))) ::: If someone is a specialist, they are skilled or experienced"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Skilled(x) ::: x is skilled",
            "Experienced(x) ::: x has experience",
            "Surgeon(x) ::: x is a surgeon",
            "CanOperate(x) ::: x can operate",
            "Specialist(x) ::: x is a specialist"
        ]
    },
    {
        "premises-NL": [
            "If a patient has a fever, they have the flu.",
            "If a patient has the flu and took the medicine correctly, they will recover.",
            "If a patient has the flu and did not take the medicine correctly, they will not recover.",
            "John has a fever.",
            "John either took the medicine or didn't.",
            "If someone has a fever and they did not take the medicine correctly, then they will not recover.",
            "If John took the medicine correctly, then he has recovered.",
            "If someone has the flu, then they either took the medicine correctly or they didn't.",
            "If someone took the medicine then they either took it correctly or incorrectly.",
            "If someone has the flu and recovers, then they are healthy.",
            "If someone does not recover and did not take the medicine correctly, then they have a fever.",
            "People are either healthy or have a fever.",
            "If John has a fever, he took the medicine.",
            "John has the flu."
        ],
        "premises-FOL": [
            "∀x (Fever(x) → HasFlu(x)) ::: If a patient has a fever, they have the flu.",
            "∀x ((HasFlu(x) ∧ TookMedicineCorrectly(x)) → Recovered(x)) ::: If a patient has the flu and took the medicine correctly, they will recover.",
            "∀x ((HasFlu(x) ∧ ¬TookMedicineCorrectly(x)) → ¬Recovered(x)) ::: If a patient has the flu and did not take the medicine correctly, they will not recover.",
            "Fever(john) ::: John has a fever.",
            "TookMedicine(john) ∨ ¬TookMedicine(john) ::: John either took the medicine or didn't.",
            "∀x ((Fever(x) ∧ ¬TookMedicineCorrectly(x)) → ¬Recovered(x)) ::: If someone has a fever and they did not take the medicine correctly, then they will not recover.",
            "TookMedicineCorrectly(john) → Recovered(john) ::: If John took the medicine correctly, then he has recovered.",
            "∀x (HasFlu(x) → (TookMedicineCorrectly(x) ∨ ¬TookMedicineCorrectly(x))) ::: If someone has the flu, then they either took the medicine correctly or they didn't.",
            "∀x (TookMedicine(x) → (TookMedicineCorrectly(x) ∨ ¬TookMedicineCorrectly(x))) ::: If someone took the medicine then they either took it correctly or incorrectly.",
            "∀x ((HasFlu(x) ∧ Recovered(x)) → Healthy(x)) ::: If someone has the flu and recovers, then they are healthy.",
            "∀x ((¬Recovered(x) ∧ ¬TookMedicineCorrectly(x)) → Fever(x)) ::: If someone does not recover and did not take the medicine correctly, then they have a fever.",
            "∀x (Healthy(x) ∨ Fever(x)) ::: People are either healthy or have a fever.",
            "Fever(john) → TookMedicine(john) ::: If John has a fever, he took the medicine.",
            "HasFlu(john) ::: John has the flu."
        ],
        "predicates": [
            "Fever(x) ::: x has a fever.",
            "TookMedicine(x) ::: x took the medicine.",
            "TookMedicineCorrectly(x) ::: x took the medicine correctly.",
            "HasFlu(x) ::: x has the flu.",
            "Recovered(x) ::: x recovered."
        ]
    },
    {
        "premises-NL": [
            "All programmers like computers.",
            "Anyone who likes computers spends time indoors.",
            "Anyone who spends time indoors is not good at sports.",
            "John is a programmer.",
            "If someone is good at sports, then they spend time outdoors.",
            "John likes computers and is a programmer.",
            "People are either good at sports or not good at sports.",
            "If someone spends time indoors, they are not good at sports.",
            "If someone is a programmer, they spend time indoors.",
            "If someone likes computers, they are healthy.",
            "If someone is healthy, they are good at sports.",
            "If someone is a programmer, they are healthy.",
            "If someone spends time outdoors, they are healthy.",
            "John is healthy.",
            "If John spends time indoors, he is not good at sports."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → LikesComputers(x)) ::: All programmers like computers.",
            "∀x (LikesComputers(x) → SpendsTimeIndoors(x)) ::: Anyone who likes computers spends time indoors.",
            "∀x (SpendsTimeIndoors(x) → ¬GoodAtSports(x)) ::: Anyone who spends time indoors is not good at sports.",
            "Programmer(john) ::: John is a programmer.",
            "∀x (GoodAtSports(x) → ¬SpendsTimeIndoors(x)) ::: If someone is good at sports, then they spend time outdoors.",
            "(LikesComputers(john) ∧ Programmer(john)) ::: John likes computers and is a programmer.",
            "∀x (GoodAtSports(x) ∨ ¬GoodAtSports(x)) ::: People are either good at sports or not good at sports.",
            "∀x (SpendsTimeIndoors(x) → ¬GoodAtSports(x)) ::: If someone spends time indoors, they are not good at sports.",
            "∀x (Programmer(x) → SpendsTimeIndoors(x)) ::: If someone is a programmer, they spend time indoors.",
            "∀x (LikesComputers(x) → IsHealthy(x)) ::: If someone likes computers, they are healthy.",
            "∀x (IsHealthy(x) → GoodAtSports(x)) ::: If someone is healthy, they are good at sports.",
            "∀x (Programmer(x) → IsHealthy(x)) ::: If someone is a programmer, they are healthy.",
            "∀x (¬SpendsTimeIndoors(x) → IsHealthy(x)) ::: If someone spends time outdoors, they are healthy.",
            "IsHealthy(john) ::: John is healthy.",
            "SpendsTimeIndoors(john) → ¬GoodAtSports(john) ::: If John spends time indoors, he is not good at sports."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer.",
            "GoodAtSports(x) ::: x is good at sports.",
            "LikesComputers(x) ::: x likes computers.",
            "SpendsTimeIndoors(x) ::: x spends time indoors.",
            "IsHealthy(x) ::: x is healthy."
        ]
    },
    {
        "premises-NL": [
            "All students study hard.",
            "Anyone who studies hard reads books.",
            "Anyone who studies hard gets good grades.",
            "John is a student.",
            "If someone gets good grades, then they attends classes.",
            "If someone attends classes, then they read books.",
            "If someone does not read books, then they do not get good grades.",
            "John studies hard.",
            "Mary is a student.",
            "If someone is a student, then they either read books or they do not read books.",
            "If someone is a student, then they either get good grades or do not get good grades.",
            "If someone studies hard then they read books and get good grades.",
            "If someone is a student and they do not read books, then they will not get good grades.",
            "Every student studies hard.",
            "If someone gets good grades, they read books."
        ],
        "premises-FOL": [
            "∀x (Student(x) → StudiesHard(x)) ::: All students study hard.",
            "∀x (StudiesHard(x) → ReadsBooks(x)) ::: Anyone who studies hard reads books.",
            "∀x (StudiesHard(x) → GetsGoodGrades(x)) ::: Anyone who studies hard gets good grades.",
            "Student(john) ::: John is a student.",
            "∀x (GetsGoodGrades(x) → AttendsClasses(x)) ::: If someone gets good grades, then they attends classes.",
            "∀x (AttendsClasses(x) → ReadsBooks(x)) ::: If someone attends classes, then they read books.",
            "∀x (¬ReadsBooks(x) → ¬GetsGoodGrades(x)) ::: If someone does not read books, then they do not get good grades.",
            "StudiesHard(john) ::: John studies hard.",
            "Student(mary) ::: Mary is a student.",
            "∀x (Student(x) → (ReadsBooks(x) ∨ ¬ReadsBooks(x))) ::: If someone is a student, then they either read books or they do not read books.",
            "∀x (Student(x) → (GetsGoodGrades(x) ∨ ¬GetsGoodGrades(x))) ::: If someone is a student, then they either get good grades or do not get good grades.",
            "∀x (StudiesHard(x) → (ReadsBooks(x) ∧ GetsGoodGrades(x))) ::: If someone studies hard then they read books and get good grades.",
            "∀x ((Student(x) ∧ ¬ReadsBooks(x)) → ¬GetsGoodGrades(x)) ::: If someone is a student and they do not read books, then they will not get good grades.",
            "∀x (Student(x) → StudiesHard(x)) ::: Every student studies hard.",
            "∀x (GetsGoodGrades(x) → ReadsBooks(x)) ::: If someone gets good grades, they read books."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "ReadsBooks(x) ::: x reads books.",
            "GetsGoodGrades(x) ::: x gets good grades.",
            "StudiesHard(x) ::: x studies hard.",
            "AttendsClasses(x) ::: x attends classes."
        ]
    },
    {
        "premises-NL": [
            "All athletes train.",
            "Anyone who trains is a doctor.",
            "All doctors help people.",
            "John is an athlete.",
            "If someone is a doctor, then they have passion.",
            "Anyone who helps people is also a doctor.",
            "If someone is a doctor, they are also a helper.",
            "Anyone who is a helper helps people.",
            "John trained.",
            "If someone is a doctor, they help other people.",
            "If someone helps people, then they are healthy.",
            "Mary is a doctor.",
            "If someone is an athlete, they have to be good.",
            "If someone is trained, then they must have been helped.",
            "If someone is a doctor, they help."
        ],
        "premises-FOL": [
            "∀x (Athlete(x) → Trained(x)) ::: All athletes train.",
            "∀x (Trained(x) → Doctor(x)) ::: Anyone who trains is a doctor.",
            "∀x (Doctor(x) → HelpsPeople(x)) ::: All doctors help people.",
            "Athlete(john) ::: John is an athlete.",
            "∀x (Doctor(x) → HasPassion(x)) ::: If someone is a doctor, then they have passion.",
            "∀x (HelpsPeople(x) → Doctor(x)) ::: Anyone who helps people is also a doctor.",
            "∀x (Doctor(x) → Helper(x)) ::: If someone is a doctor, they are also a helper.",
            "∀x (Helper(x) → HelpsPeople(x)) ::: Anyone who is a helper helps people.",
            "Trained(john) ::: John trained.",
            "∀x (Doctor(x) → HelpsPeople(x)) ::: If someone is a doctor, they help other people.",
            "∀x (HelpsPeople(x) → Healthy(x)) ::: If someone helps people, then they are healthy.",
            "Doctor(mary) ::: Mary is a doctor.",
            "∀x (Athlete(x) → Good(x)) ::: If someone is an athlete, they have to be good.",
            "∀x (Trained(x) → Helped(x)) ::: If someone is trained, then they must have been helped.",
            "∀x (Doctor(x) → Help(x)) ::: If someone is a doctor, they help."
        ],
        "predicates": [
            "Athlete(x) ::: x is an athlete.",
            "Trained(x) ::: x trained.",
            "Doctor(x) ::: x is a doctor.",
            "HelpsPeople(x) ::: x helps people.",
            "HasPassion(x) ::: x has passion."
        ]
    },
    {
        "premises-NL": [
            "All penguins are birds.",
            "All penguins cannot fly.",
            "If something is a penguin, it is a bird.",
            "There exists a penguin."
        ],
        "premises-FOL": [
            "∀x (Penguin(x) → Bird(x)) ::: All penguins are birds.",
            "∀x (Penguin(x) → ¬Flies(x)) ::: All penguins cannot fly.",
            "∀x (Penguin(x) → Bird(x)) ::: If something is a penguin, it is a bird.",
            "∃x Penguin(x) ::: There exists a penguin."
        ],
        "predicates": [
            "Bird(x) ::: x is a bird",
            "Flies(x) ::: x can fly",
            "Penguin(x) ::: x is a penguin"
        ]
    },
    {
        "premises-NL": [
            "All doctors are educated.",
            "All researchers are educated.",
            "If someone is a doctor, then they study medicine.",
            "If someone studies medicine, then they work at a hospital.",
            "If someone works at a hospital, then they are either a doctor or a researcher.",
            "John is a doctor.",
            "John is a researcher."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Educated(x)) ::: All doctors are educated.",
            "∀x (Researcher(x) → Educated(x)) ::: All researchers are educated.",
            "∀x (Doctor(x) → StudiesMedicine(x)) ::: If someone is a doctor, then they study medicine.",
            "∀x (StudiesMedicine(x) → WorksAtHospital(x)) ::: If someone studies medicine, then they work at a hospital.",
            "∀x (WorksAtHospital(x) → (Doctor(x) ∨ Researcher(x))) ::: If someone works at a hospital, then they are either a doctor or a researcher.",
            "Doctor(John) ::: John is a doctor.",
            "Researcher(John) ::: John is a researcher."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Researcher(x) ::: x is a researcher",
            "Educated(x) ::: x is educated",
            "StudiesMedicine(x) ::: x studies medicine",
            "WorksAtHospital(x) ::: x works at a hospital"
        ]
    },
    {
        "premises-NL": [
            "Every student is enrolled in a course.",
            "Some students attend every lecture.",
            "If a student is enrolled in a course, they are eligible to attend lectures.",
            "If a student attends every lecture, they are a student.",
            "If a student is enrolled in a course and attends every lecture, then the student is in the class",
            "Some students are neither enrolled in a course nor do they attend every lecture.",
            "If a student doesn't attend all lectures they will not pass the course.",
            "If a student passes the course they must be enrolled.",
            "If a student is not in the class they will not receive a grade.",
            "Every student either is enrolled in a course or doesn't attend all lectures.",
            "Every student that is in the class is also enrolled."
        ],
        "premises-FOL": [
            "∀x (Student(x) → EnrolledInCourse(x)) ::: Every student is enrolled in a course.",
            "∃x (Student(x) ∧ AttendLectureEveryTime(x)) ::: Some students attend every lecture.",
            "∀x (EnrolledInCourse(x) → AttendLectureEveryTime(x)) ::: If a student is enrolled in a course, they are eligible to attend lectures.",
            "∀x (AttendLectureEveryTime(x) → Student(x)) ::: If a student attends every lecture, they are a student.",
            "∀x ((EnrolledInCourse(x) ∧ AttendLectureEveryTime(x)) → InClass(x)) ::: If a student is enrolled in a course and attends every lecture, then the student is in the class",
            "∃x (¬EnrolledInCourse(x) ∧ ¬AttendLectureEveryTime(x)) ::: Some students are neither enrolled in a course nor do they attend every lecture.",
            "∀x (¬AttendLectureEveryTime(x) → ¬PassCourse(x)) ::: If a student doesn't attend all lectures they will not pass the course.",
            "∀x (PassCourse(x) → EnrolledInCourse(x)) ::: If a student passes the course they must be enrolled.",
            "∀x (¬InClass(x) → ¬ReceiveGrade(x)) ::: If a student is not in the class they will not receive a grade.",
            "∀x (Student(x) → (EnrolledInCourse(x) ∨ ¬AttendLectureEveryTime(x))) ::: Every student either is enrolled in a course or doesn't attend all lectures.",
            "∀x (InClass(x) → EnrolledInCourse(x)) ::: Every student that is in the class is also enrolled."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "EnrolledInCourse(x) ::: x is enrolled in a course.",
            "AttendLectureEveryTime(x) ::: x attends every lecture."
        ]
    },
    {
        "premises-NL": [
            "All students are diligent.",
            "Alice is a student.",
            "If someone is a student, they study hard.",
            "Bob is a student.",
            "Students always do homework.",
            "Alice and Bob are friends."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Diligent(x)) ::: All students are diligent.",
            "Student(alice) ::: Alice is a student.",
            "∀x (Student(x) → StudiesHard(x)) ::: If someone is a student, they study hard.",
            "Student(bob) ::: Bob is a student.",
            "∀x (Student(x) → DoesHomework(x)) ::: Students always do homework.",
            "Friends(alice, bob) ::: Alice and Bob are friends."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Diligent(x) ::: x is diligent"
        ]
    },
    {
        "premises-NL": [
            "All apples are fruits.",
            "All apples are red.",
            "All apples are sweet.",
            "There is an apple.",
            "Bananas are fruits.",
            "Bananas are not red.",
            "Bananas can be sweet."
        ],
        "premises-FOL": [
            "∀x (Apple(x) → Fruit(x)) ::: All apples are fruits.",
            "∀x (Apple(x) → Red(x)) ::: All apples are red.",
            "∀x (Apple(x) → Sweet(x)) ::: All apples are sweet.",
            "∃x Apple(x) ::: There is an apple.",
            "∀x (Banana(x) → Fruit(x)) ::: Bananas are fruits.",
            "∀x (Banana(x) → ¬Red(x)) ::: Bananas are not red.",
            "∃x (Banana(x) ∧ Sweet(x)) ::: Bananas can be sweet."
        ],
        "predicates": [
            "Fruit(x) ::: x is a fruit",
            "Red(x) ::: x is red",
            "Sweet(x) ::: x is sweet",
            "Apple(x) ::: x is an apple",
            "Banana(x) ::: x is a banana"
        ]
    },
    {
        "premises-NL": [
            "Everyone likes themselves.",
            "John plays with Mary.",
            "If someone likes someone, they are friends.",
            "John is a person.",
            "Mary is a person.",
            "If someone plays with someone, both like each other.",
            "Mary likes John.",
            "John likes John."
        ],
        "premises-FOL": [
            "∀x (Likes(x, x)) ::: Everyone likes themselves.",
            "PlaysWith(john, mary) ::: John plays with Mary.",
            "∀x ∀y (Likes(x, y) → FriendOf(x, y)) ::: If someone likes someone, they are friends.",
            "Person(john) ::: John is a person.",
            "Person(mary) ::: Mary is a person.",
            "∀x ∀y (PlaysWith(x, y) → (Likes(x, y) ∧ Likes(y, x))) ::: If someone plays with someone, both like each other.",
            "Likes(mary, john) ::: Mary likes John.",
            "Likes(john, john) ::: John likes John."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Likes(x, y) ::: x likes y",
            "PlaysWith(x, y) ::: x plays with y",
            "FriendOf(x, y) ::: x is a friend of y"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All surgeons work at hospitals.",
            "Anyone who works at a hospital and is a doctor, has a degree.",
            "Dr. Smith is a surgeon.",
            "Surgeons specialize in surgery.",
            "Dr. Smith works at a hospital.",
            "Dr. Smith is a doctor.",
            "All surgeon assistants are medical professionals.",
            "Medical professionals have degrees.",
            "If someone is a surgeon, they are a doctor.",
            "If x specializes in surgery, then x is a surgeon."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Surgeon(x) → WorksAtHospital(x)) ::: All surgeons work at hospitals.",
            "∀x ((WorksAtHospital(x) ∧ Doctor(x)) → HasDegree(x)) ::: Anyone who works at a hospital and is a doctor, has a degree.",
            "Surgeon(smith) ::: Dr. Smith is a surgeon.",
            "∀x (SpecializesIn(x, surgery) → Surgeon(x)) ::: Surgeons specialize in surgery.",
            "WorksAtHospital(smith) ::: Dr. Smith works at a hospital.",
            "Doctor(smith) ::: Dr. Smith is a doctor.",
            "∀x (IsSurgeonAssistant(x) → IsMedicalProfessional(x)) ::: All surgeon assistants are medical professionals.",
            "∀x (IsMedicalProfessional(x) → HasDegree(x)) ::: Medical professionals have degrees.",
            "∀x (Surgeon(x) → Doctor(x)) ::: If someone is a surgeon, they are a doctor.",
            "∀x (SpecializesIn(x, surgery) → Surgeon(x)) ::: If x specializes in surgery, then x is a surgeon."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "HasDegree(x) ::: x has a degree",
            "WorksAtHospital(x) ::: x works at a hospital",
            "SpecializesIn(x, y) ::: x specializes in y",
            "IsSurgeonAssistant(x) ::: x is a surgeon assistant",
            "IsMedicalProfessional(x) ::: x is a medical professional"
        ]
    },
    {
        "premises-NL": [
            "All scientists work at universities or do research.",
            "Anyone who works at a university is a scientist.",
            "All researchers are scientists.",
            "Some researchers do not attend universities.",
            "All students attend universities.",
            "No scientist is a student.",
            "If someone works at a university and does research, they are not a student.",
            "Anyone who graduated from a university is a scientist.",
            "Anyone who attends a university is a student.",
            "Everyone who is not a student, does research or is a scientist.",
            "No scientist teaches at any university."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → (WorksAt(x, y) ∨ Researcher(x))) ::: All scientists work at universities or do research.",
            "∀x (WorksAt(x, y) → Scientist(x)) ::: Anyone who works at a university is a scientist.",
            "∀x (Researcher(x) → Scientist(x)) ::: All researchers are scientists.",
            "∃x (Researcher(x) ∧ ¬AttendsUniversity(x)) ::: Some researchers do not attend universities.",
            "∀x (Student(x) → AttendsUniversity(x)) ::: All students attend universities.",
            "∀x (Scientist(x) → ¬Student(x)) ::: No scientist is a student.",
            "∀x ((WorksAt(x, y) ∧ Researcher(x)) → ¬Student(x)) ::: If someone works at a university and does research, they are not a student.",
            "∀x (GraduatedFrom(x, y) → Scientist(x)) ::: Anyone who graduated from a university is a scientist.",
            "∀x (AttendsUniversity(x) → Student(x)) ::: Anyone who attends a university is a student.",
            "∀x (¬Student(x) → (Researcher(x) ∨ Scientist(x))) ::: Everyone who is not a student, does research or is a scientist.",
            "∀x ∀y (Scientist(x) → ¬TeachesAt(x, y)) ::: No scientist teaches at any university."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Student(x) ::: x is a student",
            "WorksAt(x, y) ::: x works at y",
            "TeachesAt(x, y) ::: x teaches at y",
            "Researcher(x) ::: x is a researcher",
            "EnrolledIn(x, y) ::: x is enrolled in y",
            "GraduatedFrom(x, y) ::: x graduated from y",
            "AttendsUniversity(x) ::: x attends a university"
        ]
    },
    {
        "premises-NL": [
            "All programmers know Python or Java.",
            "All engineers are experts.",
            "All experts are skilled at coding.",
            "If someone knows Python and is an engineer, they are skilled at coding.",
            "If someone knows Java and is a programmer, they are skilled at coding.",
            "Some programmers are also engineers.",
            "John knows Python."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → (KnowsProgrammingLanguage(x, python) ∨ KnowsProgrammingLanguage(x, java))) ::: All programmers know Python or Java.",
            "∀x (Engineer(x) → Expert(x)) ::: All engineers are experts.",
            "∀x (Expert(x) → SkilledAtCoding(x)) ::: All experts are skilled at coding.",
            "∀x ((KnowsProgrammingLanguage(x, python) ∧ Engineer(x)) → SkilledAtCoding(x)) ::: If someone knows Python and is an engineer, they are skilled at coding.",
            "∀x ((KnowsProgrammingLanguage(x, java) ∧ Programmer(x)) → SkilledAtCoding(x)) ::: If someone knows Java and is a programmer, they are skilled at coding.",
            "∃x (Programmer(x) ∧ Engineer(x)) ::: Some programmers are also engineers.",
            "KnowsProgrammingLanguage(john, python) ::: John knows Python.",
            "Programmer(john) ::: John is a programmer."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "Engineer(x) ::: x is an engineer",
            "SkilledAtCoding(x) ::: x is skilled at coding",
            "Expert(x) ::: x is an expert",
            "KnowsProgrammingLanguage(x, y) ::: x knows programming language y"
        ]
    },
    {
        "premises-NL": [
            "All books recommended by Alice are interesting.",
            "All books are either interesting or boring.",
            "Some expensive books are recommended by Alice.",
            "If a book is interesting, then it's not boring.",
            "Bob reads all the books Alice recommends.",
            "Alice recommends at least one book.",
            "All books read by Bob are expensive.",
            "Bob reads book1 and book2",
            "Book1 is expensive"
        ],
        "premises-FOL": [
            "∀x (RecommendedBy(alice, x) → Interesting(x)) ::: All books recommended by Alice are interesting.",
            "∀x (Book(x) → (Interesting(x) ∨ Boring(x))) ::: All books are either interesting or boring.",
            "∃x (Expensive(x) ∧ RecommendedBy(alice, x)) ::: Some expensive books are recommended by Alice.",
            "∀x (Interesting(x) → ¬Boring(x)) ::: If a book is interesting, then it's not boring.",
            "∀x (RecommendedBy(alice, x) → Reads(bob, x)) ::: Bob reads all the books Alice recommends.",
            "∃x RecommendedBy(alice, x) ::: Alice recommends at least one book.",
            "∀x (Reads(bob, x) → Expensive(x)) ::: All books read by Bob are expensive.",
            "Reads(bob, book1) ∧ Reads(bob, book2) ::: Bob reads book1 and book2",
            "Expensive(book1) ::: Book1 is expensive"
        ],
        "predicates": [
            "Book(x) ::: x is a book",
            "Interesting(x) ::: x is interesting",
            "Expensive(x) ::: x is expensive",
            "RecommendedBy(x, y) ::: x recommends y",
            "Reads(x, y) ::: x reads y"
        ]
    },
    {
        "premises-NL": [
            "Sarah is a student.",
            "If someone is a student and studies hard, then they will pass the exam.",
            "Sarah studies hard.",
            "If someone likes coffee, then they buy coffee.",
            "Sarah likes coffee.",
            "If someone has a book, then they read it.",
            "Sarah has a book titled 'Logic 101'.",
            "The author of 'Logic 101' is Professor Smith.",
            "If someone reads a book by Professor Smith, they get a good grade.",
            "If someone gets a good grade, then they are smart.",
            "If someone buys coffee, they drink coffee.",
            "Sarah buys coffee.",
            "Anyone who is smart and finishes homework will pass the exam."
        ],
        "premises-FOL": [
            "Student(sarah) ::: Sarah is a student.",
            "∀x (Student(x) ∧ StudiesHard(x) → PassesExam(x)) ::: If someone is a student and studies hard, then they will pass the exam.",
            "StudiesHard(sarah) ::: Sarah studies hard.",
            "∀x (LikesCoffee(x) → BuysCoffee(x)) ::: If someone likes coffee, then they buy coffee.",
            "LikesCoffee(sarah) ::: Sarah likes coffee.",
            "∀x ∀y (HasBook(x, y) → ReadsBook(x, y)) ::: If someone has a book, then they read it.",
            "HasBook(sarah, \"Logic 101\") ::: Sarah has a book titled 'Logic 101'.",
            "IsAuthor(professor_smith, \"Logic 101\") ::: The author of 'Logic 101' is Professor Smith.",
            "∀x (ReadsBook(x, \"Logic 101\") → GoodGrade(x)) ::: If someone reads a book by Professor Smith, they get a good grade.",
            "∀x (GoodGrade(x) → Smart(x)) ::: If someone gets a good grade, then they are smart.",
            "∀x (BuysCoffee(x) → DrinksCoffee(x)) ::: If someone buys coffee, they drink coffee.",
            "BuysCoffee(sarah) ::: Sarah buys coffee.",
            "∀x (Smart(x) ∧ FinishesHomework(x) → PassesExam(x)) ::: Anyone who is smart and finishes homework will pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassesExam(x) ::: x passes the exam",
            "LikesCoffee(x) ::: x likes coffee",
            "HasBook(x, y) ::: x has book y",
            "ReadsBook(x, y) ::: x reads book y",
            "IsAuthor(x, y) ::: x is the author of y",
            "GoodGrade(x) ::: x gets a good grade",
            "Smart(x) ::: x is smart",
            "BuysCoffee(x) ::: x buys coffee",
            "DrinksCoffee(x) ::: x drinks coffee",
            "FinishesHomework(x) ::: x finishes their homework",
            "GetsHelp(x, y) ::: x gets help from y"
        ]
    },
    {
        "premises-NL": [
            "Alice likes Bob.",
            "Bob likes Carol.",
            "If someone likes someone, they attend the same events.",
            "Alice and Bob attended the same event.",
            "If people attend the same event, they know each other.",
            "If someone is a friend of someone, then they like them.",
            "Alice is a friend of Bob.",
            "If someone works with someone, then they are friends.",
            "Bob works with Carol.",
            "If someone plays a sport with someone, they like that person.",
            "Alice plays soccer with Bob.",
            "If someone has a pet, they know the pet.",
            "Alice has a dog named Sparky.",
            "If someone lives in a city, they know people from that city.",
            "Alice lives in New York."
        ],
        "premises-FOL": [
            "Likes(alice, bob) ::: Alice likes Bob.",
            "Likes(bob, carol) ::: Bob likes Carol.",
            "∀x ∀y (Likes(x, y) → Attends(x, event)) ::: If someone likes someone, they attend the same events.",
            "Attends(alice, event) ∧ Attends(bob, event) ::: Alice and Bob attended the same event.",
            "∀x ∀y (Attends(x, y) ∧ Attends(z, y) → Knows(x, z)) ::: If people attend the same event, they know each other.",
            "∀x ∀y (IsFriendOf(x, y) → Likes(x, y)) ::: If someone is a friend of someone, then they like them.",
            "IsFriendOf(alice, bob) ::: Alice is a friend of Bob.",
            "∀x ∀y (WorksWith(x, y) → IsFriendOf(x, y)) ::: If someone works with someone, then they are friends.",
            "WorksWith(bob, carol) ::: Bob works with Carol.",
            "∀x ∀y (PlaysSport(x, y) → Likes(x, y)) ::: If someone plays a sport with someone, they like that person.",
            "PlaysSport(alice, bob) ::: Alice plays soccer with Bob.",
            "∀x ∀y (HasPet(x, y) → Knows(x, y)) ::: If someone has a pet, they know the pet.",
            "HasPet(alice, sparky) ::: Alice has a dog named Sparky.",
            "∀x ∀y (LivesIn(x, z) → Knows(x, y)) ::: If someone lives in a city, they know people from that city.",
            "LivesIn(alice, new_york) ::: Alice lives in New York."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Knows(x, y) ::: x knows y",
            "Attends(x, y) ::: x attends event y",
            "IsFriendOf(x, y) ::: x is a friend of y",
            "WorksWith(x, y) ::: x works with y",
            "PlaysSport(x, y) ::: x plays sport y",
            "HasPet(x, y) ::: x has pet y",
            "LivesIn(x, y) ::: x lives in y",
            "IsMemberOf(x, y) ::: x is a member of y",
            "ReadsBook(x, y) ::: x reads book y",
            "WritesArticle(x, y) ::: x writes article y",
            "IsAuthorOf(x, y) ::: x is the author of y",
            "Sells(x, y, z) ::: x sells y to z",
            "Buys(x, y, z) ::: x buys y from z",
            "Drives(x, y) ::: x drives y"
        ]
    },
    {
        "premises-NL": [
            "Everyone who drinks coffee also drinks tea.",
            "John drinks coffee.",
            "If John drinks coffee, then John is happy.",
            "If John is happy, then John likes tea.",
            "If John drinks tea, then John is not sad.",
            "Everyone is either happy or sad.",
            "John is not sad.",
            "If John is happy, John likes coffee.",
            "John is a friend of Mary.",
            "Mary drinks either coffee or tea."
        ],
        "premises-FOL": [
            "∀x (Drinks(x, coffee) → Drinks(x, tea)) ::: Everyone who drinks coffee also drinks tea.",
            "Drinks(john, coffee) ::: John drinks coffee.",
            "Drinks(john, coffee) → Happy(john) ::: If John drinks coffee, then John is happy.",
            "Happy(john) → Likes(john, tea) ::: If John is happy, then John likes tea.",
            "Drinks(john, tea) → ¬Sad(john) ::: If John drinks tea, then John is not sad.",
            "∀x (Happy(x) ∨ Sad(x)) ::: Everyone is either happy or sad.",
            "¬Sad(john) ::: John is not sad.",
            "Happy(john) → Likes(john, coffee) ::: If John is happy, John likes coffee.",
            "Friend(john, mary) ::: John is a friend of Mary.",
            "Drinks(mary, coffee) ∨ Drinks(mary, tea) ::: Mary drinks either coffee or tea."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Coffee(x) ::: x is coffee",
            "Tea(x) ::: x is tea",
            "Friend(x, y) ::: x is a friend of y",
            "Drinks(x, y) ::: x drinks y",
            "Happy(x) ::: x is happy",
            "Sad(x) ::: x is sad",
            "Morning(x) ::: x is in the morning",
            "Evening(x) ::: x is in the evening",
            "Sleepy(x) ::: x is sleepy"
        ]
    },
    {
        "premises-NL": [
            "All doctors work at a hospital.",
            "All people who work at a hospital have a medical degree.",
            "Some doctors attend conferences.",
            "Everyone who attends a conference is a researcher.",
            "No researchers have a medical degree.",
            "Anyone who works at a hospital is either a doctor or a nurse.",
            "If someone is a nurse, they do not have a medical degree.",
            "Some doctors do not attend any conference.",
            "Some nurses attend conferences.",
            "Some people are doctors.",
            "All doctors are people.",
            "Someone does not work at a hospital.",
            "Someone does not have a medical degree.",
            "If someone is a doctor, they have a medical degree."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → WorksAtHospital(x)) ::: All doctors work at a hospital.",
            "∀x (WorksAtHospital(x) → HasMedicalDegree(x)) ::: All people who work at a hospital have a medical degree.",
            "∃x (Doctor(x) ∧ AttendsConference(x)) ::: Some doctors attend conferences.",
            "∀x (AttendsConference(x) → Researcher(x)) ::: Everyone who attends a conference is a researcher.",
            "∀x (Researcher(x) → ¬HasMedicalDegree(x)) ::: No researchers have a medical degree.",
            "∀x (WorksAtHospital(x) → (Doctor(x) ∨ Nurse(x))) ::: Anyone who works at a hospital is either a doctor or a nurse.",
            "∀x (Nurse(x) → ¬HasMedicalDegree(x)) ::: If someone is a nurse, they do not have a medical degree.",
            "∃x (Doctor(x) ∧ ¬AttendsConference(x)) ::: Some doctors do not attend any conference.",
            "∃x (Nurse(x) ∧ AttendsConference(x)) ::: Some nurses attend conferences.",
            "∃x Doctor(x) ::: Some people are doctors.",
            "∀x (Doctor(x) → Person(x)) ::: All doctors are people.",
            "∃x ¬WorksAtHospital(x) ::: Someone does not work at a hospital.",
            "∃x ¬HasMedicalDegree(x) ::: Someone does not have a medical degree.",
            "∀x (Doctor(x) → HasMedicalDegree(x)) ::: If someone is a doctor, they have a medical degree."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "HasMedicalDegree(x) ::: x has a medical degree",
            "WorksAtHospital(x) ::: x works at a hospital",
            "AttendsConference(x) ::: x attends a conference",
            "Researcher(x) ::: x is a researcher"
        ]
    },
    {
        "premises-NL": [
            "All engineers have a degree.",
            "Anyone who has a degree studies engineering.",
            "All engineers are employed.",
            "Anyone who attends a meeting works on projects.",
            "All those who manage a team are professionals.",
            "Some engineers are experts.",
            "All experts are engineers.",
            "All engineers write reports.",
            "Anyone who is skilled is an engineer.",
            "All engineers use software.",
            "Anyone who uses software solves problems.",
            "Someone designs things.",
            "Someone is an engineer.",
            "All engineers are skilled.",
            "Anyone who is skilled works on projects.",
            "All those who solves problems are skilled.",
            "Anyone who writes reports is a professional."
        ],
        "premises-FOL": [
            "∀x (Engineer(x) → HasDegree(x)) ::: All engineers have a degree.",
            "∀x (HasDegree(x) → StudiesEngineering(x)) ::: Anyone who has a degree studies engineering.",
            "∀x (Engineer(x) → IsEmployed(x)) ::: All engineers are employed.",
            "∀x (AttendsMeeting(x) → WorksOnProjects(x)) ::: Anyone who attends a meeting works on projects.",
            "∀x (ManagesTeam(x) → Professional(x)) ::: All those who manage a team are professionals.",
            "∃x (Engineer(x) ∧ Expert(x)) ::: Some engineers are experts.",
            "∀x (Expert(x) → Engineer(x)) ::: All experts are engineers.",
            "∀x (Engineer(x) → WritesReports(x)) ::: All engineers write reports.",
            "∀x (IsSkilled(x) → Engineer(x)) ::: Anyone who is skilled is an engineer.",
            "∀x (Engineer(x) → UsesSoftware(x)) ::: All engineers use software.",
            "∀x (UsesSoftware(x) → SolvesProblems(x)) ::: Anyone who uses software solves problems.",
            "∃x∃y Designs(x, y) ::: Someone designs things.",
            "∃x Engineer(x) ::: Someone is an engineer.",
            "∀x (Engineer(x) → IsSkilled(x)) ::: All engineers are skilled.",
            "∀x (IsSkilled(x) → WorksOnProjects(x)) ::: Anyone who is skilled works on projects.",
            "∀x (SolvesProblems(x) → IsSkilled(x)) ::: All those who solves problems are skilled.",
            "∀x (WritesReports(x) → Professional(x)) ::: Anyone who writes reports is a professional."
        ],
        "predicates": [
            "Engineer(x) ::: x is an engineer",
            "WorksOnProjects(x) ::: x works on projects",
            "Professional(x) ::: x is a professional",
            "HasDegree(x) ::: x has a degree",
            "StudiesEngineering(x) ::: x studies engineering",
            "IsEmployed(x) ::: x is employed",
            "AttendsMeeting(x) ::: x attends a meeting",
            "ManagesTeam(x) ::: x manages a team",
            "Expert(x) ::: x is an expert",
            "WritesReports(x) ::: x writes reports",
            "IsSkilled(x) ::: x is skilled",
            "UsesSoftware(x) ::: x uses software",
            "Designs(x,y) ::: x designs y",
            "SolvesProblems(x) ::: x solves problems"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All doctors know medicine.",
            "If someone knows medicine, then they are not ignorant.",
            "Every doctor treats patients.",
            "Some doctors are surgeons.",
            "If a doctor is not ignorant, then they are good at their job.",
            "If someone treats patients, then they are a doctor.",
            "Anyone who knows medicine is specialized in their field.",
            "Anyone who is specialized in their field is not ignorant.",
            "If a doctor is specialized in medicine, they treat patients.",
            "Doctors who are specialized in medicine are not ignorant.",
            "If a doctor is not ignorant, they are a surgeon.",
            "Surgeons treat patients.",
            "If someone is a surgeon, then they know medicine.",
            "If someone is a doctor, then they are not ignorant.",
            "If someone is a surgeon and treats patients, then they are a doctor."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Doctor(x) → KnowsMedicine(x)) ::: All doctors know medicine.",
            "∀x (KnowsMedicine(x) → ¬Ignorant(x)) ::: If someone knows medicine, then they are not ignorant.",
            "∀x (Doctor(x) → TreatsPatients(x)) ::: Every doctor treats patients.",
            "∃x (Doctor(x) ∧ Surgeon(x)) ::: Some doctors are surgeons.",
            "∀x (¬Ignorant(x) → GoodAtJob(x)) ::: If a doctor is not ignorant, then they are good at their job.",
            "∀x (TreatsPatients(x) → Doctor(x)) ::: If someone treats patients, then they are a doctor.",
            "∀x (KnowsMedicine(x) → SpecializedIn(x, Field)) ::: Anyone who knows medicine is specialized in their field.",
            "∀x (SpecializedIn(x, Field) → ¬Ignorant(x)) ::: Anyone who is specialized in their field is not ignorant.",
            "∀x (Doctor(x) ∧ SpecializedIn(x, Medicine) → TreatsPatients(x)) ::: If a doctor is specialized in medicine, they treat patients.",
            "∀x (Doctor(x) ∧ SpecializedIn(x, Medicine) → ¬Ignorant(x)) ::: Doctors who are specialized in medicine are not ignorant.",
            "∀x (¬Ignorant(x) → Surgeon(x)) ::: If a doctor is not ignorant, they are a surgeon.",
            "∀x (Surgeon(x) → TreatsPatients(x)) ::: Surgeons treat patients.",
            "∀x (Surgeon(x) → KnowsMedicine(x)) ::: If someone is a surgeon, then they know medicine.",
            "∀x (Doctor(x) → ¬Ignorant(x)) ::: If someone is a doctor, then they are not ignorant.",
            "∀x (Surgeon(x) ∧ TreatsPatients(x) → Doctor(x)) ::: If someone is a surgeon and treats patients, then they are a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Surgeon(x) ::: x is a surgeon.",
            "KnowsMedicine(x) ::: x knows medicine.",
            "Ignorant(x) ::: x is ignorant.",
            "SpecializedIn(x, y) ::: x is specialized in field y.",
            "TreatsPatients(x) ::: x treats patients."
        ]
    },
    {
        "premises-NL": [
            "Dr. Smith is a doctor.",
            "John is a patient.",
            "Dr. Smith has John as a patient.",
            "If someone is a doctor and has a patient, then they treat their patient.",
            "If someone is a patient, they need help.",
            "John is sick.",
            "If someone is sick, they need help.",
            "If someone is a doctor, then they are in the hospital.",
            "If someone receives care they are treated"
        ],
        "premises-FOL": [
            "Doctor(drSmith) ::: Dr. Smith is a doctor",
            "Patient(john) ::: John is a patient",
            "HasPatient(drSmith, john) ::: Dr. Smith has John as a patient",
            "∀x ∀y (Doctor(x) ∧ HasPatient(x, y) → Treats(x, y)) ::: If someone is a doctor and has a patient, then they treat their patient.",
            "∀x (Patient(x) → NeedsHelp(x)) ::: If someone is a patient, they need help.",
            "IsSick(john) ::: John is sick",
            "∀x (IsSick(x) → NeedsHelp(x)) ::: If someone is sick, they need help.",
            "∀x (Doctor(x) → InHospital(x)) ::: If someone is a doctor, then they are in the hospital",
            "∀x (ReceivesCare(x) → Treated(x)) ::: If someone receives care they are treated"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Patient(x) ::: x is a patient",
            "HasPatient(x, y) ::: x has y as a patient",
            "Treats(x, y) ::: x treats y",
            "InHospital(x) ::: x is in the hospital",
            "NeedsHelp(x) ::: x needs help",
            "IsSick(x) ::: x is sick",
            "ReceivesCare(x) ::: x receives care",
            "AdministersMedication(x, y) ::: x administers medication to y"
        ]
    },
    {
        "premises-NL": [
            "All programmers are smart.",
            "Some smart people write code.",
            "Anyone who writes code enjoys work, or they are not a programmer.",
            "John is a programmer.",
            "Mary is smart.",
            "Mary writes code.",
            "Programmers who write code like their job."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → Smart(x)) ::: All programmers are smart.",
            "∃x (Smart(x) ∧ WritesCode(x)) ::: Some smart people write code.",
            "∀x (WritesCode(x) → (EnjoysWork(x) ∨ ¬Programmer(x))) ::: Anyone who writes code enjoys work, or they are not a programmer.",
            "Programmer(John) ::: John is a programmer.",
            "Smart(Mary) ::: Mary is smart.",
            "WritesCode(Mary) ::: Mary writes code.",
            "∀x ((Programmer(x) ∧ WritesCode(x)) → EnjoysWork(x)) ::: Programmers who write code like their job.",
            "Programmer(John) → Smart(John) ::: If John is a programmer, then he is smart.",
            "Smart(John) ::: John is smart.",
            "WritesCode(John) ∨ ¬Programmer(John) ::: John either writes code or is not a programmer.",
            "¬Programmer(John) ∨ EnjoysWork(John) ::: John either is not a programmer or enjoys his work."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "WritesCode(x) ::: x writes code",
            "EnjoysWork(x) ::: x enjoys work",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All doctors are kind.",
            "Some kind people treat patients.",
            "Anyone who treats patients prescribes medication or is not a doctor.",
            "David is a doctor.",
            "David treats a patient.",
            "David is kind.",
            "Doctors who treat patients prescribes medication.",
            "Doctors who are not kind does not prescribe medication.",
            "All doctors prescribe medication or do not treat patient.",
            "Some doctors are not kind.",
            "Doctors either prescribe medication or do not treat patients.",
            "Every doctor treats patients or does not prescribes medication."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → IsKind(x)) ::: All doctors are kind.",
            "∃x (IsKind(x) ∧ TreatsPatient(x)) ::: Some kind people treat patients.",
            "∀x (TreatsPatient(x) → (PrescribesMedication(x) ∨ ¬Doctor(x))) ::: Anyone who treats patients prescribes medication or is not a doctor.",
            "Doctor(David) ::: David is a doctor.",
            "TreatsPatient(David) ::: David treats a patient.",
            "IsKind(David) ::: David is kind.",
            "∀x ((Doctor(x) ∧ TreatsPatient(x)) → PrescribesMedication(x)) ::: Doctors who treat patients prescribes medication.",
            "∀x ((Doctor(x) ∧ ¬IsKind(x)) → ¬PrescribesMedication(x)) ::: Doctors who are not kind does not prescribe medication.",
            "∀x (Doctor(x) → (PrescribesMedication(x) ∨ ¬TreatsPatient(x))) ::: All doctors prescribe medication or do not treat patient.",
            "∃x (Doctor(x) ∧ ¬IsKind(x)) ::: Some doctors are not kind.",
            "∀x (Doctor(x) → (PrescribesMedication(x) ∨ ¬TreatsPatient(x))) ::: Doctors either prescribe medication or do not treat patients.",
            "∀x (Doctor(x) → (TreatsPatient(x) ∨ ¬PrescribesMedication(x))) ::: Every doctor treats patients or does not prescribes medication."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "TreatsPatient(x) ::: x treats a patient",
            "PrescribesMedication(x) ::: x prescribes medication",
            "IsKind(x) ::: x is kind"
        ]
    },
    {
        "premises-NL": [
            "All scientists publish research.",
            "Some scientists work on a project.",
            "Anyone who works on a project collaborates with others, or they are not a scientist.",
            "Emily is a scientist.",
            "Emily works on a project.",
            "Emily publishes research.",
            "Scientists who works on project collaborates.",
            "If a scientist does not work on a project then he does not collaborate.",
            "Every scientists collaborates or does not work on the project.",
            "Some scientist does not publishes the work.",
            "Every scientist collaborates or does not work on a project.",
            "A scientist either collaborates or does not work on the project.",
            "Some scientists are not smart."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Publishes(x)) ::: All scientists publish research.",
            "∃x (Scientist(x) ∧ WorksOnProject(x)) ::: Some scientists work on a project.",
            "∀x (WorksOnProject(x) → (Collaborates(x) ∨ ¬Scientist(x))) ::: Anyone who works on a project collaborates with others, or they are not a scientist.",
            "Scientist(Emily) ::: Emily is a scientist.",
            "WorksOnProject(Emily) ::: Emily works on a project.",
            "Publishes(Emily) ::: Emily publishes research.",
            "∀x ((Scientist(x) ∧ WorksOnProject(x)) → Collaborates(x)) ::: Scientists who works on project collaborates.",
            "∀x ((Scientist(x) ∧ ¬WorksOnProject(x)) → ¬Collaborates(x)) ::: If a scientist does not work on a project then he does not collaborate.",
            "∀x (Scientist(x) → (Collaborates(x) ∨ ¬WorksOnProject(x))) ::: Every scientists collaborates or does not work on the project.",
            "∃x (Scientist(x) ∧ ¬Publishes(x)) ::: Some scientist does not publishes the work.",
            "∀x (Scientist(x) → (Collaborates(x) ∨ ¬WorksOnProject(x))) ::: Every scientist collaborates or does not work on a project.",
            "∀x (Scientist(x) → (Collaborates(x) ∨ ¬WorksOnProject(x))) ::: A scientist either collaborates or does not work on the project.",
            "∃x (Scientist(x) ∧ ¬Smart(x)) ::: Some scientists are not smart."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "WorksOnProject(x) ::: x works on a project",
            "Collaborates(x) ::: x collaborates with others",
            "Publishes(x) ::: x publishes research"
        ]
    },
    {
        "premises-NL": [
            "All managers communicate effectively.",
            "Some managers assign tasks.",
            "Anyone who assigns tasks provides feedback or is not a manager.",
            "Olivia is a manager.",
            "Olivia assigns tasks.",
            "Olivia communicates effectively.",
            "Managers who assigns tasks provide feedback.",
            "Managers who is not helpful provides feedback.",
            "All managers provide feedback or do not assigns tasks.",
            "Some managers are not helpful.",
            "Every manager provides feedback or not assign tasks.",
            "Managers either provide feedback or do not assign tasks.",
            "Some managers are not smart.",
            "Anyone who provide feedback is helpful or is not a manager."
        ],
        "premises-FOL": [
            "∀x (Manager(x) → Communicates(x)) ::: All managers communicate effectively.",
            "∃x (Manager(x) ∧ AssignsTasks(x)) ::: Some managers assign tasks.",
            "∀x (AssignsTasks(x) → (ProvidesFeedback(x) ∨ ¬Manager(x))) ::: Anyone who assigns tasks provides feedback or is not a manager.",
            "Manager(Olivia) ::: Olivia is a manager.",
            "AssignsTasks(Olivia) ::: Olivia assigns tasks.",
            "Communicates(Olivia) ::: Olivia communicates effectively.",
            "∀x ((Manager(x) ∧ AssignsTasks(x)) → ProvidesFeedback(x)) ::: Managers who assigns tasks provide feedback.",
            "∀x ((Manager(x) ∧ ¬IsHelpful(x)) → ProvidesFeedback(x)) ::: Managers who is not helpful provides feedback.",
            "∀x (Manager(x) → (ProvidesFeedback(x) ∨ ¬AssignsTasks(x))) ::: All managers provide feedback or do not assigns tasks.",
            "∃x (Manager(x) ∧ ¬IsHelpful(x)) ::: Some managers are not helpful.",
            "∀x (Manager(x) → (ProvidesFeedback(x) ∨ ¬AssignsTasks(x))) ::: Every manager provides feedback or not assign tasks.",
            "∀x (Manager(x) → (ProvidesFeedback(x) ∨ ¬AssignsTasks(x))) ::: Managers either provide feedback or do not assign tasks.",
            "∃x (Manager(x) ∧ ¬Smart(x)) ::: Some managers are not smart.",
            "∀x (ProvidesFeedback(x) → (IsHelpful(x) ∨ ¬Manager(x))) ::: Anyone who provide feedback is helpful or is not a manager."
        ],
        "predicates": [
            "Manager(x) ::: x is a manager",
            "AssignsTasks(x) ::: x assigns tasks",
            "ProvidesFeedback(x) ::: x provides feedback",
            "Communicates(x) ::: x communicates effectively",
            "IsHelpful(x) ::: x is helpful"
        ]
    },
    {
        "premises-NL": [
            "Everyone eats apples or bananas.",
            "If someone eats something, they like it.",
            "Anyone who likes apples does not eat bananas.",
            "John eats apples.",
            "John likes apples.",
            "Everyone likes apples or bananas.",
            "John does not eat bananas.",
            "John likes bananas."
        ],
        "premises-FOL": [
            "∀x (Eats(x, Apples) ∨ Eats(x, Bananas)) ::: Everyone eats apples or bananas.",
            "∀x ∀y (Eats(x, y) → Likes(x, y)) ::: If someone eats something, they like it.",
            "∀x (Likes(x, Apples) → ¬ Eats(x, Bananas)) ::: Anyone who likes apples does not eat bananas.",
            "Eats(John, Apples) ::: John eats apples.",
            "Likes(John, Apples) ::: John likes apples.",
            "∀x (Likes(x, Apples) ∨ Likes(x, Bananas)) ::: Everyone likes apples or bananas.",
            "¬ Eats(John, Bananas) ::: John does not eat bananas.",
            "Likes(John, Bananas) ::: John likes bananas."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y.",
            "Eats(x, y) ::: x eats y."
        ]
    },
    {
        "premises-NL": [
            "All doctors are smart.",
            "All smart people are tall or healthy.",
            "If someone is a doctor, then they are healthy or tall.",
            "If someone is a doctor, then they are smart.",
            "All healthy people are smart.",
            "John is a doctor.",
            "John is smart.",
            "John is tall or healthy.",
            "All doctors are healthy or tall."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Smart(x)) ::: All doctors are smart.",
            "∀x (Smart(x) → (Tall(x) ∨ Healthy(x))) ::: All smart people are tall or healthy.",
            "∀x (Doctor(x) → (Healthy(x) ∨ Tall(x))) ::: If someone is a doctor, then they are healthy or tall.",
            "∀x (Doctor(x) → Smart(x)) ::: If someone is a doctor, then they are smart.",
            "∀x (Healthy(x) → Smart(x)) ::: All healthy people are smart.",
            "Doctor(John) ::: John is a doctor.",
            "Smart(John) ::: John is smart.",
            "Tall(John) ∨ Healthy(John) ::: John is tall or healthy.",
            "∀x (Doctor(x) → (Healthy(x) ∨ Tall(x))) ::: All doctors are healthy or tall."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Tall(x) ::: x is tall.",
            "Healthy(x) ::: x is healthy.",
            "Smart(x) ::: x is smart."
        ]
    },
    {
        "premises-NL": [
            "No biologist studies economics.",
            "All biologists are interested in biology.",
            "Anyone who is interested in biology studies it.",
            "John is a biologist.",
            "If someone is interested in something, they study it.",
            "No economist is a biologist.",
            "All biologists are either scientists or doctors.",
            "John is interested in biology.",
            "John studies biology.",
            "John does not study economics."
        ],
        "premises-FOL": [
            "∀x (Biologist(x) → ¬Studies(x, Economics)) ::: No biologist studies economics.",
            "∀x (Biologist(x) → InterestedIn(x, Biology)) ::: All biologists are interested in biology.",
            "∀x (InterestedIn(x, Biology) → Studies(x, Biology)) ::: Anyone who is interested in biology studies it.",
            "Biologist(John) ::: John is a biologist.",
            "∀x ∀y (InterestedIn(x, y) → Studies(x, y)) ::: If someone is interested in something, they study it.",
            "∀x (Economist(x) → ¬Biologist(x)) ::: No economist is a biologist.",
            "∀x (Biologist(x) → (Scientist(x) ∨ Doctor(x))) ::: All biologists are either scientists or doctors.",
            "InterestedIn(John, Biology) ::: John is interested in biology.",
            "Studies(John, Biology) ::: John studies biology.",
            "¬Studies(John, Economics) ::: John does not study economics."
        ],
        "predicates": [
            "Biologist(x) ::: x is a biologist.",
            "Studies(x, y) ::: x studies y.",
            "Economist(x) ::: x is an economist.",
            "InterestedIn(x, y) ::: x is interested in y."
        ]
    },
    {
        "premises-NL": [
            "Anyone who studies computer science is smart.",
            "All students work hard.",
            "If someone is a student and studies computer science, then they work hard.",
            "Anyone who is smart is not a doctor.",
            "John is a student.",
            "John studies computer science.",
            "John is smart.",
            "John works hard.",
            "John is not a doctor.",
            "Anyone who works hard is not a doctor or a lazy person.",
            "All doctors are smart.",
            "If someone is a doctor, they are smart."
        ],
        "premises-FOL": [
            "∀x (Studies(x, ComputerScience) → Smart(x)) ::: Anyone who studies computer science is smart.",
            "∀x (Student(x) → WorksHard(x)) ::: All students work hard.",
            "∀x ((Student(x) ∧ Studies(x, ComputerScience)) → WorksHard(x)) ::: If someone is a student and studies computer science, then they work hard.",
            "∀x (Smart(x) → ¬Doctor(x)) ::: Anyone who is smart is not a doctor.",
            "Student(John) ::: John is a student.",
            "Studies(John, ComputerScience) ::: John studies computer science.",
            "Smart(John) ::: John is smart.",
            "WorksHard(John) ::: John works hard.",
            "¬Doctor(John) ::: John is not a doctor.",
            "∀x (WorksHard(x) → (¬Doctor(x) ∨ ¬Lazy(x))) ::: Anyone who works hard is not a doctor or a lazy person.",
            "∀x (Doctor(x) → Smart(x)) ::: All doctors are smart.",
            "∀x (Doctor(x) → Smart(x)) ::: If someone is a doctor, they are smart."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Studies(x, y) ::: x studies y.",
            "Doctor(x) ::: x is a doctor.",
            "Smart(x) ::: x is smart.",
            "WorksHard(x) ::: x works hard."
        ]
    },
    {
        "premises-NL": [
            "All non-smokers are healthy.",
            "John is a non-smoker.",
            "Mary is not a smoker.",
            "John and Mary are individuals."
        ],
        "premises-FOL": [
            "∀x (¬Smoker(x) → Healthy(x)) ::: All non-smokers are healthy.",
            "¬Smoker(john) ::: John is a non-smoker.",
            "¬Smoker(mary) ::: Mary is not a smoker.",
            "(Healthy(john) ∧ Healthy(mary)) ::: John and Mary are individuals."
        ],
        "predicates": [
            "Healthy(x) ::: x is healthy.",
            "Smoker(x) ::: x is a smoker."
        ]
    },
    {
        "premises-NL": [
            "All students attend either seminars or lectures.",
            "Some students attend seminars.",
            "Some students attend lectures.",
            "John is a student.",
            "Mary is a student.",
            "John attends seminars.",
            "Mary attends lectures.",
            "John and Mary attend some classes."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (SeminarAttends(x) ∨ LectureAttends(x))) ::: All students attend either seminars or lectures.",
            "∃x (Student(x) ∧ SeminarAttends(x)) ::: Some students attend seminars.",
            "∃x (Student(x) ∧ LectureAttends(x)) ::: Some students attend lectures.",
            "Student(john) ::: John is a student.",
            "Student(mary) ::: Mary is a student.",
            "SeminarAttends(john) ::: John attends seminars.",
            "LectureAttends(mary) ::: Mary attends lectures.",
            "SeminarAttends(john) ∨ LectureAttends(mary) ::: John and Mary attend some classes."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "SeminarAttends(x) ::: x attends seminars.",
            "LectureAttends(x) ::: x attends lectures."
        ]
    },
    {
        "premises-NL": [
            "All students who study hard pass the exam.",
            "Anyone who passes the exam gets good grades.",
            "If a student attends all classes, they will not miss classes.",
            "Some students study hard.",
            "Some students do not get good grades.",
            "Anyone who has homework will not pass the exam.",
            "If a student has homework, they study hard.",
            "John is a student and studies hard.",
            "Mary is a student.",
            "Mary has homework.",
            "John attends all classes.",
            "Mary does not attend all classes.",
            "If a student misses classes they will not pass the exam.",
            "Some students have homework."
        ],
        "premises-FOL": [
            "∀x ((Student(x) ∧ StudiesHard(x)) → PassesExam(x)) ::: All students who study hard pass the exam.",
            "∀x (PassesExam(x) → GetsGoodGrades(x)) ::: Anyone who passes the exam gets good grades.",
            "∀x ((Student(x) ∧ AttendsClasses(x)) → ¬MissesClasses(x)) ::: If a student attends all classes, they will not miss classes.",
            "∃x (Student(x) ∧ StudiesHard(x)) ::: Some students study hard.",
            "∃x (Student(x) ∧ ¬GetsGoodGrades(x)) ::: Some students do not get good grades.",
            "∀x (HasHomework(x) → ¬PassesExam(x)) ::: Anyone who has homework will not pass the exam.",
            "∀x (HasHomework(x) → StudiesHard(x)) ::: If a student has homework, they study hard.",
            "(Student(john) ∧ StudiesHard(john)) ::: John is a student and studies hard.",
            "Student(mary) ::: Mary is a student.",
            "HasHomework(mary) ::: Mary has homework.",
            "AttendsClasses(john) ::: John attends all classes.",
            "¬AttendsClasses(mary) ::: Mary does not attend all classes.",
            "∀x ((Student(x) ∧ MissesClasses(x)) → ¬PassesExam(x)) ::: If a student misses classes they will not pass the exam.",
            "∃x (Student(x) ∧ HasHomework(x)) ::: Some students have homework."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesHard(x) ::: x studies hard.",
            "AttendsClasses(x) ::: x attends all classes.",
            "GetsGoodGrades(x) ::: x gets good grades.",
            "HasHomework(x) ::: x has homework.",
            "MissesClasses(x) ::: x misses classes.",
            "PassesExam(x) ::: x passes the exam."
        ]
    },
    {
        "premises-NL": [
            "All people are either healthy or have a disease.",
            "Some people are not healthy."
        ],
        "premises-FOL": [
            "∀x (Person(x) → (Healthy(x) ∨ HasDisease(x))) ::: For all x, if x is a person, then x is healthy or has a disease.",
            "∃x (Person(x) ∧ ¬Healthy(x)) ::: There exists someone who is a person and is not healthy."
        ],
        "predicates": [
            "Healthy(x) ::: x is healthy",
            "HasDisease(x) ::: x has a disease"
        ]
    },
    {
        "premises-NL": [
            "All students like coffee.",
            "David is a student.",
            "Everyone who likes coffee attends a lecture.",
            "David attends a lecture.",
            "If someone attends a lecture, then they study."
        ],
        "premises-FOL": [
            "∀x (Student(x) → LikesCoffee(x)) ::: All students like coffee.",
            "Student(david) ::: David is a student.",
            "∀x (LikesCoffee(x) → AttendsLecture(x)) ::: Everyone who likes coffee attends a lecture.",
            "AttendsLecture(david) ::: David attends a lecture.",
            "∀x (AttendsLecture(x) → Studies(x)) ::: If someone attends a lecture, then they study."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "LikesCoffee(x) ::: x likes coffee",
            "AttendsLecture(x) ::: x attends a lecture"
        ]
    },
    {
        "premises-NL": [
            "All doctors have a medical degree.",
            "Sarah has a medical degree.",
            "Everyone who has a medical degree is employed.",
            "Sarah is a doctor.",
            "All doctors specialize in something.",
            "If someone specializes in surgery, they work at a hospital."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HasDegree(x, medical)) ::: All doctors have a medical degree.",
            "HasDegree(sarah, medical) ::: Sarah has a medical degree.",
            "∀x (HasDegree(x, medical) → Employed(x)) ::: Everyone who has a medical degree is employed.",
            "Doctor(sarah) ::: Sarah is a doctor.",
            "∀x ∃y SpecializesIn(x, y) ::: All doctors specialize in something.",
            "∀x ∀y (SpecializesIn(x, surgery) → WorksAt(x, hospital)) ::: If someone specializes in surgery, they work at a hospital."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Employed(x) ::: x is employed",
            "HasDegree(x, y) ::: x has a degree in y",
            "SpecializesIn(x, y) ::: x specializes in y",
            "WorksAt(x, y) ::: x works at y"
        ]
    },
    {
        "premises-NL": [
            "Everyone who is rich owns a car.",
            "Everyone who is rich owns a house.",
            "If someone works hard and saves money, they are rich.",
            "Someone works hard.",
            "Someone saves money.",
            "If someone is smart they work hard.",
            "If someone is smart, then they save money."
        ],
        "premises-FOL": [
            "∀x (IsRich(x) → Owns(x, car)) ::: Everyone who is rich owns a car.",
            "∀x (IsRich(x) → Owns(x, house)) ::: Everyone who is rich owns a house.",
            "∀x ((WorksHard(x) ∧ SavesMoney(x)) → IsRich(x)) ::: If someone works hard and saves money, they are rich.",
            "∃x WorksHard(x) ::: Someone works hard.",
            "∃x SavesMoney(x) ::: Someone saves money.",
            "∀x (IsSmart(x) → WorksHard(x)) ::: If someone is smart they work hard.",
            "∀x (IsSmart(x) → SavesMoney(x)) ::: If someone is smart, then they save money."
        ],
        "predicates": [
            "Owns(x, y) ::: x owns y",
            "IsRich(x) ::: x is rich",
            "HasCar(x) ::: x has a car",
            "HasHouse(x) ::: x has a house",
            "WorksHard(x) ::: x works hard",
            "SavesMoney(x) ::: x saves money",
            "IsSmart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All products are either defective or usable.",
            "Defective products need repair.",
            "If a product needs repair, it is not usable.",
            "All high-quality products are not defective.",
            "Some products are high quality.",
            "Product A is produced by Company X.",
            "Product A has warranty.",
            "If a product has warranty and is not defective then is usable."
        ],
        "premises-FOL": [
            "∀x (Defective(x) ∨ Usable(x)) ::: All products are either defective or usable.",
            "∀x (Defective(x) → NeedsRepair(x)) ::: Defective products need repair.",
            "∀x (NeedsRepair(x) → ¬Usable(x)) ::: If a product needs repair, it is not usable.",
            "∀x (HighQuality(x) → ¬Defective(x)) ::: All high-quality products are not defective.",
            "∃x HighQuality(x) ::: Some products are high quality.",
            "ProducedBy(productA, companyX) ::: Product A is produced by Company X.",
            "HasWarranty(productA) ::: Product A has warranty.",
            "∀x ((HasWarranty(x) ∧ ¬Defective(x)) → Usable(x)) ::: If a product has warranty and is not defective then is usable."
        ],
        "predicates": [
            "Defective(x) ::: x is defective",
            "Usable(x) ::: x is usable",
            "ProducedBy(x, y) ::: x is produced by y",
            "HighQuality(x) ::: x is of high quality",
            "NeedsRepair(x) ::: x needs repair",
            "SoldBy(x, y) ::: x is sold by y",
            "HasWarranty(x) ::: x has warranty",
            "PurchasedBy(x, y) ::: x is purchased by y"
        ]
    },
    {
        "premises-NL": [
            "If someone is a friend of Mary, then Mary is a friend of them.",
            "John is a friend of Mary.",
            "If someone is a friend of Mary, then they like what Mary likes.",
            "Mary likes art.",
            "If someone likes art, they enjoy art.",
            "If someone enjoys art, they are happy.",
            "If someone is happy, then they are kind.",
            "If someone is kind and likes art, then they have a pet.",
            "If someone likes art and has a pet, then they like art."
        ],
        "premises-FOL": [
            "∀x (FriendOf(x, mary) → FriendOf(mary, x)) ::: If someone is a friend of Mary, then Mary is a friend of them.",
            "FriendOf(john, mary) ::: John is a friend of Mary.",
            "∀x (FriendOf(x, mary) → Likes(x, y)) ::: If someone is a friend of Mary, then they like what Mary likes.",
            "Likes(mary, art) ::: Mary likes art.",
            "∀x (Likes(x, art) → Enjoys(x, art)) ::: If someone likes art, they enjoy art.",
            "∀x (Enjoys(x, art) → IsHappy(x)) ::: If someone enjoys art, they are happy.",
            "∀x (IsHappy(x) → IsKind(x)) ::: If someone is happy, then they are kind.",
            "∀x (IsKind(x) ∧ Likes(x, art) → HasPet(x)) ::: If someone is kind and likes art, then they have a pet.",
            "∀x (Likes(x, art) ∧ HasPet(x) → Likes(x, art)) ::: If someone likes art and has a pet, then they like art."
        ],
        "predicates": [
            "FriendOf(x, y) ::: x is a friend of y",
            "Likes(x, y) ::: x likes y",
            "Enjoys(x, y) ::: x enjoys y",
            "Studies(x, y) ::: x studies y",
            "GoesTo(x, y) ::: x goes to y",
            "IsHappy(x) ::: x is happy",
            "Owns(x, y) ::: x owns y",
            "IsKind(x) ::: x is kind",
            "HasPet(x) ::: x has a pet"
        ]
    },
    {
        "premises-NL": [
            "All mammals are animals.",
            "All mammals are either land animals or water animals, but not both.",
            "If something is a land animal, it is not a water animal.",
            "If something is a mammal, it can't fly.",
            "No land animal can fly.",
            "If an animal is not a mammal, it might be land animal.",
            "Some animals are mammals.",
            "Some animal is a land animal.",
            "If something is an animal, it is either a mammal or not a mammal.",
            "If an animal is not a land animal, it is a water animal or can fly."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → IsAnimal(x)) ::: All mammals are animals.",
            "∀x (Mammal(x) → (LandAnimal(x) ⊕ WaterAnimal(x))) ::: All mammals are either land animals or water animals, but not both.",
            "∀x (LandAnimal(x) → ¬WaterAnimal(x)) ::: If something is a land animal, it is not a water animal.",
            "∀x (Mammal(x) → ¬CanFly(x)) ::: If something is a mammal, it can't fly.",
            "∀x (LandAnimal(x) → ¬CanFly(x)) ::: No land animal can fly.",
            "∀x (¬Mammal(x) → (LandAnimal(x) ∨ WaterAnimal(x))) ::: If an animal is not a mammal, it might be land animal.",
            "∃x Mammal(x) ::: Some animals are mammals.",
            "∃x LandAnimal(x) ::: Some animal is a land animal.",
            "∀x (IsAnimal(x) → (Mammal(x) ∨ ¬Mammal(x))) ::: If something is an animal, it is either a mammal or not a mammal.",
            "∀x (IsAnimal(x) ∧ ¬LandAnimal(x) → (WaterAnimal(x) ∨ CanFly(x))) ::: If an animal is not a land animal, it is a water animal or can fly."
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal.",
            "LandAnimal(x) ::: x is a land animal.",
            "WaterAnimal(x) ::: x is a water animal.",
            "CanFly(x) ::: x can fly.",
            "IsAnimal(x) ::: x is an animal."
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "Anyone who is a surgeon is a medical specialist.",
            "Every doctor who works at the hospital is a hospital employee.",
            "Anyone who is a hospital employee is a healthcare professional.",
            "Some doctors are surgeons.",
            "Dr. Smith is a doctor.",
            "Dr. Smith works at a hospital.",
            "Dr. Smith is a specialist."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Surgeon(x) → Specialist(x)) ::: Anyone who is a surgeon is a medical specialist.",
            "∀x (Doctor(x) ∧ WorksAtHospital(x) → HospitalEmployee(x)) ::: Every doctor who works at the hospital is a hospital employee.",
            "∀x (HospitalEmployee(x) → HealthcareProfessional(x)) ::: Anyone who is a hospital employee is a healthcare professional.",
            "∃x (Doctor(x) ∧ Surgeon(x)) ::: Some doctors are surgeons.",
            "Doctor(smith) ::: Dr. Smith is a doctor.",
            "WorksAtHospital(smith) ::: Dr. Smith works at a hospital.",
            "Specialist(smith) ::: Dr. Smith is a specialist."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "WorksAtHospital(x) ::: x works at a hospital.",
            "HealthcareProfessional(x) ::: x is a healthcare professional.",
            "Surgeon(x) ::: x is a surgeon.",
            "HospitalEmployee(x) ::: x is an employee of the hospital.",
            "Specialist(x) ::: x is a medical specialist."
        ]
    },
    {
        "premises-NL": [
            "All students who study hard and attend classes will receive good grades.",
            "Students who receive good grades will pass the exam.",
            "If a student is enrolled in a course and attends all lectures, they are attending classes.",
            "John is a student and studies hard.",
            "John is enrolled in the course 'Logic 101'.",
            "John attends all lectures of Logic 101.",
            "If a student understands the material, they will receive good grades.",
            "If a student likes the professor they will attend lectures",
            "John likes the professor of 'Logic 101'."
        ],
        "premises-FOL": [
            "∀x ((Student(x) ∧ StudiesHard(x) ∧ AttendsClasses(x)) → ReceivesGoodGrades(x)) ::: All students who study hard and attend classes will receive good grades.",
            "∀x (ReceivesGoodGrades(x) → PassesExam(x)) ::: Students who receive good grades will pass the exam.",
            "∀x ∀y (EnrolledInCourse(x, y) ∧ AttendsLecture(x, y) → AttendsClasses(x)) ::: If a student is enrolled in a course and attends all lectures, they are attending classes.",
            "Student(john) ∧ StudiesHard(john) ::: John is a student and studies hard.",
            "EnrolledInCourse(john, 'Logic 101') ::: John is enrolled in the course 'Logic 101'.",
            "AttendsLecture(john, 'Logic 101') ::: John attends all lectures of Logic 101.",
            "∀x (UnderstandsMaterial(x) → ReceivesGoodGrades(x)) ::: If a student understands the material, they will receive good grades.",
            "∀x ∀y (LikesProfessor(x,y) → AttendsLecture(x,y)) ::: If a student likes the professor they will attend lectures",
            "LikesProfessor(john, 'Logic 101') ::: John likes the professor of 'Logic 101'."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesHard(x) ::: x studies hard.",
            "AttendsClasses(x) ::: x attends classes.",
            "PassesExam(x) ::: x passes the exam.",
            "ReceivesGoodGrades(x) ::: x receives good grades.",
            "EnrolledInCourse(x, y) ::: x is enrolled in course y.",
            "AttendsLecture(x, y) ::: x attends lecture y.",
            "UnderstandsMaterial(x) ::: x understands the material.",
            "LikesProfessor(x,y) ::: x likes the professor y."
        ]
    },
    {
        "premises-NL": [
            "All scientists who receive grants publish research.",
            "Scientists who work at a university conduct experiments.",
            "Anyone who conducts experiments and uses equipment publishes research.",
            "If someone teaches students, then they are a scientist.",
            "Some scientists specialize in biology.",
            "If a scientist specializes in biology and reads articles, they conduct experiments.",
            "Dr. Smith is a scientist and receives a grant.",
            "Dr. Smith works at a university.",
            "Dr. Smith teaches students.",
            "All people who publish research contribute to science."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) ∧ ReceivesGrant(x) → PublishesResearch(x)) ::: All scientists who receive grants publish research.",
            "∀x (Scientist(x) ∧ WorksAtUniversity(x) → ConductsExperiments(x)) ::: Scientists who work at a university conduct experiments.",
            "∀x ∀z (ConductsExperiments(x) ∧ UsesEquipment(x, z) → PublishesResearch(x)) ::: Anyone who conducts experiments and uses equipment publishes research.",
            "∀x (TeachesStudents(x) → Scientist(x)) ::: If someone teaches students, then they are a scientist.",
            "∃x (Scientist(x) ∧ SpecializesIn(x, 'Biology')) ::: Some scientists specialize in biology.",
            "∀x (Scientist(x) ∧ SpecializesIn(x, 'Biology') ∧ ReadsArticles(x) → ConductsExperiments(x)) ::: If a scientist specializes in biology and reads articles, they conduct experiments.",
            "Scientist(smith) ∧ ReceivesGrant(smith) ::: Dr. Smith is a scientist and receives a grant.",
            "WorksAtUniversity(smith) ::: Dr. Smith works at a university.",
            "TeachesStudents(smith) ::: Dr. Smith teaches students.",
            "∀x (PublishesResearch(x) → ContributesToScience(x)) ::: All people who publish research contribute to science."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist.",
            "PublishesResearch(x) ::: x publishes research.",
            "ContributesToScience(x) ::: x contributes to the field of science.",
            "ReceivesGrant(x) ::: x receives a grant.",
            "WorksAtUniversity(x) ::: x works at a university.",
            "TeachesStudents(x) ::: x teaches students.",
            "ConductsExperiments(x) ::: x conducts experiments.",
            "SpecializesIn(x, y) ::: x specializes in y.",
            "UsesEquipment(x, z) ::: x uses equipment z.",
            "ReadsArticles(x) ::: x reads articles."
        ]
    },
    {
        "premises-NL": [
            "Companies that invest in green energy and use renewable resources reduce their carbon footprint.",
            "Companies that implement sustainable practices and employ eco-friendly methods will reduce their carbon footprint.",
            "Companies that reduce their carbon footprint and adopt a circular economy improve their public image.",
            "A company that collaborates with an NGO is implementing sustainable practices.",
            "Company A invests in green energy and uses renewable resources.",
            "Company A employs eco-friendly methods.",
            "Company B generates waste and does not adopt circular economy.",
            "If a company has a high profit it invests in green energy and implements sustainable practices.",
            "Company C collaborates with an NGO.",
            "All companies that improves their public image have high profit.",
            "If a company does not reduce its carbon footprint, it does not improve its public image."
        ],
        "premises-FOL": [
            "∀x (Company(x) ∧ InvestsInGreenEnergy(x) ∧ UsesRenewableResources(x) → ReducesCarbonFootprint(x)) ::: Companies that invest in green energy and use renewable resources reduce their carbon footprint.",
            "∀x (Company(x) ∧ ImplementsSustainablePractices(x) ∧ EmployEcoFriendlyMethods(x) → ReducesCarbonFootprint(x)) ::: Companies that implement sustainable practices and employ eco-friendly methods will reduce their carbon footprint.",
            "∀x (Company(x) ∧ ReducesCarbonFootprint(x) ∧ AdoptsCircularEconomy(x) → ImprovesPublicImage(x)) ::: Companies that reduce their carbon footprint and adopt a circular economy improve their public image.",
            "∀x (Company(x) ∧ CollaboratesWithNGO(x) → ImplementsSustainablePractices(x)) ::: A company that collaborates with an NGO is implementing sustainable practices.",
            "InvestsInGreenEnergy(companyA) ∧ UsesRenewableResources(companyA) ::: Company A invests in green energy and uses renewable resources.",
            "EmployEcoFriendlyMethods(companyA) ::: Company A employs eco-friendly methods.",
            "GeneratesWaste(companyB) ∧ ¬AdoptsCircularEconomy(companyB) ::: Company B generates waste and does not adopt circular economy.",
            "∀x (Company(x) ∧ HasHighProfit(x) → InvestsInGreenEnergy(x) ∧ ImplementsSustainablePractices(x)) ::: If a company has a high profit it invests in green energy and implements sustainable practices.",
            "CollaboratesWithNGO(companyC) ::: Company C collaborates with an NGO.",
            "∀x (Company(x) ∧ ImprovesPublicImage(x) → HasHighProfit(x)) ::: All companies that improves their public image have high profit.",
            "∀x (¬ReducesCarbonFootprint(x) → ¬ImprovesPublicImage(x)) ::: If a company does not reduce its carbon footprint, it does not improve its public image."
        ],
        "predicates": [
            "Company(x) ::: x is a company.",
            "InvestsInGreenEnergy(x) ::: x invests in green energy.",
            "ImplementsSustainablePractices(x) ::: x implements sustainable practices.",
            "ReducesCarbonFootprint(x) ::: x reduces its carbon footprint.",
            "ImprovesPublicImage(x) ::: x improves its public image.",
            "UsesRenewableResources(x) ::: x uses renewable resources.",
            "EmploysEcoFriendlyMethods(x) ::: x employs eco-friendly methods.",
            "GeneratesWaste(x) ::: x generates waste.",
            "AdoptsCircularEconomy(x) ::: x adopts a circular economy.",
            "CollaboratesWithNGO(x) ::: x collaborates with an NGO.",
            "HasHighProfit(x) ::: x has high profit."
        ]
    },
    {
        "premises-NL": [
            "All students are diligent.",
            "Some students pass the exam.",
            "If someone is a student and diligent, then they are a diligent student.",
            "If someone is a student, they are diligent or they are not diligent.",
            "If someone passes the exam, they are a student or they are not a student.",
            "If someone is a student and they pass the exam, then someone is a student and they pass the exam.",
            "If something is a student and something is diligent, then something is a diligent student.",
            "If someone is not a student, they do not pass the exam.",
            "If someone is a student, then they are not a diligent student or they are not passing the exam.",
            "If someone is diligent, then they are diligent."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Diligant(x)) ::: All students are diligent",
            "∃x (Student(x) ∧ PassExam(x)) ::: Some students pass the exam",
            "∀x ∀y ((Student(x) ∧ Diligant(x)) → DiligantStudent(y)) ::: If someone is a student and diligent, then they are a diligent student",
            "∀x (Student(x) → (Diligant(x) ∨ ¬Diligant(x))) ::: If someone is a student, they are diligent or they are not diligent",
            "∀x (PassExam(x) → (Student(x) ∨ ¬Student(x))) ::: If someone passes the exam, they are a student or they are not a student",
            "∀x ((Student(x) ∧ PassExam(x)) → (Student(x) ∧ PassExam(x))) ::: If someone is a student and they pass the exam, then someone is a student and they pass the exam",
            "∀x ∀y ((Student(x) ∧ Diligant(y)) → DiligantStudent(y)) ::: If something is a student and something is diligent, then something is a diligent student",
            "∀x (¬Student(x) → ¬PassExam(x)) ::: If someone is not a student, they do not pass the exam",
            "∀x (Student(x) → (¬DiligantStudent(x) ∨ ¬PassExam(x))) ::: If someone is a student, then they are not a diligent student or they are not passing the exam",
            "∀x (Diligant(x) → Diligant(x)) ::: If someone is diligent, then they are diligent"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Diligant(x) ::: x is diligent",
            "PassExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "Every doctor treats a patient.",
            "Some doctors are specialists.",
            "If someone is a specialist and treats someone, then that someone is a specialist and treats that someone.",
            "If someone is a doctor and treats someone, then that someone is a doctor and treats that someone.",
            "If someone is a specialist and treats someone, then that someone is a doctor or treats someone.",
            "If someone is a patient, then someone is a patient.",
            "If someone is a doctor, then someone is a doctor.",
            "If someone is a doctor and not a specialist, then someone is a doctor or treats someone.",
            "If someone is a specialist, that person is a doctor.",
            "If a specialist treats someone, the specialist is a doctor.",
            "If a patient is treated, the patient is treated.",
            "If something is a doctor and a specialist, the doctor is a specialist."
        ],
        "premises-FOL": [
            "∀x ∃y (Doctor(x) → Treats(x, y)) ::: Every doctor treats a patient",
            "∃x (Doctor(x) ∧ Specialist(x)) ::: Some doctors are specialists",
            "∀x ∀y ((Specialist(x) ∧ Treats(x, y)) → (Specialist(x) ∧ Treats(x, y))) ::: If someone is a specialist and treats someone, then that someone is a specialist and treats that someone",
            "∀x ∀y ((Doctor(x) ∧ Treats(x, y)) → (Doctor(x) ∧ Treats(x, y))) ::: If someone is a doctor and treats someone, then that someone is a doctor and treats that someone",
            "∀x ∀y ((Specialist(x) ∧ Treats(x, y)) → (Doctor(x) ∨ Treats(x, y))) ::: If someone is a specialist and treats someone, then that someone is a doctor or treats someone",
            "∀x (Patient(x) → Patient(x)) ::: If someone is a patient, then someone is a patient",
            "∀x (Doctor(x) → Doctor(x)) ::: If someone is a doctor, then someone is a doctor",
            "∀x ∀y ((Doctor(x) ∧ ¬Specialist(x)) → (Doctor(x) ∨ Treats(x, y))) ::: If someone is a doctor and not a specialist, then someone is a doctor or treats someone",
            "∀x (Specialist(x) → Doctor(x)) ::: If someone is a specialist, that person is a doctor",
            "∀x ∀y (Specialist(x) ∧ Treats(x, y) → Doctor(x)) ::: If a specialist treats someone, the specialist is a doctor",
            "∀x (Treats(x, y) → Treats(x, y)) ::: If a patient is treated, the patient is treated",
            "∀x ∀y ((Doctor(x) ∧ Specialist(x)) → Specialist(x)) ::: If something is a doctor and a specialist, the doctor is a specialist"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Patient(y) ::: y is a patient",
            "Treats(x, y) ::: x treats y",
            "Specialist(x) ::: x is a specialist"
        ]
    },
    {
        "premises-NL": [
            "All cats chase mice.",
            "Some animals are cats.",
            "If something is a cat, that thing is an animal.",
            "If something is an animal, that thing is not a cat or it is a cat.",
            "If something is a mouse and chased by a cat, then that mouse is a mouse.",
            "If someone is a cat and chases a mouse, that is chasing the mouse.",
            "If someone is a cat and chases a mouse, then that is not a mouse or chased.",
            "If something is a cat and chased a mouse, then it is a cat.",
            "If something chases a mouse, that is not a mouse or is chased.",
            "If someone is an animal, they chase a mouse or they do not chase a mouse.",
            "If something is a cat and chased a mouse, then it is not a mouse or is a cat.",
            "If something chases something else, it chases.",
            "If something chases a mouse, it is an animal."
        ],
        "premises-FOL": [
            "∀x ∃y (Cat(x) → Chases(x, y)) ::: All cats chase mice",
            "∃x (Animal(x) ∧ Cat(x)) ::: Some animals are cats",
            "∀x (Cat(x) → Animal(x)) ::: If something is a cat, that thing is an animal",
            "∀x (Animal(x) → (¬Cat(x) ∨ Cat(x))) ::: If something is an animal, that thing is not a cat or it is a cat",
            "∀x ∀y ((Mouse(y) ∧ Chases(x, y)) → Mouse(y)) ::: If something is a mouse and chased by a cat, then that mouse is a mouse",
            "∀x ∀y ((Cat(x) ∧ Chases(x, y)) → Chases(x, y)) ::: If someone is a cat and chases a mouse, that is chasing the mouse",
            "∀x ∀y ((Cat(x) ∧ Chases(x, y)) → (¬Mouse(y) ∨ Chases(x, y))) ::: If someone is a cat and chases a mouse, then that is not a mouse or chased",
            "∀x ∀y ((Cat(x) ∧ Chases(x, y)) → Cat(x)) ::: If something is a cat and chased a mouse, then it is a cat",
            "∀x ∀y (Chases(x, y) → (¬Mouse(y) ∨ Chases(x, y))) ::: If something chases a mouse, that is not a mouse or is chased",
            "∀x (Animal(x) → (Chases(x, y) ∨ ¬Chases(x, y))) ::: If someone is an animal, they chase a mouse or they do not chase a mouse",
            "∀x ∀y ((Cat(x) ∧ Chases(x, y)) → (¬Mouse(y) ∨ Cat(x))) ::: If something is a cat and chased a mouse, then it is not a mouse or is a cat",
            "∀x ∀y (Chases(x, y) → Chases(x, y)) ::: If something chases something else, it chases",
            "∀x ∃y (Chases(x, y) → Animal(x)) ::: If something chases a mouse, it is an animal"
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Mouse(y) ::: y is a mouse",
            "Chases(x, y) ::: x chases y",
            "Animal(x) ::: x is an animal"
        ]
    },
    {
        "premises-NL": [
            "All programmers use computers.",
            "Some people are programmers.",
            "All programmers write code.",
            "If someone writes code, then they are a person or write code.",
            "If someone writes code, then they are not a person or they write code.",
            "If someone is a person and writes code, then that person writes code.",
            "If someone is a programmer and uses a computer, then that person writes code.",
            "If someone uses a computer, then that person writes code.",
            "If someone is a programmer, they write code or do not write code.",
            "If someone writes code, then that is writing code.",
            "If someone writes code, then they are a person and write code.",
            "If someone is a person, they write code or do not write code.",
            "If someone is a person and writes code, they are writing code.",
            "If someone is a programmer, then that person is writing code."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → UsesComputer(x)) ::: All programmers use computers",
            "∃x (Person(x) ∧ Programmer(x)) ::: Some people are programmers",
            "∀x (Programmer(x) → WritesCode(x)) ::: All programmers write code",
            "∀x (WritesCode(x) → (Person(x) ∨ WritesCode(x))) ::: If someone writes code, then they are a person or write code",
            "∀x (WritesCode(x) → (¬Person(x) ∨ WritesCode(x))) ::: If someone writes code, then they are not a person or they write code",
            "∀x ((Person(x) ∧ WritesCode(x)) → WritesCode(x)) ::: If someone is a person and writes code, then that person writes code",
            "∀x (Programmer(x) ∧ UsesComputer(x) → WritesCode(x)) ::: If someone is a programmer and uses a computer, then that person writes code",
            "∀x (UsesComputer(x) → WritesCode(x)) ::: If someone uses a computer, then that person writes code",
            "∀x (Programmer(x) → (WritesCode(x) ∨ ¬WritesCode(x))) ::: If someone is a programmer, they write code or do not write code",
            "∀x (WritesCode(x) → WritesCode(x)) ::: If someone writes code, then that is writing code",
            "∀x (WritesCode(x) → (Person(x) ∧ WritesCode(x))) ::: If someone writes code, then they are a person and write code",
            "∀x (Person(x) → (WritesCode(x) ∨ ¬WritesCode(x))) ::: If someone is a person, they write code or do not write code",
            "∀x ((Person(x) ∧ WritesCode(x)) → WritesCode(x)) ::: If someone is a person and writes code, they are writing code",
            "∀x (Programmer(x) → WritesCode(x)) ::: If someone is a programmer, then that person is writing code"
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "UsesComputer(x) ::: x uses a computer",
            "Person(x) ::: x is a person",
            "WritesCode(x) ::: x writes code"
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "Some smart students have good grades.",
            "All students who like logic attend lectures.",
            "Some students like logic.",
            "Anyone who likes logic is a student.",
            "If someone is smart, they like logic.",
            "If someone has good grades and is a student, they are smart.",
            "Students are people who attend classes.",
            "Smart people do well in the exam.",
            "Attending lectures is necessary for having good grades.",
            "There is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "∃x (Smart(x) ∧ GoodGrades(x)) ::: Some smart students have good grades.",
            "∀x (LikesLogic(x) → AttendsLectures(x)) ::: All students who like logic attend lectures.",
            "∃x LikesLogic(x) ::: Some students like logic.",
            "∀x (LikesLogic(x) → Student(x)) ::: Anyone who likes logic is a student.",
            "∀x (Smart(x) → LikesLogic(x)) ::: If someone is smart, they like logic.",
            "∀x ((GoodGrades(x) ∧ Student(x)) → Smart(x)) ::: If someone has good grades and is a student, they are smart.",
            "∀x (Student(x) → AttendsClasses(x)) ::: Students are people who attend classes.",
            "∀x (Smart(x) → DoesWellInExam(x)) ::: Smart people do well in the exam.",
            "∀x (GoodGrades(x) → AttendsLectures(x)) ::: Attending lectures is necessary for having good grades.",
            "∃x Student(x) ::: There is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Smart(x) ::: x is smart",
            "GoodGrades(x) ::: x has good grades",
            "AttendsLectures(x) ::: x attends lectures",
            "LikesLogic(x) ::: x likes logic"
        ]
    },
    {
        "premises-NL": [
            "All patients with a virus have a fever.",
            "All patients with a virus have a cough.",
            "If a patient has a fever and a cough, then they are likely infected.",
            "If a patient is likely infected, they might need to be isolated.",
            "There is a patient who has a virus.",
            "A patient with a virus always has a fever.",
            "A patient with a virus always has a cough.",
            "If someone has a virus, they are likely infected.",
            "If a patient is infected, they have a fever and cough.",
            "Patients who have a fever and a cough need attention.",
            "If a patient is likely infected, they have to be isolated.",
            "All patients are human."
        ],
        "premises-FOL": [
            "∀x (HasVirus(x) → Fever(x)) ::: All patients with a virus have a fever.",
            "∀x (HasVirus(x) → Cough(x)) ::: All patients with a virus have a cough.",
            "∀x ((Fever(x) ∧ Cough(x)) → LikelyInfected(x)) ::: If a patient has a fever and a cough, then they are likely infected.",
            "∀x (LikelyInfected(x) → NeedsIsolation(x)) ::: If a patient is likely infected, they might need to be isolated.",
            "∃x HasVirus(x) ::: There is a patient who has a virus.",
            "∀x (HasVirus(x) → Fever(x)) ::: A patient with a virus always has a fever.",
            "∀x (HasVirus(x) → Cough(x)) ::: A patient with a virus always has a cough.",
            "∀x (HasVirus(x) → LikelyInfected(x)) ::: If someone has a virus, they are likely infected.",
            "∀x (Infected(x) → (Fever(x) ∧ Cough(x))) ::: If a patient is infected, they have a fever and cough.",
            "∀x ((Fever(x) ∧ Cough(x)) → NeedsAttention(x)) ::: Patients who have a fever and a cough need attention.",
            "∀x (LikelyInfected(x) → Isolate(x)) ::: If a patient is likely infected, they have to be isolated.",
            "∀x (Patient(x) → Human(x)) ::: All patients are human."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient",
            "Fever(x) ::: x has a fever",
            "Cough(x) ::: x has a cough",
            "LikelyInfected(x) ::: x is likely infected",
            "HasVirus(x) ::: x has a virus",
            "Isolate(x) ::: x needs to be isolated"
        ]
    },
    {
        "premises-NL": [
            "All members of the green party support renewable energy.",
            "Anyone who supports renewable energy is an environmentalist.",
            "All members of the green party are citizens.",
            "Some citizens are members of the green party.",
            "If someone is a politician, they have political beliefs.",
            "All politicians are citizens.",
            "Every environmentalist supports renewable energy.",
            "Environmentalists are citizens.",
            "If someone is a member of the green party, they are a politician.",
            "Citizens are people.",
            "Anyone who supports renewable energy is a politician.",
            "Every environmentalist has political beliefs.",
            "Some people are politicians."
        ],
        "premises-FOL": [
            "∀x (MemberOfGreenParty(x) → SupportsRenewableEnergy(x)) ::: All members of the green party support renewable energy.",
            "∀x (SupportsRenewableEnergy(x) → Environmentalist(x)) ::: Anyone who supports renewable energy is an environmentalist.",
            "∀x (MemberOfGreenParty(x) → Citizen(x)) ::: All members of the green party are citizens.",
            "∃x (Citizen(x) ∧ MemberOfGreenParty(x)) ::: Some citizens are members of the green party.",
            "∀x (Politician(x) → HasPoliticalBeliefs(x)) ::: If someone is a politician, they have political beliefs.",
            "∀x (Politician(x) → Citizen(x)) ::: All politicians are citizens.",
            "∀x (Environmentalist(x) → SupportsRenewableEnergy(x)) ::: Every environmentalist supports renewable energy.",
            "∀x (Environmentalist(x) → Citizen(x)) ::: Environmentalists are citizens.",
            "∀x (MemberOfGreenParty(x) → Politician(x)) ::: If someone is a member of the green party, they are a politician.",
            "∀x (Citizen(x) → Person(x)) ::: Citizens are people.",
            "∀x (SupportsRenewableEnergy(x) → Politician(x)) ::: Anyone who supports renewable energy is a politician.",
            "∀x (Environmentalist(x) → HasPoliticalBeliefs(x)) ::: Every environmentalist has political beliefs.",
            "∃x Politician(x) ::: Some people are politicians."
        ],
        "predicates": [
            "Citizen(x) ::: x is a citizen",
            "MemberOfGreenParty(x) ::: x is a member of the green party",
            "Environmentalist(x) ::: x is an environmentalist",
            "SupportsRenewableEnergy(x) ::: x supports renewable energy",
            "Politician(x) ::: x is a politician",
            "HasPoliticalBeliefs(x) ::: x has political beliefs"
        ]
    },
    {
        "premises-NL": [
            "All cats are animals.",
            "If a cat is eating, it is not likely sick.",
            "If a cat is playing, it is happy.",
            "If a cat is happy, it is healthy.",
            "Some cats have toys.",
            "If a cat is not eating, it is likely sick.",
            "If a cat is eating, it is not playing.",
            "If a cat is healthy, it is eating.",
            "Cats are not happy when sick.",
            "A cat that is not eating is unlikely to be playing.",
            "Cats are animals that eat food.",
            "If a cat is playing, it is eating.",
            "If a cat is not healthy, it is not happy.",
            "If a cat is sick, then it doesn't have a toy."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → Animal(x)) ::: All cats are animals.",
            "∀x ((Cat(x) ∧ Eating(x)) → ¬LikelySick(x)) ::: If a cat is eating, it is not likely sick.",
            "∀x ((Cat(x) ∧ Playing(x)) → Happy(x)) ::: If a cat is playing, it is happy.",
            "∀x (Happy(x) → Healthy(x)) ::: If a cat is happy, it is healthy.",
            "∃x (Cat(x) ∧ HasToy(x)) ::: Some cats have toys.",
            "∀x ((Cat(x) ∧ ¬Eating(x)) → LikelySick(x)) ::: If a cat is not eating, it is likely sick.",
            "∀x ((Cat(x) ∧ Eating(x)) → ¬Playing(x)) ::: If a cat is eating, it is not playing.",
            "∀x (Healthy(x) → Eating(x)) ::: If a cat is healthy, it is eating.",
            "∀x ((Cat(x) ∧ LikelySick(x)) → ¬Happy(x)) ::: Cats are not happy when sick.",
            "∀x ((Cat(x) ∧ ¬Eating(x)) → ¬Playing(x)) ::: A cat that is not eating is unlikely to be playing.",
            "∀x (Cat(x) → (Animal(x) ∧ EatsFood(x))) ::: Cats are animals that eat food.",
            "∀x ((Cat(x) ∧ Playing(x)) → Eating(x)) ::: If a cat is playing, it is eating.",
            "∀x ((Cat(x) ∧ ¬Healthy(x)) → ¬Happy(x)) ::: If a cat is not healthy, it is not happy.",
            "∀x ((Cat(x) ∧ LikelySick(x)) → ¬HasToy(x)) ::: If a cat is sick, then it doesn't have a toy."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Eating(x) ::: x is eating",
            "LikelySick(x) ::: x is likely sick",
            "HasToy(x) ::: x has a toy",
            "Happy(x) ::: x is happy",
            "Playing(x) ::: x is playing",
            "Healthy(x) ::: x is healthy"
        ]
    },
    {
        "premises-NL": [
            "All students are taking the exam.",
            "Some students passed the exam.",
            "Professor Smith teaches the exam.",
            "All students who passed the exam like Professor Smith.",
            "Professor Smith is a professor."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakingExam(x)) ::: All students are taking the exam.",
            "∃x (Student(x) ∧ PassedExam(x)) ::: Some students passed the exam.",
            "Teaches(ProfessorSmith, Exam) ::: Professor Smith teaches the exam.",
            "∀x (Student(x) ∧ PassedExam(x) → LikesProfessor(x)) ::: All students who passed the exam like Professor Smith.",
            "IsProfessor(ProfessorSmith) ::: Professor Smith is a professor."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PassedExam(x) ::: x passed the exam",
            "LikesProfessor(x) ::: x likes the professor",
            "Teaches(x, y) ::: x teaches y",
            "IsProfessor(x) ::: x is a professor"
        ]
    },
    {
        "premises-NL": [
            "All cars are either red or blue.",
            "Some people own a car.",
            "All red cars are expensive.",
            "If someone owns a car, then that car is either new or old.",
            "No new car is used by anyone.",
            "Everyone drives a car if and only if they use the car.",
            "John owns a red car.",
            "John drives a car.",
            "All old cars are not used."
        ],
        "premises-FOL": [
            "∀x (Car(x) → Red(x) ∨ Blue(x)) ::: All cars are either red or blue.",
            "∃x ∃y (Person(x) ∧ Car(y) ∧ Owns(x, y)) ::: Some people own a car.",
            "∀x (Red(x) → Expensive(x)) ::: All red cars are expensive.",
            "∀x ∀y (Owns(x, y) ∧ Car(y) → IsNew(y) ∨ IsOld(y)) ::: If someone owns a car, then that car is either new or old.",
            "∀x ∀y (IsNew(y) → ¬Uses(x, y)) ::: No new car is used by anyone.",
            "∀x ∀y (Drives(x, y) ↔ Uses(x, y)) ::: Everyone drives a car if and only if they use the car.",
            "∃y (Owns(John, y) ∧ Red(y) ∧ Car(y)) ::: John owns a red car.",
            "∃y Drives(John, y) ::: John drives a car.",
            "∀x ∀y (IsOld(y) ∧ Car(y) → ¬Uses(x, y)) ::: All old cars are not used."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Car(x) ::: x is a car",
            "Owns(x, y) ::: x owns y",
            "Red(x) ::: x is red",
            "Expensive(x) ::: x is expensive",
            "Uses(x, y) ::: x uses y",
            "Drives(x, y) ::: x drives y",
            "IsNew(x) ::: x is new",
            "IsOld(x) ::: x is old"
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "David is a student.",
            "If someone studies hard and likes pizza, they will pass the exam.",
            "David studies hard.",
            "David likes pizza."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "Student(david) ::: David is a student.",
            "∀x ((HardStudy(x) ∧ LikesPizza(x)) → PassExam(x)) ::: If someone studies hard and likes pizza, they will pass the exam.",
            "HardStudy(david) ::: David studies hard.",
            "LikesPizza(david) ::: David likes pizza."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "HardStudy(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "LikesPizza(x) ::: x likes pizza"
        ]
    },
    {
        "premises-NL": [
            "Alice is a person.",
            "Bob is a person.",
            "Carol is a person.",
            "If Alice is friends with Bob, then Bob is friends with Alice.",
            "If Bob is friends with Alice, they are friends.",
            "Alice and Bob are friends.",
            "Bob and Carol are friends.",
            "If x is friends with y and y is friends with z, then x is friends with z.",
            "For all x, if x is a person, then x is a person.",
            "For all x, y, if x is friends with y, then y is friends with x.",
            "If Alice and Carol are not friends, then Bob is not friends with Alice or Carol."
        ],
        "premises-FOL": [
            "Person(alice) ::: Alice is a person.",
            "Person(bob) ::: Bob is a person.",
            "Person(carol) ::: Carol is a person.",
            "∀x ∀y (Friends(x, y) → Friends(y, x)) ::: If x is friends with y, then y is friends with x.",
            "∀x ∀y (Friends(x, y) → Friends(x, y)) ::: If Bob is friends with Alice, they are friends.",
            "Friends(alice, bob) ::: Alice and Bob are friends.",
            "Friends(bob, carol) ::: Bob and Carol are friends.",
            "∀x ∀y ∀z ((Friends(x, y) ∧ Friends(y, z)) → Friends(x, z)) ::: If x is friends with y and y is friends with z, then x is friends with z.",
            "∀x (Person(x) → Person(x)) ::: For all x, if x is a person, then x is a person.",
            "∀x ∀y (Friends(x, y) → Friends(y, x)) ::: For all x, y, if x is friends with y, then y is friends with x.",
            "¬Friends(alice, carol) → (¬Friends(bob, alice) ∨ ¬Friends(bob, carol)) ::: If Alice and Carol are not friends, then Bob is not friends with Alice or Carol."
        ],
        "predicates": [
            "Friends(x, y) ::: x and y are friends.",
            "Person(x) ::: x is a person."
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled in a university.",
            "Alice is a student.",
            "Bob is a student.",
            "Carol is a student.",
            "Math is a course.",
            "Physics is a course.",
            "Chemistry is a course.",
            "Alice takes Math.",
            "Alice takes Physics.",
            "If anyone takes Math, they are a student.",
            "If a student takes Math, they take Chemistry.",
            "If a student takes Physics and Math, they must take Chemistry.",
            "If Alice does not take Chemistry and takes Math, then Alice is not a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → EnrolledInUniversity(x)) ::: All students are enrolled in a university.",
            "Student(alice) ::: Alice is a student.",
            "Student(bob) ::: Bob is a student.",
            "Student(carol) ::: Carol is a student.",
            "Course(math) ::: Math is a course.",
            "Course(physics) ::: Physics is a course.",
            "Course(chemistry) ::: Chemistry is a course.",
            "Takes(alice, math) ::: Alice takes Math.",
            "Takes(alice, physics) ::: Alice takes Physics.",
            "∀x (Takes(x, math) → Student(x)) ::: If anyone takes Math, they are a student.",
            "∀x (Student(x) ∧ Takes(x, math) → Takes(x, chemistry)) ::: If a student takes Math, they take Chemistry.",
            "∀x (Student(x) ∧ Takes(x, physics) ∧ Takes(x, math) → Takes(x, chemistry)) ::: If a student takes Physics and Math, they must take Chemistry.",
            "¬Takes(alice, chemistry) ∧ Takes(alice, math) → ¬Student(alice) ::: If Alice does not take Chemistry and takes Math, then Alice is not a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Takes(x, y) ::: x takes course y.",
            "Course(y) ::: y is a course."
        ]
    },
    {
        "premises-NL": [
            "All doctors work in hospitals.",
            "All humans are mammals.",
            "All mammals are animals.",
            "All animals breathe.",
            "Alice is a doctor.",
            "Bob is a human.",
            "If someone is a doctor, then they are a human.",
            "If someone is a human, then they are mortal.",
            "All doctors are human.",
            "All humans are mortal.",
            "No immortal thing is human.",
            "If something is mortal, then it is living.",
            "If something is living, then it breathes."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → WorksInHospital(x)) ::: All doctors work in hospitals.",
            "∀x (Human(x) → Mammal(x)) ::: All humans are mammals.",
            "∀x (Mammal(x) → Animal(x)) ::: All mammals are animals.",
            "∀x (Animal(x) → Breathes(x)) ::: All animals breathe.",
            "Doctor(alice) ::: Alice is a doctor.",
            "Human(bob) ::: Bob is a human.",
            "∀x (Doctor(x) → Human(x)) ::: If someone is a doctor, then they are a human.",
            "∀x (Human(x) → Mortal(x)) ::: If someone is a human, then they are mortal.",
            "∀x (Doctor(x) → Human(x)) ::: All doctors are human.",
            "∀x (Human(x) → Mortal(x)) ::: All humans are mortal.",
            "¬∃x (Immortal(x) ∧ Human(x)) ::: No immortal thing is human.",
            "∀x (Mortal(x) → Living(x)) ::: If something is mortal, then it is living.",
            "∀x (Living(x) → Breathes(x)) ::: If something is living, then it breathes."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Human(x) ::: x is a human.",
            "Mortal(x) ::: x is mortal."
        ]
    },
    {
        "premises-NL": [
            "If someone has a disease and doesn't take medicine, their condition worsens.",
            "A specific disease affects a person.",
            "The person is not taking the medicine.",
            "Anyone affected by a disease needs medicine to avoid worsening.",
            "The medicine prevents the disease from worsening the condition.",
            "If a person doesn't take medicine, their condition worsens.",
            "This specific disease affects a person."
        ],
        "premises-FOL": [
            "∀x ∀y (Disease(x, y) ∧ ¬Takes(y, z) → Worsens(y)) ::: If someone has a disease and doesn't take medicine, their condition worsens.",
            "Disease(SpecificDisease, Person) ::: A specific disease affects a person.",
            "¬Takes(Person, Medicine) ::: The person is not taking the medicine.",
            "∀x ∀y (Disease(x, y) → Takes(y, z)) ::: Anyone affected by a disease needs medicine to avoid worsening.",
            "∀x ∀y (Takes(x, y) → ¬Worsens(y)) ::: The medicine prevents the disease from worsening the condition.",
            "∀x (¬Takes(x, Medicine) → Worsens(x)) ::: If a person doesn't take medicine, their condition worsens.",
            "Disease(SpecificDisease, Person) ::: This specific disease affects a person."
        ],
        "predicates": [
            "Disease(x, y) ::: Disease x affects person y.",
            "Takes(x, y) ::: Person x takes medicine y.",
            "Worsens(x) ::: Person x's condition worsens."
        ]
    },
    {
        "premises-NL": [
            "All students who study hard pass the exam.",
            "Some students attend classes.",
            "All students who attend classes attend the lecture.",
            "Some students are studying hard.",
            "All students are either studying hard or failing the exam.",
            "No student both studies hard and fails the exam.",
            "Some students are both students and attend classes."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) → PassedExam(x)) ::: If x is a student and studies hard, then x passed the exam.",
            "∃x (Student(x) ∧ AttendsClasses(x)) ::: There exists a student who attends classes.",
            "∀x (AttendsClasses(x) → AttendsLecture(x)) ::: If x attends classes, then x attends the lecture.",
            "∃x (Student(x) ∧ StudiesHard(x)) ::: There exists a student who is studying hard.",
            "∀x (Student(x) → (StudiesHard(x) ∨ FailsExam(x))) ::: If x is a student, then x is either studying hard or failing the exam.",
            "¬∃x (StudiesHard(x) ∧ FailsExam(x)) ::: No one both studies hard and fails the exam.",
            "∃x (Student(x) ∧ AttendsClasses(x)) ::: There exists a student attending classes."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PassedExam(x) ::: x passed the exam",
            "AttendsLecture(x) ::: x attends the lecture",
            "StudiesHard(x) ::: x studies hard",
            "FailsExam(x) ::: x fails the exam",
            "AttendsClasses(x) ::: x attends classes"
        ]
    },
    {
        "premises-NL": [
            "All researchers who work at a university need funding.",
            "All researchers who need funding are successful.",
            "All successful researchers publish papers.",
            "Some researchers work at a university.",
            "All researchers who have a grant receive funding.",
            "All researchers that receive funding are successful.",
            "Some researchers have a grant.",
            "Some researchers are both researchers and have a grant."
        ],
        "premises-FOL": [
            "∀x (Researcher(x) ∧ WorksAtUniversity(x) → NeedsFunding(x)) ::: If x is a researcher and works at a university, then x needs funding.",
            "∀x (NeedsFunding(x) → IsSuccessful(x)) ::: If x needs funding, then x is successful.",
            "∀x (IsSuccessful(x) → PublishesPapers(x)) ::: If x is successful, then x publishes papers.",
            "∃x (Researcher(x) ∧ WorksAtUniversity(x)) ::: There exists a researcher who works at a university.",
            "∀x (Researcher(x) ∧ HasGrant(x) → ReceivesFunding(x)) ::: If x is a researcher and has a grant, then x receives funding.",
            "∀x (ReceivesFunding(x) → IsSuccessful(x)) ::: If x receives funding, then x is successful.",
            "∃x (Researcher(x) ∧ HasGrant(x)) ::: There exists a researcher who has a grant.",
            "∃x (Researcher(x) ∧ HasGrant(x)) ::: Some researchers have a grant."
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher",
            "HasGrant(x) ::: x has a grant",
            "PublishesPapers(x) ::: x publishes papers",
            "WorksAtUniversity(x) ::: x works at a university",
            "NeedsFunding(x) ::: x needs funding",
            "IsSuccessful(x) ::: x is successful",
            "IsPublished(x) ::: x has papers published",
            "ReceivesFunding(x) ::: x receives funding"
        ]
    },
    {
        "premises-NL": [
            "All patients treated by a specialist receive treatment.",
            "All patients who recover are not hospitalized.",
            "All patients who are critically ill need surgery.",
            "Some patients are treated by specialists.",
            "All patients who receive treatment have insurance.",
            "No patient is critically ill and recovers.",
            "Some patients have a disease.",
            "All patients with insurance can receive treatment.",
            "All patients who need surgery are critically ill."
        ],
        "premises-FOL": [
            "∀x (TreatedBySpecialist(x) → ReceivesTreatment(x)) ::: If x is treated by a specialist, then x receives treatment.",
            "∀x (Recovers(x) → ¬IsHospitalized(x)) ::: If x recovers, then x is not hospitalized.",
            "∀x (CriticallyIll(x) → NeedsSurgery(x)) ::: If x is critically ill, then x needs surgery.",
            "∃x TreatedBySpecialist(x) ::: There exists a patient treated by a specialist.",
            "∀x (ReceivesTreatment(x) → HasInsurance(x)) ::: If x receives treatment, then x has insurance.",
            "¬∃x (CriticallyIll(x) ∧ Recovers(x)) ::: No patient is critically ill and recovers.",
            "∃x (Patient(x) ∧ HasDisease(x)) ::: There exists a patient who has a disease.",
            "∀x (HasInsurance(x) → ReceivesTreatment(x)) ::: If x has insurance, then x receives treatment.",
            "∀x (NeedsSurgery(x) → CriticallyIll(x)) ::: If x needs surgery, then x is critically ill."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient",
            "TreatedBySpecialist(x) ::: x is treated by a specialist",
            "Recovers(x) ::: x recovers",
            "CriticallyIll(x) ::: x is critically ill",
            "HasInsurance(x) ::: x has insurance",
            "NeedsSurgery(x) ::: x needs surgery",
            "ReceivesTreatment(x) ::: x receives treatment",
            "IsHospitalized(x) ::: x is hospitalized",
            "HasDisease(x) ::: x has disease"
        ]
    },
    {
        "premises-NL": [
            "All profitable companies have high revenue.",
            "All companies that have high revenue and low expenses are profitable.",
            "All companies that increase market share are innovative.",
            "No company is both profitable and loses money.",
            "Some companies expand internationally.",
            "All innovative companies employ many people.",
            "All companies with low expenses are competitive.",
            "Some companies have low expenses.",
            "All companies that employ many people increase market share.",
            "All competitive companies increase market share."
        ],
        "premises-FOL": [
            "∀x (Profitable(x) → HasHighRevenue(x)) ::: If x is profitable, then x has high revenue.",
            "∀x ((HasHighRevenue(x) ∧ HasLowExpenses(x)) → Profitable(x)) ::: If x has high revenue and low expenses, then x is profitable.",
            "∀x (IncreasesMarketShare(x) → IsInnovative(x)) ::: If x increases market share, then x is innovative.",
            "¬∃x (Profitable(x) ∧ LosesMoney(x)) ::: No company is both profitable and loses money.",
            "∃x (Company(x) ∧ ExpandsInternationally(x)) ::: There exists a company which expands internationally.",
            "∀x (IsInnovative(x) → EmploysManyPeople(x)) ::: If x is innovative, then x employs many people.",
            "∀x (HasLowExpenses(x) → IsCompetitive(x)) ::: If x has low expenses, then x is competitive.",
            "∃x (HasLowExpenses(x)) ::: There exists a company with low expenses.",
            "∀x (EmploysManyPeople(x) → IncreasesMarketShare(x)) ::: If x employs many people, then x increases market share.",
            "∀x (IsCompetitive(x) → IncreasesMarketShare(x)) ::: If x is competitive, then x increases market share."
        ],
        "predicates": [
            "Company(x) ::: x is a company",
            "Profitable(x) ::: x is profitable",
            "IncreasesMarketShare(x) ::: x increases market share",
            "HasHighRevenue(x) ::: x has high revenue",
            "HasLowExpenses(x) ::: x has low expenses",
            "IsInnovative(x) ::: x is innovative",
            "LosesMoney(x) ::: x loses money",
            "EmploysManyPeople(x) ::: x employs many people",
            "ExpandsInternationally(x) ::: x expands internationally",
            "IsCompetitive(x) ::: x is competitive"
        ]
    },
    {
        "premises-NL": [
            "All mammals breathe air.",
            "All animals that breathe air have a heart.",
            "All mammals are warm-blooded.",
            "No mammal lays eggs.",
            "Some animals live on land.",
            "All animals either live on land or in water.",
            "All warm-blooded animals are mammals.",
            "Some animals are not cold-blooded.",
            "All animals that have lungs breathe air.",
            "All animals with gills live in water.",
            "All animals that breathe air have lungs."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → BreathesAir(x)) ::: If x is a mammal, then x breathes air.",
            "∀x (BreathesAir(x) → HasHeart(x)) ::: If x breathes air, then x has a heart.",
            "∀x (Mammal(x) → IsWarmBlooded(x)) ::: If x is a mammal, then x is warm-blooded.",
            "¬∃x (Mammal(x) ∧ LaysEggs(x)) ::: No mammal lays eggs.",
            "∃x (Animal(x) ∧ LivesOnLand(x)) ::: There exists an animal which lives on land.",
            "∀x (Animal(x) → (LivesOnLand(x) ∨ LivesInWater(x))) ::: If x is an animal, then x lives on land or in water.",
            "∀x (IsWarmBlooded(x) → Mammal(x)) ::: If x is warm-blooded, then x is a mammal.",
            "∃x ¬IsColdBlooded(x) ::: There exists something which is not cold-blooded.",
            "∀x (BreathesAir(x) → HasLungs(x)) ::: If x breathes air, then x has lungs.",
            "∀x (HasGills(x) → LivesInWater(x)) ::: If x has gills, then x lives in water.",
            "∀x (BreathesAir(x) → HasLungs(x)) ::: If x breathes air, then x has lungs."
        ],
        "predicates": [
            "Animal(x) ::: x is an animal",
            "Mammal(x) ::: x is a mammal",
            "HasHeart(x) ::: x has a heart",
            "BreathesAir(x) ::: x breathes air",
            "LaysEggs(x) ::: x lays eggs",
            "IsWarmBlooded(x) ::: x is warm-blooded",
            "IsColdBlooded(x) ::: x is cold-blooded",
            "LivesOnLand(x) ::: x lives on land",
            "LivesInWater(x) ::: x lives in water",
            "HasLungs(x) ::: x has lungs",
            "HasGills(x) ::: x has gills"
        ]
    },
    {
        "premises-NL": [
            "All students taking Math and Physics study hard.",
            "If someone studies hard, they get good grades.",
            "If someone gets good grades, they are successful.",
            "Alice is taking Math.",
            "Alice is taking Physics.",
            "Bob is a student.",
            "Taking Math and Physics implies studying hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ Takes(x, math) ∧ Takes(x, physics) → StudiesHard(x)) ::: All students taking Math and Physics study hard.",
            "∀x (StudiesHard(x) → GoodGrade(x)) ::: If someone studies hard, they get good grades.",
            "∀x (GoodGrade(x) → Successful(x)) ::: If someone gets good grades, they are successful.",
            "Takes(alice, math) ::: Alice is taking Math.",
            "Takes(alice, physics) ::: Alice is taking Physics.",
            "Student(bob) ::: Bob is a student.",
            "∀x (Takes(x, math) ∧ Takes(x, physics) → StudiesHard(x)) ::: Taking Math and Physics implies studying hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Takes(x, y) ::: x takes course y",
            "Math(x) ::: x is math",
            "Physics(x) ::: x is physics",
            "Successful(x) ::: x is successful",
            "StudiesHard(x) ::: x studies hard",
            "GoodGrade(x) ::: x gets good grades"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard are smart.",
            "John is a student.",
            "If someone is smart, they will pass the exam.",
            "John studies hard.",
            "Anyone who is a student and studies hard will pass the exam.",
            "If someone is a student, and they are not smart, then they don't study hard.",
            "John is smart or John studies hard.",
            "If John is not smart then he does not study hard",
            "If John is a student and smart then he passes the exam.",
            "John is a student and a smart student.",
            "Not (John is a student and John is not smart).",
            "John is either not a student, or studies hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ HardStudy(x) → Smart(x)) ::: All students who study hard are smart",
            "Student(John) ::: John is a student",
            "∀x (Smart(x) → PassExam(x)) ::: If someone is smart, they will pass the exam",
            "HardStudy(John) ::: John studies hard",
            "∀x (Student(x) ∧ HardStudy(x) → PassExam(x)) ::: Anyone who is a student and studies hard will pass the exam",
            "∀x (Student(x) ∧ ¬Smart(x) → ¬HardStudy(x)) ::: If someone is a student, and they are not smart, then they don't study hard",
            "Smart(John) ∨ HardStudy(John) ::: John is smart or John studies hard",
            "¬Smart(John) → ¬HardStudy(John) ::: If John is not smart then he does not study hard",
            "Student(John) ∧ Smart(John) → PassExam(John) ::: If John is a student and smart then he passes the exam",
            "Student(John) ∧ Smart(John) ::: John is a student and a smart student",
            "¬(Student(John) ∧ ¬Smart(John)) ::: Not (John is a student and John is not smart)",
            "¬Student(John) ∨ HardStudy(John) ::: John is either not a student, or studies hard"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "HardStudy(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "John is a student.",
            "All students who study hard attend class.",
            "Anyone who attends class takes an exam.",
            "If someone takes an exam and passes, they get a good grade.",
            "John studies hard.",
            "John takes the exam.",
            "If John takes the exam, then he passes the exam.",
            "All students who attend class pass their exams.",
            "If someone studies hard, then they attend class.",
            "Every student studies either hard or not at all.",
            "John either studies hard or not at all.",
            "If someone does not study hard, they will not get a good grade."
        ],
        "premises-FOL": [
            "Student(John) ::: John is a student.",
            "∀x (Student(x) ∧ StudiesHard(x) → AttendsClass(x)) ::: All students who study hard attend class.",
            "∀x (AttendsClass(x) → TakesExam(x)) ::: Anyone who attends class takes an exam.",
            "∀x (TakesExam(x) ∧ PassExam(x) → GoodGrade(x)) ::: If someone takes an exam and passes, they get a good grade.",
            "StudiesHard(John) ::: John studies hard.",
            "TakesExam(John) ::: John takes the exam.",
            "TakesExam(John) → PassExam(John) ::: If John takes the exam, then he passes the exam.",
            "∀x (Student(x) ∧ AttendsClass(x) → PassExam(x)) ::: All students who attend class pass their exams.",
            "∀x (StudiesHard(x) → AttendsClass(x)) ::: If someone studies hard, then they attend class.",
            "∀x (Student(x) → (StudiesHard(x) ∨ ¬StudiesHard(x))) ::: Every student studies either hard or not at all.",
            "Student(John) → (StudiesHard(John) ∨ ¬StudiesHard(John)) ::: John either studies hard or not at all.",
            "∀x (¬StudiesHard(x) → ¬GoodGrade(x)) ::: If someone does not study hard, they will not get a good grade."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "GoodGrade(x) ::: x gets a good grade",
            "AttendsClass(x) ::: x attends class",
            "TakesExam(x) ::: x takes exam",
            "PassExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "All doctors are people.",
            "All people who are doctors and work at a hospital treat patients.",
            "There is a doctor.",
            "There is a person who works at a hospital.",
            "If someone is a doctor and works at a hospital, then they treat patients.",
            "If someone treats patients, then they must be a doctor.",
            "If a doctor is not at a hospital, they don't treat patients.",
            "If a person is a doctor and works at a hospital, that person treats patients.",
            "Someone is a doctor and that someone works at a hospital.",
            "A doctor is a person.",
            "There is no person who is a doctor and works at a hospital and does not treat patients.",
            "Every doctor is a person who treats patients at the hospital."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Person(x)) ::: All doctors are people.",
            "∀x (Doctor(x) ∧ WorksAtHospital(x) → TreatsPatients(x)) ::: All people who are doctors and work at a hospital treat patients.",
            "∃x Doctor(x) ::: There is a doctor.",
            "∃x WorksAtHospital(x) ::: There is a person who works at a hospital.",
            "∀x ∀y ((Doctor(x) ∧ WorksAtHospital(y)) → TreatsPatients(x)) ::: If someone is a doctor and works at a hospital, then they treat patients.",
            "∀x (TreatsPatients(x) → Doctor(x)) ::: If someone treats patients, then they must be a doctor.",
            "∀x (Doctor(x) ∧ ¬WorksAtHospital(x) → ¬TreatsPatients(x)) ::: If a doctor is not at a hospital, they don't treat patients.",
            "∀x (Doctor(x) ∧ WorksAtHospital(x) → TreatsPatients(x)) ::: If a person is a doctor and works at a hospital, that person treats patients.",
            "∃x (Doctor(x) ∧ WorksAtHospital(x)) ::: Someone is a doctor and that someone works at a hospital.",
            "∀x (Doctor(x) → Person(x)) ::: A doctor is a person.",
            "¬∃x (Doctor(x) ∧ WorksAtHospital(x) ∧ ¬TreatsPatients(x)) ::: There is no person who is a doctor and works at a hospital and does not treat patients.",
            "∀x (Doctor(x) → (Person(x) ∧ TreatsPatients(x))) ::: Every doctor is a person who treats patients at the hospital."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "WorksAtHospital(x) ::: x works at a hospital",
            "TreatsPatients(x) ::: x treats patients",
            "Person(x) ::: x is a person"
        ]
    },
    {
        "premises-NL": [
            "All scientists read books.",
            "Some scientists study.",
            "Anyone who studies is not lazy.",
            "Anyone who reads a book, writes a book.",
            "All scientists write books.",
            "Some people are scientists.",
            "All people who write are scientists.",
            "No scientist is lazy.",
            "All scientists study."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Reads(x, Book)) ::: All scientists read books.",
            "∃x (Scientist(x) ∧ Studies(x, x)) ::: Some scientists study.",
            "∀x (Studies(x, x) → ¬Lazy(x)) ::: Anyone who studies is not lazy.",
            "∀x ∀y (Reads(x, y) → Writes(x, y)) ::: Anyone who reads a book, writes a book.",
            "∀x (Scientist(x) → Writes(x, Book)) ::: All scientists write books.",
            "∃x Scientist(x) ::: Some people are scientists.",
            "∀x (Writes(x, Book) → Scientist(x)) ::: All people who write are scientists.",
            "∀x (Scientist(x) → ¬Lazy(x)) ::: No scientist is lazy.",
            "∀x (Scientist(x) → Studies(x, x)) ::: All scientists study."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Studies(x, y) ::: x studies y",
            "Lazy(x) ::: x is lazy",
            "Book(x) ::: x is a book",
            "Reads(x, y) ::: x reads y",
            "Writes(x, y) ::: x writes y"
        ]
    },
    {
        "premises-NL": [
            "All patients are human.",
            "Dr. Jones is a doctor.",
            "Dr. Jones treats all patients.",
            "If a doctor treats a patient, they prescribe medication to that patient.",
            "If a patient takes prescribed medication, they either experience side effects or their condition improves.",
            "If a medication is effective and a patient takes it, then their condition improves.",
            "If a patient takes a prescribed medication, the medication is effective or has side effects.",
            "If a patient takes prescribed medication and has side effects, the patient reports them to the doctor.",
            "If a patient's condition improves, they do not have side effects.",
            "If the patient does not report side effects to the doctor, they did not have them.",
            "If a patient has side effects and reports them to a doctor, the medication is not effective.",
            "If the medication is effective, then it helps the patient.",
            "Medication A is prescribed"
        ],
        "premises-FOL": [
            "∀x (Patient(x) → Human(x)) ::: All patients are human",
            "Doctor(jones) ::: Dr. Jones is a doctor",
            "∀x (Patient(x) → Treats(jones, x)) ::: Dr. Jones treats all patients",
            "∀x ∀y (Doctor(x) ∧ Treats(x, y) → PrescribesMedication(y)) ::: If a doctor treats a patient, they prescribe medication to that patient",
            "∀x (TakesMedication(x, y) → (HasSideEffects(x) ∨ ImprovesCondition(x))) ::: If a patient takes prescribed medication, they either experience side effects or their condition improves",
            "∀x ∀y (IsEffective(y) ∧ TakesMedication(x, y) → ImprovesCondition(x)) ::: If a medication is effective and a patient takes it, then their condition improves",
            "∀x (PrescribedMedication(x) ∧ TakesMedication(y,x) → (IsEffective(x) ∨ HasSideEffects(y))) ::: If a patient takes a prescribed medication, the medication is effective or has side effects",
            "∀x (TakesMedication(x, y) ∧ HasSideEffects(x) → ReportsSideEffects(x, jones)) ::: If a patient takes prescribed medication and has side effects, the patient reports them to the doctor",
            "∀x (ImprovesCondition(x) → ¬HasSideEffects(x)) ::: If a patient's condition improves, they do not have side effects",
            "∀x (¬ReportsSideEffects(x, jones) → ¬HasSideEffects(x)) ::: If the patient does not report side effects to the doctor, they did not have them",
            "∀x (HasSideEffects(x) ∧ ReportsSideEffects(x, jones) → ¬IsEffective(x)) ::: If a patient has side effects and reports them to a doctor, the medication is not effective",
            "∀x (IsEffective(x) → HelpsPatient(x)) ::: If the medication is effective, then it helps the patient",
            "PrescribedMedication(medicationA) ::: Medication A is prescribed"
        ],
        "predicates": [
            "Patient(x) ::: x is a patient",
            "PrescribedMedication(x) ::: x is prescribed medication",
            "TakesMedication(x, y) ::: x takes medication y",
            "HasSideEffects(x) ::: x has side effects",
            "ImprovesCondition(x) ::: x's condition improves",
            "IsEffective(x) ::: x is effective",
            "Doctor(x) ::: x is a doctor",
            "Treats(x, y) ::: x treats y",
            "ReportsSideEffects(x, y) ::: x reports side effects to y"
        ]
    },
    {
        "premises-NL": [
            "All students either study math or science.",
            "John is a student.",
            "If someone is a student, then they take an exam.",
            "Anyone who studies math takes an exam.",
            "Anyone who studies science takes an exam.",
            "John studies math."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (StudiesMath(x) ∨ StudiesScience(x))) ::: All students either study math or science.",
            "Student(john) ::: John is a student.",
            "∀x (Student(x) → TakesExam(x)) ::: If someone is a student, then they take an exam.",
            "∀x (StudiesMath(x) → TakesExam(x)) ::: Anyone who studies math takes an exam.",
            "∀x (StudiesScience(x) → TakesExam(x)) ::: Anyone who studies science takes an exam.",
            "StudiesMath(john) ::: John studies math."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesMath(x) ::: x studies math",
            "StudiesScience(x) ::: x studies science",
            "TakesExam(x) ::: x takes an exam"
        ]
    },
    {
        "premises-NL": [
            "Everyone who owns a car is a driver.",
            "All drivers have a job.",
            "If someone has a job and pays taxes, then they are rich.",
            "Anyone who is rich owns a house.",
            "Bob owns a car.",
            "If someone is rich, they live in the city.",
            "Bob has a job.",
            "If someone has a job they are employed.",
            "Bob pays taxes."
        ],
        "premises-FOL": [
            "∀x (Owns(x, car) → IsDriver(x)) ::: Everyone who owns a car is a driver.",
            "∀x (IsDriver(x) → HasJob(x)) ::: All drivers have a job.",
            "∀x (HasJob(x) ∧ PaysTaxes(x) → IsRich(x)) ::: If someone has a job and pays taxes, then they are rich.",
            "∀x (IsRich(x) → Owns(x, house)) ::: Anyone who is rich owns a house.",
            "Owns(bob, car) ::: Bob owns a car.",
            "∀x (IsRich(x) → LivesInCity(x)) ::: If someone is rich, they live in the city.",
            "HasJob(bob) ::: Bob has a job.",
            "∀x (HasJob(x) → IsEmployed(x)) ::: If someone has a job they are employed.",
            "PaysTaxes(bob) ::: Bob pays taxes."
        ],
        "predicates": [
            "Owns(x, y) ::: x owns y",
            "IsRich(x) ::: x is rich",
            "HasJob(x) ::: x has a job",
            "LivesInCity(x) ::: x lives in the city",
            "Car(x) ::: x is a car",
            "House(x) ::: x is a house",
            "PaysTaxes(x) ::: x pays taxes",
            "IsEmployed(x) ::: x is employed",
            "IsDriver(x) ::: x is a driver"
        ]
    },
    {
        "premises-NL": [
            "All students either study hard or fail the exam.",
            "Anyone who studies hard passes the exam.",
            "If someone passes the exam, they are not lazy.",
            "Some students study hard.",
            "If someone is lazy, they do not have friends.",
            "Anyone who goes to a party is happy.",
            "Bob studies hard.",
            "If someone works part time, they are not lazy.",
            "Some students play sports.",
            "If someone fails the exam, they are lazy."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (StudiesHard(x) ∨ FailsExam(x))) ::: All students either study hard or fail the exam.",
            "∀x (StudiesHard(x) → PassesExam(x)) ::: Anyone who studies hard passes the exam.",
            "∀x (PassesExam(x) → ¬Lazy(x)) ::: If someone passes the exam, they are not lazy.",
            "∃x (Student(x) ∧ StudiesHard(x)) ::: Some students study hard.",
            "∀x (Lazy(x) → ¬HasFriends(x)) ::: If someone is lazy, they do not have friends.",
            "∀x (GoesToParty(x) → IsHappy(x)) ::: Anyone who goes to a party is happy.",
            "StudiesHard(bob) ::: Bob studies hard.",
            "∀x (WorksPartTime(x) → ¬Lazy(x)) ::: If someone works part time, they are not lazy.",
            "∃x (Student(x) ∧ PlaysSports(x)) ::: Some students play sports.",
            "∀x (FailsExam(x) → Lazy(x)) ::: If someone fails the exam, they are lazy."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Lazy(x) ::: x is lazy",
            "StudiesHard(x) ::: x studies hard",
            "PassesExam(x) ::: x passes the exam",
            "FailsExam(x) ::: x fails the exam",
            "HasFriends(x) ::: x has friends",
            "GoesToParty(x) ::: x goes to a party",
            "IsHappy(x) ::: x is happy",
            "PlaysSports(x) ::: x plays sports",
            "WorksPartTime(x) ::: x works part time"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "Dr. Smith is a doctor.",
            "Anyone who treats a patient is employed.",
            "John is a patient.",
            "If someone is a doctor, then they treat patients.",
            "A doctor is employed if they treat a patient.",
            "If someone is a doctor they are employed."
        ],
        "premises-FOL": [
            "∀x ∀y (Doctor(x) ∧ Patient(y) → Treats(x, y)) ::: All doctors treat patients.",
            "Doctor(smith) ::: Dr. Smith is a doctor.",
            "∀x ∀y (Treats(x, y) → Employed(x)) ::: Anyone who treats a patient is employed.",
            "Patient(john) ::: John is a patient.",
            "∀x (Doctor(x) → Treats(x, john)) ::: If someone is a doctor, then they treat patients.",
            "∀x ∀y (Doctor(x) ∧ Treats(x, y) → Employed(x)) ::: A doctor is employed if they treat a patient.",
            "∀x (Doctor(x) → Employed(x)) ::: If someone is a doctor they are employed."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Employed(x) ::: x is employed",
            "Treats(x, y) ::: x treats y",
            "Patient(x) ::: x is a patient"
        ]
    },
    {
        "premises-NL": [
            "All students take at least one course.",
            "Some courses are difficult.",
            "If a student takes a difficult course and passes, they are smart.",
            "John is a student.",
            "If someone takes a difficult course, and the course is passed, that person is considered to be smart.",
            "Every student who takes a difficult course must also pass it to be considered smart.",
            "If someone is taking a difficult course and passes, then they're smart.",
            "If a course is difficult, and a student takes it, then they either pass or fail."
        ],
        "premises-FOL": [
            "∀x ∃y (Student(x) → Takes(x, y)) ::: All students take at least one course.",
            "∃x DifficultCourse(x) ::: Some courses are difficult.",
            "∀x ∀y ((Student(x) ∧ DifficultCourse(y) ∧ Takes(x, y) ∧ Passes(x, y)) → Smart(x)) ::: If a student takes a difficult course and passes, they are smart.",
            "Student(john) ::: John is a student.",
            "∀x ∀y ((DifficultCourse(y) ∧ Takes(x, y) ∧ Passes(x, y)) → Smart(x)) ::: If someone takes a difficult course, and the course is passed, that person is considered to be smart.",
            "∀x ∀y (DifficultCourse(y) ∧ Takes(x, y) → Passes(x, y) ∨ ¬Passes(x, y)) ::: Every student who takes a difficult course must also pass it to be considered smart.",
            "∀x ∀y ((DifficultCourse(y) ∧ Takes(x, y) ∧ Passes(x, y)) → Smart(x)) ::: If someone is taking a difficult course and passes, then they're smart.",
            "∀x ∀y (DifficultCourse(y) ∧ Takes(x, y) → Passes(x, y) ∨ ¬Passes(x, y)) ::: If a course is difficult, and a student takes it, then they either pass or fail."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "DifficultCourse(x) ::: x is a difficult course",
            "Takes(x, y) ::: x takes course y",
            "Passes(x, y) ::: x passes course y",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients who have a disease.",
            "If someone is a patient, they have a disease.",
            "Dr. Smith is a doctor.",
            "John is a patient.",
            "Anyone who treats a patient is a doctor.",
            "Anyone who is a doctor treats a patient.",
            "If a patient has a disease, they are sick.",
            "If someone is treated by a doctor then they are sick."
        ],
        "premises-FOL": [
            "∀x ∀y (Doctor(x) ∧ Patient(y) ∧ HasDisease(y, z) → Treats(x, y)) ::: All doctors treat patients who have a disease.",
            "∀x ∀y (Patient(x) → HasDisease(x, y)) ::: If someone is a patient, they have a disease.",
            "Doctor(smith) ::: Dr. Smith is a doctor.",
            "Patient(john) ::: John is a patient.",
            "∀x ∀y (Treats(x, y) → Doctor(x)) ::: Anyone who treats a patient is a doctor.",
            "∀x ∃y (Doctor(x) → Treats(x, y)) ::: Anyone who is a doctor treats a patient.",
            "∀x ∀y (HasDisease(x, y) → Sick(x)) ::: If a patient has a disease, they are sick.",
            "∀x ∀y (Treats(x, y) ∧ Doctor(x) → Sick(y)) ::: If someone is treated by a doctor then they are sick."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Treats(x, y) ::: x treats y",
            "Patient(x) ::: x is a patient",
            "Sick(x) ::: x is sick",
            "HasDisease(x, y) ::: x has disease y"
        ]
    },
    {
        "premises-NL": [
            "All cats are animals.",
            "Some animals are not mammals.",
            "Some animals are cats."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → Animal(x)) ::: For all x, if x is a cat then x is an animal",
            "∃x (Animal(x) ∧ ¬Mammal(x)) ::: There exists an x such that x is an animal and x is not a mammal",
            "∃x (Animal(x) ∧ Cat(x)) ::: There exists an x such that x is an animal and x is a cat"
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Mammal(x) ::: x is a mammal",
            "Animal(x) ::: x is an animal",
            "IsCat(x) ::: x is a cat"
        ]
    },
    {
        "premises-NL": [
            "All plants are watered if they are in sunlight.",
            "All plants are healthy if they are watered.",
            "If a plant is healthy, it grows.",
            "This is a plant.",
            "This plant is in sunlight.",
            "If a plant is in sunlight, it is watered.",
            "If a plant grows, then it's healthy.",
            "This plant is either not in sunlight, or it is watered.",
            "If this plant is watered, it will grow.",
            "The plant is watered if in sunlight.",
            "If the plant is healthy, it grows.",
            "If the plant is in sunlight, then it's not healthy.",
            "The plant is in sunlight, and it is watered.",
            "The plant is healthy.",
            "If the plant is watered, it is healthy."
        ],
        "premises-FOL": [
            "∀x (Plant(x) ∧ InSunlight(x) → Watered(x)) ::: All plants are watered if they are in sunlight.",
            "∀x (Plant(x) ∧ Watered(x) → Healthy(x)) ::: All plants are healthy if they are watered.",
            "∀x (Healthy(x) → Grows(x)) ::: If a plant is healthy, it grows.",
            "Plant(this) ::: This is a plant.",
            "InSunlight(this) ::: This plant is in sunlight.",
            "∀x (Plant(x) ∧ InSunlight(x) → Watered(x)) ::: If a plant is in sunlight, it is watered.",
            "∀x (Grows(x) → Healthy(x)) ::: If a plant grows, then it's healthy.",
            "¬InSunlight(this) ∨ Watered(this) ::: This plant is either not in sunlight, or it is watered.",
            "Watered(this) → Grows(this) ::: If this plant is watered, it will grow.",
            "∀x (Plant(x) ∧ InSunlight(x) → Watered(x)) ::: The plant is watered if in sunlight.",
            "Healthy(this) → Grows(this) ::: If the plant is healthy, it grows.",
            "InSunlight(this) → ¬Healthy(this) ::: If the plant is in sunlight, then it's not healthy.",
            "InSunlight(this) ∧ Watered(this) ::: The plant is in sunlight, and it is watered.",
            "Healthy(this) ::: The plant is healthy.",
            "Watered(this) → Healthy(this) ::: If the plant is watered, it is healthy."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "InSunlight(x) ::: x is in sunlight",
            "Watered(x) ::: x is watered",
            "Grows(x) ::: x grows",
            "Healthy(x) ::: x is healthy"
        ]
    },
    {
        "premises-NL": [
            "Alice is a student.",
            "All students who study hard pass the exam.",
            "Alice studies hard.",
            "All students who attend class are smart.",
            "Alice attends class.",
            "Smart students pass the exam.",
            "If someone reads a book, they study hard.",
            "Alice reads a book.",
            "If someone likes pizza, they attends class.",
            "Alice likes pizza.",
            "If someone is smart they pass the exam.",
            "All students either study hard or don't like pizza.",
            "All students either studies hard or smart.",
            "All students either attend class or reads a book."
        ],
        "premises-FOL": [
            "Student(alice) ::: Alice is a student.",
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: All students who study hard pass the exam.",
            "StudiesHard(alice) ::: Alice studies hard.",
            "∀x (Student(x) ∧ AttendsClass(x) → Smart(x)) ::: All students who attend class are smart.",
            "AttendsClass(alice) ::: Alice attends class.",
            "∀x (Smart(x) → PassExam(x)) ::: Smart students pass the exam.",
            "∀x (ReadsBook(x) → StudiesHard(x)) ::: If someone reads a book, they study hard.",
            "ReadsBook(alice) ::: Alice reads a book.",
            "∀x (LikesPizza(x) → AttendsClass(x)) ::: If someone likes pizza, they attends class.",
            "LikesPizza(alice) ::: Alice likes pizza.",
            "∀x (Smart(x) → PassExam(x)) ::: If someone is smart they pass the exam.",
            "∀x (Student(x) → (StudiesHard(x) ∨ ¬LikesPizza(x))) ::: All students either study hard or don't like pizza.",
            "∀x (Student(x) → (StudiesHard(x) ∨ Smart(x))) ::: All students either studies hard or smart.",
            "∀x (Student(x) → (AttendsClass(x) ∨ ReadsBook(x))) ::: All students either attend class or reads a book."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesHard(x) ::: x studies hard.",
            "PassExam(x) ::: x passes the exam.",
            "LikesPizza(x) ::: x likes pizza.",
            "Smart(x) ::: x is smart.",
            "AttendsClass(x) ::: x attends class.",
            "ReadsBook(x) ::: x reads a book."
        ]
    },
    {
        "premises-NL": [
            "All programmers are smart.",
            "John is a programmer.",
            "Everyone who is smart enjoys logic.",
            "If someone is good at logic then they enjoy logic.",
            "John is a friend of Mary.",
            "Mary attends the logic seminar.",
            "Anyone who attends the logic seminar works at a university.",
            "Anyone who works at a university is a programmer.",
            "All friends of Mary are programmers.",
            "If anyone enjoys logic, then they are smart.",
            "If John is a programmer, then John works at a university.",
            "If John works at a university, then John is smart.",
            "If John is smart, then John enjoys logic.",
            "If anyone enjoys logic, then they are good at logic."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → Smart(x)) ::: All programmers are smart",
            "Programmer(john) ::: John is a programmer",
            "∀x (Smart(x) → Enjoys(x, logic)) ::: Everyone who is smart enjoys logic",
            "∀x (GoodAtLogic(x) → Enjoys(x, logic)) ::: If someone is good at logic then they enjoy logic",
            "IsFriendOf(john, mary) ::: John is a friend of Mary",
            "Attends(mary, LogicSeminar) ::: Mary attends the logic seminar",
            "∀x (Attends(x, LogicSeminar) → WorksAt(x, University)) ::: Anyone who attends the logic seminar works at a university",
            "∀x (WorksAt(x, University) → Programmer(x)) ::: Anyone who works at a university is a programmer",
            "∀x (IsFriendOf(x, mary) → Programmer(x)) ::: All friends of Mary are programmers",
            "∀x (Enjoys(x, logic) → Smart(x)) ::: If anyone enjoys logic, then they are smart",
            "Programmer(john) → WorksAt(john, University) ::: If John is a programmer, then John works at a university",
            "WorksAt(john, University) → Smart(john) ::: If John works at a university, then John is smart",
            "Smart(john) → Enjoys(john, logic) ::: If John is smart, then John enjoys logic",
            "∀x (Enjoys(x, logic) → GoodAtLogic(x)) ::: If anyone enjoys logic, then they are good at logic"
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "GoodAtLogic(x) ::: x is good at logic",
            "IsFriendOf(x, y) ::: x is a friend of y",
            "Enjoys(x, y) ::: x enjoys y",
            "Attends(x, y) ::: x attends y",
            "Smart(x) ::: x is smart",
            "WorksAt(x, y) ::: x works at y"
        ]
    },
    {
        "premises-NL": [
            "All doctors are employed.",
            "Dr. Smith is a doctor.",
            "Dr. Smith specializes in surgery.",
            "Anyone who specializes in surgery is registered.",
            "All registered doctors are employed.",
            "If someone is a doctor and employed, then they treat patients.",
            "Dr. Smith has a degree in medicine.",
            "Anyone who treats patients is a researcher.",
            "All researchers publish papers.",
            "If someone publishes a paper, then they study science.",
            "Dr. Smith studies science.",
            "Anyone who studies science writes reports.",
            "If someone writes a report then they are an expert in a field.",
            "If someone is an expert then they are employed.",
            "If someone is employed then they are a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Employed(x)) ::: All doctors are employed",
            "Doctor(smith) ::: Dr. Smith is a doctor",
            "SpecializesIn(smith, Surgery) ::: Dr. Smith specializes in surgery",
            "∀x (SpecializesIn(x, Surgery) → IsRegistered(x)) ::: Anyone who specializes in surgery is registered",
            "∀x (IsRegistered(x) → Employed(x)) ::: All registered doctors are employed",
            "∀x (Doctor(x) ∧ Employed(x) → TreatsPatient(x, y)) ::: If someone is a doctor and employed, then they treat patients",
            "HasDegree(smith, Medicine) ::: Dr. Smith has a degree in medicine",
            "∀x (TreatsPatient(x, y) → Researcher(x)) ::: Anyone who treats patients is a researcher",
            "∀x (Researcher(x) → Publishes(x, y)) ::: All researchers publish papers",
            "∀x (Publishes(x, y) → Studies(x, Science)) ::: If someone publishes a paper, then they study science",
            "Studies(smith, Science) ::: Dr. Smith studies science",
            "∀x (Studies(x, Science) → WritesReport(x, y)) ::: Anyone who studies science writes reports",
            "∀x (WritesReport(x, y) → ExpertIn(x, z)) ::: If someone writes a report then they are an expert in a field",
            "∀x (ExpertIn(x, z) → Employed(x)) ::: If someone is an expert then they are employed",
            "∀x (Employed(x) → Doctor(x)) ::: If someone is employed then they are a doctor"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Employed(x) ::: x is employed",
            "SpecializesIn(x, y) ::: x specializes in y",
            "HasDegree(x, y) ::: x has a degree in y",
            "TreatsPatient(x, y) ::: x treats patient y",
            "IsRegistered(x) ::: x is registered",
            "Researcher(x) ::: x is a researcher",
            "Publishes(x, y) ::: x publishes y",
            "Studies(x, y) ::: x studies y",
            "WritesReport(x, y) ::: x writes report y",
            "ExpertIn(x, y) ::: x is an expert in y"
        ]
    },
    {
        "premises-NL": [
            "All mammals are warm-blooded.",
            "Some animals are mammals.",
            "If something is an animal and a mammal then it eats plants.",
            "Animals that eat plants live in forests.",
            "All herbivores eat plants.",
            "If something is a carnivore then it eats meat.",
            "All mammals have fur.",
            "Animals that have fur don't migrate.",
            "If something migrates then it is not endangered.",
            "All mammals protect their young.",
            "Animals that are aquatic don't have fur.",
            "If something can fly, it has wings.",
            "If an animal is a mammal and has fur, it is not nocturnal.",
            "All reptiles are not mammals.",
            "If an animal is a mammal then it is not a reptile.",
            "If something is warm-blooded, it is an animal."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → WarmBlooded(x)) ::: All mammals are warm-blooded",
            "∃x (Animal(x) ∧ Mammal(x)) ::: Some animals are mammals",
            "∀x (Animal(x) ∧ Mammal(x) → Eats(x, Plants)) ::: If something is an animal and a mammal then it eats plants",
            "∀x (Eats(x, Plants) → LivesIn(x, Forests)) ::: Animals that eat plants live in forests",
            "∀x (Herbivore(x) → Eats(x, Plants)) ::: All herbivores eat plants",
            "∀x (Carnivore(x) → Eats(x, Meat)) ::: If something is a carnivore then it eats meat",
            "∀x (Mammal(x) → HasFur(x)) ::: All mammals have fur",
            "∀x (HasFur(x) → ¬Migrates(x)) ::: Animals that have fur don't migrate",
            "∀x (Migrates(x) → ¬IsEndangered(x)) ::: If something migrates then it is not endangered",
            "∀x (Mammal(x) → ProtectsYoung(x)) ::: All mammals protect their young",
            "∀x (IsAquatic(x) → ¬HasFur(x)) ::: Animals that are aquatic don't have fur",
            "∀x (CanFly(x) → HasWings(x)) ::: If something can fly, it has wings",
            "∀x (Mammal(x) ∧ HasFur(x) → ¬IsNocturnal(x)) ::: If an animal is a mammal and has fur, it is not nocturnal",
            "∀x (Reptile(x) → ¬Mammal(x)) ::: All reptiles are not mammals",
            "∀x (Mammal(x) → ¬Reptile(x)) ::: If an animal is a mammal then it is not a reptile",
            "∀x (WarmBlooded(x) → Animal(x)) ::: If something is warm-blooded, it is an animal"
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal",
            "WarmBlooded(x) ::: x is warm-blooded",
            "Animal(x) ::: x is an animal",
            "Eats(x, y) ::: x eats y",
            "LivesIn(x, y) ::: x lives in y",
            "IsHerbivore(x) ::: x is a herbivore",
            "IsCarnivore(x) ::: x is a carnivore",
            "HasFur(x) ::: x has fur",
            "Migrates(x) ::: x migrates",
            "IsEndangered(x) ::: x is endangered",
            "ProtectsYoung(x) ::: x protects young",
            "IsAquatic(x) ::: x is aquatic",
            "CanFly(x) ::: x can fly",
            "HasWings(x) ::: x has wings",
            "IsNocturnal(x) ::: x is nocturnal",
            "IsReptile(x) ::: x is a reptile"
        ]
    },
    {
        "premises-NL": [
            "All scientists are curious.",
            "Some curious people are successful.",
            "Anyone who publishes papers is a scientist.",
            "If someone reads a lot of books, then they are curious.",
            "Anyone who works at a university is a scientist.",
            "Those who study history are not scientists.",
            "Curious people design experiments.",
            "Anyone who designs experiments analyzes data.",
            "If someone analyzes data, they present their findings.",
            "Successful people gain funding.",
            "Anyone who teaches is curious.",
            "Those who write books are not scientists.",
            "If someone is a scientist, they attend conferences.",
            "Anyone who attends conferences collaborates with others.",
            "If someone gains funding, they are successful.",
            "If someone is successful, then they publish papers.",
            "Those who study science are scientists."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Curious(x)) ::: All scientists are curious",
            "∃x (Curious(x) ∧ Successful(x)) ::: Some curious people are successful",
            "∀x (Publishes(x, y) → Scientist(x)) ::: Anyone who publishes papers is a scientist",
            "∀x (Reads(x, y) → Curious(x)) ::: If someone reads a lot of books, then they are curious",
            "∀x (WorksAt(x, University) → Scientist(x)) ::: Anyone who works at a university is a scientist",
            "∀x (Studies(x, History) → ¬Scientist(x)) ::: Those who study history are not scientists",
            "∀x (Curious(x) → DesignsExperiment(x)) ::: Curious people design experiments",
            "∀x (DesignsExperiment(x) → AnalyzesData(x)) ::: Anyone who designs experiments analyzes data",
            "∀x (AnalyzesData(x) → PresentsFindings(x)) ::: If someone analyzes data, they present their findings",
            "∀x (Successful(x) → GainsFunding(x)) ::: Successful people gain funding",
            "∀x (Teaches(x, y) → Curious(x)) ::: Anyone who teaches is curious",
            "∀x (WritesBook(x) → ¬Scientist(x)) ::: Those who write books are not scientists",
            "∀x (Scientist(x) → AttendsConference(x)) ::: If someone is a scientist, they attend conferences",
            "∀x (AttendsConference(x) → CollaboratesWith(x, y)) ::: Anyone who attends conferences collaborates with others",
            "∀x (GainsFunding(x) → Successful(x)) ::: If someone gains funding, they are successful",
            "∀x (Successful(x) → Publishes(x, y)) ::: If someone is successful, then they publish papers",
            "∀x (Studies(x, Science) → Scientist(x)) ::: Those who study science are scientists"
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Curious(x) ::: x is curious",
            "Successful(x) ::: x is successful",
            "Publishes(x, y) ::: x publishes y",
            "Reads(x, y) ::: x reads y",
            "WorksAt(x, y) ::: x works at y",
            "Studies(x, y) ::: x studies y",
            "IsInnovative(x) ::: x is innovative",
            "CollaboratesWith(x, y) ::: x collaborates with y",
            "AttendsConference(x) ::: x attends conference",
            "GainsFunding(x) ::: x gains funding",
            "Teaches(x, y) ::: x teaches y",
            "WritesBook(x) ::: x writes a book",
            "DesignsExperiment(x) ::: x designs an experiment",
            "AnalyzesData(x) ::: x analyzes data",
            "PresentsFindings(x) ::: x presents findings",
            "AllScientists are curious.",
            "Some curious people are successful.",
            "Anyone who publishes papers is a scientist.",
            "If someone reads a lot of books, then they are curious.",
            "Anyone who works at a university is a scientist.",
            "Those who study history are not scientists.",
            "Curious people design experiments.",
            "Anyone who designs experiments analyzes data.",
            "If someone analyzes data, they present their findings.",
            "Successful people gain funding.",
            "Anyone who teaches is curious.",
            "Those who write books are not scientists.",
            "If someone is a scientist, they attend conferences.",
            "Anyone who attends conferences collaborates with others.",
            "If someone gains funding, they are successful.",
            "If someone is successful, then they publish papers.",
            "Those who study science are scientists."
        ]
    },
    {
        "premises-NL": [
            "All artists are creative.",
            "Some creative people are also musicians.",
            "If someone paints, they are creative.",
            "If someone writes, they are an artist.",
            "Anyone who plays a musical instrument is a musician.",
            "If someone sings, they enjoy music.",
            "People who enjoy music attend concerts.",
            "Those who study art are artists.",
            "Those who teach music are musicians.",
            "If someone composes music, they are creative.",
            "Anyone who designs things is an artist.",
            "If someone plays in a band, they are a musician.",
            "Musicians write lyrics.",
            "People who read books are creative.",
            "Creative people create sculptures.",
            "Anyone who paints pictures is an artist.",
            "Anyone who is a musician, studies art, and writes lyrics, must be an artist.",
            "Anyone who is a artist and composes music is creative."
        ],
        "premises-FOL": [
            "∀x (Artist(x) → Creative(x)) ::: All artists are creative",
            "∃x (Creative(x) ∧ Musician(x)) ::: Some creative people are also musicians",
            "∀x (Paints(x, y) → Creative(x)) ::: If someone paints, they are creative",
            "∀x (Writes(x, y) → Artist(x)) ::: If someone writes, they are an artist",
            "∀x (PlaysInstrument(x, y) → Musician(x)) ::: Anyone who plays a musical instrument is a musician",
            "∀x (Sings(x) → EnjoysMusic(x)) ::: If someone sings, they enjoy music",
            "∀x (EnjoysMusic(x) → AttendsConcerts(x)) ::: People who enjoy music attend concerts",
            "∀x (StudiesArt(x) → Artist(x)) ::: Those who study art are artists",
            "∀x (TeachesMusic(x, y) → Musician(x)) ::: Those who teach music are musicians",
            "∀x (Composes(x, y) → Creative(x)) ::: If someone composes music, they are creative",
            "∀x (Designs(x, y) → Artist(x)) ::: Anyone who designs things is an artist",
            "∀x (PlaysInBand(x, y) → Musician(x)) ::: If someone plays in a band, they are a musician",
            "∀x (Musician(x) → WritesLyrics(x, y)) ::: Musicians write lyrics",
            "∀x (ReadsBooks(x) → Creative(x)) ::: People who read books are creative",
            "∀x (Creative(x) → CreatesSculptures(x)) ::: Creative people create sculptures",
            "∀x (PaintsPictures(x, y) → Artist(x)) ::: Anyone who paints pictures is an artist",
            "∀x (Musician(x) ∧ StudiesArt(x) ∧ WritesLyrics(x, y) → Artist(x)) ::: Anyone who is a musician, studies art, and writes lyrics, must be an artist",
            "∀x (Artist(x) ∧ Composes(x, y) → Creative(x)) ::: Anyone who is a artist and composes music is creative"
        ],
        "predicates": [
            "Artist(x) ::: x is an artist",
            "Creative(x) ::: x is creative",
            "Musician(x) ::: x is a musician",
            "Paints(x, y) ::: x paints y",
            "Writes(x, y) ::: x writes y",
            "PlaysInstrument(x, y) ::: x plays instrument y",
            "Sings(x) ::: x sings",
            "EnjoysMusic(x) ::: x enjoys music",
            "AttendsConcerts(x) ::: x attends concerts",
            "StudiesArt(x) ::: x studies art",
            "TeachesMusic(x) ::: x teaches music",
            "Composes(x, y) ::: x composes y",
            "Designs(x, y) ::: x designs y",
            "PlaysInBand(x, y) ::: x plays in band y",
            "WritesLyrics(x, y) ::: x writes lyrics y",
            "ReadsBooks(x) ::: x reads books",
            "CreatesSculptures(x) ::: x creates sculptures",
            "PaintsPictures(x) ::: x paints pictures"
        ]
    },
    {
        "premises-NL": [
            "All students are smart or attend university.",
            "Some students study hard.",
            "All smart students succeed.",
            "Those who attend university are students.",
            "Some people who study hard are students.",
            "Anyone who attends university studies hard.",
            "If someone is smart they will study hard.",
            "Anyone who is a student who studies hard is also smart.",
            "Anyone who is smart succeeds."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (IsSmart(x) ∨ AttendsUniversity(x))) ::: All students are smart or attend university.",
            "∃x (Student(x) ∧ StudiesHard(x)) ::: Some students study hard.",
            "∀x (IsSmart(x) → Succeeds(x)) ::: All smart students succeed.",
            "∀x (AttendsUniversity(x) → Student(x)) ::: Those who attend university are students.",
            "∃x (StudiesHard(x) ∧ Student(x)) ::: Some people who study hard are students.",
            "∀x (AttendsUniversity(x) → StudiesHard(x)) ::: Anyone who attends university studies hard.",
            "∀x (IsSmart(x) → StudiesHard(x)) ::: If someone is smart they will study hard.",
            "∀x (Student(x) ∧ StudiesHard(x) → IsSmart(x)) ::: Anyone who is a student who studies hard is also smart.",
            "∀x (IsSmart(x) → Succeeds(x)) ::: Anyone who is smart succeeds."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "Succeeds(x) ::: x succeeds",
            "AttendsUniversity(x) ::: x attends university",
            "IsSmart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All researchers attend conferences or get funding.",
            "Some researchers publish papers.",
            "All researchers who attend conferences are productive.",
            "Productive researchers advance their career.",
            "Some people who publish papers are researchers.",
            "Anyone who attends conferences gets funding.",
            "If someone publishes papers they are productive.",
            "Anyone who is a researcher who publishes papers gets funding.",
            "Anyone who gets funding and publishes papers is also productive.",
            "Anyone who is productive will advance their career."
        ],
        "premises-FOL": [
            "∀x (Researcher(x) → (AttendsConferences(x) ∨ GetsFunding(x))) ::: All researchers attend conferences or get funding.",
            "∃x (Researcher(x) ∧ PublishesPapers(x)) ::: Some researchers publish papers.",
            "∀x (Researcher(x) ∧ AttendsConferences(x) → IsProductive(x)) ::: All researchers who attend conferences are productive.",
            "∀x (IsProductive(x) → AdvancesCareer(x)) ::: Productive researchers advance their career.",
            "∃x (PublishesPapers(x) ∧ Researcher(x)) ::: Some people who publish papers are researchers.",
            "∀x (AttendsConferences(x) → GetsFunding(x)) ::: Anyone who attends conferences gets funding.",
            "∀x (PublishesPapers(x) → IsProductive(x)) ::: If someone publishes papers they are productive.",
            "∀x (Researcher(x) ∧ PublishesPapers(x) → GetsFunding(x)) ::: Anyone who is a researcher who publishes papers gets funding.",
            "∀x (GetsFunding(x) ∧ PublishesPapers(x) → IsProductive(x)) ::: Anyone who gets funding and publishes papers is also productive.",
            "∀x (IsProductive(x) → AdvancesCareer(x)) ::: Anyone who is productive will advance their career."
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher",
            "GetsFunding(x) ::: x gets funding",
            "PublishesPapers(x) ::: x publishes papers",
            "AttendsConferences(x) ::: x attends conferences",
            "IsProductive(x) ::: x is productive",
            "AdvancesCareer(x) ::: x advances their career"
        ]
    },
    {
        "premises-NL": [
            "All scientists conduct experiments or collect samples.",
            "Some scientists use equipment.",
            "Anyone who uses equipment will publish a paper.",
            "If someone collects samples they analyze the data.",
            "All scientists write reports.",
            "Those who analyze data attend conferences.",
            "If someone attends conferences, they receive funding.",
            "Anyone who receives funding is successful.",
            "If someone is successful and writes reports then they conduct experiments.",
            "Some scientists collaborate with others.",
            "Anyone who publishes a paper reviews papers.",
            "Scientists who write reports have a theory and do experiments.",
            "Anyone who analyzes data is successful."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → (ConductsExperiments(x) ∨ CollectsSamples(x))) ::: All scientists conduct experiments or collect samples.",
            "∃x (Scientist(x) ∧ UsesEquipment(x)) ::: Some scientists use equipment.",
            "∀x (UsesEquipment(x) → PublishesPaper(x)) ::: Anyone who uses equipment will publish a paper.",
            "∀x (CollectsSamples(x) → AnalyzesData(x)) ::: If someone collects samples they analyze the data.",
            "∀x (Scientist(x) → WritesReports(x)) ::: All scientists write reports.",
            "∀x (AnalyzesData(x) → AttendsConferences(x)) ::: Those who analyze data attend conferences.",
            "∀x (AttendsConferences(x) → ReceivesFunding(x)) ::: If someone attends conferences, they receive funding.",
            "∀x (ReceivesFunding(x) → IsSuccessful(x)) ::: Anyone who receives funding is successful.",
            "∀x (IsSuccessful(x) ∧ WritesReports(x) → ConductsExperiments(x)) ::: If someone is successful and writes reports then they conduct experiments.",
            "∃x ∃y (Scientist(x) ∧ Collaborates(x, y)) ::: Some scientists collaborate with others.",
            "∀x (PublishesPaper(x) → ReviewsPapers(x)) ::: Anyone who publishes a paper reviews papers.",
            "∀x (Scientist(x) ∧ WritesReports(x) → (HasTheory(x) ∧ ConductsExperiments(x))) ::: Scientists who write reports have a theory and do experiments.",
            "∀x (AnalyzesData(x) → IsSuccessful(x)) ::: Anyone who analyzes data is successful."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "ConductsExperiments(x) ::: x conducts experiments",
            "AnalyzesData(x) ::: x analyzes data",
            "CollectsSamples(x) ::: x collects samples",
            "UsesEquipment(x) ::: x uses equipment",
            "PublishesPaper(x) ::: x publishes a paper",
            "WritesReports(x) ::: x writes reports",
            "AttendsConferences(x) ::: x attends conferences",
            "ReceivesFunding(x) ::: x receives funding",
            "IsSuccessful(x) ::: x is successful",
            "Collaborates(x, y) ::: x collaborates with y",
            "ReviewsPapers(x) ::: x reviews papers",
            "HasTheory(x) ::: x has a theory"
        ]
    },
    {
        "premises-NL": [
            "All plants are green.",
            "Anything that is green is alive.",
            "Anything that is alive needs nutrients.",
            "All plants require sunlight.",
            "All plants require water.",
            "A plant has sunlight if it requires sunlight.",
            "A plant has water if it requires water.",
            "Something is a plant.",
            "If a plant grows, it becomes tall.",
            "John is a plant."
        ],
        "premises-FOL": [
            "∀x (Plant(x) → IsGreen(x)) ::: All plants are green.",
            "∀x (IsGreen(x) → IsAlive(x)) ::: Anything that is green is alive.",
            "∀x (IsAlive(x) → NeedsNutrients(x)) ::: Anything that is alive needs nutrients.",
            "∀x (Plant(x) → RequiresSunlight(x)) ::: All plants require sunlight.",
            "∀x (Plant(x) → RequiresWater(x)) ::: All plants require water.",
            "∀x (Plant(x) ∧ RequiresSunlight(x) → HasSunlight(x)) ::: A plant has sunlight if it requires sunlight.",
            "∀x (Plant(x) ∧ RequiresWater(x) → HasWater(x)) ::: A plant has water if it requires water.",
            "∃x Plant(x) ::: Something is a plant.",
            "∀x (Plant(x) ∧ Grows(x) → IsTall(x)) ::: If a plant grows, it becomes tall.",
            "Plant(John) ::: John is a plant."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "HasSunlight(x) ::: x has sunlight",
            "HasWater(x) ::: x has water",
            "Grows(x) ::: x grows",
            "IsGreen(x) ::: x is green",
            "IsTall(x) ::: x is tall",
            "RequiresSunlight(x) ::: x requires sunlight",
            "RequiresWater(x) ::: x requires water",
            "IsAlive(x) ::: x is alive",
            "NeedsNutrients(x) ::: x needs nutrients"
        ]
    },
    {
        "premises-NL": [
            "All professors are researchers.",
            "All researchers publish papers.",
            "Some papers are cited frequently.",
            "Dr. Smith is a professor.",
            "All professors are also professors."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Researcher(x)) ::: All professors are researchers.",
            "∀x ∃y (Researcher(x) → Publishes(x, y)) ::: All researchers publish papers.",
            "∃x (Paper(x) ∧ CitedFrequently(x)) ::: Some papers are cited frequently.",
            "Professor(Smith) ::: Dr. Smith is a professor.",
            "∀x (Professor(x) → Professor(x)) ::: All professors are also professors."
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher",
            "Professor(x) ::: x is a professor",
            "Publishes(x, y) ::: x publishes y",
            "Paper(x) ::: x is a paper"
        ]
    },
    {
        "premises-NL": [
            "Everyone is either rich or poor.",
            "No rich person is happy.",
            "Some poor people are happy.",
            "John is poor.",
            "Mary is rich.",
            "John owns a car.",
            "Mary owns a house.",
            "If someone is poor and owns a car, then they are happy.",
            "If someone is rich and owns a house, then they are happy."
        ],
        "premises-FOL": [
            "∀x (Rich(x) ∨ Poor(x)) ::: Everyone is either rich or poor.",
            "∀x (Rich(x) → ¬Happy(x)) ::: No rich person is happy.",
            "∃x (Poor(x) ∧ Happy(x)) ::: Some poor people are happy.",
            "Poor(John) ::: John is poor.",
            "Rich(Mary) ::: Mary is rich.",
            "Owns(John, car) ::: John owns a car.",
            "Owns(Mary, house) ::: Mary owns a house.",
            "∀x ∀y ((Poor(x) ∧ Owns(x, y)) → Happy(x)) ::: If someone is poor and owns a car, then they are happy.",
            "∀x ∀y ((Rich(x) ∧ Owns(x, y)) → Happy(x)) ::: If someone is rich and owns a house, then they are happy.",
            "Happy(x) ∨ ¬Happy(x) ::: Someone is either happy or not happy.",
            "Happy(John) ∨ Happy(Mary) ::: Either John or Mary is happy.",
            "Happy(Mary) ∨ Happy(John) ::: Either Mary or John is happy.",
            "Happy(Mary) ∨ ¬Happy(John) ::: Either Mary is happy or John isn't"
        ],
        "predicates": [
            "Happy(x) ::: x is happy",
            "Rich(x) ::: x is rich",
            "Poor(x) ::: x is poor",
            "Owns(x, y) ::: x owns y"
        ]
    },
    {
        "premises-NL": [
            "All students are either smart or not smart.",
            "All students who study pass the exam.",
            "If someone is smart and doesn't study, they will fail the exam.",
            "If someone is not smart and doesn't study, they will fail the exam.",
            "Some students don't pass the exam.",
            "John is a student.",
            "Mary is a student.",
            "No one is both smart and not smart.",
            "Everyone who passes the exam studies.",
            "If someone is smart, then they will pass the exam.",
            "If someone is not smart, then they will fail the exam.",
            "Some students are smart.",
            "Some students are not smart.",
            "John does not pass the exam.",
            "Mary fails the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Smart(x) ∨ ¬Smart(x))) ::: All students are either smart or not smart.",
            "∀x ((Student(x) ∧ Studies(x)) → PassesExam(x)) ::: All students who study pass the exam.",
            "∀x (((Smart(x) ∧ ¬Studies(x))) → FailsExam(x)) ::: If someone is smart and doesn't study, they will fail the exam.",
            "∀x (((¬Smart(x) ∧ ¬Studies(x))) → FailsExam(x)) ::: If someone is not smart and doesn't study, they will fail the exam.",
            "∃x (Student(x) ∧ ¬PassesExam(x)) ::: Some students don't pass the exam.",
            "Student(John) ::: John is a student.",
            "Student(Mary) ::: Mary is a student.",
            "¬∃x (Smart(x) ∧ ¬Smart(x)) ::: No one is both smart and not smart.",
            "∀x (PassesExam(x) → Studies(x)) ::: Everyone who passes the exam studies.",
            "∀x (Smart(x) → PassesExam(x)) ::: If someone is smart, then they will pass the exam.",
            "∀x (¬Smart(x) → FailsExam(x)) ::: If someone is not smart, then they will fail the exam.",
            "∃x (Student(x) ∧ Smart(x)) ::: Some students are smart.",
            "∃x (Student(x) ∧ ¬Smart(x)) ::: Some students are not smart.",
            "¬PassesExam(John) ::: John does not pass the exam.",
            "FailsExam(Mary) ::: Mary fails the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "PassesExam(x) ::: x passes the exam",
            "Smart(x) ::: x is smart",
            "FailsExam(x) ::: x fails the exam"
        ]
    },
    {
        "premises-NL": [
            "Everyone is either wealthy or poor.",
            "All wealthy people own a house.",
            "All wealthy people own a car.",
            "No poor person owns both a house and a car.",
            "Some people are employed by wealthy people.",
            "John is wealthy.",
            "Mary is poor.",
            "If someone drives a car, they own a car.",
            "If someone drives a house, they own a house.",
            "All wealthy people drive a car.",
            "All poor people drive a house.",
            "John employs someone.",
            "Mary does not employ anyone.",
            "If someone is wealthy, they drive a car or a house.",
            "If someone is poor, they drive a car or a house."
        ],
        "premises-FOL": [
            "∀x (Wealthy(x) ∨ Poor(x)) ::: Everyone is either wealthy or poor.",
            "∀x (Wealthy(x) → Owns(x, house)) ::: All wealthy people own a house.",
            "∀x (Wealthy(x) → Owns(x, car)) ::: All wealthy people own a car.",
            "¬∃x (Poor(x) ∧ Owns(x, house) ∧ Owns(x, car)) ::: No poor person owns both a house and a car.",
            "∃x ∃y (Employs(x, y) ∧ Wealthy(x)) ::: Some people are employed by wealthy people.",
            "Wealthy(John) ::: John is wealthy.",
            "Poor(Mary) ::: Mary is poor.",
            "∀x ∀y (Drives(x, y) → Owns(x, y)) ::: If someone drives a car, they own a car.",
            "∀x ∀y (Drives(x, y) → Owns(x, y)) ::: If someone drives a house, they own a house.",
            "∀x (Wealthy(x) → Drives(x, car)) ::: All wealthy people drive a car.",
            "∀x (Poor(x) → Drives(x, house)) ::: All poor people drive a house.",
            "∃x Employs(John, x) ::: John employs someone.",
            "¬∃x Employs(Mary, x) ::: Mary does not employ anyone.",
            "∀x (Wealthy(x) → (Drives(x, car) ∨ Drives(x, house))) ::: If someone is wealthy, they drive a car or a house.",
            "∀x (Poor(x) → (Drives(x, car) ∨ Drives(x, house))) ::: If someone is poor, they drive a car or a house.",
            "∃x Owns(John, x) ::: John owns something."
        ],
        "predicates": [
            "Owns(x, y) ::: x owns y",
            "Wealthy(x) ::: x is wealthy",
            "Poor(x) ::: x is poor",
            "Employs(x, y) ::: x employs y",
            "Car(x) ::: x is a car",
            "House(x) ::: x is a house",
            "Drives(x, y) ::: x drives y"
        ]
    },
    {
        "premises-NL": [
            "All students take an exam.",
            "Anyone who takes an exam studies.",
            "Some students are not lazy.",
            "Students who pass the exam are not lazy.",
            "If someone studies, they either pass the exam or are lazy.",
            "If someone does not pass the exam, they are lazy."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakesExam(x)) ::: All students take an exam.",
            "∀x (TakesExam(x) → Studies(x)) ::: Anyone who takes an exam studies.",
            "∃x (Student(x) ∧ ¬Lazy(x)) ::: Some students are not lazy.",
            "∀x ((Student(x) ∧ PassesExam(x)) → ¬Lazy(x)) ::: Students who pass the exam are not lazy.",
            "∀x (Studies(x) → (PassesExam(x) ∨ Lazy(x))) ::: If someone studies, they either pass the exam or are lazy.",
            "∀x (¬PassesExam(x) → Lazy(x)) ::: If someone does not pass the exam, they are lazy."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "TakesExam(x) ::: x takes an exam",
            "PassesExam(x) ::: x passes an exam"
        ]
    },
    {
        "premises-NL": [
            "All plants are alive.",
            "All plants need nutrients.",
            "If something is alive and needs nutrients, it grows.",
            "Some plants receive sunlight.",
            "Every plant that receives sunlight is green.",
            "If a plant is green, it receives water.",
            "Some plants get nutrients from the soil.",
            "Anything that gets nutrients from the soil is a plant."
        ],
        "premises-FOL": [
            "∀x (Plant(x) → IsAlive(x)) ::: All plants are alive.",
            "∀x (Plant(x) → NeedsNutrients(x)) ::: All plants need nutrients.",
            "∀x ((IsAlive(x) ∧ NeedsNutrients(x)) → Grows(x)) ::: If something is alive and needs nutrients, it grows.",
            "∃x (Plant(x) ∧ ReceivesSunlight(x)) ::: Some plants receive sunlight.",
            "∀x (ReceivesSunlight(x) → ReceivesWater(x)) ::: Every plant that receives sunlight is green.",
            "∀x (IsGreen(x) → ReceivesWater(x)) ::: If a plant is green, it receives water.",
            "∃x ∃y (Plant(x) ∧ GetsNutrientsFrom(x, y)) ::: Some plants get nutrients from the soil.",
            "∀x ∀y (GetsNutrientsFrom(x, y) → Plant(x)) ::: Anything that gets nutrients from the soil is a plant."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "ReceivesSunlight(x) ::: x receives sunlight",
            "ReceivesWater(x) ::: x receives water",
            "Grows(x) ::: x grows",
            "IsAlive(x) ::: x is alive",
            "NeedsNutrients(x) ::: x needs nutrients",
            "IsGreen(x) ::: x is green",
            "GetsNutrientsFrom(x,y) ::: x gets nutrients from y"
        ]
    },
    {
        "premises-NL": [
            "Every student is smart.",
            "If someone is a student, then they study hard.",
            "If someone is smart and studies hard, then they are a genius.",
            "Alice is a student.",
            "Bob is a student.",
            "Alice is smart.",
            "Bob studies hard.",
            "If someone is a student and studies hard, then they are smart.",
            "Charlie is a student.",
            "Dave is a student.",
            "Charlie studies hard.",
            "Dave is smart.",
            "If someone is a student, then they are smart or they study hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: Every student is smart.",
            "∀x (Student(x) → StudiesHard(x)) ::: If someone is a student, then they study hard.",
            "∀x ((Smart(x) ∧ StudiesHard(x)) → Genius(x)) ::: If someone is smart and studies hard, then they are a genius.",
            "Student(Alice) ::: Alice is a student.",
            "Student(Bob) ::: Bob is a student.",
            "Smart(Alice) ::: Alice is smart.",
            "StudiesHard(Bob) ::: Bob studies hard.",
            "∀x ((Student(x) ∧ StudiesHard(x)) → Smart(x)) ::: If someone is a student and studies hard, then they are smart.",
            "Student(Charlie) ::: Charlie is a student.",
            "Student(Dave) ::: Dave is a student.",
            "StudiesHard(Charlie) ::: Charlie studies hard.",
            "Smart(Dave) ::: Dave is smart.",
            "∀x (Student(x) → (Smart(x) ∨ StudiesHard(x))) ::: If someone is a student, then they are smart or they study hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Smart(x) ::: x is smart.",
            "StudiesHard(x) ::: x studies hard.",
            "Genius(x) ::: x is a genius."
        ]
    },
    {
        "premises-NL": [
            "Everyone who studies medicine is a doctor.",
            "Everyone who studies law is a lawyer.",
            "If someone is a doctor or a lawyer, then they have a high salary.",
            "If someone studies medicine, then they are intelligent.",
            "If someone studies law, then they are intelligent.",
            "John studies medicine.",
            "Mary studies law.",
            "If someone is intelligent, then they can solve puzzles.",
            "If someone has a high salary, they work long hours.",
            "John is intelligent.",
            "Mary is intelligent.",
            "If someone solves puzzles, then they are smart.",
            "If someone studies law and medicine, they are smart.",
            "If someone has a high salary, they have a large house.",
            "If someone is smart, then they are not a doctor."
        ],
        "premises-FOL": [
            "∀x (StudiesMedicine(x) → Doctor(x)) ::: Everyone who studies medicine is a doctor.",
            "∀x (StudiesLaw(x) → Lawyer(x)) ::: Everyone who studies law is a lawyer.",
            "∀x ((Doctor(x) ∨ Lawyer(x)) → HighSalary(x)) ::: If someone is a doctor or a lawyer, then they have a high salary.",
            "∀x (StudiesMedicine(x) → Intelligent(x)) ::: If someone studies medicine, then they are intelligent.",
            "∀x (StudiesLaw(x) → Intelligent(x)) ::: If someone studies law, then they are intelligent.",
            "StudiesMedicine(John) ::: John studies medicine.",
            "StudiesLaw(Mary) ::: Mary studies law.",
            "∀x (Intelligent(x) → SolvesPuzzles(x)) ::: If someone is intelligent, then they can solve puzzles.",
            "∀x (HighSalary(x) → WorksLongHours(x)) ::: If someone has a high salary, they work long hours.",
            "Intelligent(John) ::: John is intelligent.",
            "Intelligent(Mary) ::: Mary is intelligent.",
            "∀x (SolvesPuzzles(x) → Smart(x)) ::: If someone solves puzzles, then they are smart.",
            "∀x ((StudiesLaw(x) ∧ StudiesMedicine(x)) → Smart(x)) ::: If someone studies law and medicine, they are smart.",
            "∀x (HighSalary(x) → HasLargeHouse(x)) ::: If someone has a high salary, they have a large house.",
            "∀x (Smart(x) → ¬Doctor(x)) ::: If someone is smart, then they are not a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Lawyer(x) ::: x is a lawyer.",
            "StudiesMedicine(x) ::: x studies medicine.",
            "StudiesLaw(x) ::: x studies law."
        ]
    },
    {
        "premises-NL": [
            "All apples are fruits.",
            "All fruits are either green or red.",
            "Apples are round.",
            "If something is round, it is not large.",
            "Some apples are green.",
            "If something is red, it is not green.",
            "No large thing is green.",
            "Some fruits are large.",
            "Every green thing is a fruit.",
            "Something is a fruit and large.",
            "Every apple is large or green.",
            "If something is a fruit and not large, then it is green.",
            "If something is an apple, it's also green or not large.",
            "Something is an apple."
        ],
        "premises-FOL": [
            "∀x (Apple(x) → IsFruit(x)) ::: All apples are fruits.",
            "∀x (IsFruit(x) → (Green(x) ∨ Red(x))) ::: All fruits are either green or red.",
            "∀x (Apple(x) → Round(x)) ::: Apples are round.",
            "∀x (Round(x) → ¬Large(x)) ::: If something is round, it is not large.",
            "∃x (Apple(x) ∧ Green(x)) ::: Some apples are green.",
            "∀x (Red(x) → ¬Green(x)) ::: If something is red, it is not green.",
            "∀x (¬Large(x) → ¬Green(x)) ::: No large thing is green.",
            "∃x (IsFruit(x) ∧ Large(x)) ::: Some fruits are large.",
            "∀x (Green(x) → IsFruit(x)) ::: Every green thing is a fruit.",
            "∃x (IsFruit(x) ∧ Large(x)) ::: Something is a fruit and large.",
            "∀x (Apple(x) → (Large(x) ∨ Green(x))) ::: Every apple is large or green.",
            "∀x ((IsFruit(x) ∧ ¬Large(x)) → Green(x)) ::: If something is a fruit and not large, then it is green.",
            "∀x (Apple(x) → (Green(x) ∨ ¬Large(x))) ::: If something is an apple, it's also green or not large.",
            "∃x Apple(x) ::: Something is an apple."
        ],
        "predicates": [
            "Green(x) ::: x is green.",
            "Large(x) ::: x is large.",
            "Round(x) ::: x is round.",
            "IsFruit(x) ::: x is a fruit."
        ]
    },
    {
        "premises-NL": [
            "If someone eats well and exercises, then they are healthy.",
            "If someone is healthy, then they are happy.",
            "If someone has friends, then they are happy.",
            "John eats well and exercises.",
            "If someone is not happy, they do not have friends.",
            "If someone does not eat well, then they are not healthy or they are not happy.",
            "If someone exercises, they eat well.",
            "If someone is not healthy, they do not eat well or do not exercise.",
            "If someone is happy, then they have friends.",
            "John is not happy.",
            "If someone is happy, then they exercise.",
            "Mary does not exercise.",
            "If someone eats well, they exercise and are not healthy or they are not happy.",
            "If someone is healthy and has friends, they are happy.",
            "If someone is not happy and has friends, then they are not healthy and exercise.",
            "Mary is not healthy."
        ],
        "premises-FOL": [
            "∀x ((EatsWell(x) ∧ Exercises(x)) → Healthy(x)) ::: If someone eats well and exercises, then they are healthy.",
            "∀x (Healthy(x) → Happy(x)) ::: If someone is healthy, then they are happy.",
            "∀x (HasFriends(x) → Happy(x)) ::: If someone has friends, then they are happy.",
            "EatsWell(John) ∧ Exercises(John) ::: John eats well and exercises.",
            "∀x (¬Happy(x) → ¬HasFriends(x)) ::: If someone is not happy, they do not have friends.",
            "∀x (¬EatsWell(x) → (¬Healthy(x) ∨ ¬Happy(x))) ::: If someone does not eat well, then they are not healthy or they are not happy.",
            "∀x (Exercises(x) → EatsWell(x)) ::: If someone exercises, they eat well.",
            "∀x (¬Healthy(x) → (¬EatsWell(x) ∨ ¬Exercises(x))) ::: If someone is not healthy, they do not eat well or do not exercise.",
            "∀x (Happy(x) → HasFriends(x)) ::: If someone is happy, then they have friends.",
            "¬Happy(John) ::: John is not happy.",
            "∀x (Happy(x) → Exercises(x)) ::: If someone is happy, then they exercise.",
            "¬Exercises(Mary) ::: Mary does not exercise.",
            "∀x (EatsWell(x) → (Exercises(x) ∧ (¬Healthy(x) ∨ ¬Happy(x)))) ::: If someone eats well, they exercise and are not healthy or they are not happy.",
            "∀x ((Healthy(x) ∧ HasFriends(x)) → Happy(x)) ::: If someone is healthy and has friends, they are happy.",
            "∀x ((¬Happy(x) ∧ HasFriends(x)) → (¬Healthy(x) ∧ Exercises(x))) ::: If someone is not happy and has friends, then they are not healthy and exercise.",
            "¬Healthy(Mary) ::: Mary is not healthy."
        ],
        "predicates": [
            "Healthy(x) ::: x is healthy.",
            "Happy(x) ::: x is happy.",
            "EatsWell(x) ::: x eats well.",
            "Exercises(x) ::: x exercises.",
            "HasFriends(x) ::: x has friends."
        ]
    },
    {
        "premises-NL": [
            "All scientists are researchers.",
            "All researchers read books.",
            "If someone reads books, they understand concepts.",
            "Anyone who understands concepts is knowledgeable.",
            "All scientists read books.",
            "If x is a scientist then x is a researcher.",
            "If someone is a researcher, they understand concepts.",
            "If someone reads books, they are a scientist.",
            "If someone is a researcher, they are knowledgeable.",
            "If someone understands concepts, then they are a researcher.",
            "If someone is a scientist, they are knowledgeable.",
            "Researchers read books and understand concepts.",
            "If someone reads books, they are knowledgeable.",
            "If someone does not read books, they are not scientists.",
            "If someone is a researcher then they read books.",
            "If someone is a scientist and a researcher, they read books.",
            "Anyone who reads books is a scientist."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Researcher(x)) ::: All scientists are researchers.",
            "∀x (Researcher(x) → ReadsBooks(x)) ::: All researchers read books.",
            "∀x (ReadsBooks(x) → UnderstandsConcepts(x)) ::: If someone reads books, they understand concepts.",
            "∀x (UnderstandsConcepts(x) → Knowledgeable(x)) ::: Anyone who understands concepts is knowledgeable.",
            "∀x (Scientist(x) → ReadsBooks(x)) ::: All scientists read books.",
            "∀x (Scientist(x) → Researcher(x)) ::: If x is a scientist then x is a researcher.",
            "∀x (Researcher(x) → UnderstandsConcepts(x)) ::: If someone is a researcher, they understand concepts.",
            "∀x (ReadsBooks(x) → Scientist(x)) ::: If someone reads books, they are a scientist.",
            "∀x (Researcher(x) → Knowledgeable(x)) ::: If someone is a researcher, they are knowledgeable.",
            "∀x (UnderstandsConcepts(x) → Researcher(x)) ::: If someone understands concepts, then they are a researcher.",
            "∀x (Scientist(x) → Knowledgeable(x)) ::: If someone is a scientist, they are knowledgeable.",
            "∀x (Researcher(x) → (ReadsBooks(x) ∧ UnderstandsConcepts(x))) ::: Researchers read books and understand concepts.",
            "∀x (ReadsBooks(x) → Knowledgeable(x)) ::: If someone reads books, they are knowledgeable.",
            "∀x (¬ReadsBooks(x) → ¬Scientist(x)) ::: If someone does not read books, they are not scientists.",
            "∀x (Researcher(x) → ReadsBooks(x)) ::: If someone is a researcher then they read books.",
            "∀x ∀y ((Scientist(x) ∧ Researcher(x)) → ReadsBooks(x)) ::: If someone is a scientist and a researcher, they read books.",
            "∀x (ReadsBooks(x) → Scientist(x)) ::: Anyone who reads books is a scientist."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist.",
            "Knowledgeable(x) ::: x is knowledgeable.",
            "Researcher(x) ::: x is a researcher.",
            "ReadsBooks(x) ::: x reads books.",
            "UnderstandsConcepts(x) ::: x understands concepts."
        ]
    },
    {
        "premises-NL": [
            "All students who study hard like coffee.",
            "Alex is a student.",
            "If Alex likes coffee, then Alex studies hard.",
            "If a student studies hard, they will pass the exam.",
            "Alex likes coffee.",
            "Some students study hard.",
            "If a student is a student and likes coffee, they study hard.",
            "Every student who studies hard also likes coffee.",
            "Alex is a student who likes coffee.",
            "If a student passes the exam, then they are a student.",
            "Alex is a student and likes coffee."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ HardWork(x) → LikesCoffee(x)) ::: All students who study hard like coffee.",
            "Student(Alex) ::: Alex is a student.",
            "LikesCoffee(Alex) → HardWork(Alex) ::: If Alex likes coffee, then Alex studies hard.",
            "∀x (HardWork(x) → PassExam(x)) ::: If a student studies hard, they will pass the exam.",
            "LikesCoffee(Alex) ::: Alex likes coffee.",
            "∃x HardWork(x) ::: Some students study hard.",
            "∀x (Student(x) ∧ LikesCoffee(x) → HardWork(x)) ::: If a student is a student and likes coffee, they study hard.",
            "∀x (HardWork(x) → LikesCoffee(x)) ::: Every student who studies hard also likes coffee.",
            "Student(Alex) ∧ LikesCoffee(Alex) ::: Alex is a student who likes coffee.",
            "∀x (PassExam(x) → Student(x)) ::: If a student passes the exam, then they are a student.",
            "Student(Alex) ∧ LikesCoffee(Alex) ::: Alex is a student and likes coffee."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "HardWork(x) ::: x studies hard.",
            "PassExam(x) ::: x passes the exam.",
            "LikesCoffee(x) ::: x likes coffee."
        ]
    },
    {
        "premises-NL": [
            "If a patient has a fever and a cough, then they are sick.",
            "If a patient has a fever, they need medicine.",
            "If a patient has a fever and is not sick, then they do not have a cough.",
            "The patient has a fever.",
            "If a patient needs medicine, then they are sick.",
            "If a patient has a cough, they are sick.",
            "If a patient is sick, then they have a fever.",
            "If a patient has a fever or a cough, then they need medicine.",
            "If a patient has a cough, then they have a fever.",
            "The patient has a cough or does not have a cough.",
            "If the patient is sick, they need medicine.",
            "If a patient needs medicine, they have a fever.",
            "The patient has a cough."
        ],
        "premises-FOL": [
            "∀x (Fever(x) ∧ Cough(x) → Sick(x)) ::: If a patient has a fever and a cough, then they are sick.",
            "∀x (Fever(x) → NeedsMedicine(x)) ::: If a patient has a fever, they need medicine.",
            "∀x (Fever(x) ∧ ¬Sick(x) → ¬Cough(x)) ::: If a patient has a fever and is not sick, then they do not have a cough.",
            "Fever(Patient) ::: The patient has a fever.",
            "∀x (NeedsMedicine(x) → Sick(x)) ::: If a patient needs medicine, then they are sick.",
            "∀x (Cough(x) → Sick(x)) ::: If a patient has a cough, they are sick.",
            "∀x (Sick(x) → Fever(x)) ::: If a patient is sick, then they have a fever.",
            "∀x ((Fever(x) ∨ Cough(x)) → NeedsMedicine(x)) ::: If a patient has a fever or a cough, then they need medicine.",
            "∀x (Cough(x) → Fever(x)) ::: If a patient has a cough, then they have a fever.",
            "Cough(Patient) ∨ ¬Cough(Patient) ::: The patient has a cough or does not have a cough.",
            "∀x (Sick(x) → NeedsMedicine(x)) ::: If the patient is sick, they need medicine.",
            "∀x (NeedsMedicine(x) → Fever(x)) ::: If a patient needs medicine, they have a fever.",
            "Cough(Patient) ::: The patient has a cough."
        ],
        "predicates": [
            "Fever(x) ::: x has a fever.",
            "NeedsMedicine(x) ::: x needs medicine.",
            "Cough(x) ::: x has a cough.",
            "Sick(x) ::: x is sick."
        ]
    },
    {
        "premises-NL": [
            "All doctors help patients.",
            "If John is a doctor, then John studies medicine.",
            "If John is kind, then John helps patients.",
            "John is a doctor.",
            "If John studies medicine, then John is a doctor.",
            "If someone is a doctor, they are kind.",
            "John is kind.",
            "If someone studies medicine, then they are kind.",
            "If John is a doctor and studies medicine, then John is kind.",
            "If John is kind and studies medicine, then John is a doctor.",
            "John studies medicine.",
            "If someone helps patients, then they are kind.",
            "If John is a doctor, then he helps patients.",
            "If John is kind, then he is a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HelpsPatients(x)) ::: All doctors help patients.",
            "Doctor(John) → StudiesMedicine(John) ::: If John is a doctor, then John studies medicine.",
            "IsKind(John) → HelpsPatients(John) ::: If John is kind, then John helps patients.",
            "Doctor(John) ::: John is a doctor.",
            "StudiesMedicine(John) → Doctor(John) ::: If John studies medicine, then John is a doctor.",
            "∀x (Doctor(x) → IsKind(x)) ::: If someone is a doctor, they are kind.",
            "IsKind(John) ::: John is kind.",
            "∀x (StudiesMedicine(x) → IsKind(x)) ::: If someone studies medicine, then they are kind.",
            "Doctor(John) ∧ StudiesMedicine(John) → IsKind(John) ::: If John is a doctor and studies medicine, then John is kind.",
            "IsKind(John) ∧ StudiesMedicine(John) → Doctor(John) ::: If John is kind and studies medicine, then John is a doctor.",
            "StudiesMedicine(John) ::: John studies medicine.",
            "∀x (HelpsPatients(x) → IsKind(x)) ::: If someone helps patients, then they are kind.",
            "Doctor(John) → HelpsPatients(John) ::: If John is a doctor, then he helps patients.",
            "IsKind(John) → Doctor(John) ::: If John is kind, then he is a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "HelpsPatients(x) ::: x helps patients.",
            "StudiesMedicine(x) ::: x studies medicine.",
            "IsKind(x) ::: x is kind."
        ]
    },
    {
        "premises-NL": [
            "Everyone who exercises regularly is healthy.",
            "Someone who exercises regularly follows a balanced diet.",
            "No one who follows a balanced diet is a smoker.",
            "John exercises regularly.",
            "Anyone who exercises regularly is healthy.",
            "If someone exercises regularly, then they are not a smoker.",
            "If someone exercises regularly, they are not a smoker.",
            "If John exercises regularly, then John is not a smoker.",
            "No one who smokes is healthy.",
            "Some people exercise regularly.",
            "Someone who follows a balanced diet is healthy.",
            "If someone is healthy, they do not smoke.",
            "John follows a balanced diet."
        ],
        "premises-FOL": [
            "∀x (ExercisesRegularly(x) → Healthy(x)) ::: Everyone who exercises regularly is healthy.",
            "∃x (ExercisesRegularly(x) ∧ FollowsDiet(x)) ::: Someone who exercises regularly follows a balanced diet.",
            "∀x (FollowsDiet(x) → ¬Smoker(x)) ::: No one who follows a balanced diet is a smoker.",
            "ExercisesRegularly(john) ::: John exercises regularly.",
            "∀x (ExercisesRegularly(x) → Healthy(x)) ::: Anyone who exercises regularly is healthy.",
            "∀x (ExercisesRegularly(x) → ¬Smoker(x)) ::: If someone exercises regularly, then they are not a smoker.",
            "∀x (ExercisesRegularly(x) → ¬Smoker(x)) ::: If someone exercises regularly, they are not a smoker.",
            "¬Smoker(john) ::: If John exercises regularly, then John is not a smoker.",
            "∀x (Smoker(x) → ¬Healthy(x)) ::: No one who smokes is healthy.",
            "∃x ExercisesRegularly(x) ::: Some people exercise regularly.",
            "∃x (FollowsDiet(x) ∧ Healthy(x)) ::: Someone who follows a balanced diet is healthy.",
            "∀x (Healthy(x) → ¬Smoker(x)) ::: If someone is healthy, they do not smoke.",
            "FollowsDiet(john) ::: John follows a balanced diet."
        ],
        "predicates": [
            "Healthy(x) ::: x is healthy.",
            "Smoker(x) ::: x is a smoker.",
            "ExercisesRegularly(x) ::: x exercises regularly.",
            "FollowsDiet(x) ::: x follows a balanced diet."
        ]
    },
    {
        "premises-NL": [
            "Every employee who works hard is rewarded.",
            "Anyone who works hard receives a promotion.",
            "If someone is rewarded, then they are happy.",
            "John is an employee and works hard.",
            "If someone is rewarded, they are happy.",
            "Some employees are not rewarded.",
            "Everyone who receives a promotion is happy.",
            "John is an employee.",
            "Anyone who works hard is an employee.",
            "No one who works hard is unhappy.",
            "John works hard.",
            "Some employees are not happy.",
            "Some rewarded people are not happy.",
            "John receives a promotion."
        ],
        "premises-FOL": [
            "∀x ((Employee(x) ∧ WorksHard(x)) → IsRewarded(x)) ::: Every employee who works hard is rewarded.",
            "∀x (WorksHard(x) → ReceivesPromotion(x)) ::: Anyone who works hard receives a promotion.",
            "∀x (IsRewarded(x) → Happy(x)) ::: If someone is rewarded, then they are happy.",
            "Employee(john) ∧ WorksHard(john) ::: John is an employee and works hard.",
            "∀x (IsRewarded(x) → Happy(x)) ::: If someone is rewarded, they are happy.",
            "∃x (Employee(x) ∧ ¬IsRewarded(x)) ::: Some employees are not rewarded.",
            "∀x (ReceivesPromotion(x) → Happy(x)) ::: Everyone who receives a promotion is happy.",
            "Employee(john) ::: John is an employee.",
            "∀x (WorksHard(x) → Employee(x)) ::: Anyone who works hard is an employee.",
            "∀x (WorksHard(x) → ¬Happy(x)) ::: No one who works hard is unhappy.",
            "WorksHard(john) ::: John works hard.",
            "∃x (Employee(x) ∧ ¬Happy(x)) ::: Some employees are not happy.",
            "∃x (IsRewarded(x) ∧ ¬Happy(x)) ::: Some rewarded people are not happy.",
            "ReceivesPromotion(john) ::: John receives a promotion."
        ],
        "predicates": [
            "Employee(x) ::: x is an employee.",
            "Happy(x) ::: x is happy.",
            "WorksHard(x) ::: x works hard.",
            "ReceivesPromotion(x) ::: x receives a promotion.",
            "IsRewarded(x) ::: x is rewarded."
        ]
    },
    {
        "premises-NL": [
            "Every student who studies hard passes the exam.",
            "Anyone who passes the exam gets good grades.",
            "If someone gets good grades, then they like the subject.",
            "Alice is a student and studies hard.",
            "If someone likes the subject, they get good grades.",
            "Some students do not get good grades.",
            "Everyone who studies hard likes the subject.",
            "Alice is a student.",
            "Some students do not study hard.",
            "Alice studies hard.",
            "Everyone who passes the exam likes the subject.",
            "Alice passes the exam.",
            "Some who pass the exam do not like the subject.",
            "If Alice likes the subject, then Alice gets good grades.",
            "Alice gets good grades."
        ],
        "premises-FOL": [
            "∀x ((Student(x) ∧ StudiesHard(x)) → PassesExam(x)) ::: Every student who studies hard passes the exam.",
            "∀x (PassesExam(x) → GetsGoodGrades(x)) ::: Anyone who passes the exam gets good grades.",
            "∀x (GetsGoodGrades(x) → LikesSubject(x)) ::: If someone gets good grades, then they like the subject.",
            "Student(alice) ∧ StudiesHard(alice) ::: Alice is a student and studies hard.",
            "∀x (LikesSubject(x) → GetsGoodGrades(x)) ::: If someone likes the subject, they get good grades.",
            "∃x (Student(x) ∧ ¬GetsGoodGrades(x)) ::: Some students do not get good grades.",
            "∀x (StudiesHard(x) → LikesSubject(x)) ::: Everyone who studies hard likes the subject.",
            "Student(alice) ::: Alice is a student.",
            "∃x (Student(x) ∧ ¬StudiesHard(x)) ::: Some students do not study hard.",
            "StudiesHard(alice) ::: Alice studies hard.",
            "∀x (PassesExam(x) → LikesSubject(x)) ::: Everyone who passes the exam likes the subject.",
            "PassesExam(alice) ::: Alice passes the exam.",
            "∃x (PassesExam(x) ∧ ¬LikesSubject(x)) ::: Some who pass the exam do not like the subject.",
            "∀x (LikesSubject(alice) → GetsGoodGrades(alice)) ::: If Alice likes the subject, then Alice gets good grades.",
            "GetsGoodGrades(alice) ::: Alice gets good grades."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "LikesSubject(x) ::: x likes the subject.",
            "StudiesHard(x) ::: x studies hard.",
            "PassesExam(x) ::: x passes the exam.",
            "GetsGoodGrades(x) ::: x gets good grades."
        ]
    },
    {
        "premises-NL": [
            "Anyone who enjoys reading reads novels.",
            "Anyone who reads novels borrows books.",
            "If someone borrows books, then they do not dislike books.",
            "Bob enjoys reading.",
            "If someone enjoys reading, then they love libraries.",
            "Some who read novels dislike books.",
            "Everyone who borrows books loves libraries.",
            "Bob enjoys reading and reads novels.",
            "Bob reads novels.",
            "Anyone who loves libraries enjoys reading.",
            "Bob borrows books.",
            "If Bob reads novels, Bob borrows books.",
            "Bob reads novels and borrows books.",
            "Anyone who borrows books does not dislike books.",
            "Bob loves libraries.",
            "If someone borrows books, they do not dislike books."
        ],
        "premises-FOL": [
            "∀x (EnjoysReading(x) → ReadsNovels(x)) ::: Anyone who enjoys reading reads novels.",
            "∀x (ReadsNovels(x) → BorrowsBooks(x)) ::: Anyone who reads novels borrows books.",
            "∀x (BorrowsBooks(x) → ¬DislikesBooks(x)) ::: If someone borrows books, then they do not dislike books.",
            "EnjoysReading(bob) ::: Bob enjoys reading.",
            "∀x (EnjoysReading(x) → LovesLibraries(x)) ::: If someone enjoys reading, then they love libraries.",
            "∃x (ReadsNovels(x) ∧ DislikesBooks(x)) ::: Some who read novels dislike books.",
            "∀x (BorrowsBooks(x) → LovesLibraries(x)) ::: Everyone who borrows books loves libraries.",
            "EnjoysReading(bob) ∧ ReadsNovels(bob) ::: Bob enjoys reading and reads novels.",
            "ReadsNovels(bob) ::: Bob reads novels.",
            "∀x (LovesLibraries(x) → EnjoysReading(x)) ::: Anyone who loves libraries enjoys reading.",
            "BorrowsBooks(bob) ::: Bob borrows books.",
            "∀x (ReadsNovels(bob) → BorrowsBooks(bob)) ::: If Bob reads novels, Bob borrows books.",
            "ReadsNovels(bob) ∧ BorrowsBooks(bob) ::: Bob reads novels and borrows books.",
            "∀x (BorrowsBooks(x) → ¬DislikesBooks(x)) ::: Anyone who borrows books does not dislike books.",
            "LovesLibraries(bob) ::: Bob loves libraries.",
            "∀x (BorrowsBooks(x) → ¬DislikesBooks(x)) ::: If someone borrows books, they do not dislike books."
        ],
        "predicates": [
            "EnjoysReading(x) ::: x enjoys reading.",
            "DislikesBooks(x) ::: x dislikes books.",
            "ReadsNovels(x) ::: x reads novels.",
            "LovesLibraries(x) ::: x loves libraries.",
            "BorrowsBooks(x) ::: x borrows books."
        ]
    },
    {
        "premises-NL": [
            "Anyone who has a high income is rich.",
            "Anyone who owns an expensive car is rich.",
            "If someone is rich, then they invest in stocks.",
            "David has a high income.",
            "If someone is rich, then they are happy.",
            "Some people are rich and do not have high incomes.",
            "Anyone who invests in stocks is happy.",
            "David is rich.",
            "Some people are rich.",
            "David has a high income and owns an expensive car.",
            "David invests in stocks.",
            "If someone is happy, then they are rich.",
            "Some people who own expensive cars are happy.",
            "David owns an expensive car.",
            "Some people who invest in stocks are rich.",
            "If David has a high income, then David is happy.",
            "David is happy."
        ],
        "premises-FOL": [
            "∀x (HasHighIncome(x) → Rich(x)) ::: Anyone who has a high income is rich.",
            "∀x (OwnsExpensiveCar(x) → Rich(x)) ::: Anyone who owns an expensive car is rich.",
            "∀x (Rich(x) → InvestsInStocks(x)) ::: If someone is rich, then they invest in stocks.",
            "HasHighIncome(david) ::: David has a high income.",
            "∀x (Rich(x) → Happy(x)) ::: If someone is rich, then they are happy.",
            "∃x (Rich(x) ∧ ¬HasHighIncome(x)) ::: Some people are rich and do not have high incomes.",
            "∀x (InvestsInStocks(x) → Happy(x)) ::: Anyone who invests in stocks is happy.",
            "Rich(david) ::: David is rich.",
            "∃x Rich(x) ::: Some people are rich.",
            "HasHighIncome(david) ∧ OwnsExpensiveCar(david) ::: David has a high income and owns an expensive car.",
            "InvestsInStocks(david) ::: David invests in stocks.",
            "∀x (Happy(x) → Rich(x)) ::: If someone is happy, then they are rich.",
            "∃x (OwnsExpensiveCar(x) ∧ Happy(x)) ::: Some people who own expensive cars are happy.",
            "OwnsExpensiveCar(david) ::: David owns an expensive car.",
            "∃x (InvestsInStocks(x) ∧ Rich(x)) ::: Some people who invest in stocks are rich.",
            "∀x (HasHighIncome(david) → Happy(david)) ::: If David has a high income, then David is happy.",
            "Happy(david) ::: David is happy."
        ],
        "predicates": [
            "Rich(x) ::: x is rich.",
            "Happy(x) ::: x is happy.",
            "OwnsExpensiveCar(x) ::: x owns an expensive car.",
            "HasHighIncome(x) ::: x has a high income.",
            "InvestsInStocks(x) ::: x invests in stocks."
        ]
    },
    {
        "premises-NL": [
            "All programmers are skilled.",
            "David is a programmer.",
            "Everything that is a programmer has the property of skilled.",
            "If someone is a programmer, they are skilled.",
            "Every programmer has skill",
            "Programmers have skill",
            "For any person if they are a programmer, they must be skilled."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → Skilled(x)) ::: All programmers are skilled.",
            "Programmer(david) ::: David is a programmer.",
            "∀x (Programmer(x) → Skilled(x)) ::: Everything that is a programmer has the property of skilled.",
            "∀x (Programmer(x) → Skilled(x)) ::: If someone is a programmer, they are skilled.",
            "∀x (Programmer(x) → Skilled(x)) ::: Every programmer has skill",
            "∀x (Programmer(x) → Skilled(x)) ::: Programmers have skill",
            "∀x (Programmer(x) → Skilled(x)) ::: For any person if they are a programmer, they must be skilled."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "Skilled(x) ::: x is skilled"
        ]
    },
    {
        "premises-NL": [
            "All doctors are educated.",
            "Some scientists are doctors.",
            "Anyone who is a doctor has to be educated.",
            "At least one scientist is a doctor.",
            "There exists someone that is a doctor and a scientist.",
            "For all x, if x is a doctor, then x is educated.",
            "Not all doctors are uneducated.",
            "Some educated people are doctors.",
            "If one is a doctor then they are educated."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Educated(x)) ::: All doctors are educated.",
            "∃x (Scientist(x) ∧ Doctor(x)) ::: Some scientists are doctors.",
            "∀x (Doctor(x) → Educated(x)) ::: Anyone who is a doctor has to be educated.",
            "∃x (Scientist(x) ∧ Doctor(x)) ::: At least one scientist is a doctor.",
            "∃x (Scientist(x) ∧ Doctor(x)) ::: There exists someone that is a doctor and a scientist.",
            "∀x (Doctor(x) → Educated(x)) ::: For all x, if x is a doctor, then x is educated.",
            "¬∀x (Doctor(x) → ¬Educated(x)) ::: Not all doctors are uneducated.",
            "∃x (Educated(x) ∧ Doctor(x)) ::: Some educated people are doctors.",
            "∀x (Doctor(x) → Educated(x)) ::: If one is a doctor then they are educated."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Educated(x) ::: x is educated",
            "Scientist(x) ::: x is a scientist"
        ]
    },
    {
        "premises-NL": [
            "All athletes are fit.",
            "John is an athlete.",
            "John is not injured.",
            "If John is an athlete, then he is fit.",
            "Athletes are always fit.",
            "John is an athlete implies that John is fit.",
            "The statement that John is an athlete, means he is fit.",
            "It's not the case that John is injured.",
            "John is an athlete and is not injured.",
            "John has the property of being an athlete and not injured."
        ],
        "premises-FOL": [
            "∀x (Athlete(x) → Fit(x)) ::: All athletes are fit.",
            "Athlete(john) ::: John is an athlete.",
            "¬Injured(john) ::: John is not injured.",
            "Athlete(john) → Fit(john) ::: If John is an athlete, then he is fit.",
            "∀x (Athlete(x) → Fit(x)) ::: Athletes are always fit.",
            "Athlete(john) → Fit(john) ::: John is an athlete implies that John is fit.",
            "Athlete(john) → Fit(john) ::: The statement that John is an athlete, means he is fit.",
            "¬Injured(john) ::: It's not the case that John is injured.",
            "Athlete(john) ∧ ¬Injured(john) ::: John is an athlete and is not injured.",
            "Athlete(john) ∧ ¬Injured(john) ::: John has the property of being an athlete and not injured."
        ],
        "predicates": [
            "Athlete(x) ::: x is an athlete",
            "Fit(x) ::: x is fit",
            "Injured(x) ::: x is injured"
        ]
    },
    {
        "premises-NL": [
            "All artists are creative.",
            "Some painters are artists.",
            "All creative people are imaginative.",
            "If someone is an artist, then they are creative.",
            "At least one painter is an artist.",
            "Anyone who is creative, is imaginative.",
            "Artists are always creative.",
            "Creative people have imagination.",
            "Painters are also artists.",
            "There are artists who are creative.",
            "Every artist has creative properties."
        ],
        "premises-FOL": [
            "∀x (Artist(x) → Creative(x)) ::: All artists are creative.",
            "∃x (Painter(x) ∧ Artist(x)) ::: Some painters are artists.",
            "∀x (Creative(x) → Imaginative(x)) ::: All creative people are imaginative.",
            "∀x (Artist(x) → Creative(x)) ::: If someone is an artist, then they are creative.",
            "∃x (Painter(x) ∧ Artist(x)) ::: At least one painter is an artist.",
            "∀x (Creative(x) → Imaginative(x)) ::: Anyone who is creative, is imaginative.",
            "∀x (Artist(x) → Creative(x)) ::: Artists are always creative.",
            "∀x (Creative(x) → Imaginative(x)) ::: Creative people have imagination.",
            "∃x (Painter(x) ∧ Artist(x)) ::: Painters are also artists.",
            "∃x (Artist(x) ∧ Creative(x)) ::: There are artists who are creative.",
            "∀x (Artist(x) → Creative(x)) ::: Every artist has creative properties."
        ],
        "predicates": [
            "Artist(x) ::: x is an artist",
            "Creative(x) ::: x is creative",
            "Painter(x) ::: x is a painter",
            "Imaginative(x) ::: x is imaginative"
        ]
    },
    {
        "premises-NL": [
            "All students study.",
            "Sarah is a student.",
            "If someone studies, they either pass the exam or fail.",
            "If Sarah fails the exam, she is not a student.",
            "All students either pass or fail.",
            "Professor John teaches Sarah.",
            "If John teaches someone, he likes them.",
            "John is a professor.",
            "If Sarah studies, then John likes her.",
            "Sarah does not fail the exam.",
            "If someone fails the exam, they do not study.",
            "If someone studies, then the professor likes them."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Studies(x)) ::: All students study",
            "Student(sarah) ::: Sarah is a student",
            "∀x (Studies(x) → Pass(x) ∨ ¬Pass(x)) ::: If someone studies, they either pass the exam or fail",
            "¬Pass(sarah) → ¬Student(sarah) ::: If Sarah fails the exam, she is not a student",
            "∀x (Student(x) → Pass(x) ∨ ¬Pass(x)) ::: All students either pass or fail",
            "Teaches(john, sarah) ::: Professor John teaches Sarah",
            "∀x ∀y (Teaches(x, y) → Likes(x, y)) ::: If John teaches someone, he likes them",
            "Professor(john) ::: John is a professor",
            "Studies(sarah) → Likes(john, sarah) ::: If Sarah studies, then John likes her",
            "¬¬Pass(sarah) ::: Sarah does not fail the exam",
            "∀x (¬Pass(x) → ¬Studies(x)) ::: If someone fails the exam, they do not study",
            "∀x (Studies(x) → Likes(john, x)) ::: If someone studies, then the professor likes them"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "Pass(x) ::: x passes the exam",
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches y",
            "Likes(x, y) ::: x likes y"
        ]
    },
    {
        "premises-NL": [
            "All apples are either red or green.",
            "If an apple is not green, then it is red.",
            "If an apple is ripe, then it is tasty.",
            "If an apple is tasty, then someone eats it.",
            "All apples are fruit.",
            "If an apple is on the tree, then the apple is a fruit.",
            "If an apple is not eaten, it is on the tree.",
            "If an apple is red, then it's not green.",
            "If an apple is green, it is not red.",
            "Every apple is either ripe or not ripe.",
            "If a fruit is not ripe, then it is green.",
            "If something is red and it is not ripe, then it is not tasty.",
            "If an apple is on tree, it is ripe",
            "If an apple is red, it is on the tree.",
            "If an apple is not eaten it is red."
        ],
        "premises-FOL": [
            "∀x (Apple(x) → (Red(x) ∨ Green(x))) ::: All apples are either red or green.",
            "∀x (Apple(x) ∧ ¬Green(x) → Red(x)) ::: If an apple is not green, then it is red.",
            "∀x (Apple(x) ∧ Ripe(x) → Tasty(x)) ::: If an apple is ripe, then it is tasty.",
            "∀x (Apple(x) ∧ Tasty(x) → Eaten(x)) ::: If an apple is tasty, then someone eats it.",
            "∀x (Apple(x) → IsFruit(x)) ::: All apples are fruit.",
            "∀x (Apple(x) ∧ OnTree(x) → IsFruit(x)) ::: If an apple is on the tree, then the apple is a fruit.",
            "∀x (Apple(x) ∧ ¬Eaten(x) → OnTree(x)) ::: If an apple is not eaten, it is on the tree.",
            "∀x (Apple(x) ∧ Red(x) → ¬Green(x)) ::: If an apple is red, then it's not green.",
            "∀x (Apple(x) ∧ Green(x) → ¬Red(x)) ::: If an apple is green, it is not red.",
            "∀x (Apple(x) → (Ripe(x) ∨ ¬Ripe(x))) ::: Every apple is either ripe or not ripe.",
            "∀x (IsFruit(x) ∧ ¬Ripe(x) → Green(x)) ::: If a fruit is not ripe, then it is green.",
            "∀x (Apple(x) ∧ Red(x) ∧ ¬Ripe(x) → ¬Tasty(x)) ::: If something is red and it is not ripe, then it is not tasty.",
            "∀x (Apple(x) ∧ OnTree(x) → Ripe(x)) ::: If an apple is on tree, it is ripe",
            "∀x (Apple(x) ∧ Red(x) → OnTree(x)) ::: If an apple is red, it is on the tree.",
            "∀x (Apple(x) ∧ ¬Eaten(x) → Red(x)) ::: If an apple is not eaten it is red."
        ],
        "predicates": [
            "Apple(x) ::: x is an apple",
            "Red(x) ::: x is red",
            "Green(x) ::: x is green",
            "Ripe(x) ::: x is ripe",
            "Eaten(x) ::: x is eaten",
            "Tasty(x) ::: x is tasty",
            "OnTree(x) ::: x is on a tree",
            "IsFruit(x) ::: x is fruit"
        ]
    },
    {
        "premises-NL": [
            "All cars are vehicles.",
            "All cars have engines.",
            "If something has an engine, then it is motorized.",
            "If something is motorized, then it uses fuel.",
            "A car is a vehicle that drives on the road.",
            "If something is a car, then it uses fuel.",
            "If a vehicle is a truck, then it drives on the road.",
            "If a vehicle drives on the road, it has wheels.",
            "If a vehicle has an engine, it has wheels.",
            "If something is a car, it is motorized and has an engine.",
            "If something has wheels, then it drives on the road or is in a garage.",
            "If a vehicle does not use fuel, it is not a car.",
            "If a car uses fuel, it has wheels.",
            "If a car has an engine, it is a vehicle.",
            "If something is a truck, it has wheels.",
            "If something uses fuel, then it is a car or is a truck."
        ],
        "premises-FOL": [
            "∀x (Car(x) → Vehicle(x)) ::: All cars are vehicles.",
            "∀x (Car(x) → HasEngine(x)) ::: All cars have engines.",
            "∀x (HasEngine(x) → IsMotorized(x)) ::: If something has an engine, then it is motorized.",
            "∀x (IsMotorized(x) → UsesFuel(x)) ::: If something is motorized, then it uses fuel.",
            "∀x (Car(x) → Vehicle(x) ∧ DrivesOnRoad(x)) ::: A car is a vehicle that drives on the road.",
            "∀x (Car(x) → UsesFuel(x)) ::: If something is a car, then it uses fuel.",
            "∀x (Truck(x) → DrivesOnRoad(x)) ::: If a vehicle is a truck, then it drives on the road.",
            "∀x (DrivesOnRoad(x) → HasWheels(x)) ::: If a vehicle drives on the road, it has wheels.",
            "∀x (HasEngine(x) → HasWheels(x)) ::: If a vehicle has an engine, it has wheels.",
            "∀x (Car(x) → IsMotorized(x) ∧ HasEngine(x)) ::: If something is a car, it is motorized and has an engine.",
            "∀x (HasWheels(x) → (DrivesOnRoad(x) ∨ InGarage(x))) ::: If something has wheels, then it drives on the road or is in a garage.",
            "∀x (¬UsesFuel(x) → ¬Car(x)) ::: If a vehicle does not use fuel, it is not a car.",
            "∀x (Car(x) ∧ UsesFuel(x) → HasWheels(x)) ::: If a car uses fuel, it has wheels.",
            "∀x (Car(x) ∧ HasEngine(x) → Vehicle(x)) ::: If a car has an engine, it is a vehicle.",
            "∀x (Truck(x) → HasWheels(x)) ::: If something is a truck, it has wheels.",
            "∀x (UsesFuel(x) → (Car(x) ∨ Truck(x))) ::: If something uses fuel, then it is a car or is a truck."
        ],
        "predicates": [
            "Vehicle(x) ::: x is a vehicle",
            "Car(x) ::: x is a car",
            "HasEngine(x) ::: x has an engine",
            "HasWheels(x) ::: x has wheels",
            "IsMotorized(x) ::: x is motorized",
            "Truck(x) ::: x is a truck",
            "UsesFuel(x) ::: x uses fuel",
            "DrivesOnRoad(x) ::: x drives on the road"
        ]
    },
    {
        "premises-NL": [
            "All doctors have a medical degree.",
            "Everyone who studies medicine attends a medical school.",
            "Some people who attend a medical school become doctors.",
            "If someone studies medicine, they will get a medical degree"
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HasDegree(x, medical_degree)) ::: For all x, if x is a doctor, then x has a medical degree.",
            "∀x ∀y (Studies(x, medicine) ∧ MedicalSchool(y) ∧ Attends(x, y)) ::: For all x and y, if x studies medicine and y is a medical school then x attends y.",
            "∃x (Attends(x, y) ∧ Doctor(x)) ::: There exists x and y, such that x attends y and x is a doctor.",
            "∀x (Studies(x, medicine) → HasDegree(x, medical_degree)) ::: For all x, if x studies medicine, then x has a medical degree."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "HasDegree(x, y) ::: Person x has degree y",
            "Studies(x, y) ::: Person x studies subject y",
            "MedicalSchool(y) ::: y is a medical school",
            "Attends(x, y) ::: Person x attends school y"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All surgeons specialize in cardiology.",
            "Every doctor practices medicine.",
            "Every doctor who practices medicine is knowledgeable.",
            "If someone specializes in cardiology, they are also a doctor.",
            "John is a surgeon.",
            "If someone is a doctor, they are knowledgeable.",
            "All doctors are surgeons.",
            "John practices medicine.",
            "John specializes in cardiology.",
            "Every doctor that practices medicine is knowledgeable.",
            "For all x, if x is a surgeon, then x specializes in cardiology.",
            "For all x, if x is a doctor, then x practices medicine.",
            "For all x, if x practices medicine, then x is knowledgeable."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Surgeon(x) → SpecializesIn(x, cardiology)) ::: All surgeons specialize in cardiology.",
            "∀x (Doctor(x) → Practices(x, medicine)) ::: Every doctor practices medicine.",
            "∀x (Doctor(x) ∧ Practices(x, medicine) → Knowledgeable(x)) ::: Every doctor who practices medicine is knowledgeable.",
            "∀x (SpecializesIn(x, cardiology) → Doctor(x)) ::: If someone specializes in cardiology, they are also a doctor.",
            "Surgeon(john) ::: John is a surgeon.",
            "∀x (Doctor(x) → Knowledgeable(x)) ::: If someone is a doctor, they are knowledgeable.",
            "∀x (Doctor(x) → Surgeon(x)) ::: All doctors are surgeons.",
            "Practices(john, medicine) ::: John practices medicine.",
            "SpecializesIn(john, cardiology) ::: John specializes in cardiology.",
            "∀x (Doctor(x) ∧ Practices(x, medicine) → Knowledgeable(x)) ::: Every doctor that practices medicine is knowledgeable.",
            "∀x (Surgeon(x) → SpecializesIn(x, cardiology)) ::: For all x, if x is a surgeon, then x specializes in cardiology.",
            "∀x (Doctor(x) → Practices(x, medicine)) ::: For all x, if x is a doctor, then x practices medicine.",
            "∀x (Practices(x, medicine) → Knowledgeable(x)) ::: For all x, if x practices medicine, then x is knowledgeable."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "SpecializesIn(x, y) ::: x specializes in y",
            "Cardiology(x) ::: x is a cardiology",
            "Knowledgeable(x) ::: x is knowledgeable",
            "Practices(x, y) ::: x practices in y"
        ]
    },
    {
        "premises-NL": [
            "Every student studies.",
            "If someone studies, they are smart.",
            "All students are taught by a professor.",
            "Professor Smith teaches John.",
            "John is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Studies(x)) ::: For all x, if x is a student, then x studies.",
            "∀x (Studies(x) → Smart(x)) ::: For all x, if x studies, then x is smart.",
            "∀x ∃y (Student(x) → Teaches(y, x) ∧ Professor(y)) ::: For all x, if x is a student, then there exists a y such that y teaches x and y is a professor.",
            "Teaches(smith, john) ::: Smith teaches John.",
            "Student(john) ::: John is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "Smart(x) ::: x is smart",
            "Teaches(x, y) ::: x teaches y",
            "Professor(x) ::: x is a professor"
        ]
    },
    {
        "premises-NL": [
            "All athletes take supplements.",
            "Anyone who takes supplements has a medical checkup.",
            "If someone has a medical checkup and passes it, they are healthy.",
            "Healthy people are not injured.",
            "Every athlete is either healthy or injured.",
            "No injured athlete is capable of competing.",
            "John is an athlete."
        ],
        "premises-FOL": [
            "∀x (Athlete(x) → TakesSupplements(x)) ::: For all x, if x is an athlete, then x takes supplements.",
            "∀x (TakesSupplements(x) → HasMedicalCheckup(x)) ::: For all x, if x takes supplements, then x has a medical checkup.",
            "∀x ((HasMedicalCheckup(x) ∧ PassesMedicalCheckup(x)) → Healthy(x)) ::: For all x, if x has a medical checkup and passes it, then x is healthy.",
            "∀x (Healthy(x) → ¬Injured(x)) ::: For all x, if x is healthy, then x is not injured.",
            "∀x (Athlete(x) → (Healthy(x) ∨ Injured(x))) ::: For all x, if x is an athlete, then x is healthy or injured.",
            "∀x (Injured(x) → ¬CapableOfCompeting(x)) ::: For all x, if x is injured, then x is not capable of competing.",
            "Athlete(john) ::: John is an athlete."
        ],
        "predicates": [
            "Athlete(x) ::: x is an athlete",
            "Healthy(x) ::: x is healthy",
            "Injured(x) ::: x is injured",
            "CapableOfCompeting(x) ::: x is capable of competing",
            "TakesSupplements(x) ::: x takes supplements",
            "HasMedicalCheckup(x) ::: x has a medical checkup",
            "PassesMedicalCheckup(x) ::: x passes a medical checkup"
        ]
    },
    {
        "premises-NL": [
            "All people in a band are musicians.",
            "Every musician plays at least one instrument.",
            "If someone plays a guitar, then they are a musician.",
            "Anyone in a band has practice.",
            "If two people share the stage, they are both in a band.",
            "Anyone who is a musician has a concert.",
            "John is in a band.",
            "Mary is in a band."
        ],
        "premises-FOL": [
            "∀x (InBand(x) → Musician(x)) ::: For all x, if x is in a band, then x is a musician.",
            "∀x ∃y (Musician(x) → PlaysInstrument(x, y)) ::: For all x, if x is a musician, then there exists a y such that x plays y.",
            "∀x ∀y (PlaysInstrument(x, y) ∧ IsGuitar(y) → Musician(x)) ::: For all x and y, if x plays y and y is a guitar, then x is a musician.",
            "∀x (InBand(x) → HasPractice(x)) ::: For all x, if x is in a band, then x has practice.",
            "∀x ∀y (SharesStage(x, y) → (InBand(x) ∧ InBand(y))) ::: For all x and y, if x and y share the stage, then x and y are in a band.",
            "∀x (Musician(x) → HasConcert(x)) ::: For all x, if x is a musician, then x has a concert.",
            "InBand(john) ::: John is in a band.",
            "InBand(mary) ::: Mary is in a band."
        ],
        "predicates": [
            "InBand(x) ::: x is in a band",
            "Musician(x) ::: x is a musician",
            "PlaysInstrument(x, y) ::: x plays instrument y",
            "IsGuitar(y) ::: y is a guitar",
            "IsSinger(x) ::: x is a singer",
            "HasPractice(x) ::: x has practice",
            "HasConcert(x) ::: x has a concert",
            "SharesStage(x, y) ::: x and y share the stage"
        ]
    },
    {
        "premises-NL": [
            "All scientists are researchers.",
            "If someone studies science, then they are a student.",
            "If someone works at a university, they are funded.",
            "Alice is a scientist.",
            "Bob studies science.",
            "Charles works at a university.",
            "If someone is a scientist, then they like research.",
            "If someone likes research and is funded, then they are a researcher.",
            "If someone is a student, they study science.",
            "If someone works at a university, then they are funded.",
            "If a scientist likes research, they are funded.",
            "Charles works at a university and Alice is a scientist.",
            "Student(bob) ::: Bob is a student.",
            "∀x (Scientist(x) → Researcher(x)) ::: All scientists are researchers.",
            "∀x (Studies(x, science) → Student(x)) ::: If someone studies science, then they are a student.",
            "∀x (WorksAt(x, university) → IsFunded(x)) ::: If someone works at a university, they are funded."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Researcher(x)) ::: All scientists are researchers.",
            "∀x (Studies(x, science) → Student(x)) ::: If someone studies science, then they are a student.",
            "∀x (WorksAt(x, university) → IsFunded(x)) ::: If someone works at a university, they are funded.",
            "Scientist(alice) ::: Alice is a scientist.",
            "Studies(bob, science) ::: Bob studies science.",
            "WorksAt(charles, university) ::: Charles works at a university.",
            "∀x (Scientist(x) → Likes(x, research)) ::: If someone is a scientist, then they like research.",
            "∀x ((Likes(x, research) ∧ IsFunded(x)) → Researcher(x)) ::: If someone likes research and is funded, then they are a researcher.",
            "∀x (Student(x) → Studies(x, science)) ::: If someone is a student, they study science.",
            "∀x (WorksAt(x, university) → IsFunded(x)) ::: If someone works at a university, then they are funded.",
            "∀x (Scientist(x) → Likes(x, research)) ::: If someone is a scientist, then they like research.",
            "(WorksAt(charles, university) ∧ Scientist(alice)) ::: Charles works at a university and Alice is a scientist.",
            "Student(bob) ::: Bob is a student.",
            "∀x (Scientist(x) → Researcher(x)) ::: All scientists are researchers.",
            "∀x (Studies(x, science) → Student(x)) ::: If someone studies science, then they are a student.",
            "∀x (WorksAt(x, university) → IsFunded(x)) ::: If someone works at a university, they are funded.",
            "∀x (Scientist(x) → Researcher(x)) ::: All scientists are researchers."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Student(x) ::: x is a student",
            "Researcher(x) ::: x is a researcher",
            "Studies(x, y) ::: x studies y",
            "WorksAt(x, y) ::: x works at y",
            "IsFunded(x) ::: x is funded",
            "Likes(x, y) ::: x likes y"
        ]
    },
    {
        "premises-NL": [
            "Every cat is a mammal.",
            "Every mammal is an animal.",
            "If something is a cat, then it is a mammal.",
            "If something is a mammal, then it is an animal.",
            "All cats are mammals.",
            "All mammals are animals.",
            "Cats are mammals.",
            "Mammals are animals.",
            "Being a cat means being a mammal.",
            "Being a mammal means being an animal.",
            "If something is not a mammal, it is not a cat.",
            "If something is not an animal, it is not a mammal.",
            "Not being a mammal implies not being a cat.",
            "Not being an animal implies not being a mammal.",
            "Everything is a mammal if it is a cat"
        ],
        "premises-FOL": [
            "∀x (Cat(x) → Mammal(x)) ::: Every cat is a mammal",
            "∀x (Mammal(x) → Animal(x)) ::: Every mammal is an animal",
            "∀x (Cat(x) → Mammal(x)) ::: If something is a cat, then it is a mammal",
            "∀x (Mammal(x) → Animal(x)) ::: If something is a mammal, then it is an animal",
            "∀x (Cat(x) → Mammal(x)) ::: All cats are mammals",
            "∀x (Mammal(x) → Animal(x)) ::: All mammals are animals",
            "∀x (Cat(x) → Mammal(x)) ::: Cats are mammals",
            "∀x (Mammal(x) → Animal(x)) ::: Mammals are animals",
            "∀x (Cat(x) → Mammal(x)) ::: Being a cat means being a mammal",
            "∀x (Mammal(x) → Animal(x)) ::: Being a mammal means being an animal",
            "∀x (¬Mammal(x) → ¬Cat(x)) ::: If something is not a mammal, it is not a cat",
            "∀x (¬Animal(x) → ¬Mammal(x)) ::: If something is not an animal, it is not a mammal",
            "∀x (¬Mammal(x) → ¬Cat(x)) ::: Not being a mammal implies not being a cat",
            "∀x (¬Animal(x) → ¬Mammal(x)) ::: Not being an animal implies not being a mammal",
            "∀x (Cat(x) → Mammal(x)) ::: Everything is a mammal if it is a cat"
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Mammal(x) ::: x is a mammal",
            "Animal(x) ::: x is an animal"
        ]
    },
    {
        "premises-NL": [
            "Some students passed the exam.",
            "Anyone who passed the exam is eligible for a scholarship.",
            "If a student passed the exam, then they are eligible for a scholarship.",
            "All students who passed the exam are eligible for a scholarship.",
            "Some who passed are students.",
            "Those who passed are scholarship eligible.",
            "If you passed, you get a scholarship.",
            "Having passed leads to a scholarship.",
            "The ones who passed are eligible for a scholarship.",
            "Some students have passed.",
            "If a student passes, they are scholarship eligible.",
            "Passing means you're eligible.",
            "Students who pass get scholarships.",
            "Some students are eligible for a scholarship because they passed.",
            "If someone is a student and passed, they are eligible for a scholarship.",
            "If a student passed, and if that same student is not scholarship eligible, then contradiction."
        ],
        "premises-FOL": [
            "∃x (Student(x) ∧ PassedExam(x)) ::: Some students passed the exam",
            "∀x (PassedExam(x) → ScholarshipEligible(x)) ::: Anyone who passed the exam is eligible for a scholarship",
            "∀x ((Student(x) ∧ PassedExam(x)) → ScholarshipEligible(x)) ::: If a student passed the exam, then they are eligible for a scholarship",
            "∀x ((Student(x) ∧ PassedExam(x)) → ScholarshipEligible(x)) ::: All students who passed the exam are eligible for a scholarship",
            "∃x (PassedExam(x) ∧ Student(x)) ::: Some who passed are students",
            "∀x (PassedExam(x) → ScholarshipEligible(x)) ::: Those who passed are scholarship eligible",
            "∀x (PassedExam(x) → ScholarshipEligible(x)) ::: If you passed, you get a scholarship",
            "∀x (PassedExam(x) → ScholarshipEligible(x)) ::: Having passed leads to a scholarship",
            "∀x (PassedExam(x) → ScholarshipEligible(x)) ::: The ones who passed are eligible for a scholarship",
            "∃x (Student(x) ∧ PassedExam(x)) ::: Some students have passed",
            "∀x ((Student(x) ∧ PassedExam(x)) → ScholarshipEligible(x)) ::: If a student passes, they are scholarship eligible",
            "∀x (PassedExam(x) → ScholarshipEligible(x)) ::: Passing means you're eligible",
            "∀x ((Student(x) ∧ PassedExam(x)) → ScholarshipEligible(x)) ::: Students who pass get scholarships",
            "∃x (Student(x) ∧ PassedExam(x) ∧ ScholarshipEligible(x)) ::: Some students are eligible for a scholarship because they passed",
            "∀x ((Student(x) ∧ PassedExam(x)) → ScholarshipEligible(x)) ::: If someone is a student and passed, they are eligible for a scholarship",
            "∀x ((Student(x) ∧ PassedExam(x)) → ScholarshipEligible(x)) ∨ (Student(x) ∧ PassedExam(x) ∧ ¬ScholarshipEligible(x)) ::: If a student passed, and if that same student is not scholarship eligible, then contradiction"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PassedExam(x) ::: x passed the exam",
            "ScholarshipEligible(x) ::: x is eligible for a scholarship"
        ]
    },
    {
        "premises-NL": [
            "All plants need sunlight and water.",
            "If a plant grows, it's alive.",
            "If a plant is alive, it is green.",
            "If something is green, it is a plant.",
            "Plants have water and sunlight.",
            "If a plant grows, it needs nutrients.",
            "If a plant needs nutrients, it gets them from the soil.",
            "Every plant is part of a garden.",
            "If something is part of a garden, it is a plant.",
            "Something is green and is a plant.",
            "Everything has water and sunlight.",
            "If a plant is green, it has water.",
            "If a plant gets nutrients from the soil, it will grow.",
            "If a plant has sunlight, it is green.",
            "If a plant has water, it grows.",
            "If a plant gets nutrients, the plant grows.",
            "If a plant needs sunlight and water, it will grow.",
            "If a plant has water, it will have sunlight."
        ],
        "premises-FOL": [
            "∀x (Plant(x) → (HasWater(x) ∧ HasSunlight(x))) ::: All plants need sunlight and water.",
            "∀x (Grows(x) → IsAlive(x)) ::: If a plant grows, it's alive.",
            "∀x (IsAlive(x) → IsGreen(x)) ::: If a plant is alive, it is green.",
            "∀x (IsGreen(x) → Plant(x)) ::: If something is green, it is a plant.",
            "∀x (Plant(x) → (HasWater(x) ∧ HasSunlight(x))) ::: Plants have water and sunlight.",
            "∀x (Grows(x) → NeedsNutrients(x)) ::: If a plant grows, it needs nutrients.",
            "∀x ∀y (NeedsNutrients(x) → GetsNutrientsFrom(x, y)) ::: If a plant needs nutrients, it gets them from the soil.",
            "∀x ∃y PartOf(x, y) ::: Every plant is part of a garden.",
            "∀x ∀y (PartOf(x, y) → Plant(x)) ::: If something is part of a garden, it is a plant.",
            "∃x (IsGreen(x) ∧ Plant(x)) ::: Something is green and is a plant.",
            "∀x (HasWater(x) ∧ HasSunlight(x)) ::: Everything has water and sunlight.",
            "∀x (IsGreen(x) → HasWater(x)) ::: If a plant is green, it has water.",
            "∀x (GetsNutrientsFrom(x, soil) → Grows(x)) ::: If a plant gets nutrients from the soil, it will grow.",
            "∀x (Plant(x) ∧ HasSunlight(x) → IsGreen(x)) ::: If a plant has sunlight, it is green.",
            "∀x (Plant(x) ∧ HasWater(x) → Grows(x)) ::: If a plant has water, it grows.",
            "∀x (NeedsNutrients(x) → Grows(x)) ::: If a plant gets nutrients, the plant grows.",
            "∀x (Plant(x) ∧ HasSunlight(x) ∧ HasWater(x) → Grows(x)) ::: If a plant needs sunlight and water, it will grow.",
            "∀x (Plant(x) ∧ HasWater(x) → HasSunlight(x)) ::: If a plant has water, it will have sunlight."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "HasWater(x) ::: x has water",
            "HasSunlight(x) ::: x has sunlight",
            "Grows(x) ::: x grows",
            "IsGreen(x) ::: x is green",
            "IsAlive(x) ::: x is alive",
            "NeedsNutrients(x) ::: x needs nutrients",
            "GetsNutrientsFrom(x, y) ::: x gets nutrients from y",
            "PartOf(x, y) ::: x is part of y"
        ]
    },
    {
        "premises-NL": [
            "All doctors help patients.",
            "Sarah is a doctor.",
            "All patients are sick."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HelpsPatients(x)) ::: All doctors help patients.",
            "Doctor(sarah) ::: Sarah is a doctor.",
            "∀x (Patient(x) → IsSick(x)) ::: All patients are sick.",
            "Patient(john) ::: John is a patient.",
            "HelpsPatients(sarah) ::: Sarah helps patients.",
            "Treats(sarah,john) ::: Sarah treats John.",
            "∀x (Treats(sarah, x) → Patient(x)) ::: Sarah treats only patients.",
            "¬IsSick(bill) ::: Bill is not sick.",
            "∀x (HelpsPatients(x) ↔ Treats(x,y)) ::: Anyone who helps patients treats them and vice-versa.",
            "¬Doctor(bill) ::: Bill is not a doctor.",
            "HelpsPatients(sarah) ::: Sarah helps patients."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Patient(x) ::: x is a patient",
            "HelpsPatients(x) ::: x helps patients",
            "Treats(x, y) ::: x treats y",
            "IsSick(x) ::: x is sick"
        ]
    },
    {
        "premises-NL": [
            "All fruits are sweet.",
            "All red fruits are sweet.",
            "All yellow fruits are sweet.",
            "Some fruits grow on trees.",
            "All things that grow on trees are fruits.",
            "Either something is red or it is yellow.",
            "Every sweet thing is a fruit.",
            "Some fruits are red.",
            "Some fruits are yellow.",
            "All red things are fruits.",
            "All yellow things are fruits.",
            "Some fruits are not sweet.",
            "No fruit is both red and yellow."
        ],
        "premises-FOL": [
            "∀x (Fruit(x) → Sweet(x)) ::: All fruits are sweet.",
            "∀x (Red(x) → Sweet(x)) ::: All red fruits are sweet.",
            "∀x (Yellow(x) → Sweet(x)) ::: All yellow fruits are sweet.",
            "∃x (Fruit(x) ∧ GrowsOnTree(x)) ::: Some fruits grow on trees.",
            "∀x (GrowsOnTree(x) → Fruit(x)) ::: All things that grow on trees are fruits.",
            "∀x (Red(x) ∨ Yellow(x)) ::: Either something is red or it is yellow.",
            "∀x (Sweet(x) → Fruit(x)) ::: Every sweet thing is a fruit.",
            "∃x (Fruit(x) ∧ Red(x)) ::: Some fruits are red.",
            "∃x (Fruit(x) ∧ Yellow(x)) ::: Some fruits are yellow.",
            "∀x (Red(x) → Fruit(x)) ::: All red things are fruits.",
            "∀x (Yellow(x) → Fruit(x)) ::: All yellow things are fruits.",
            "∃x (Fruit(x) ∧ ¬Sweet(x)) ::: Some fruits are not sweet.",
            "¬∃x (Fruit(x) ∧ Red(x) ∧ Yellow(x)) ::: No fruit is both red and yellow."
        ],
        "predicates": [
            "Fruit(x) ::: x is a fruit",
            "Red(x) ::: x is red",
            "Yellow(x) ::: x is yellow",
            "Sweet(x) ::: x is sweet",
            "GrowsOnTree(x) ::: x grows on a tree"
        ]
    },
    {
        "premises-NL": [
            "All programmers write code.",
            "All people who write code use an IDE.",
            "All people who know Python write code.",
            "Some programmers have a degree.",
            "Anyone who has a degree knows Python.",
            "All those who use an IDE know Python.",
            "Some programmers write code.",
            "All who write code are programmers.",
            "Some who use IDEs write code.",
            "Anyone who knows Python writes code.",
            "No one who knows Python has a degree.",
            "Anyone who writes code uses an IDE.",
            "Some people write code.",
            "All programmers know Python."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → WritesCode(x)) ::: All programmers write code.",
            "∀x (WritesCode(x) → UsesIDE(x)) ::: All people who write code use an IDE.",
            "∀x (KnowsPython(x) → WritesCode(x)) ::: All people who know Python write code.",
            "∃x (Programmer(x) ∧ HasDegree(x)) ::: Some programmers have a degree.",
            "∀x (HasDegree(x) → KnowsPython(x)) ::: Anyone who has a degree knows Python.",
            "∀x (UsesIDE(x) → KnowsPython(x)) ::: All those who use an IDE know Python.",
            "∃x (Programmer(x) ∧ WritesCode(x)) ::: Some programmers write code.",
            "∀x (WritesCode(x) → Programmer(x)) ::: All who write code are programmers.",
            "∃x (UsesIDE(x) ∧ WritesCode(x)) ::: Some who use IDEs write code.",
            "∀x (KnowsPython(x) → WritesCode(x)) ::: Anyone who knows Python writes code.",
            "¬∃x (KnowsPython(x) ∧ HasDegree(x)) ::: No one who knows Python has a degree.",
            "∀x (WritesCode(x) → UsesIDE(x)) ::: Anyone who writes code uses an IDE.",
            "∃x WritesCode(x) ::: Some people write code.",
            "∀x (Programmer(x) → KnowsPython(x)) ::: All programmers know Python."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "KnowsPython(x) ::: x knows Python",
            "WritesCode(x) ::: x writes code",
            "UsesIDE(x) ::: x uses an IDE",
            "HasDegree(x) ::: x has a degree"
        ]
    },
    {
        "premises-NL": [
            "All mammals have fur.",
            "All land animals have fur.",
            "All water animals breathe air.",
            "Some mammals breathe air.",
            "All things that breathe air are mammals.",
            "All mammals are either land animals or water animals.",
            "All things with fur are mammals.",
            "Some things are mammals.",
            "Some land animals do not breathe air.",
            "All animals breathe air.",
            "No land animal is a water animal.",
            "Some mammals are land animals.",
            "Some mammals are water animals.",
            "All animals with fur are mammals.",
            "All animals that are not land animals are water animals."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → HasFur(x)) ::: All mammals have fur.",
            "∀x (LandAnimal(x) → HasFur(x)) ::: All land animals have fur.",
            "∀x (WaterAnimal(x) → BreathesAir(x)) ::: All water animals breathe air.",
            "∃x (Mammal(x) ∧ BreathesAir(x)) ::: Some mammals breathe air.",
            "∀x (BreathesAir(x) → Mammal(x)) ::: All things that breathe air are mammals.",
            "∀x (Mammal(x) → (LandAnimal(x) ∨ WaterAnimal(x))) ::: All mammals are either land animals or water animals.",
            "∀x (HasFur(x) → Mammal(x)) ::: All things with fur are mammals.",
            "∃x Mammal(x) ::: Some things are mammals.",
            "∃x (LandAnimal(x) ∧ ¬BreathesAir(x)) ::: Some land animals do not breathe air.",
            "∀x BreathesAir(x) ::: All animals breathe air.",
            "¬∃x (LandAnimal(x) ∧ WaterAnimal(x)) ::: No land animal is a water animal.",
            "∃x (Mammal(x) ∧ LandAnimal(x)) ::: Some mammals are land animals.",
            "∃x (Mammal(x) ∧ WaterAnimal(x)) ::: Some mammals are water animals.",
            "∀x (HasFur(x) → Mammal(x)) ::: All animals with fur are mammals.",
            "∀x (¬LandAnimal(x) → WaterAnimal(x)) ::: All animals that are not land animals are water animals."
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal",
            "LandAnimal(x) ::: x is a land animal",
            "WaterAnimal(x) ::: x is a water animal",
            "HasFur(x) ::: x has fur",
            "BreathesAir(x) ::: x breathes air"
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "Some students study medicine.",
            "All those who study medicine must pass the exam.",
            "Anyone who passes the exam is a doctor.",
            "John is a student.",
            "John studies medicine.",
            "Therefore there exists a doctor."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "∃x (Student(x) ∧ StudiesMedicine(x)) ::: Some students study medicine.",
            "∀x (StudiesMedicine(x) → PassesExam(x)) ::: All those who study medicine must pass the exam.",
            "∀x (PassesExam(x) → Doctor(x)) ::: Anyone who passes the exam is a doctor.",
            "Student(john) ::: John is a student.",
            "StudiesMedicine(john) ::: John studies medicine.",
            "∀x (Smart(x) → PassesExam(x)) ::: If someone is smart, then they pass the exam.",
            "∀x (Student(x) → StudiesMedicine(x) ∨ ¬Smart(x)) ::: All students study medicine or are not smart.",
            "¬∃x (Student(x) ∧ ¬StudiesMedicine(x)) ::: Nobody is a student who does not study medicine.",
            "∀x (StudiesMedicine(x) → Smart(x)) ::: If someone studies medicine, then they are smart.",
            "Student(peter) ::: Peter is a student.",
            "¬Smart(peter) ::: Peter is not smart."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Smart(x) ::: x is smart.",
            "Doctor(x) ::: x is a doctor.",
            "StudiesMedicine(x) ::: x studies medicine.",
            "PassesExam(x) ::: x passes the exam."
        ]
    },
    {
        "premises-NL": [
            "All researchers write papers.",
            "All who write papers attend conferences.",
            "Some who attend conferences are not lazy.",
            "Anyone who works hard does not attend conferences.",
            "All researchers work hard.",
            "If someone is a researcher, they are smart.",
            "Some researchers publish papers.",
            "Therefore some researchers are not lazy.",
            "All who write papers publish.",
            "John is a researcher.",
            "John writes papers.",
            "John attends conferences.",
            "John is smart."
        ],
        "premises-FOL": [
            "∀x (Researcher(x) → WritesPapers(x)) ::: All researchers write papers.",
            "∀x (WritesPapers(x) → AttendsConference(x)) ::: All who write papers attend conferences.",
            "∃x (AttendsConference(x) ∧ ¬Lazy(x)) ::: Some who attend conferences are not lazy.",
            "∀x (WorksHard(x) → ¬AttendsConference(x)) ::: Anyone who works hard does not attend conferences.",
            "∀x (Researcher(x) → WorksHard(x)) ::: All researchers work hard.",
            "∀x (Researcher(x) → IsSmart(x)) ::: If someone is a researcher, they are smart.",
            "∃x (Researcher(x) ∧ Publishes(x)) ::: Some researchers publish papers.",
            "Researcher(john) ::: John is a researcher.",
            "WritesPapers(john) ::: John writes papers.",
            "AttendsConference(john) ::: John attends conferences.",
            "IsSmart(john) ::: John is smart.",
            "∀x (WritesPapers(x) → Publishes(x)) ::: All who write papers publish.",
            "¬∃x (Lazy(x) ∧ WorksHard(x)) ::: Nobody is both lazy and works hard."
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher.",
            "Lazy(x) ::: x is lazy.",
            "WritesPapers(x) ::: x writes papers.",
            "AttendsConference(x) ::: x attends conferences.",
            "WorksHard(x) ::: x works hard.",
            "IsSmart(x) ::: x is smart.",
            "Publishes(x) ::: x publishes."
        ]
    },
    {
        "premises-NL": [
            "All scientists have a degree.",
            "Anyone who has a degree and works at a university is a scientist.",
            "Some scientists publish research.",
            "Anyone who publishes research is respected by their peers.",
            "All scientists work at a university.",
            "John is a scientist.",
            "John has a degree.",
            "Mary works at a university.",
            "Mary has a degree.",
            "John publishes research.",
            "If someone publishes, they're respected."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → HasDegree(x)) ::: All scientists have a degree.",
            "∀x (HasDegree(x) ∧ WorksAtUniversity(x) → Scientist(x)) ::: Anyone who has a degree and works at a university is a scientist.",
            "∃x (Scientist(x) ∧ PublishesResearch(x)) ::: Some scientists publish research.",
            "∀x (PublishesResearch(x) → Respected(x)) ::: Anyone who publishes research is respected.",
            "∀x (Scientist(x) → WorksAtUniversity(x)) ::: All scientists work at a university.",
            "Scientist(john) ::: John is a scientist.",
            "HasDegree(john) ::: John has a degree.",
            "WorksAtUniversity(mary) ::: Mary works at a university.",
            "HasDegree(mary) ::: Mary has a degree.",
            "PublishesResearch(john) ::: John publishes research.",
            "∀x (PublishesResearch(x) → Respected(x)) ::: If someone publishes, they're respected."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist.",
            "PublishesResearch(x) ::: x publishes research.",
            "Respected(x) ::: x is respected.",
            "HasDegree(x) ::: x has a degree.",
            "WorksAtUniversity(x) ::: x works at a university."
        ]
    },
    {
        "premises-NL": [
            "All students attend university.",
            "Anyone who has graduated is an alumni.",
            "Some members of the club are students.",
            "Anyone who attends university is either a student or an alumni.",
            "John is a member of the club.",
            "Mary is a student.",
            "Mary attends university.",
            "All students who are members of the club attend university.",
            "No student has graduated.",
            "If someone is an alumni, then they have graduated.",
            "All members of the club are either students or alumni.",
            "Students are not alumni."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsUniversity(x)) ::: All students attend university.",
            "∀x (HasGraduated(x) → Alumni(x)) ::: Anyone who has graduated is an alumni.",
            "∃x (MemberOfClub(x) ∧ Student(x)) ::: Some members of the club are students.",
            "∀x (AttendsUniversity(x) → (Student(x) ∨ Alumni(x))) ::: Anyone who attends university is either a student or an alumni.",
            "MemberOfClub(john) ::: John is a member of the club.",
            "Student(mary) ::: Mary is a student.",
            "AttendsUniversity(mary) ::: Mary attends university.",
            "∀x (MemberOfClub(x) ∧ Student(x) → AttendsUniversity(x)) ::: All students who are members of the club attend university.",
            "∀x ¬(Student(x) ∧ HasGraduated(x)) ::: No student has graduated.",
            "∀x (Alumni(x) → HasGraduated(x)) ::: If someone is an alumni, then they have graduated.",
            "∀x (MemberOfClub(x) → (Student(x) ∨ Alumni(x))) ::: All members of the club are either students or alumni.",
            "∀x (Student(x) → ¬Alumni(x)) ::: Students are not alumni."
        ],
        "predicates": [
            "MemberOfClub(x) ::: x is a member of the club.",
            "Student(x) ::: x is a student.",
            "Alumni(x) ::: x is an alumni.",
            "AttendsUniversity(x) ::: x attends a university.",
            "HasGraduated(x) ::: x has graduated."
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "No surgeon is a consultant.",
            "Some consultants are specialists.",
            "All specialists are doctors.",
            "There is at least one surgeon.",
            "If someone is a surgeon, then they are a doctor.",
            "Every consultant is either a specialist or not a doctor.",
            "If someone is a doctor, they are either a surgeon or a consultant.",
            "If someone is not a doctor, then they are not a surgeon.",
            "Someone is either a doctor or not a surgeon.",
            "If someone is a consultant, then they are a doctor.",
            "No one is both a consultant and a surgeon."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Surgeon(x) → ¬Consultant(x)) ::: No surgeon is a consultant.",
            "∃x (Consultant(x) ∧ Specialist(x)) ::: Some consultants are specialists.",
            "∀x (Specialist(x) → Doctor(x)) ::: All specialists are doctors.",
            "∃x Surgeon(x) ::: There is at least one surgeon.",
            "∀x (Surgeon(x) → Doctor(x)) ::: If someone is a surgeon, then they are a doctor.",
            "∀x (Consultant(x) → (Specialist(x) ∨ ¬Doctor(x))) ::: Every consultant is either a specialist or not a doctor.",
            "∀x (Doctor(x) → (Surgeon(x) ∨ Consultant(x))) ::: If someone is a doctor, they are either a surgeon or a consultant.",
            "∀x (¬Doctor(x) → ¬Surgeon(x)) ::: If someone is not a doctor, then they are not a surgeon.",
            "∀x (Doctor(x) ∨ ¬Surgeon(x)) ::: Someone is either a doctor or not a surgeon.",
            "∀x (Consultant(x) → Doctor(x)) ::: If someone is a consultant, then they are a doctor.",
            "∀x ¬(Consultant(x) ∧ Surgeon(x)) ::: No one is both a consultant and a surgeon."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Specialist(x) ::: x is a specialist",
            "Surgeon(x) ::: x is a surgeon",
            "Consultant(x) ::: x is a consultant"
        ]
    },
    {
        "premises-NL": [
            "All students attend class.",
            "If a student attends class, then they study hard.",
            "If a student studies hard and is smart, then they pass the exam.",
            "There exists a student who is smart.",
            "Every student is either smart or does not study hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClass(x)) ::: All students attend class.",
            "∀x (AttendsClass(x) → StudiesHard(x)) ::: If a student attends class, then they study hard.",
            "∀x ((StudiesHard(x) ∧ Smart(x)) → PassesExam(x)) ::: If a student studies hard and is smart, then they pass the exam.",
            "∃x Smart(x) ::: There exists a student who is smart.",
            "∀x (Student(x) → (Smart(x) ∨ ¬StudiesHard(x))) ::: Every student is either smart or does not study hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "AttendsClass(x) ::: x attends class",
            "PassesExam(x) ::: x passes the exam",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All diligent students study hard.",
            "All students who study hard attend classes.",
            "Anyone who attends classes passes exams.",
            "Those who pass exams get good grades.",
            "Anyone who fails does not get good grades.",
            "If a student doesn't succeed, then they fail.",
            "A student either succeeds or fails.",
            "A student is diligent if and only if they study hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ Diligent(x) → StudiesHard(x)) ::: All diligent students study hard.",
            "∀x (StudiesHard(x) → AttendsClasses(x)) ::: All students who study hard attend classes.",
            "∀x (AttendsClasses(x) → PassesExams(x)) ::: Anyone who attends classes passes exams.",
            "∀x (PassesExams(x) → GetsGoodGrades(x)) ::: Those who pass exams get good grades.",
            "∀x (Fails(x) → ¬GetsGoodGrades(x)) ::: Anyone who fails does not get good grades.",
            "∀x (¬Succeed(x) → Fails(x)) ::: If a student doesn't succeed, then they fail.",
            "∀x (Student(x) → (Succeed(x) ∨ Fails(x))) ::: A student either succeeds or fails.",
            "∀x (Student(x) ∧ Diligent(x) ↔ StudiesHard(x)) ::: A student is diligent if and only if they study hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Diligent(x) ::: x is diligent",
            "Succeed(x) ::: x will succeed",
            "Fails(x) ::: x fails",
            "StudiesHard(x) ::: x studies hard",
            "AttendsClasses(x) ::: x attends classes",
            "PassesExams(x) ::: x passes exams",
            "GetsGoodGrades(x) ::: x gets good grades"
        ]
    },
    {
        "premises-NL": [
            "All professors are teachers.",
            "If someone is a professor, they teach students.",
            "If someone is a teacher, they knows their students.",
            "Some students attend classes.",
            "Some professors are researchers.",
            "If someone studies, they attends.",
            "If someone studies and is a teacher, they attends.",
            "Some teachers are professors.",
            "If someone studies and attends, they knows their teachers.",
            "If someone attends and is a professor, they teaches students.",
            "If someone is a professor and teaches students, they knows their students.",
            "Every professor is a teacher.",
            "If someone teaches students, they are a teacher.",
            "Some professors studies."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Teacher(x)) ::: All professors are teachers.",
            "∀x (Professor(x) → Teaches(x, AllStudents)) ::: If someone is a professor, they teach students.",
            "∀x (Teacher(x) → Knows(x, AllStudents)) ::: If someone is a teacher, they knows their students.",
            "∃x (Student(x) ∧ Attends(x, Classes)) ::: Some students attend classes.",
            "∃x (Professor(x) ∧ Researcher(x)) ::: Some professors are researchers.",
            "∀x (Studies(x, Course) → Attends(x, Course)) ::: If someone studies, they attends.",
            "∀x (Studies(x, Course) ∧ Teacher(x) → Attends(x, Course)) ::: If someone studies and is a teacher, they attends.",
            "∃x (Teacher(x) ∧ Professor(x)) ::: Some teachers are professors.",
            "∀x (Studies(x, Course) ∧ Attends(x, Course) → Knows(x, AllTeachers)) ::: If someone studies and attends, they knows their teachers.",
            "∀x (Attends(x, Course) ∧ Professor(x) → Teaches(x, Course)) ::: If someone attends and is a professor, they teaches students.",
            "∀x (Professor(x) ∧ Teaches(x, AllStudents) → Knows(x, AllStudents)) ::: If someone is a professor and teaches students, they knows their students.",
            "∀x (Professor(x) → Teacher(x)) ::: Every professor is a teacher.",
            "∀x (Teaches(x, AllStudents) → Teacher(x)) ::: If someone teaches students, they are a teacher.",
            "∃x (Professor(x) ∧ Studies(x, Course)) ::: Some professors studies."
        ],
        "predicates": [
            "Teacher(x) ::: x is a teacher.",
            "Professor(x) ::: x is a professor.",
            "Student(x) ::: x is a student.",
            "Knows(x, y) ::: x knows y.",
            "Teaches(x, y) ::: x teaches y.",
            "Studies(x, y) ::: x studies y.",
            "Attends(x, y) ::: x attends y.",
            "Researcher(x) ::: x is a researcher."
        ]
    },
    {
        "premises-NL": [
            "All students like science.",
            "John is a student.",
            "Biology is a science.",
            "Anyone who likes science is good at it.",
            "If someone is good at science and studies biology, they study biology."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Likes(x, science)) ::: All students like science.",
            "Student(john) ::: John is a student.",
            "IsScience(biology) ::: Biology is a science.",
            "∀x ∀y (Likes(x, y) ∧ IsScience(y) → GoodAt(x, y)) ::: Anyone who likes science is good at it.",
            "∀x ∀y (GoodAt(x, y) ∧ Studies(x, biology) → Studies(x, biology)) ::: If someone is good at science and studies biology, they study biology.",
            "∀x (GoodAt(x, science) ∧ Studies(x, biology) → Studies(x, biology)) ::: If someone is good at science and studies biology, they study biology.",
            "∀x (GoodAt(x, science) → Studies(x, biology)) ::: If someone is good at science and studies biology, they study biology.",
            "∀x (GoodAt(x, science) → Studies(x, biology)) ::: If someone is good at science and studies biology, they study biology.",
            "∀x (GoodAt(x, science) → Studies(x, biology)) ::: If someone is good at science and studies biology, they study biology.",
            "∀x (GoodAt(x, science) → Studies(x, biology)) ::: If someone is good at science and studies biology, they study biology."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x, y) ::: x studies y",
            "Likes(x, y) ::: x likes y",
            "IsScience(x) ::: x is a science",
            "GoodAt(x, y) ::: x is good at y"
        ]
    },
    {
        "premises-NL": [
            "All children are either vaccinated or not vaccinated.",
            "Every child has the flu or is healthy.",
            "If a child has the flu they are not healthy.",
            "A child who is not vaccinated will likely get the flu.",
            "Anyone who is not healthy will not go to school.",
            "If a child goes to school, then they are healthy.",
            "John is a child.",
            "John does not have the flu.",
            "If John has the flu he won't go to school.",
            "No one can be healthy and go to school.",
            "Every child is not healthy or goes to school."
        ],
        "premises-FOL": [
            "∀x (Child(x) → (Vaccinated(x) ∨ ¬Vaccinated(x))) ::: All children are either vaccinated or not vaccinated.",
            "∀x (Child(x) → (HasFlu(x) ∨ Healthy(x))) ::: Every child has the flu or is healthy.",
            "∀x (HasFlu(x) → ¬Healthy(x)) ::: If a child has the flu they are not healthy.",
            "∀x (¬Vaccinated(x) → HasFlu(x)) ::: A child who is not vaccinated will likely get the flu.",
            "∀x (¬Healthy(x) → ¬GoesToSchool(x)) ::: Anyone who is not healthy will not go to school.",
            "∀x (GoesToSchool(x) → Healthy(x)) ::: If a child goes to school, then they are healthy.",
            "Child(john) ::: John is a child.",
            "¬HasFlu(john) ::: John does not have the flu.",
            "HasFlu(john) → ¬GoesToSchool(john) ::: If John has the flu he won't go to school.",
            "∀x ¬(Healthy(x) ∧ GoesToSchool(x)) ::: No one can be healthy and go to school.",
            "∀x (Child(x) → (¬Healthy(x) ∨ GoesToSchool(x))) ::: Every child is not healthy or goes to school."
        ],
        "predicates": [
            "Child(x) ::: x is a child",
            "HasFlu(x) ::: x has the flu",
            "GoesToSchool(x) ::: x goes to school",
            "Vaccinated(x) ::: x is vaccinated",
            "Healthy(x) ::: x is healthy"
        ]
    },
    {
        "premises-NL": [
            "All doctors work at a hospital.",
            "Anyone who works at a hospital has a license.",
            "If someone is a surgeon, then they are a doctor.",
            "All surgeons specialize in surgery.",
            "Everyone who specializes in surgery is licensed to operate.",
            "If someone has a license, then they must have been trained.",
            "If a doctor is not a surgeon, they work at a hospital.",
            "Either someone is a surgeon, or a doctor.",
            "If someone is trained, they must work at a hospital.",
            "If someone is licensed to operate, then they are a doctor.",
            "If someone is a doctor, then they have a license.",
            "Anyone who works at a hospital and specializes is a surgeon."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → WorksAtHospital(x)) ::: All doctors work at a hospital.",
            "∀x (WorksAtHospital(x) → HasLicense(x)) ::: Anyone who works at a hospital has a license.",
            "∀x (Surgeon(x) → Doctor(x)) ::: If someone is a surgeon, then they are a doctor.",
            "∀x (Surgeon(x) → SpecializesIn(x, surgery)) ::: All surgeons specialize in surgery.",
            "∀x (SpecializesIn(x, surgery) → LicensedToOperate(x)) ::: Everyone who specializes in surgery is licensed to operate.",
            "∀x (HasLicense(x) → Trained(x)) ::: If someone has a license, then they must have been trained.",
            "∀x (Doctor(x) ∧ ¬Surgeon(x) → WorksAtHospital(x)) ::: If a doctor is not a surgeon, they work at a hospital.",
            "∀x (Surgeon(x) ∨ Doctor(x)) ::: Either someone is a surgeon, or a doctor.",
            "∀x (Trained(x) → WorksAtHospital(x)) ::: If someone is trained, they must work at a hospital.",
            "∀x (LicensedToOperate(x) → Doctor(x)) ::: If someone is licensed to operate, then they are a doctor.",
            "∀x (Doctor(x) → HasLicense(x)) ::: If someone is a doctor, then they have a license.",
            "∀x (WorksAtHospital(x) ∧ SpecializesIn(x, y) → Surgeon(x)) ::: Anyone who works at a hospital and specializes is a surgeon."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "HasLicense(x) ::: x has a license",
            "WorksAtHospital(x) ::: x works at a hospital",
            "SpecializesIn(x, y) ::: x specializes in y",
            "Surgeon(x) ::: x is a surgeon",
            "LicensedToOperate(x) ::: x is licensed to operate"
        ]
    },
    {
        "premises-NL": [
            "All scientists are researchers.",
            "Every researcher publishes papers.",
            "Anyone who publishes papers has a degree.",
            "If someone has a degree, they either have a degree in science or mathematics.",
            "If someone studies math, they are a scientist.",
            "John is a scientist.",
            "Anyone who studies science is a researcher.",
            "If someone studies something, they have a degree.",
            "If someone has a degree, they publish papers.",
            "If someone is a scientist, then they study science or mathematics.",
            "If someone studies science, then they have a degree in science.",
            "If someone studies mathematics, then they have a degree in mathematics.",
            "If someone is a scientist, then they are a researcher."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Researcher(x)) ::: All scientists are researchers.",
            "∀x (Researcher(x) → PublishesPapers(x)) ::: Every researcher publishes papers.",
            "∀x (PublishesPapers(x) → HasDegree(x)) ::: Anyone who publishes papers has a degree.",
            "∀x (HasDegree(x) → (DegreeScience(x) ∨ DegreeMath(x))) ::: If someone has a degree, they either have a degree in science or mathematics.",
            "∀x (Studies(x, math) → Scientist(x)) ::: If someone studies math, they are a scientist.",
            "Scientist(john) ::: John is a scientist.",
            "∀x (Studies(x, science) → Researcher(x)) ::: Anyone who studies science is a researcher.",
            "∀x ∀y (Studies(x, y) → HasDegree(x)) ::: If someone studies something, they have a degree.",
            "∀x (HasDegree(x) → PublishesPapers(x)) ::: If someone has a degree, they publish papers.",
            "∀x (Scientist(x) → (Studies(x, science) ∨ Studies(x, math))) ::: If someone is a scientist, then they study science or mathematics.",
            "∀x (Studies(x, science) → DegreeScience(x)) ::: If someone studies science, then they have a degree in science.",
            "∀x (Studies(x, math) → DegreeMath(x)) ::: If someone studies mathematics, then they have a degree in mathematics.",
            "∀x (Scientist(x) → Researcher(x)) ::: If someone is a scientist, then they are a researcher."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "DegreeScience(x) ::: x has a degree in science",
            "DegreeMath(x) ::: x has a degree in mathematics",
            "Researcher(x) ::: x is a researcher",
            "PublishesPapers(x) ::: x publishes papers",
            "HasDegree(x, y) ::: x has a degree in y",
            "Studies(x, y) ::: x studies y"
        ]
    },
    {
        "premises-NL": [
            "All doctors are employed.",
            "Some employed people are wealthy.",
            "If someone is a doctor, they are a person.",
            "If someone is employed, they are a person.",
            "If someone is wealthy, they are a person.",
            "A doctor is a human being.",
            "Doctors examine patients",
            "Employed individuals have jobs"
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Employed(x)) ::: All doctors are employed.",
            "∃x (Employed(x) ∧ Wealthy(x)) ::: Some employed people are wealthy.",
            "∀x (Doctor(x) → Person(x)) ::: If someone is a doctor, they are a person.",
            "∀x (Employed(x) → Person(x)) ::: If someone is employed, they are a person.",
            "∀x (Wealthy(x) → Person(x)) ::: If someone is wealthy, they are a person.",
            "∀x (Doctor(x) → Human(x)) ::: A doctor is a human being.",
            "∀x (Doctor(x) → ExaminesPatients(x)) ::: Doctors examine patients",
            "∀x (Employed(x) → HasJob(x)) ::: Employed individuals have jobs"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Employed(x) ::: x is employed",
            "Wealthy(x) ::: x is wealthy"
        ]
    },
    {
        "premises-NL": [
            "All cats are mammals.",
            "All mammals are animals.",
            "If something is a cat, then it has fur.",
            "If something is a mammal, then it gives milk.",
            "If something is an animal, then it breathes.",
            "A cat is a living being.",
            "A mammal is a living being.",
            "An animal is a living being.",
            "Cats are known for their purring sound.",
            "Mammals typically have warm blood."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → Mammal(x)) ::: All cats are mammals.",
            "∀x (Mammal(x) → Animal(x)) ::: All mammals are animals.",
            "∀x (Cat(x) → HasFur(x)) ::: If something is a cat, then it has fur.",
            "∀x (Mammal(x) → GivesMilk(x)) ::: If something is a mammal, then it gives milk.",
            "∀x (Animal(x) → Breathes(x)) ::: If something is an animal, then it breathes.",
            "∀x (Cat(x) → LivingBeing(x)) ::: A cat is a living being.",
            "∀x (Mammal(x) → LivingBeing(x)) ::: A mammal is a living being.",
            "∀x (Animal(x) → LivingBeing(x)) ::: An animal is a living being.",
            "∀x (Cat(x) → HasPurringSound(x)) ::: Cats are known for their purring sound.",
            "∀x (Mammal(x) → HasWarmBlood(x)) ::: Mammals typically have warm blood."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Mammal(x) ::: x is a mammal",
            "Animal(x) ::: x is an animal"
        ]
    },
    {
        "premises-NL": [
            "All apples are fruits.",
            "Some fruits are red.",
            "If something is an apple, it is eatable.",
            "If something is red, it is colorful.",
            "Some fruits grow on trees.",
            "All apples grow on trees.",
            "If something is eatable, it provides nutrients.",
            "If something provides nutrients, it is good for health.",
            "If something is a fruit, it can be eaten.",
            "If something is colorful, it can be beautiful.",
            "All fruits can be eaten."
        ],
        "premises-FOL": [
            "∀x (Apple(x) → Fruit(x)) ::: All apples are fruits.",
            "∃x (Fruit(x) ∧ Red(x)) ::: Some fruits are red.",
            "∀x (Apple(x) → Eatable(x)) ::: If something is an apple, it is eatable.",
            "∀x (Red(x) → Colorful(x)) ::: If something is red, it is colorful.",
            "∃x (Fruit(x) ∧ GrowsOnTree(x)) ::: Some fruits grow on trees.",
            "∀x (Apple(x) → GrowsOnTree(x)) ::: All apples grow on trees.",
            "∀x (Eatable(x) → ProvidesNutrients(x)) ::: If something is eatable, it provides nutrients.",
            "∀x (ProvidesNutrients(x) → GoodForHealth(x)) ::: If something provides nutrients, it is good for health.",
            "∀x (Fruit(x) → CanBeEaten(x)) ::: If something is a fruit, it can be eaten.",
            "∀x (Colorful(x) → CanBeBeautiful(x)) ::: If something is colorful, it can be beautiful.",
            "∀x (Fruit(x) → CanBeEaten(x)) ::: All fruits can be eaten."
        ],
        "predicates": [
            "Apple(x) ::: x is an apple",
            "Fruit(x) ::: x is a fruit",
            "Red(x) ::: x is red",
            "Eatable(x) ::: x is eatable",
            "GrowsOnTree(x) ::: x grows on a tree"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "Some doctors smoke.",
            "No smoker is healthy.",
            "Dr. Smith is a surgeon.",
            "Dr. Jones is a doctor.",
            "Dr. Smith smokes.",
            "Dr. Jones smokes or Dr. Smith is healthy.",
            "Dr. Brown is a doctor.",
            "If someone is a surgeon, then they are a doctor.",
            "If someone is a doctor and smokes, then they are unhealthy.",
            "Dr. Brown is healthy."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∃x (Doctor(x) ∧ Smokes(x)) ::: Some doctors smoke.",
            "∀x (Smokes(x) → ¬Healthy(x)) ::: No smoker is healthy.",
            "Surgeon(smith) ::: Dr. Smith is a surgeon.",
            "Doctor(jones) ::: Dr. Jones is a doctor.",
            "Smokes(smith) ::: Dr. Smith smokes.",
            "Smokes(jones) ∨ Healthy(smith) ::: Dr. Jones smokes or Dr. Smith is healthy.",
            "Doctor(brown) ::: Dr. Brown is a doctor.",
            "∀x (Surgeon(x) → Doctor(x)) ::: If someone is a surgeon, then they are a doctor.",
            "∀x ((Doctor(x) ∧ Smokes(x)) → ¬Healthy(x)) ::: If someone is a doctor and smokes, then they are unhealthy.",
            "Healthy(brown) ::: Dr. Brown is healthy."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Surgeon(x) ::: x is a surgeon.",
            "Healthy(x) ::: x is healthy.",
            "Smokes(x) ::: x smokes."
        ]
    },
    {
        "premises-NL": [
            "All students attend lectures.",
            "John is a student.",
            "John is not a professor.",
            "Professors do not attend lectures.",
            "Anyone who is a student is taking a course.",
            "John is taking a course."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsLectures(x)) ::: All students attend lectures.",
            "Student(john) ::: John is a student.",
            "¬Professor(john) ::: John is not a professor.",
            "∀x (Professor(x) → ¬AttendsLectures(x)) ::: Professors do not attend lectures.",
            "∀x (Student(x) → TakingCourse(x)) ::: Anyone who is a student is taking a course.",
            "TakingCourse(john) ::: John is taking a course."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "AttendsLectures(x) ::: x attends lectures."
        ]
    },
    {
        "premises-NL": [
            "All cats are mammals.",
            "Some mammals are not dogs.",
            "If something is a cat, then it has fur.",
            "Everything that has fur is a mammal.",
            "If something is a dog, it barks.",
            "No cat barks.",
            "All dogs are animals."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → Mammal(x)) ::: All cats are mammals.",
            "∃x (Mammal(x) ∧ ¬Dog(x)) ::: Some mammals are not dogs.",
            "∀x (Cat(x) → HasFur(x)) ::: If something is a cat, then it has fur.",
            "∀x (HasFur(x) → Mammal(x)) ::: Everything that has fur is a mammal.",
            "∀x (Dog(x) → Barks(x)) ::: If something is a dog, it barks.",
            "∀x (Cat(x) → ¬Barks(x)) ::: No cat barks.",
            "∀x (Dog(x) → Animal(x)) ::: All dogs are animals."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat.",
            "Mammal(x) ::: x is a mammal.",
            "Dog(x) ::: x is a dog."
        ]
    },
    {
        "premises-NL": [
            "Every student is either lazy or studies a lot.",
            "Every student who studies a lot passes the exam.",
            "John is a student.",
            "If someone is lazy, they don't exercise.",
            "Anyone who exercises is healthy.",
            "John doesn't exercise.",
            "If you are healthy, you pass the exam.",
            "Someone who doesn't pass the exam is not healthy."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Lazy(x) ∨ StudiesALot(x))) ::: Every student is either lazy or studies a lot.",
            "∀x (StudiesALot(x) → PassExam(x)) ::: Every student who studies a lot passes the exam.",
            "Student(john) ::: John is a student.",
            "∀x (Lazy(x) → ¬Exercises(x)) ::: If someone is lazy, they don't exercise.",
            "∀x (Exercises(x) → Healthy(x)) ::: Anyone who exercises is healthy.",
            "¬Exercises(john) ::: John doesn't exercise.",
            "∀x (Healthy(x) → PassExam(x)) ::: If you are healthy, you pass the exam.",
            "∀x (¬PassExam(x) → ¬Healthy(x)) ::: Someone who doesn't pass the exam is not healthy."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Lazy(x) ::: x is lazy.",
            "StudiesALot(x) ::: x studies a lot.",
            "PassExam(x) ::: x passes the exam."
        ]
    },
    {
        "premises-NL": [
            "Anyone who is a doctor or a nurse works.",
            "Every doctor is highly skilled.",
            "John is a doctor.",
            "John treats patients.",
            "If someone treats patients, they work.",
            "If someone is a nurse, they help patients.",
            "Anyone who helps patients is compassionate.",
            "Highly skilled people get paid well.",
            "John is highly skilled."
        ],
        "premises-FOL": [
            "∀x ((Doctor(x) ∨ Nurse(x)) → Works(x)) ::: Anyone who is a doctor or a nurse works.",
            "∀x (Doctor(x) → HighlySkilled(x)) ::: Every doctor is highly skilled.",
            "Doctor(john) ::: John is a doctor.",
            "TreatsPatients(john) ::: John treats patients.",
            "∀x (TreatsPatients(x) → Works(x)) ::: If someone treats patients, they work.",
            "∀x (Nurse(x) → HelpsPatients(x)) ::: If someone is a nurse, they help patients.",
            "∀x (HelpsPatients(x) → Compassionate(x)) ::: Anyone who helps patients is compassionate.",
            "∀x (HighlySkilled(x) → GetsPaidWell(x)) ::: Highly skilled people get paid well.",
            "HighlySkilled(john) ::: John is highly skilled."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Nurse(x) ::: x is a nurse.",
            "Works(x) ::: x works.",
            "HighlySkilled(x) ::: x is highly skilled."
        ]
    },
    {
        "premises-NL": [
            "All dogs are mammals.",
            "No mammals are reptiles.",
            "Fido is a dog.",
            "Fido is an animal.",
            "Every animal needs food.",
            "If something is a dog, it has fur.",
            "Everything that has fur is a mammal.",
            "Some animals are not dogs.",
            "If it is a reptile, then it lays eggs."
        ],
        "premises-FOL": [
            "∀x (Dog(x) → Mammal(x)) ::: All dogs are mammals.",
            "∀x (Mammal(x) → ¬Reptile(x)) ::: No mammals are reptiles.",
            "Dog(fido) ::: Fido is a dog.",
            "Animal(fido) ::: Fido is an animal.",
            "∀x (Animal(x) → NeedsFood(x)) ::: Every animal needs food.",
            "∀x (Dog(x) → HasFur(x)) ::: If something is a dog, it has fur.",
            "∀x (HasFur(x) → Mammal(x)) ::: Everything that has fur is a mammal.",
            "∃x (Animal(x) ∧ ¬Dog(x)) ::: Some animals are not dogs.",
            "∀x (Reptile(x) → LaysEggs(x)) ::: If it is a reptile, then it lays eggs."
        ],
        "predicates": [
            "Dog(x) ::: x is a dog.",
            "Mammal(x) ::: x is a mammal.",
            "Reptile(x) ::: x is a reptile.",
            "Animal(x) ::: x is an animal."
        ]
    },
    {
        "premises-NL": [
            "All students attend class.",
            "Alex is a student.",
            "If someone attends class and studies, then they will pass the exam.",
            "Alex studies or reads books.",
            "If Alex reads books, Alex is smart.",
            "If someone is smart, they study.",
            "If Alex studies, he attends class.",
            "Students are smart or read books.",
            "If someone attends class, they will pass the exam.",
            "If Alex is a student, then Alex studies or does not read books.",
            "If Alex is a student and reads books, Alex is smart."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendClass(x)) ::: All students attend class.",
            "Student(alex) ::: Alex is a student.",
            "∀x (AttendClass(x) ∧ Study(x) → PassExam(x)) ::: If someone attends class and studies, then they will pass the exam.",
            "Study(alex) ∨ ReadsBooks(alex) ::: Alex studies or reads books.",
            "ReadsBooks(alex) → Smart(alex) ::: If Alex reads books, Alex is smart.",
            "∀x (Smart(x) → Study(x)) ::: If someone is smart, they study.",
            "Study(alex) → AttendClass(alex) ::: If Alex studies, he attends class.",
            "∀x (Student(x) → (Smart(x) ∨ ReadsBooks(x))) ::: Students are smart or read books.",
            "∀x (AttendClass(x) → PassExam(x)) ::: If someone attends class, they will pass the exam.",
            "Student(alex) → (Study(alex) ∨ ¬ReadsBooks(alex)) ::: If Alex is a student, then Alex studies or does not read books.",
            "Student(alex) ∧ ReadsBooks(alex) → Smart(alex) ::: If Alex is a student and reads books, Alex is smart."
        ],
        "predicates": [
            "Study(x) ::: x studies.",
            "Student(x) ::: x is a student.",
            "PassExam(x) ::: x will pass the exam.",
            "AttendClass(x) ::: x attends class.",
            "Smart(x) ::: x is smart.",
            "ReadsBooks(x) ::: x reads books."
        ]
    },
    {
        "premises-NL": [
            "All patients either have the flu or are not sick.",
            "If someone has a fever, they are sick.",
            "If someone has symptoms of the flu, they have a fever.",
            "Patients who are sick receive treatment.",
            "If someone receives treatment, they take medicine.",
            "If someone takes medicine, they are not sick.",
            "If someone is sick, they have a fever.",
            "If someone has the flu, they have symptoms of the flu.",
            "Patients with the flu are sick.",
            "Someone is a patient.",
            "If a patient takes medicine, the patient is not sick.",
            "Patients are sick or not sick.",
            "Anyone who takes medicine, is not sick."
        ],
        "premises-FOL": [
            "∀x (Patient(x) → (HasDisease(x,flu) ∨ ¬Sick(x))) ::: All patients either have the flu or are not sick.",
            "∀x (HasFever(x) → Sick(x)) ::: If someone has a fever, they are sick.",
            "∀x (SymptomsFlu(x) → HasFever(x)) ::: If someone has symptoms of the flu, they have a fever.",
            "∀x (Sick(x) → ReceivesTreatment(x)) ::: Patients who are sick receive treatment.",
            "∀x (ReceivesTreatment(x) → TakesMedicine(x)) ::: If someone receives treatment, they take medicine.",
            "∀x (TakesMedicine(x) → ¬Sick(x)) ::: If someone takes medicine, they are not sick.",
            "∀x (Sick(x) → HasFever(x)) ::: If someone is sick, they have a fever.",
            "∀x (HasDisease(x,flu) → SymptomsFlu(x)) ::: If someone has the flu, they have symptoms of the flu.",
            "∀x (Patient(x) ∧ HasDisease(x,flu) → Sick(x)) ::: Patients with the flu are sick.",
            "∃x Patient(x) ::: Someone is a patient.",
            "∀x (Patient(x) ∧ TakesMedicine(x) → ¬Sick(x)) ::: If a patient takes medicine, the patient is not sick.",
            "∀x (Patient(x) → (Sick(x) ∨ ¬Sick(x))) ::: Patients are sick or not sick.",
            "∀x (TakesMedicine(x) → ¬Sick(x)) ::: Anyone who takes medicine, is not sick."
        ],
        "predicates": [
            "SymptomsFlu(x) ::: x has symptoms of the flu.",
            "Sick(x) ::: x is sick.",
            "ReceivesTreatment(x) ::: x receives treatment.",
            "TakesMedicine(x) ::: x takes medicine.",
            "HasFever(x) ::: x has a fever.",
            "Patient(x) ::: x is a patient.",
            "HasDisease(x,y) ::: x has disease y."
        ]
    },
    {
        "premises-NL": [
            "All doctors are trained.",
            "If someone is a doctor, they treat patients.",
            "If someone treats patients, they administer care.",
            "Surgeons are doctors.",
            "If someone administers care, they are a healthcare provider.",
            "If someone is a healthcare provider, they have a license.",
            "If someone is a healthcare provider, they prescribe medicine.",
            "Doctors have licenses.",
            "Nurses are healthcare providers.",
            "If someone has a license, they are a healthcare provider.",
            "Doctors administer care.",
            "If someone is a doctor and prescribes medicine, then the patient is treated.",
            "Doctors have a license and are trained.",
            "If someone treats patients and has a license, the person is a healthcare provider.",
            "Surgeons prescribe medicine."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Trained(x)) ::: All doctors are trained.",
            "∀x (Doctor(x) → TreatsPatients(x)) ::: If someone is a doctor, they treat patients.",
            "∀x (TreatsPatients(x) → AdministersCare(x)) ::: If someone treats patients, they administer care.",
            "∀x (Surgeon(x) → Doctor(x)) ::: Surgeons are doctors.",
            "∀x (AdministersCare(x) → HealthcareProvider(x)) ::: If someone administers care, they are a healthcare provider.",
            "∀x (HealthcareProvider(x) → HasLicense(x)) ::: If someone is a healthcare provider, they have a license.",
            "∀x (HealthcareProvider(x) → PrescribesMedicine(x)) ::: If someone is a healthcare provider, they prescribe medicine.",
            "∀x (Doctor(x) → HasLicense(x)) ::: Doctors have licenses.",
            "∀x (Nurse(x) → HealthcareProvider(x)) ::: Nurses are healthcare providers.",
            "∀x (HasLicense(x) → HealthcareProvider(x)) ::: If someone has a license, they are a healthcare provider.",
            "∀x (Doctor(x) → AdministersCare(x)) ::: Doctors administer care.",
            "∀x ∀y (Doctor(x) ∧ PrescribesMedicine(x) → TreatsPatients(y)) ::: If someone is a doctor and prescribes medicine, then the patient is treated.",
            "∀x (Doctor(x) → (HasLicense(x) ∧ Trained(x))) ::: Doctors have a license and are trained.",
            "∀x (TreatsPatients(x) ∧ HasLicense(x) → HealthcareProvider(x)) ::: If someone treats patients and has a license, the person is a healthcare provider.",
            "∀x (Surgeon(x) → PrescribesMedicine(x)) ::: Surgeons prescribe medicine."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "PrescribesMedicine(x) ::: x prescribes medicine.",
            "HealthcareProvider(x) ::: x is a healthcare provider.",
            "HasLicense(x) ::: x has a license.",
            "Trained(x) ::: x is trained.",
            "TreatsPatients(x) ::: x treats patients.",
            "Surgeon(x) ::: x is a surgeon.",
            "Nurse(x) ::: x is a nurse.",
            "AdministersCare(x) ::: x administers care."
        ]
    },
    {
        "premises-NL": [
            "All programmers know coding.",
            "If someone knows coding, then they are knowledgeable about coding.",
            "Alice is a programmer.",
            "Alice knows coding.",
            "If someone loves coding then they are a programmer.",
            "Bob does not know coding.",
            "Someone loves coding.",
            "If Bob loves coding, then he knows coding.",
            "Every programmer loves coding.",
            "Alice loves coding."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → Knows(x, coding)) ::: All programmers know coding.",
            "∀x (Knows(x, coding) → Knowledgeable(x, coding)) ::: If someone knows coding, then they are knowledgeable about coding.",
            "Programmer(alice) ::: Alice is a programmer.",
            "Knows(alice, coding) ::: Alice knows coding.",
            "∀x (Loves(x, coding) → Programmer(x)) ::: If someone loves coding then they are a programmer.",
            "¬Knows(bob, coding) ::: Bob does not know coding.",
            "∃x Loves(x, coding) ::: Someone loves coding.",
            "Loves(bob, coding) → Knows(bob, coding) ::: If Bob loves coding, then he knows coding.",
            "∀x (Programmer(x) → Loves(x, coding)) ::: Every programmer loves coding.",
            "Loves(alice, coding) ::: Alice loves coding."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "Knows(x, y) ::: x knows y",
            "Knowledgeable(x, y) ::: x is knowledgeable about y",
            "Loves(x, y) ::: x loves y"
        ]
    },
    {
        "premises-NL": [
            "All programmers know Python.",
            "All programmers know Java.",
            "If someone knows Python and Java, they are skilled.",
            "If a programmer uses Python and Java, then the person is skilled.",
            "John is a programmer.",
            "John knows Python and Java.",
            "If someone works at Google, they are a programmer.",
            "John works at Google.",
            "Mary uses Python.",
            "Mary uses Java.",
            "If someone uses a language and knows it, they are a programmer.",
            "Mary is a programmer.",
            "If a programmer works at a company, then they are skilled.",
            "Programmers use Python or Java",
            "If a programmer knows Python and Java, then they use them.",
            "If John is a programmer, and he works at Google, then John is skilled.",
            "Programmers are skilled or they use Python"
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → Knows(x, python)) ::: All programmers know Python.",
            "∀x (Programmer(x) → Knows(x, java)) ::: All programmers know Java.",
            "∀x (Knows(x, python) ∧ Knows(x, java) → Skilled(x)) ::: If someone knows Python and Java, they are skilled.",
            "∀x (Programmer(x) ∧ Uses(x, python) ∧ Uses(x, java) → Skilled(x)) ::: If a programmer uses Python and Java, then the person is skilled.",
            "Programmer(john) ::: John is a programmer.",
            "Knows(john, python) ∧ Knows(john, java) ::: John knows Python and Java.",
            "∀x (WorksAt(x, google) → Programmer(x)) ::: If someone works at Google, they are a programmer.",
            "WorksAt(john, google) ::: John works at Google.",
            "Uses(mary, python) ::: Mary uses Python.",
            "Uses(mary, java) ::: Mary uses Java.",
            "∀x ∀y (Uses(x, y) ∧ Knows(x, y) → Programmer(x)) ::: If someone uses a language and knows it, they are a programmer.",
            "Programmer(mary) ::: Mary is a programmer.",
            "∀x (Programmer(x) ∧ WorksAt(x, y) → Skilled(x)) ::: If a programmer works at a company, then they are skilled.",
            "∀x (Programmer(x) → (Uses(x, python) ∨ Uses(x, java))) ::: Programmers use Python or Java",
            "∀x (Programmer(x) ∧ Knows(x, python) ∧ Knows(x, java) → (Uses(x, python) ∧ Uses(x, java))) ::: If a programmer knows Python and Java, then they use them.",
            "Programmer(john) ∧ WorksAt(john, google) → Skilled(john) ::: If John is a programmer, and he works at Google, then John is skilled.",
            "∀x (Programmer(x) → Skilled(x) ∨ Uses(x, python)) ::: Programmers are skilled or they use Python"
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer.",
            "Uses(x, y) ::: x uses programming language y.",
            "Skilled(x) ::: x is skilled.",
            "Knows(x, y) ::: x knows technology y.",
            "WorksAt(x, y) ::: x works at company y."
        ]
    },
    {
        "premises-NL": [
            "All students who study get good grades.",
            "David is a student.",
            "David studies.",
            "If someone gets a good grade, they like ice cream.",
            "If someone likes ice cream, they have a pet.",
            "If someone has a pet, they play the guitar.",
            "If someone plays the guitar, they are tall.",
            "If someone is tall, they are happy.",
            "David studies and then likes ice cream",
            "David likes ice cream.",
            "David has a pet.",
            "David plays guitar.",
            "David is tall.",
            "David is happy.",
            "If someone is happy, they own a car."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ Studies(x) → GoodGrade(x)) ::: All students who study get good grades.",
            "Student(david) ::: David is a student.",
            "Studies(david) ::: David studies.",
            "∀x (GoodGrade(x) → LikesIceCream(x)) ::: If someone gets a good grade, they like ice cream.",
            "∀x (LikesIceCream(x) → HasPet(x)) ::: If someone likes ice cream, they have a pet.",
            "∀x (HasPet(x) → PlaysGuitar(x)) ::: If someone has a pet, they play the guitar.",
            "∀x (PlaysGuitar(x) → IsTall(x)) ::: If someone plays the guitar, they are tall.",
            "∀x (IsTall(x) → IsHappy(x)) ::: If someone is tall, they are happy.",
            "Studies(david) ∧ LikesIceCream(david) ::: David studies and then likes ice cream",
            "LikesIceCream(david) ::: David likes ice cream.",
            "HasPet(david) ::: David has a pet.",
            "PlaysGuitar(david) ::: David plays guitar.",
            "IsTall(david) ::: David is tall.",
            "IsHappy(david) ::: David is happy.",
            "∀x (IsHappy(x) → OwnsCar(x)) ::: If someone is happy, they own a car."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "GoodGrade(x) ::: x gets a good grade",
            "LikesIceCream(x) ::: x likes ice cream",
            "HasPet(x) ::: x has a pet",
            "PlaysGuitar(x) ::: x plays the guitar",
            "IsTall(x) ::: x is tall",
            "IsHappy(x) ::: x is happy",
            "OwnsCar(x) ::: x owns a car",
            "HasJob(x) ::: x has a job",
            "Travels(x) ::: x travels",
            "SpeaksLanguage(x, y) ::: x speaks language y",
            "ReadsBooks(x) ::: x reads books",
            "WritesCode(x) ::: x writes code",
            "SolvesProblems(x) ::: x solves problems"
        ]
    },
    {
        "premises-NL": [
            "If someone has a high salary and is not kind, they will not have many friends.",
            "John has a high salary.",
            "John is not kind.",
            "If someone does not have many friends, they will not attend parties.",
            "If someone does not attend parties, they are lonely.",
            "If someone is lonely, they travel.",
            "If someone travels, they enjoy reading.",
            "If someone enjoys reading, they buy a house.",
            "If someone buys a house, they eat healthy.",
            "If someone eats healthy, they drink coffee.",
            "John has a high salary and is not kind and does not have many friends",
            "If someone drinks coffee, they play the guitar.",
            "If someone plays the guitar, they write code.",
            "If someone writes code, they own a dog.",
            "If someone owns a dog, they watch movies.",
            "If someone watches movies, they play sports.",
            "If someone plays sports, they study."
        ],
        "premises-FOL": [
            "∀x (HighSalary(x) ∧ ¬IsKind(x) → ¬HasManyFriends(x)) ::: If someone has a high salary and is not kind, they will not have many friends.",
            "HighSalary(john) ::: John has a high salary.",
            "¬IsKind(john) ::: John is not kind.",
            "∀x (¬HasManyFriends(x) → ¬AttendsParty(x)) ::: If someone does not have many friends, they will not attend parties.",
            "∀x (¬AttendsParty(x) → Lonely(x)) ::: If someone does not attend parties, they are lonely.",
            "∀x (Lonely(x) → Travels(x)) ::: If someone is lonely, they travel.",
            "∀x (Travels(x) → EnjoysReading(x)) ::: If someone travels, they enjoy reading.",
            "∀x (EnjoysReading(x) → BuysHouse(x)) ::: If someone enjoys reading, they buy a house.",
            "∀x (BuysHouse(x) → EatsHealthy(x)) ::: If someone buys a house, they eat healthy.",
            "∀x (EatsHealthy(x) → DrinksCoffee(x)) ::: If someone eats healthy, they drink coffee.",
            "HighSalary(john) ∧ ¬IsKind(john) ∧ ¬HasManyFriends(john) ::: John has a high salary and is not kind and does not have many friends",
            "∀x (DrinksCoffee(x) → PlaysGuitar(x)) ::: If someone drinks coffee, they play the guitar.",
            "∀x (PlaysGuitar(x) → WritesCode(x)) ::: If someone plays the guitar, they write code.",
            "∀x (WritesCode(x) → OwnsDog(x)) ::: If someone writes code, they own a dog.",
            "∀x (OwnsDog(x) → WatchesMovies(x)) ::: If someone owns a dog, they watch movies.",
            "∀x (WatchesMovies(x) → PlaysSports(x)) ::: If someone watches movies, they play sports.",
            "∀x (PlaysSports(x) → Studies(x)) ::: If someone plays sports, they study."
        ],
        "predicates": [
            "HighSalary(x) ::: x has a high salary",
            "IsKind(x) ::: x is kind",
            "HasManyFriends(x) ::: x has many friends",
            "AttendsParty(x) ::: x attends a party",
            "Lonely(x) ::: x is lonely",
            "Travels(x) ::: x travels",
            "EnjoysReading(x) ::: x enjoys reading",
            "BuysHouse(x) ::: x buys a house",
            "EatsHealthy(x) ::: x eats healthy",
            "DrinksCoffee(x) ::: x drinks coffee",
            "PlaysGuitar(x) ::: x plays the guitar",
            "WritesCode(x) ::: x writes code",
            "OwnsDog(x) ::: x owns a dog",
            "WatchesMovies(x) ::: x watches movies",
            "PlaysSports(x) ::: x plays sports",
            "Studies(x) ::: x studies"
        ]
    },
    {
        "premises-NL": [
            "Every student either studies or likes pizza.",
            "If someone likes pizza, they are not happy.",
            "All students are either happy or they fail.",
            "Anyone who studies will pass the exam.",
            "John is a student.",
            "John does not like pizza.",
            "John is happy.",
            "All students either pass the exam or they fail.",
            "If someone is happy and studies, they pass the exam.",
            "Some students study.",
            "If a student studies and is happy, they pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Study(x) ∨ LikesPizza(x)) ::: Every student either studies or likes pizza.",
            "∀x (LikesPizza(x) → ¬Happy(x)) ::: If someone likes pizza, they are not happy.",
            "∀x (Student(x) → Happy(x) ∨ ¬PassExam(x)) ::: All students are either happy or they fail.",
            "∀x (Study(x) → PassExam(x)) ::: Anyone who studies will pass the exam.",
            "Student(john) ::: John is a student.",
            "¬LikesPizza(john) ::: John does not like pizza.",
            "Happy(john) ::: John is happy.",
            "∀x (Student(x) → PassExam(x) ∨ ¬PassExam(x)) ::: All students either pass the exam or they fail.",
            "∀x ((Happy(x) ∧ Study(x)) → PassExam(x)) ::: If someone is happy and studies, they pass the exam.",
            "∃x (Student(x) ∧ Study(x)) ::: Some students study.",
            "∀x ((Student(x) ∧ Study(x) ∧ Happy(x)) → PassExam(x)) ::: If a student studies and is happy, they pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Happy(x) ::: x is happy",
            "Study(x) ::: x studies",
            "PassExam(x) ::: x passes the exam",
            "LikesPizza(x) ::: x likes pizza"
        ]
    },
    {
        "premises-NL": [
            "Every registered user is either an active user or a follower.",
            "Anyone who is an active user will have a positive experience.",
            "Some followers are also registered users.",
            "If someone is a follower and a registered user, then they view content.",
            "All registered users are either followers or not.",
            "If someone views content, they have a positive experience.",
            "Some active users are also registered users.",
            "John is a registered user.",
            "John is a follower.",
            "If someone views content, they are active.",
            "Anyone who is a follower or an active user will view content.",
            "Every active user will view content."
        ],
        "premises-FOL": [
            "∀x (RegisteredUser(x) → ActiveUser(x) ∨ Follower(x)) ::: Every registered user is either an active user or a follower.",
            "∀x (ActiveUser(x) → PositiveExperience(x)) ::: Anyone who is an active user will have a positive experience.",
            "∃x (Follower(x) ∧ RegisteredUser(x)) ::: Some followers are also registered users.",
            "∀x (RegisteredUser(x) ∧ Follower(x) → ViewsContent(x, y)) ::: If someone is a follower and a registered user, then they view content.",
            "∀x (RegisteredUser(x) → Follower(x) ∨ ¬Follower(x)) ::: All registered users are either followers or not.",
            "∀x (ViewsContent(x, y) → PositiveExperience(x)) ::: If someone views content, they have a positive experience.",
            "∃x (ActiveUser(x) ∧ RegisteredUser(x)) ::: Some active users are also registered users.",
            "RegisteredUser(john) ::: John is a registered user.",
            "Follower(john) ::: John is a follower.",
            "∀x (ViewsContent(x, y) → ActiveUser(x)) ::: If someone views content, they are active.",
            "∀x ((Follower(x) ∨ ActiveUser(x)) → ViewsContent(x, y)) ::: Anyone who is a follower or an active user will view content.",
            "∀x (ActiveUser(x) → ViewsContent(x, y)) ::: Every active user will view content."
        ],
        "predicates": [
            "RegisteredUser(x) ::: x is a registered user",
            "Follower(x) ::: x is a follower",
            "ActiveUser(x) ::: x is an active user",
            "PositiveExperience(x) ::: x has a positive experience",
            "ViewsContent(x, y) ::: x views content y",
            "ContentCreator(y) ::: y is a content creator"
        ]
    },
    {
        "premises-NL": [
            "Every employee is either a programmer, a manager, or neither.",
            "All programmers are skilled.",
            "All managers are skilled.",
            "If someone is skilled and has a degree, they are an employee.",
            "If someone is a programmer, then they write code.",
            "If someone writes code, they are either a programmer or a manager.",
            "All employees either have a degree or are skilled.",
            "John is an employee.",
            "John does not write code.",
            "If someone is a programmer, they are skilled.",
            "If someone is a manager, they have a degree.",
            "Every employee either is a programmer or is a manager.",
            "Everyone who is a programmer and a manager is skilled."
        ],
        "premises-FOL": [
            "∀x (Employee(x) → Programmer(x) ∨ Manager(x) ∨ (¬Programmer(x) ∧ ¬Manager(x))) ::: Every employee is either a programmer, a manager, or neither.",
            "∀x (Programmer(x) → Skilled(x)) ::: All programmers are skilled.",
            "∀x (Manager(x) → Skilled(x)) ::: All managers are skilled.",
            "∀x ((Skilled(x) ∧ HasDegree(x)) → Employee(x)) ::: If someone is skilled and has a degree, they are an employee.",
            "∀x (Programmer(x) → WritesCode(x)) ::: If someone is a programmer, then they write code.",
            "∀x (WritesCode(x) → Programmer(x) ∨ Manager(x)) ::: If someone writes code, they are either a programmer or a manager.",
            "∀x (Employee(x) → HasDegree(x) ∨ Skilled(x)) ::: All employees either have a degree or are skilled.",
            "Employee(john) ::: John is an employee.",
            "¬WritesCode(john) ::: John does not write code.",
            "∀x (Programmer(x) → Skilled(x)) ::: If someone is a programmer, they are skilled.",
            "∀x (Manager(x) → HasDegree(x)) ::: If someone is a manager, they have a degree.",
            "∀x (Employee(x) → Programmer(x) ∨ Manager(x)) ::: Every employee either is a programmer or is a manager.",
            "∀x ((Programmer(x) ∧ Manager(x)) → Skilled(x)) ::: Everyone who is a programmer and a manager is skilled."
        ],
        "predicates": [
            "Employee(x) ::: x is an employee",
            "Programmer(x) ::: x is a programmer",
            "Manager(x) ::: x is a manager",
            "Skilled(x) ::: x is skilled",
            "HasDegree(x) ::: x has a degree",
            "WritesCode(x) ::: x writes code"
        ]
    },
    {
        "premises-NL": [
            "Every customer either purchases a product or has a subscription.",
            "Anyone who purchases a product is satisfied.",
            "Anyone who has a subscription is satisfied.",
            "If someone is satisfied and receives support, they are a customer.",
            "If someone is a customer, they use a service.",
            "If someone uses a service, they are either purchasing a product or have a subscription.",
            "All customers are either satisfied or receive support.",
            "John is a customer.",
            "John does not have a subscription.",
            "If someone purchases a product, they use a service.",
            "If someone has a subscription, they receive support.",
            "Every customer either purchases a product or receives support.",
            "Everyone who purchases a product and has a subscription is satisfied.",
            "Anyone who uses service is a customer."
        ],
        "premises-FOL": [
            "∀x (Customer(x) → PurchasesProduct(x) ∨ HasSubscription(x)) ::: Every customer either purchases a product or has a subscription.",
            "∀x (PurchasesProduct(x) → Satisfied(x)) ::: Anyone who purchases a product is satisfied.",
            "∀x (HasSubscription(x) → Satisfied(x)) ::: Anyone who has a subscription is satisfied.",
            "∀x ((Satisfied(x) ∧ ReceivesSupport(x)) → Customer(x)) ::: If someone is satisfied and receives support, they are a customer.",
            "∀x (Customer(x) → UsesService(x)) ::: If someone is a customer, they use a service.",
            "∀x (UsesService(x) → PurchasesProduct(x) ∨ HasSubscription(x)) ::: If someone uses a service, they are either purchasing a product or have a subscription.",
            "∀x (Customer(x) → Satisfied(x) ∨ ReceivesSupport(x)) ::: All customers are either satisfied or receive support.",
            "Customer(john) ::: John is a customer.",
            "¬HasSubscription(john) ::: John does not have a subscription.",
            "∀x (PurchasesProduct(x) → UsesService(x)) ::: If someone purchases a product, they use a service.",
            "∀x (HasSubscription(x) → ReceivesSupport(x)) ::: If someone has a subscription, they receive support.",
            "∀x (Customer(x) → PurchasesProduct(x) ∨ ReceivesSupport(x)) ::: Every customer either purchases a product or receives support.",
            "∀x ((PurchasesProduct(x) ∧ HasSubscription(x)) → Satisfied(x)) ::: Everyone who purchases a product and has a subscription is satisfied.",
            "∀x (UsesService(x) → Customer(x)) ::: Anyone who uses service is a customer."
        ],
        "predicates": [
            "Customer(x) ::: x is a customer",
            "PurchasesProduct(x) ::: x purchases a product",
            "HasSubscription(x) ::: x has a subscription",
            "Satisfied(x) ::: x is satisfied",
            "UsesService(x) ::: x uses a service",
            "ReceivesSupport(x) ::: x receives support"
        ]
    },
    {
        "premises-NL": [
            "Every healthy individual either exercises regularly or has a good diet.",
            "Anyone who exercises regularly is fit.",
            "Anyone with a good diet is fit.",
            "If someone is fit and avoids stress, then they are healthy.",
            "If someone is healthy, they get enough sleep.",
            "If someone gets enough sleep, then they either exercise regularly or have a good diet.",
            "All healthy individuals are either fit or avoid stress.",
            "John is healthy.",
            "John does not get enough sleep.",
            "If someone exercises regularly, they have a good diet.",
            "If someone has a good diet, they avoid stress.",
            "Every healthy individual either exercises regularly or gets enough sleep.",
            "Everyone who exercises regularly and has a good diet is fit.",
            "Anyone who gets enough sleep is healthy.",
            "If someone is healthy, they avoid stress."
        ],
        "premises-FOL": [
            "∀x (Healthy(x) → ExercisesRegularly(x) ∨ GoodDiet(x)) ::: Every healthy individual either exercises regularly or has a good diet.",
            "∀x (ExercisesRegularly(x) → Fit(x)) ::: Anyone who exercises regularly is fit.",
            "∀x (GoodDiet(x) → Fit(x)) ::: Anyone with a good diet is fit.",
            "∀x ((Fit(x) ∧ AvoidsStress(x)) → Healthy(x)) ::: If someone is fit and avoids stress, then they are healthy.",
            "∀x (Healthy(x) → HasEnoughSleep(x)) ::: If someone is healthy, they get enough sleep.",
            "∀x (HasEnoughSleep(x) → ExercisesRegularly(x) ∨ GoodDiet(x)) ::: If someone gets enough sleep, then they either exercise regularly or have a good diet.",
            "∀x (Healthy(x) → Fit(x) ∨ AvoidsStress(x)) ::: All healthy individuals are either fit or avoid stress.",
            "Healthy(john) ::: John is healthy.",
            "¬HasEnoughSleep(john) ::: John does not get enough sleep.",
            "∀x (ExercisesRegularly(x) → GoodDiet(x)) ::: If someone exercises regularly, they have a good diet.",
            "∀x (GoodDiet(x) → AvoidsStress(x)) ::: If someone has a good diet, they avoid stress.",
            "∀x (Healthy(x) → ExercisesRegularly(x) ∨ HasEnoughSleep(x)) ::: Every healthy individual either exercises regularly or gets enough sleep.",
            "∀x ((ExercisesRegularly(x) ∧ GoodDiet(x)) → Fit(x)) ::: Everyone who exercises regularly and has a good diet is fit.",
            "∀x (HasEnoughSleep(x) → Healthy(x)) ::: Anyone who gets enough sleep is healthy.",
            "∀x (Healthy(x) → AvoidsStress(x)) ::: If someone is healthy, they avoid stress."
        ],
        "predicates": [
            "Healthy(x) ::: x is healthy",
            "GoodDiet(x) ::: x has a good diet",
            "Fit(x) ::: x is fit",
            "ExercisesRegularly(x) ::: x exercises regularly",
            "HasEnoughSleep(x) ::: x gets enough sleep",
            "AvoidsStress(x) ::: x avoids stress"
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "Anyone who studies hard will pass the exam.",
            "Some students attend the lecture.",
            "All smart people study hard.",
            "Anyone who likes logic is a student.",
            "John likes logic."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "∀x (StudiesHard(x) → PassesExam(x)) ::: Anyone who studies hard will pass the exam.",
            "∃x (Student(x) ∧ AttendsLecture(x)) ::: Some students attend the lecture.",
            "∀x (Smart(x) → StudiesHard(x)) ::: All smart people study hard.",
            "∀x (LikesLogic(x) → Student(x)) ::: Anyone who likes logic is a student.",
            "LikesLogic(john) ::: John likes logic."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsLecture(x) ::: x attends the lecture",
            "PassesExam(x) ::: x passes the exam",
            "Smart(x) ::: x is smart",
            "StudiesHard(x) ::: x studies hard",
            "LikesLogic(x) ::: x likes logic"
        ]
    },
    {
        "premises-NL": [
            "All doctors are either rich or good at surgery.",
            "All specialists are doctors.",
            "Some specialists work at a hospital.",
            "No one who is good at surgery has a high salary.",
            "Anyone who works at a hospital is kind.",
            "All doctors who are kind have a high salary.",
            "Not all doctors are specialists."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Rich(x) ∨ GoodAtSurgery(x)) ::: All doctors are either rich or good at surgery.",
            "∀x (Specialist(x) → Doctor(x)) ::: All specialists are doctors.",
            "∃x (Specialist(x) ∧ WorksAtHospital(x)) ::: Some specialists work at a hospital.",
            "∀x (GoodAtSurgery(x) → ¬HasHighSalary(x)) ::: No one who is good at surgery has a high salary.",
            "∀x (WorksAtHospital(x) → IsKind(x)) ::: Anyone who works at a hospital is kind.",
            "∀x (Doctor(x) ∧ IsKind(x) → HasHighSalary(x)) ::: All doctors who are kind have a high salary.",
            "¬∀x (Doctor(x) → Specialist(x)) ::: Not all doctors are specialists."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Rich(x) ::: x is rich",
            "GoodAtSurgery(x) ::: x is good at surgery",
            "HasHighSalary(x) ::: x has a high salary",
            "Specialist(x) ::: x is a specialist",
            "WorksAtHospital(x) ::: x works at a hospital",
            "IsKind(x) ::: x is kind"
        ]
    },
    {
        "premises-NL": [
            "All students either play sports or study.",
            "Anyone who likes parties is lazy.",
            "All lazy people do not study.",
            "Some students like parties.",
            "All who fail the exam do not study.",
            "Anyone who attends class, studies.",
            "John is a student.",
            "All students are good at math.",
            "John fails the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → PlaysSports(x) ∨ Studies(x)) ::: All students either play sports or study.",
            "∀x (LikesParties(x) → IsLazy(x)) ::: Anyone who likes parties is lazy.",
            "∀x (IsLazy(x) → ¬Studies(x)) ::: All lazy people do not study.",
            "∃x (Student(x) ∧ LikesParties(x)) ::: Some students like parties.",
            "∀x (FailsExam(x) → ¬Studies(x)) ::: All who fail the exam do not study.",
            "∀x (AttendsClass(x) → Studies(x)) ::: Anyone who attends class, studies.",
            "Student(john) ::: John is a student.",
            "∀x (Student(x) → GoodAtMath(x)) ::: All students are good at math.",
            "FailsExam(john) ::: John fails the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PlaysSports(x) ::: x plays sports",
            "Studies(x) ::: x studies",
            "LikesParties(x) ::: x likes parties",
            "GoodAtMath(x) ::: x is good at math",
            "FailsExam(x) ::: x fails the exam",
            "AttendsClass(x) ::: x attends class",
            "IsLazy(x) ::: x is lazy",
            "HasFriends(x) ::: x has friends"
        ]
    },
    {
        "premises-NL": [
            "All scientists either publish papers or are not respected.",
            "All scientists who are respected have funding.",
            "Some scientists do not have funding.",
            "All scientists who are innovative and work at a university publish papers.",
            "All scientists attend conferences.",
            "Anyone who attends conferences presents research.",
            "All scientists who are innovative and present research receive awards.",
            "Some scientists are innovative.",
            "Anyone who receives awards is respected.",
            "All scientists who collaborate are respected."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → PublishesPapers(x) ∨ ¬Respected(x)) ::: All scientists either publish papers or are not respected.",
            "∀x (Scientist(x) ∧ Respected(x) → HasFunding(x)) ::: All scientists who are respected have funding.",
            "∃x (Scientist(x) ∧ ¬HasFunding(x)) ::: Some scientists do not have funding.",
            "∀x (Scientist(x) ∧ IsInnovative(x) ∧ WorksAtUniversity(x) → PublishesPapers(x)) ::: All scientists who are innovative and work at a university publish papers.",
            "∀x (Scientist(x) → AttendsConferences(x)) ::: All scientists attend conferences.",
            "∀x (AttendsConferences(x) → PresentsResearch(x)) ::: Anyone who attends conferences presents research.",
            "∀x (Scientist(x) ∧ IsInnovative(x) ∧ PresentsResearch(x) → ReceivesAwards(x)) ::: All scientists who are innovative and present research receive awards.",
            "∃x (Scientist(x) ∧ IsInnovative(x)) ::: Some scientists are innovative.",
            "∀x (ReceivesAwards(x) → Respected(x)) ::: Anyone who receives awards is respected.",
            "∀x ∀y (Scientist(x) ∧ Collaborates(x, y) → Respected(x)) ::: All scientists who collaborate are respected."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "PublishesPapers(x) ::: x publishes papers",
            "Respected(x) ::: x is respected",
            "HasFunding(x) ::: x has funding",
            "WorksAtUniversity(x) ::: x works at a university",
            "Collaborates(x, y) ::: x collaborates with y",
            "IsInnovative(x) ::: x is innovative",
            "AttendsConferences(x) ::: x attends conferences",
            "PresentsResearch(x) ::: x presents research",
            "ReceivesAwards(x) ::: x receives awards"
        ]
    },
    {
        "premises-NL": [
            "All plants require sunlight.",
            "All plants require water.",
            "If something is a plant and has sunlight, it needs water",
            "If something is green, it is a plant.",
            "If something is a plant, it needs nutrients.",
            "A plant receives nutrients if it has water and sunlight.",
            "If something grows, it's alive.",
            "If a plant is healthy, it grows.",
            "Something is a plant and has water.",
            "Something is a plant and has sunlight.",
            "Plants are green"
        ],
        "premises-FOL": [
            "∀x (Plant(x) → RequiresSunlight(x)) ::: All plants require sunlight.",
            "∀x (Plant(x) → RequiresWater(x)) ::: All plants require water.",
            "∀x (Plant(x) ∧ HasSunlight(x) → RequiresWater(x)) ::: If something is a plant and has sunlight, it needs water.",
            "∀x (IsGreen(x) → Plant(x)) ::: If something is green, it is a plant.",
            "∀x (Plant(x) → NeedsNutrients(x)) ::: If something is a plant, it needs nutrients.",
            "∀x (Plant(x) ∧ HasWater(x) ∧ HasSunlight(x) → ReceivesNutrients(x)) ::: A plant receives nutrients if it has water and sunlight.",
            "∀x (Grows(x) → IsAlive(x)) ::: If something grows, it's alive.",
            "∀x (Plant(x) ∧ IsHealthy(x) → Grows(x)) ::: If a plant is healthy, it grows.",
            "∃x (Plant(x) ∧ HasWater(x)) ::: Something is a plant and has water.",
            "∃x (Plant(x) ∧ HasSunlight(x)) ::: Something is a plant and has sunlight.",
            "∀x (Plant(x) → IsGreen(x)) ::: Plants are green"
        ],
        "predicates": [
            "Plant(x) ::: x is a plant.",
            "HasWater(x) ::: x has water.",
            "HasSunlight(x) ::: x has sunlight.",
            "Grows(x) ::: x grows.",
            "IsGreen(x) ::: x is green.",
            "NeedsNutrients(x) ::: x needs nutrients.",
            "ReceivesNutrients(x) ::: x receives nutrients.",
            "IsAlive(x) ::: x is alive.",
            "RequiresSunlight(x) ::: x requires sunlight.",
            "RequiresWater(x) ::: x requires water.",
            "IsHealthy(x) ::: x is healthy."
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled in a course.",
            "If someone is enrolled in a course, they are a student.",
            "If someone is a student, then they must register.",
            "Sarah is a student.",
            "Calculus is a course.",
            "Sarah is enrolled in Calculus."
        ],
        "premises-FOL": [
            "∀x ∃y (Student(x) → Enrolled(x, y)) ::: All students are enrolled in a course.",
            "∀x ∀y (Enrolled(x, y) → Student(x)) ::: If someone is enrolled in a course, they are a student.",
            "∀x (Student(x) → Registered(x)) ::: If someone is a student, then they must register.",
            "Student(sarah) ::: Sarah is a student.",
            "Course(calculus) ::: Calculus is a course.",
            "Enrolled(sarah, calculus) ::: Sarah is enrolled in Calculus."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Registered(x) ::: x is registered",
            "Enrolled(x, y) ::: x is enrolled in y",
            "Course(x) ::: x is a course"
        ]
    },
    {
        "premises-NL": [
            "All professors teach.",
            "All those who teach are researchers.",
            "Anyone who writes papers publishes them.",
            "Some professors write papers.",
            "Some students read papers.",
            "Anyone who publishes a paper is a researcher.",
            "Some professors are also researchers.",
            "All students who pass exams get degrees.",
            "All students are enrolled somewhere.",
            "Anyone who is a professor and writes papers is a researcher."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Teaches(x, y)) ::: All professors teach.",
            "∀x (Teaches(x, y) → Researcher(x)) ::: All those who teach are researchers.",
            "∀x (WritesPapers(x) → Publishes(x, y)) ::: Anyone who writes papers publishes them.",
            "∃x (Professor(x) ∧ WritesPapers(x)) ::: Some professors write papers.",
            "∃x ∃y (Student(x) ∧ Reads(x, y)) ::: Some students read papers.",
            "∀x (Publishes(x, y) → Researcher(x)) ::: Anyone who publishes a paper is a researcher.",
            "∃x (Professor(x) ∧ Researcher(x)) ::: Some professors are also researchers.",
            "∀x (Student(x) ∧ PassesExam(x) → HasDegree(x)) ::: All students who pass exams get degrees.",
            "∀x ∃y Enrolled(x, y) ::: All students are enrolled somewhere.",
            "∀x (Professor(x) ∧ WritesPapers(x) → Researcher(x)) ::: Anyone who is a professor and writes papers is a researcher."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "WritesPapers(x) ::: x writes papers",
            "Researcher(x) ::: x is a researcher",
            "Publishes(x, y) ::: x publishes y",
            "Student(x) ::: x is a student",
            "Reads(x, y) ::: x reads y",
            "Enrolled(x, y) ::: x is enrolled in y",
            "PassesExam(x) ::: x passes the exam",
            "HasDegree(x) ::: x has a degree",
            "Teaches(x, y) ::: x teaches y"
        ]
    },
    {
        "premises-NL": [
            "All software engineers write code.",
            "Everyone who writes code develops software.",
            "Anyone who develops software designs software.",
            "Anyone who designs software uses tools.",
            "Some software engineers have relevant degrees.",
            "Anyone who manages projects is an expert.",
            "Experts know programming.",
            "Anyone who is an expert attends meetings.",
            "All software engineers manage projects.",
            "Some people who know programming are software engineers.",
            "All software engineers attend meetings."
        ],
        "premises-FOL": [
            "∀x (SoftwareEngineer(x) → WritesCode(x)) ::: All software engineers write code.",
            "∀x (WritesCode(x) → DevelopsSoftware(x)) ::: Everyone who writes code develops software.",
            "∀x (DevelopsSoftware(x) → DesignsSoftware(x)) ::: Anyone who develops software designs software.",
            "∀x (DesignsSoftware(x) → UsesTools(x)) ::: Anyone who designs software uses tools.",
            "∃x (SoftwareEngineer(x) ∧ HasRelevantDegree(x)) ::: Some software engineers have relevant degrees.",
            "∀x (ManagesProjects(x) → Expert(x)) ::: Anyone who manages projects is an expert.",
            "∀x (Expert(x) → KnowsProgramming(x)) ::: Experts know programming.",
            "∀x (Expert(x) → AttendsMeetings(x)) ::: Anyone who is an expert attends meetings.",
            "∀x (SoftwareEngineer(x) → ManagesProjects(x)) ::: All software engineers manage projects.",
            "∃x (KnowsProgramming(x) ∧ SoftwareEngineer(x)) ::: Some people who know programming are software engineers.",
            "∀x (SoftwareEngineer(x) → AttendsMeetings(x)) ::: All software engineers attend meetings."
        ],
        "predicates": [
            "SoftwareEngineer(x) ::: x is a software engineer",
            "HasRelevantDegree(x) ::: x has a relevant degree",
            "DesignsSoftware(x) ::: x designs software",
            "WritesCode(x) ::: x writes code",
            "WorksAt(x, y) ::: x works at y",
            "DevelopsSoftware(x) ::: x develops software",
            "ManagesProjects(x) ::: x manages projects",
            "AttendsMeetings(x) ::: x attends meetings",
            "UsesTools(x) ::: x uses tools",
            "KnowsProgramming(x) ::: x knows programming",
            "Expert(x) ::: x is an expert"
        ]
    },
    {
        "premises-NL": [
            "All programmers write code.",
            "All programmers use an IDE.",
            "All good programmers follow best practices.",
            "All good programmers debug code.",
            "Anyone who understands algorithms is a good programmer.",
            "Anyone who knows Java is a programmer.",
            "All programmers who are skilled in Python test code.",
            "Anyone who tests code is a good programmer.",
            "All good programmers write documentation.",
            "All programmers who are skilled in Python use version control.",
            "Anyone who uses version control is a good programmer.",
            "Anyone who is skilled in Python knows Java."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → WritesCode(x)) ::: All programmers write code.",
            "∀x (Programmer(x) → UsesIDE(x)) ::: All programmers use an IDE.",
            "∀x (GoodProgrammer(x) → FollowsBestPractices(x)) ::: All good programmers follow best practices.",
            "∀x (GoodProgrammer(x) → DebugsCode(x)) ::: All good programmers debug code.",
            "∀x (UnderstandsAlgorithms(x) → GoodProgrammer(x)) ::: Anyone who understands algorithms is a good programmer.",
            "∀x (KnowsJava(x) → Programmer(x)) ::: Anyone who knows Java is a programmer.",
            "∀x (Programmer(x) ∧ SkilledInPython(x) → TestsCode(x)) ::: All programmers who are skilled in Python test code.",
            "∀x (TestsCode(x) → GoodProgrammer(x)) ::: Anyone who tests code is a good programmer.",
            "∀x (GoodProgrammer(x) → WritesDocumentation(x)) ::: All good programmers write documentation.",
            "∀x (Programmer(x) ∧ SkilledInPython(x) → ManagesVersionControl(x)) ::: All programmers who are skilled in Python use version control.",
            "∀x (ManagesVersionControl(x) → GoodProgrammer(x)) ::: Anyone who uses version control is a good programmer.",
            "∀x (SkilledInPython(x) → KnowsJava(x)) ::: Anyone who is skilled in Python knows Java."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "SkilledInPython(x) ::: x is skilled in Python",
            "GoodProgrammer(x) ::: x is a good programmer",
            "KnowsJava(x) ::: x knows Java",
            "WritesCode(x) ::: x writes code",
            "UsesIDE(x) ::: x uses an IDE",
            "FollowsBestPractices(x) ::: x follows best practices",
            "DebugsCode(x) ::: x debugs code",
            "UnderstandsAlgorithms(x) ::: x understands algorithms",
            "WritesDocumentation(x) ::: x writes documentation",
            "TestsCode(x) ::: x tests code",
            "ManagesVersionControl(x) ::: x manages version control"
        ]
    },
    {
        "premises-NL": [
            "All successful entrepreneurs raise capital.",
            "All successful entrepreneurs hire employees.",
            "All entrepreneurs who innovate create value.",
            "All successful entrepreneurs market their product.",
            "Anyone who has a vision is an entrepreneur.",
            "Anyone who manages a team is a successful entrepreneur.",
            "Anyone who understands the market is an entrepreneur.",
            "All who innovate solve problems effectively.",
            "All successful entrepreneurs take risks.",
            "Anyone who builds a network is an entrepreneur.",
            "All successful entrepreneurs adapt to change.",
            "Anyone who solves problems effectively creates value.",
            "All entrepreneurs who innovate solve problems effectively."
        ],
        "premises-FOL": [
            "∀x (SuccessfulEntrepreneur(x) → RaisesCapital(x)) ::: All successful entrepreneurs raise capital.",
            "∀x (SuccessfulEntrepreneur(x) → HiresEmployees(x)) ::: All successful entrepreneurs hire employees.",
            "∀x (Entrepreneur(x) ∧ Innovates(x) → CreatesValue(x)) ::: All entrepreneurs who innovate create value.",
            "∀x (SuccessfulEntrepreneur(x) → MarketsProduct(x)) ::: All successful entrepreneurs market their product.",
            "∀x (HasVision(x) → Entrepreneur(x)) ::: Anyone who has a vision is an entrepreneur.",
            "∀x (ManagesTeam(x) → SuccessfulEntrepreneur(x)) ::: Anyone who manages a team is a successful entrepreneur.",
            "∀x (UnderstandsMarket(x) → Entrepreneur(x)) ::: Anyone who understands the market is an entrepreneur.",
            "∀x (Innovates(x) → SolvesProblemsEffectively(x)) ::: All who innovate solve problems effectively.",
            "∀x (SuccessfulEntrepreneur(x) → TakesRisks(x)) ::: All successful entrepreneurs take risks.",
            "∀x (BuildsNetwork(x) → Entrepreneur(x)) ::: Anyone who builds a network is an entrepreneur.",
            "∀x (SuccessfulEntrepreneur(x) → AdaptsToChange(x)) ::: All successful entrepreneurs adapt to change.",
            "∀x (SolvesProblemsEffectively(x) → CreatesValue(x)) ::: Anyone who solves problems effectively creates value.",
            "∀x (Entrepreneur(x) ∧ Innovates(x) → SolvesProblemsEffectively(x)) ::: All entrepreneurs who innovate solve problems effectively."
        ],
        "predicates": [
            "SuccessfulEntrepreneur(x) ::: x is a successful entrepreneur",
            "Innovates(x) ::: x innovates",
            "SolvesProblemsEffectively(x) ::: x solves problems effectively",
            "RaisesCapital(x) ::: x raises capital",
            "HiresEmployees(x) ::: x hires employees",
            "MarketsProduct(x) ::: x markets a product",
            "HasVision(x) ::: x has vision",
            "ManagesTeam(x) ::: x manages a team",
            "UnderstandsMarket(x) ::: x understands the market",
            "CreatesValue(x) ::: x creates value",
            "TakesRisks(x) ::: x takes risks",
            "BuildsNetwork(x) ::: x builds a network",
            "AdaptsToChange(x) ::: x adapts to change"
        ]
    },
    {
        "premises-NL": [
            "Anyone who has a job gets paid.",
            "Anyone who gets paid has money.",
            "If someone studies, then they don't have a job.",
            "If someone gets paid, they pay bills.",
            "If someone has a job, then they have money.",
            "Anyone who studies, receives an allowance.",
            "Anyone who receives an allowance, has money.",
            "If someone has a job, they don't study.",
            "If someone has money, they don't need money.",
            "If someone needs money, then they pay bills.",
            "Anyone who is unemployed, doesn't have a job.",
            "If someone doesn't have a job, and doesn't have money, then they are unemployed."
        ],
        "premises-FOL": [
            "∀x (HasJob(x) → GetsPaid(x)) ::: Anyone who has a job gets paid.",
            "∀x (GetsPaid(x) → HasMoney(x)) ::: Anyone who gets paid has money.",
            "∀x (Studies(x) → ¬HasJob(x)) ::: If someone studies, then they don't have a job.",
            "∀x (GetsPaid(x) → PaysBills(x)) ::: If someone gets paid, they pay bills.",
            "∀x (HasJob(x) → HasMoney(x)) ::: If someone has a job, then they have money.",
            "∀x (Studies(x) → ReceivesAllowance(x)) ::: Anyone who studies, receives an allowance.",
            "∀x (ReceivesAllowance(x) → HasMoney(x)) ::: Anyone who receives an allowance, has money.",
            "∀x (HasJob(x) → ¬Studies(x)) ::: If someone has a job, they don't study.",
            "∀x (HasMoney(x) → ¬NeedsMoney(x)) ::: If someone has money, they don't need money.",
            "∀x (NeedsMoney(x) → PaysBills(x)) ::: If someone needs money, then they pay bills.",
            "∀x (Unemployed(x) → ¬HasJob(x)) ::: Anyone who is unemployed, doesn't have a job.",
            "∀x ((¬HasJob(x) ∧ ¬HasMoney(x)) → Unemployed(x)) ::: If someone doesn't have a job, and doesn't have money, then they are unemployed."
        ],
        "predicates": [
            "HasJob(x) ::: x has a job.",
            "HasMoney(x) ::: x has money.",
            "Unemployed(x) ::: x is unemployed.",
            "Studies(x) ::: x studies.",
            "ReceivesAllowance(x) ::: x receives an allowance.",
            "PaysBills(x) ::: x pays bills.",
            "HasBills(x) ::: x has bills.",
            "Rich(x) ::: x is rich.",
            "Working(x) ::: x is working.",
            "GetsPaid(x) ::: x gets paid.",
            "NeedsMoney(x) ::: x needs money.",
            "HasSavings(x) ::: x has savings."
        ]
    },
    {
        "premises-NL": [
            "All researchers are experts.",
            "Some people are not researchers.",
            "If someone knows all topics, then they are an expert.",
            "John is a person.",
            "John knows all topics.",
            "Some topics exist.",
            "If x is an expert and x specializes in y then x knows y.",
            "If someone knows all topics, they are not a researcher."
        ],
        "premises-FOL": [
            "∀x (Researcher(x) → Expert(x)) ::: For all x, if x is a researcher, then x is an expert.",
            "∃x (Person(x) ∧ ¬Researcher(x)) ::: There exists a person who is not a researcher.",
            "∀x (AllKnow(x,y) → Expert(x)) ::: For all x, if x knows all topics, then x is an expert.",
            "Person(john) ::: John is a person.",
            "AllKnow(john, topics) ::: John knows all topics.",
            "∃x Topic(x) ::: There exists a topic.",
            "∀x ∀y (Expert(x) ∧ Specializes(x, y) → Knows(x, y)) ::: For all x and y, if x is an expert and x specializes in y, then x knows y.",
            "∀x (AllKnow(x,y) → ¬Researcher(x)) ::: For all x, if x knows all topics, then x is not a researcher."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "Researcher(x) ::: x is a researcher.",
            "Expert(x) ::: x is an expert.",
            "Knows(x, y) ::: x knows y.",
            "Topic(x) ::: x is a topic.",
            "Specializes(x,y) ::: x specializes in topic y.",
            "AllKnow(x, y) ::: x knows every topic y."
        ]
    },
    {
        "premises-NL": [
            "All birds are animals.",
            "All birds have wings.",
            "No mammals have wings.",
            "Some birds are aquatic.",
            "All aquatic animals are not land dwellers.",
            "Some animals are birds.",
            "If something is aquatic, it cannot be a land dweller.",
            "Everything that is a bird can fly.",
            "If x can fly, then x has wings."
        ],
        "premises-FOL": [
            "∀x (Bird(x) → Animal(x)) ::: For all x, if x is a bird, then x is an animal.",
            "∀x (Bird(x) → Wings(x)) ::: For all x, if x is a bird, then x has wings.",
            "∀x (Mammal(x) → ¬Wings(x)) ::: For all x, if x is a mammal, then x does not have wings.",
            "∃x (Bird(x) ∧ Aquatic(x)) ::: There exists an x such that x is a bird and x is aquatic.",
            "∀x (Aquatic(x) → ¬LandDweller(x)) ::: For all x, if x is aquatic, then x is not a land dweller.",
            "∃x (Animal(x) ∧ Bird(x)) ::: There exists an x such that x is an animal and x is a bird.",
            "∀x ∀y (Aquatic(x) → ¬LandDweller(x)) ::: For all x and y, if x is aquatic then x is not a land dweller.",
            "∀x (Bird(x) → CanFly(x)) ::: For all x, if x is a bird, then x can fly.",
            "∀x (CanFly(x) → Wings(x)) ::: For all x, if x can fly, then x has wings."
        ],
        "predicates": [
            "Animal(x) ::: x is an animal.",
            "Mammal(x) ::: x is a mammal.",
            "Wings(x) ::: x has wings.",
            "Bird(x) ::: x is a bird.",
            "IsFlying(x) ::: x is flying.",
            "LivesIn(x, y) ::: x lives in y.",
            "Aquatic(x) ::: x is aquatic.",
            "LandDweller(x) ::: x is a land dweller.",
            "CanFly(x) ::: x can fly."
        ]
    },
    {
        "premises-NL": [
            "All students either study hard or enjoy movies.",
            "David is a student.",
            "If David likes chocolate, then he does not enjoy movies.",
            "David likes chocolate.",
            "If someone enjoys movies, they don't study hard.",
            "If someone studies hard they pass the exam.",
            "All students pass the exam or don't like chocolate.",
            "If David is a student and likes chocolate, then he doesn't study hard.",
            "If David likes chocolate, then he doesn't study hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (StudiesHard(x) ∨ EnjoysMovies(x))) ::: All students either study hard or enjoy movies",
            "Student(david) ::: David is a student",
            "LikesChocolate(david) → ¬EnjoysMovies(david) ::: If David likes chocolate, then he does not enjoy movies",
            "LikesChocolate(david) ::: David likes chocolate",
            "∀x (EnjoysMovies(x) → ¬StudiesHard(x)) ::: If someone enjoys movies, they don't study hard",
            "∀x (StudiesHard(x) → PassExam(x)) ::: If someone studies hard they pass the exam",
            "∀x (Student(x) → (PassExam(x) ∨ ¬LikesChocolate(x))) ::: All students pass the exam or don't like chocolate",
            "(Student(david) ∧ LikesChocolate(david)) → ¬StudiesHard(david) ::: If David is a student and likes chocolate, then he doesn't study hard",
            "LikesChocolate(david) → ¬StudiesHard(david) ::: If David likes chocolate, then he doesn't study hard"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "LikesChocolate(x) ::: x likes chocolate",
            "EnjoysMovies(x) ::: x enjoys movies"
        ]
    },
    {
        "premises-NL": [
            "All cats are either black or friendly.",
            "If something is black, it is not friendly.",
            "If something hunts mice, it is a cat.",
            "Whiskers is a cat.",
            "Whiskers is not black.",
            "If Whiskers is a cat, then Whiskers hunts mice.",
            "If Whiskers is not black, then Whiskers is friendly.",
            "Whiskers is not a pet.",
            "All pets are friendly.",
            "If something is friendly, it is a pet.",
            "If a cat hunts mice, then it is not friendly."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → (Black(x) ∨ Friendly(x))) ::: All cats are either black or friendly",
            "∀x (Black(x) → ¬Friendly(x)) ::: If something is black, it is not friendly",
            "∀x (HuntsMice(x) → Cat(x)) ::: If something hunts mice, it is a cat",
            "Cat(whiskers) ::: Whiskers is a cat",
            "¬Black(whiskers) ::: Whiskers is not black",
            "Cat(whiskers) → HuntsMice(whiskers) ::: If Whiskers is a cat, then Whiskers hunts mice",
            "¬Black(whiskers) → Friendly(whiskers) ::: If Whiskers is not black, then Whiskers is friendly",
            "¬IsPet(whiskers) ::: Whiskers is not a pet",
            "∀x (IsPet(x) → Friendly(x)) ::: All pets are friendly",
            "∀x (Friendly(x) → IsPet(x)) ::: If something is friendly, it is a pet",
            "∀x (Cat(x) ∧ HuntsMice(x)) → ¬Friendly(x) ::: If a cat hunts mice, then it is not friendly"
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Black(x) ::: x is black",
            "Friendly(x) ::: x is friendly",
            "HuntsMice(x) ::: x hunts mice",
            "IsPet(x) ::: x is a pet"
        ]
    },
    {
        "premises-NL": [
            "Sarah likes books or Sarah likes movies.",
            "If someone likes books, they read them.",
            "If someone likes movies, they watch them.",
            "All books are read.",
            "All movies are watched.",
            "If someone reads something, they like it.",
            "If someone watches something, they like it.",
            "If Sarah reads books or watches movies, then she is happy.",
            "If someone likes books, then they are happy.",
            "If someone likes movies, then they are happy.",
            "If Sarah reads books, then she is happy.",
            "If Sarah watches movies, then she is happy.",
            "If Sarah reads books and watches movies, she is happy."
        ],
        "premises-FOL": [
            "Likes(sarah, books) ∨ Likes(sarah, movies) ::: Sarah likes books or Sarah likes movies",
            "∀x (Likes(x, books) → Reads(x, books)) ::: If someone likes books, they read them",
            "∀x (Likes(x, movies) → Watches(x, movies)) ::: If someone likes movies, they watch them",
            "∀x (Book(x) → Reads(x, x)) ::: All books are read",
            "∀x (Movie(x) → Watches(x, x)) ::: All movies are watched",
            "∀x (Reads(x, y) → Likes(x, y)) ::: If someone reads something, they like it",
            "∀x (Watches(x, y) → Likes(x, y)) ::: If someone watches something, they like it",
            "(Reads(sarah, books) ∨ Watches(sarah, movies)) → Happy(sarah) ::: If Sarah reads books or watches movies, then she is happy",
            "∀x (Likes(x, books) → Happy(x)) ::: If someone likes books, then they are happy",
            "∀x (Likes(x, movies) → Happy(x)) ::: If someone likes movies, then they are happy",
            "Reads(sarah, books) → Happy(sarah) ::: If Sarah reads books, then she is happy",
            "Watches(sarah, movies) → Happy(sarah) ::: If Sarah watches movies, then she is happy",
            "(Reads(sarah, books) ∧ Watches(sarah, movies)) → Happy(sarah) ::: If Sarah reads books and watches movies, she is happy."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Book(x) ::: x is a book",
            "Movie(x) ::: x is a movie",
            "Happy(x) ::: x is happy",
            "Reads(x, y) ::: x reads y",
            "Watches(x, y) ::: x watches y"
        ]
    },
    {
        "premises-NL": [
            "All students study or they don't pass the exam.",
            "If a student studies and understands the material, they will pass the exam.",
            "If someone attends class, they study.",
            "If someone studies and attends class, then they understand the material.",
            "John is a student.",
            "John studies.",
            "If John studies and attends class, then John understands the material.",
            "If John understands the material, then he will pass the exam.",
            "John is a student and studies.",
            "If a student studies and understands the material, then they will pass the exam.",
            "If John studies or does not attends class, then he is not going to understand the material.",
            "If John attends class and studies then he understands the material.",
            "If John studies, then he attends class.",
            "John understands the material.",
            "If John studies and does not understand material, then he does not pass the exam.",
            "If John studies and attends class, then he understands the material.",
            "John is not going to attend class or John will pass the exam.",
            "John reads the book."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Studies(x) ∨ ¬PassExam(x)) ::: All students study or they don't pass the exam.",
            "∀x (Studies(x) ∧ UnderstandsMaterial(x) → PassExam(x)) ::: If a student studies and understands the material, they will pass the exam.",
            "∀x (AttendsClass(x) → Studies(x)) ::: If someone attends class, they study.",
            "∀x (Studies(x) ∧ AttendsClass(x) → UnderstandsMaterial(x)) ::: If someone studies and attends class, then they understand the material.",
            "Student(John) ::: John is a student.",
            "Studies(John) ::: John studies.",
            "Studies(John) ∧ AttendsClass(John) → UnderstandsMaterial(John) ::: If John studies and attends class, then John understands the material.",
            "UnderstandsMaterial(John) → PassExam(John) ::: If John understands the material, then he will pass the exam.",
            "Student(John) ∧ Studies(John) ::: John is a student and studies.",
            "∀x (Studies(x) ∧ UnderstandsMaterial(x) → PassExam(x)) ::: If a student studies and understands the material, then they will pass the exam.",
            "Studies(John) ∨ ¬AttendsClass(John) → ¬UnderstandsMaterial(John) ::: If John studies or does not attends class, then he is not going to understand the material.",
            "AttendsClass(John) ∧ Studies(John) → UnderstandsMaterial(John) ::: If John attends class and studies then he understands the material.",
            "Studies(John) → AttendsClass(John) ::: If John studies, then he attends class.",
            "UnderstandsMaterial(John) ::: John understands the material.",
            "Studies(John) ∧ ¬UnderstandsMaterial(John) → ¬PassExam(John) ::: If John studies and does not understand material, then he does not pass the exam.",
            "Studies(John) ∧ AttendsClass(John) → UnderstandsMaterial(John) ::: If John studies and attends class, then he understands the material.",
            "¬AttendsClass(John) ∨ PassExam(John) ::: John is not going to attend class or John will pass the exam.",
            "ReadsBook(John) ::: John reads the book."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "UnderstandsMaterial(x) ::: x understands the material",
            "PassExam(x) ::: x passes the exam",
            "AttendsClass(x) ::: x attends class",
            "ReadsBook(x) ::: x reads a book"
        ]
    },
    {
        "premises-NL": [
            "All artists love painting.",
            "Some artists paint.",
            "Anyone who paints also dances.",
            "If someone is an artist, then they either paint or dance.",
            "If someone paints, then they love painting.",
            "Some artists are not dancers.",
            "All people are either artists or not.",
            "Some people paint.",
            "If someone is a painter, they are an artist.",
            "Anyone who paints is also an artist.",
            "Anyone who dances is happy.",
            "Some dancers are happy."
        ],
        "premises-FOL": [
            "∀x (Artist(x) → LovesPainting(x)) ::: All artists love painting.",
            "∃x (Artist(x) ∧ Paints(x)) ::: Some artists paint.",
            "∀x (Paints(x) → Dances(x)) ::: Anyone who paints also dances.",
            "∀x (Artist(x) → (Paints(x) ∨ Dances(x))) ::: If someone is an artist, then they either paint or dance.",
            "∀x (Paints(x) → LovesPainting(x)) ::: If someone paints, then they love painting.",
            "∃x (Artist(x) ∧ ¬Dances(x)) ::: Some artists are not dancers.",
            "∀x (Artist(x) ∨ ¬Artist(x)) ::: All people are either artists or not.",
            "∃x Paints(x) ::: Some people paint.",
            "∀x (Paints(x) → Artist(x)) ::: If someone is a painter, they are an artist.",
            "∀x (Paints(x) → Artist(x)) ::: Anyone who paints is also an artist.",
            "∀x (Dances(x) → Happy(x)) ::: Anyone who dances is happy.",
            "∃x (Dances(x) ∧ Happy(x)) ::: Some dancers are happy."
        ],
        "predicates": [
            "Artist(x) ::: x is an artist",
            "LovesPainting(x) ::: x loves painting",
            "Dances(x) ::: x dances",
            "Paints(x) ::: x paints"
        ]
    },
    {
        "premises-NL": [
            "All participants are either scientists or engineers.",
            "Some engineers are also managers.",
            "Every scientist is a participant.",
            "Some participants are engineers.",
            "If someone is an engineer, they are a participant.",
            "All managers are participants.",
            "If someone is a scientist, they are intelligent.",
            "If someone is a manager, they are organized.",
            "All who are scientists are not managers.",
            "Some scientists are intelligent.",
            "Some managers are organized.",
            "All participants are either intelligent or organized.",
            "If one is intelligent, they are a scientist."
        ],
        "premises-FOL": [
            "∀x (Participant(x) → (Scientist(x) ∨ Engineer(x))) ::: All participants are either scientists or engineers.",
            "∃x (Engineer(x) ∧ Manager(x)) ::: Some engineers are also managers.",
            "∀x (Scientist(x) → Participant(x)) ::: Every scientist is a participant.",
            "∃x (Participant(x) ∧ Engineer(x)) ::: Some participants are engineers.",
            "∀x (Engineer(x) → Participant(x)) ::: If someone is an engineer, they are a participant.",
            "∀x (Manager(x) → Participant(x)) ::: All managers are participants.",
            "∀x (Scientist(x) → Intelligent(x)) ::: If someone is a scientist, they are intelligent.",
            "∀x (Manager(x) → Organized(x)) ::: If someone is a manager, they are organized.",
            "∀x (Scientist(x) → ¬Manager(x)) ::: All who are scientists are not managers.",
            "∃x (Scientist(x) ∧ Intelligent(x)) ::: Some scientists are intelligent.",
            "∃x (Manager(x) ∧ Organized(x)) ::: Some managers are organized.",
            "∀x (Participant(x) → (Intelligent(x) ∨ Organized(x))) ::: All participants are either intelligent or organized.",
            "∀x (Intelligent(x) → Scientist(x)) ::: If one is intelligent, they are a scientist."
        ],
        "predicates": [
            "Participant(x) ::: x is a participant",
            "Scientist(x) ::: x is a scientist",
            "Engineer(x) ::: x is an engineer",
            "Manager(x) ::: x is a manager"
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled in a course.",
            "Every student takes an exam.",
            "Everyone who is enrolled must be a student.",
            "Anyone who takes an exam either works at the company or is a student.",
            "No student works at the company and takes exam.",
            "Some students are not enrolled.",
            "All students are young.",
            "Every young person takes an exam.",
            "Anyone young works at the company or is taking exams.",
            "Anyone who is enrolled works at the company.",
            "Some people take exams.",
            "If someone is young, then they work for the company.",
            "Some students are also employees of the company."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x)) ::: All students are enrolled in a course.",
            "∀x (Student(x) → TakesExam(x)) ::: Every student takes an exam.",
            "∀x (Enrolled(x) → Student(x)) ::: Everyone who is enrolled must be a student.",
            "∀x (TakesExam(x) → (WorksAtCompany(x) ∨ Student(x))) ::: Anyone who takes an exam either works at the company or is a student.",
            "∀x (¬(Student(x) ∧ WorksAtCompany(x) ∧ TakesExam(x))) ::: No student works at the company and takes exam.",
            "∃x (Student(x) ∧ ¬Enrolled(x)) ::: Some students are not enrolled.",
            "∀x (Student(x) → Young(x)) ::: All students are young.",
            "∀x (Young(x) → TakesExam(x)) ::: Every young person takes an exam.",
            "∀x (Young(x) → (WorksAtCompany(x) ∨ TakesExam(x))) ::: Anyone young works at the company or is taking exams.",
            "∀x (Enrolled(x) → WorksAtCompany(x)) ::: Anyone who is enrolled works at the company.",
            "∃x TakesExam(x) ::: Some people take exams.",
            "∀x (Young(x) → WorksAtCompany(x)) ::: If someone is young, then they work for the company.",
            "∃x (Student(x) ∧ WorksAtCompany(x)) ::: Some students are also employees of the company."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "WorksAtCompany(x) ::: x works at the company",
            "Enrolled(x) ::: x is enrolled in a course",
            "TakesExam(x) ::: x takes an exam"
        ]
    },
    {
        "premises-NL": [
            "All economists study economics.",
            "Everyone who studies economics understands markets.",
            "Anyone who understands markets recommends the policy.",
            "Some economists are also financial analysts.",
            "All financial analysts recommend the policy.",
            "If someone studies economics then they recommend the policy.",
            "Anyone who does not understand markets is not an economist.",
            "Some people recommend the policy.",
            "Some people study economics.",
            "If someone is an economist, then they are also a financial analyst.",
            "Someone who understands markets studies economics.",
            "If one is an economist, then they understand markets.",
            "All who study economics recommend the policy.",
            "Some people don't study economics or understand markets."
        ],
        "premises-FOL": [
            "∀x (Economist(x) → StudiesEconomics(x)) ::: All economists study economics.",
            "∀x (StudiesEconomics(x) → UnderstandsMarkets(x)) ::: Everyone who studies economics understands markets.",
            "∀x (UnderstandsMarkets(x) → RecommendsPolicy(x)) ::: Anyone who understands markets recommends the policy.",
            "∃x (Economist(x) ∧ FinancialAnalyst(x)) ::: Some economists are also financial analysts.",
            "∀x (FinancialAnalyst(x) → RecommendsPolicy(x)) ::: All financial analysts recommend the policy.",
            "∀x (StudiesEconomics(x) → RecommendsPolicy(x)) ::: If someone studies economics then they recommend the policy.",
            "∀x (¬UnderstandsMarkets(x) → ¬Economist(x)) ::: Anyone who does not understand markets is not an economist.",
            "∃x RecommendsPolicy(x) ::: Some people recommend the policy.",
            "∃x StudiesEconomics(x) ::: Some people study economics.",
            "∀x (Economist(x) → FinancialAnalyst(x)) ::: If someone is an economist, then they are also a financial analyst.",
            "∃x (UnderstandsMarkets(x) ∧ StudiesEconomics(x)) ::: Someone who understands markets studies economics.",
            "∀x (Economist(x) → UnderstandsMarkets(x)) ::: If one is an economist, then they understand markets.",
            "∀x (StudiesEconomics(x) → RecommendsPolicy(x)) ::: All who study economics recommend the policy.",
            "∃x (¬StudiesEconomics(x) ∨ ¬UnderstandsMarkets(x)) ::: Some people don't study economics or understand markets."
        ],
        "predicates": [
            "Economist(x) ::: x is an economist",
            "RecommendsPolicy(x) ::: x recommends the policy",
            "StudiesEconomics(x) ::: x studies economics",
            "UnderstandsMarkets(x) ::: x understands markets"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "Some doctors are also patients.",
            "If someone is a doctor and a patient, then they have a disease.",
            "Not all patients have diseases.",
            "There is a patient."
        ],
        "premises-FOL": [
            "∀x ∀y (Doctor(x) ∧ Patient(y) → Treats(x, y)) ::: All doctors treat patients.",
            "∃x (Doctor(x) ∧ Patient(x)) ::: Some doctors are also patients.",
            "∀x (Doctor(x) ∧ Patient(x) → HasDisease(x)) ::: If someone is a doctor and a patient, then they have a disease.",
            "∃x ¬HasDisease(x) ::: Not all patients have diseases.",
            "∃x Patient(x) ::: There is a patient."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Patient(x) ::: x is a patient.",
            "HasDisease(x) ::: x has a disease.",
            "Treats(x, y) ::: x treats y."
        ]
    },
    {
        "premises-NL": [
            "All economists study economics.",
            "All those who study economics are employed.",
            "Anyone who is employed either works in finance or has savings.",
            "Anyone who has savings is rich.",
            "If someone is an economist, then they are employed.",
            "There is someone who studies economics and works in finance."
        ],
        "premises-FOL": [
            "∀x (Economist(x) → StudiesEconomics(x)) ::: All economists study economics.",
            "∀x (StudiesEconomics(x) → IsEmployed(x)) ::: All those who study economics are employed.",
            "∀x (IsEmployed(x) → (WorksInFinance(x) ∨ HasSavings(x))) ::: Anyone who is employed either works in finance or has savings.",
            "∀x (HasSavings(x) → Rich(x)) ::: Anyone who has savings is rich.",
            "∀x (Economist(x) → IsEmployed(x)) ::: If someone is an economist, then they are employed.",
            "∃x (StudiesEconomics(x) ∧ WorksInFinance(x)) ::: There is someone who studies economics and works in finance."
        ],
        "predicates": [
            "Economist(x) ::: x is an economist.",
            "Rich(x) ::: x is rich.",
            "WorksInFinance(x) ::: x works in finance.",
            "StudiesEconomics(x) ::: x studies economics.",
            "HasSavings(x) ::: x has savings.",
            "IsEmployed(x) ::: x is employed."
        ]
    },
    {
        "premises-NL": [
            "All active users are users.",
            "All users have profiles.",
            "If a user posts, then the user is active or has a profile.",
            "If a user posts and is not active, then they must have a profile.",
            "If a user is not active, then they are verified.",
            "All verified users have profiles.",
            "Some users share content and are active.",
            "If a user shares content and likes posts, then they have a profile.",
            "If a user follows a user, then the user has a profile."
        ],
        "premises-FOL": [
            "∀x (Active(x) → User(x)) ::: All active users are users.",
            "∀x (User(x) → HasProfile(x)) ::: All users have profiles.",
            "∀x (Posts(x) → (Active(x) ∨ HasProfile(x))) ::: If a user posts, then the user is active or has a profile.",
            "∀x (Posts(x) ∧ ¬Active(x) → HasProfile(x)) ::: If a user posts and is not active, then they must have a profile.",
            "∀x (¬Active(x) → IsVerified(x)) ::: If a user is not active, then they are verified.",
            "∀x (IsVerified(x) → HasProfile(x)) ::: All verified users have profiles.",
            "∃x ∃y (User(x) ∧ SharesContent(x, y) ∧ Active(x)) ::: Some users share content and are active.",
            "∀x ∀y ((SharesContent(x, y) ∧ LikesPost(x, y)) → HasProfile(x)) ::: If a user shares content and likes posts, then they have a profile.",
            "∀x ∀y (Follows(x, y) → HasProfile(x)) ::: If a user follows a user, then the user has a profile."
        ],
        "predicates": [
            "User(x) ::: x is a user.",
            "Active(x) ::: x is active.",
            "Posts(x) ::: x posts.",
            "HasProfile(x) ::: x has a profile.",
            "FriendsWith(x, y) ::: x is friends with y.",
            "Follows(x, y) ::: x follows y.",
            "LikesPost(x, y) ::: x likes post y.",
            "IsVerified(x) ::: x is verified.",
            "SharesContent(x, y) ::: x shares content y."
        ]
    },
    {
        "premises-NL": [
            "All students have homework.",
            "If a student fails the exam, they did not study hard.",
            "Some students are smart.",
            "Some students study hard.",
            "If a student doesn't study hard they fail the exam.",
            "If someone is a student and they pass the exam then they are smart.",
            "If a student has homework then they are a student.",
            "If a student fails the exam then they have homework.",
            "Some students do not have homework.",
            "Anyone who is a student is studying hard or not studying hard.",
            "Some students have homework and studies hard.",
            "If a student studies hard, they have homework.",
            "Some students are failing the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → HasHomework(x)) ::: All students have homework.",
            "∀x (FailsExam(x) → ¬StudiesHard(x)) ::: If a student fails the exam, they did not study hard.",
            "∃x (Student(x) ∧ Smart(x)) ::: Some students are smart.",
            "∃x (Student(x) ∧ StudiesHard(x)) ::: Some students study hard.",
            "∀x (¬StudiesHard(x) → FailsExam(x)) ::: If a student doesn't study hard they fail the exam.",
            "∀x ((Student(x) ∧ PassesExam(x)) → Smart(x)) ::: If someone is a student and they pass the exam then they are smart.",
            "∀x (HasHomework(x) → Student(x)) ::: If a student has homework then they are a student.",
            "∀x (FailsExam(x) → HasHomework(x)) ::: If a student fails the exam then they have homework.",
            "∃x (Student(x) ∧ ¬HasHomework(x)) ::: Some students do not have homework.",
            "∀x (Student(x) → (StudiesHard(x) ∨ ¬StudiesHard(x))) ::: Anyone who is a student is studying hard or not studying hard.",
            "∃x (Student(x) ∧ HasHomework(x) ∧ StudiesHard(x)) ::: Some students have homework and studies hard.",
            "∀x (StudiesHard(x) → HasHomework(x)) ::: If a student studies hard, they have homework.",
            "∃x (Student(x) ∧ FailsExam(x)) ::: Some students are failing the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "FailsExam(x) ::: x fails the exam",
            "PassesExam(x) ::: x passes the exam",
            "HasHomework(x) ::: x has homework"
        ]
    },
    {
        "premises-NL": [
            "All students are required to take the exam.",
            "If someone is a student, they are in the class.",
            "If someone is in the class, they are required to take the exam.",
            "If John is a student, he is required to take the exam.",
            "Everyone who takes the exam either passes or fails.",
            "If someone fails, they do not pass.",
            "John is a student.",
            "If someone takes the exam and passes, they graduate.",
            "John graduated."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakeExam(x)) ::: All students are required to take the exam.",
            "∀x (Student(x) → InClass(x)) ::: If someone is a student, they are in the class.",
            "∀x (InClass(x) → TakeExam(x)) ::: If someone is in the class, they are required to take the exam.",
            "Student(john) → TakeExam(john) ::: If John is a student, he is required to take the exam.",
            "∀x (TakeExam(x) → (PassExam(x) ∨ FailExam(x))) ::: Everyone who takes the exam either passes or fails.",
            "∀x (FailExam(x) → ¬PassExam(x)) ::: If someone fails, they do not pass.",
            "Student(john) ::: John is a student.",
            "∀x (TakeExam(x) ∧ PassExam(x) → Graduate(x)) ::: If someone takes the exam and passes, they graduate.",
            "Graduate(john) ::: John graduated."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PassExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "All doctors are medical professionals.",
            "All researchers are scientists.",
            "If someone is a medical professional, they can provide medical care.",
            "If someone is a scientist, they can conduct research.",
            "Anyone who provides medical care is a doctor.",
            "Anyone who conducts research is a researcher.",
            "Some doctors are researchers.",
            "John is a doctor.",
            "John specializes in cardiology.",
            "If someone specializes in cardiology, they are a medical professional.",
            "If someone specializes in research, they conduct research.",
            "Not all doctors are researchers."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → MedicalProfessional(x)) ::: All doctors are medical professionals.",
            "∀x (Researcher(x) → Scientist(x)) ::: All researchers are scientists.",
            "∀x (MedicalProfessional(x) → ProvidesMedicalCare(x)) ::: If someone is a medical professional, they can provide medical care.",
            "∀x (Scientist(x) → ConductsResearch(x)) ::: If someone is a scientist, they can conduct research.",
            "∀x (ProvidesMedicalCare(x) → Doctor(x)) ::: Anyone who provides medical care is a doctor.",
            "∀x (ConductsResearch(x) → Researcher(x)) ::: Anyone who conducts research is a researcher.",
            "∃x (Doctor(x) ∧ Researcher(x)) ::: Some doctors are researchers.",
            "Doctor(john) ::: John is a doctor.",
            "SpecializesIn(john, cardiology) ::: John specializes in cardiology.",
            "∀x (SpecializesIn(x, cardiology) → MedicalProfessional(x)) ::: If someone specializes in cardiology, they are a medical professional.",
            "∀x (SpecializesIn(x, research) → ConductsResearch(x)) ::: If someone specializes in research, they conduct research.",
            "¬∀x (Doctor(x) → Researcher(x)) ::: Not all doctors are researchers."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Researcher(x) ::: x is a researcher",
            "ConductsResearch(x) ::: x conducts research",
            "SpecializesIn(x, y) ::: x specializes in y"
        ]
    },
    {
        "premises-NL": [
            "If a patient has a fever, then they are sick.",
            "If a patient takes medicine and is sick, then they recover.",
            "The patient has a fever.",
            "The patient has not taken medicine.",
            "If a patient is diagnosed with a treatable disease and takes medicine, they recover.",
            "If a person has a cold, they have a fever.",
            "The patient is diagnosed with a cold.",
            "If a patient has influenza and takes antibiotics they recover.",
            "If a patient takes antibiotics, they have taken medicine.",
            "If someone takes antibiotics, they have not recovered."
        ],
        "premises-FOL": [
            "∀x (HasFever(x) → Sick(x)) ::: If a patient has a fever, then they are sick.",
            "∀x (TakesMedicine(x) ∧ Sick(x) → Recovered(x)) ::: If a patient takes medicine and is sick, then they recover.",
            "HasFever(patient) ::: The patient has a fever.",
            "¬TakesMedicine(patient) ::: The patient has not taken medicine.",
            "∀x ∀y (DiagnosedWith(x, y) ∧ Treatable(y) ∧ TakesMedicine(x) → Recovered(x)) ::: If a patient is diagnosed with a treatable disease and takes medicine, they recover.",
            "∀x (HasCold(x) → HasFever(x)) ::: If a person has a cold, they have a fever.",
            "DiagnosedWith(patient, cold) ::: The patient is diagnosed with a cold.",
            "∀x (HasInfluenza(x) ∧ TakesAntibiotics(x) → Recovered(x)) ::: If a patient has influenza and takes antibiotics they recover.",
            "∀x (TakesAntibiotics(x) → TakesMedicine(x)) ::: If a patient takes antibiotics, they have taken medicine.",
            "∀x (TakesAntibiotics(x) → ¬Recovered(x)) ::: If someone takes antibiotics, they have not recovered."
        ],
        "predicates": [
            "HasFever(x) ::: x has a fever",
            "TakesMedicine(x) ::: x takes medicine",
            "Sick(x) ::: x is sick",
            "DiagnosedWith(x, y) ::: x is diagnosed with disease y",
            "Disease(y) ::: y is a disease",
            "Treatable(y) ::: y is treatable",
            "Recovered(x) ::: x has recovered",
            "HasSymptoms(x, y) ::: x has symptom y",
            "Symptom(y) ::: y is a symptom",
            "HasCold(x) ::: x has a cold",
            "TakesAntibiotics(x) ::: x takes antibiotics",
            "HasInfluenza(x) ::: x has influenza"
        ]
    },
    {
        "premises-NL": [
            "All people drink coffee or tea.",
            "If someone drinks coffee, they like coffee.",
            "If someone drinks tea, they like tea.",
            "John drinks coffee.",
            "Mary drinks tea.",
            "Everyone is a person.",
            "If someone likes coffee or tea they are happy."
        ],
        "premises-FOL": [
            "∀x (Person(x) → (Drinks(x, coffee) ∨ Drinks(x, tea))) ::: All people drink coffee or tea.",
            "∀x (Drinks(x, coffee) → Likes(x, coffee)) ::: If someone drinks coffee, they like coffee.",
            "∀x (Drinks(x, tea) → Likes(x, tea)) ::: If someone drinks tea, they like tea.",
            "Drinks(john, coffee) ::: John drinks coffee.",
            "Drinks(mary, tea) ::: Mary drinks tea.",
            "∀x (Person(x)) ::: Everyone is a person.",
            "∀x ((Likes(x, coffee) ∨ Likes(x, tea)) → Happy(x)) ::: If someone likes coffee or tea they are happy."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Likes(x, y) ::: x likes y",
            "Coffee(x) ::: x is coffee",
            "Tea(x) ::: x is tea",
            "Drinks(x, y) ::: x drinks y",
            "Healthy(x) ::: x is healthy",
            "Happy(x) ::: x is happy"
        ]
    },
    {
        "premises-NL": [
            "All cats are animals.",
            "All mice are animals.",
            "Every animal that hunts is fast.",
            "Every cat hunts mice.",
            "All mice are small.",
            "If something hunts and is fast, then it chases something.",
            "There exists a cat.",
            "There exists a mouse."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → IsAnimal(x)) ::: All cats are animals.",
            "∀x (Mouse(x) → IsAnimal(x)) ::: All mice are animals.",
            "∀x (Hunts(x, y) → Fast(x)) ::: Every animal that hunts is fast.",
            "∀x (Cat(x) → Hunts(x, y)) ::: Every cat hunts mice.",
            "∀x (Mouse(x) → Small(x)) ::: All mice are small.",
            "∀x ∀y ((Hunts(x, y) ∧ Fast(x)) → Chases(x, y)) ::: If something hunts and is fast, then it chases something.",
            "∃x Cat(x) ::: There exists a cat.",
            "∃y Mouse(y) ::: There exists a mouse."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Mouse(x) ::: x is a mouse",
            "Chases(x, y) ::: x chases y",
            "Hunts(x, y) ::: x hunts y",
            "Fast(x) ::: x is fast",
            "Small(x) ::: x is small",
            "LivesIn(x, y) ::: x lives in y",
            "IsAnimal(x) ::: x is an animal"
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "Alice is a student.",
            "If someone is a student and studies hard, they will pass the exam.",
            "Alice studies hard.",
            "If someone is smart and studies hard, they will pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "Student(alice) ::: Alice is a student.",
            "∀x (Student(x) ∧ StudyHard(x) → PassExam(x)) ::: If someone is a student and studies hard, they will pass the exam.",
            "StudyHard(alice) ::: Alice studies hard.",
            "∀x (Smart(x) ∧ StudyHard(x) → PassExam(x)) ::: If someone is smart and studies hard, they will pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudyHard(x) ::: x studies hard.",
            "PassExam(x) ::: x passes the exam.",
            "Smart(x) ::: x is smart."
        ]
    },
    {
        "premises-NL": [
            "If someone owns a car or a bicycle, then they have transportation.",
            "If someone has transportation, they can travel.",
            "Anyone who has transportation does not walk everywhere.",
            "Alice owns a car.",
            "Bob owns a bicycle.",
            "If someone owns a car, they have transportation.",
            "If someone drives a car, they have transportation."
        ],
        "premises-FOL": [
            "∀x ((Owns(x, car) ∨ Owns(x, bicycle)) → HasTransportation(x)) ::: If someone owns a car or a bicycle, then they have transportation.",
            "∀x (HasTransportation(x) → CanTravel(x)) ::: If someone has transportation, they can travel.",
            "∀x (HasTransportation(x) → ¬WalksEverywhere(x)) ::: Anyone who has transportation does not walk everywhere.",
            "Owns(alice, car) ::: Alice owns a car.",
            "Owns(bob, bicycle) ::: Bob owns a bicycle.",
            "∀x (Owns(x, car) → HasTransportation(x)) ::: If someone owns a car, they have transportation.",
            "∀x (Drives(x, car) → HasTransportation(x)) ::: If someone drives a car, they have transportation."
        ],
        "predicates": [
            "Owns(x, y) ::: x owns y.",
            "Car(x) ::: x is a car.",
            "Bicycle(x) ::: x is a bicycle.",
            "WalksEverywhere(x) ::: x walks everywhere.",
            "HasTransportation(x) ::: x has transportation.",
            "CanTravel(x, y) ::: x can travel to y.",
            "Drives(x, y) ::: x drives y."
        ]
    },
    {
        "premises-NL": [
            "Alice is a friend of Bob.",
            "Bob is a friend of Alice.",
            "Everyone who is friends with Bob likes coffee.",
            "Alice and Bob are friends."
        ],
        "premises-FOL": [
            "Friend(alice, bob) ::: Alice is a friend of Bob.",
            "Friend(bob, alice) ::: Bob is a friend of Alice.",
            "∀x (Friend(bob, x) → Likes(x, coffee)) ::: Everyone who is friends with Bob likes coffee.",
            "Friend(alice, bob) ∧ Friend(bob, alice) ::: Alice and Bob are friends."
        ],
        "predicates": [
            "Friend(x, y) ::: x is a friend of y",
            "Likes(x, y) ::: x likes y"
        ]
    },
    {
        "premises-NL": [
            "Alice studies hard.",
            "If Alice studies hard, then Bob studies hard.",
            "If Bob studies hard, then he will pass the exam.",
            "Bob studies hard.",
            "Alice will study hard if she wants to pass the exam.",
            "Bob wants to pass the exam.",
            "If Alice and Bob study hard, then they will both pass the exam.",
            "If both Alice and Bob pass the exam, then Bob will pass the exam."
        ],
        "premises-FOL": [
            "HardStudy(alice) ::: Alice studies hard",
            "HardStudy(alice) → HardStudy(bob) ::: If Alice studies hard, then Bob studies hard.",
            "HardStudy(bob) → PassExam(bob) ::: If Bob studies hard, then he will pass the exam.",
            "HardStudy(bob) ::: Bob studies hard.",
            "PassExam(alice) → HardStudy(alice) ::: Alice will study hard if she wants to pass the exam.",
            "PassExam(bob) ::: Bob wants to pass the exam.",
            "HardStudy(alice) ∧ HardStudy(bob) → PassExam(alice) ∧ PassExam(bob) ::: If Alice and Bob study hard, then they will both pass the exam.",
            "PassExam(alice) ∧ PassExam(bob) → PassExam(bob) ::: If both Alice and Bob pass the exam, then Bob will pass the exam."
        ],
        "predicates": [
            "HardStudy(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "John likes apples or Mary likes apples.",
            "If John likes apples, then he eats apples.",
            "If Mary likes apples, then she eats apples.",
            "John does not eat apples.",
            "If Mary likes apples, then John likes apples.",
            "John likes apples or Bob likes oranges.",
            "If Mary likes apples, then Bob does not like oranges.",
            "John does not like apples if Mary likes apples.",
            "If Mary likes apples, then John does not like apples."
        ],
        "premises-FOL": [
            "Likes(john, apples) ∨ Likes(mary, apples) ::: John likes apples or Mary likes apples.",
            "Likes(john, apples) → Eats(john, apples) ::: If John likes apples, then he eats apples.",
            "Likes(mary, apples) → Eats(mary, apples) ::: If Mary likes apples, then she eats apples.",
            "¬Eats(john, apples) ::: John does not eat apples.",
            "Likes(mary, apples) → Likes(john, apples) ::: If Mary likes apples, then John likes apples.",
            "Likes(john, apples) ∨ Likes(bob, oranges) ::: John likes apples or Bob likes oranges.",
            "Likes(mary, apples) → ¬Likes(bob, oranges) ::: If Mary likes apples, then Bob does not like oranges.",
            "Likes(mary, apples) → ¬Likes(john, apples) ::: John does not like apples if Mary likes apples.",
            "Likes(mary, apples) → ¬Likes(john, apples) ::: If Mary likes apples, then John does not like apples."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y"
        ]
    },
    {
        "premises-NL": [
            "Every patient who receives treatment has a fever.",
            "All patients who receive treatment are sick.",
            "Patient John receives treatment.",
            "If someone has a fever, they are sick.",
            "John is a patient."
        ],
        "premises-FOL": [
            "∀x (ReceivesTreatment(x) → HasFever(x)) ::: Everyone who receives treatment has a fever.",
            "∀x (ReceivesTreatment(x) → Sick(x)) ::: Everyone who receives treatment is sick.",
            "ReceivesTreatment(john) ::: John receives treatment.",
            "∀x (HasFever(x) → Sick(x)) ::: If anyone has a fever, they are sick.",
            "Patient(john) ::: John is a patient."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient.",
            "HasFever(x) ::: x has a fever.",
            "Sick(x) ::: x is sick.",
            "ReceivesTreatment(x) ::: x receives treatment."
        ]
    },
    {
        "premises-NL": [
            "Every student who studies hard has knowledge.",
            "Every student who has knowledge will pass the exam.",
            "Every student who attends all lectures studies hard.",
            "If someone studies hard, they like learning.",
            "If a student likes learning, they will pass the exam.",
            "All students who study hard attend all lectures."
        ],
        "premises-FOL": [
            "∀x (StudiesHard(x) → HasKnowledge(x)) ::: Anyone who studies hard has knowledge.",
            "∀x (HasKnowledge(x) → PassesExam(x)) ::: Anyone who has knowledge will pass the exam.",
            "∀x (AttendsLectures(x) → StudiesHard(x)) ::: Anyone who attends all lectures studies hard.",
            "∀x (StudiesHard(x) → LikesLearning(x)) ::: If someone studies hard, they like learning.",
            "∀x (LikesLearning(x) → PassesExam(x)) ::: If a student likes learning, they will pass the exam.",
            "∀x (StudiesHard(x) → AttendsLectures(x)) ::: All students who study hard attend all lectures."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesHard(x) ::: x studies hard.",
            "AttendsLectures(x) ::: x attends lectures.",
            "PassesExam(x) ::: x passes the exam.",
            "HasKnowledge(x) ::: x has knowledge.",
            "LikesLearning(x) ::: x likes learning."
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "Anyone who treats patients can diagnose.",
            "Anyone who can diagnose can prescribe medicine if they have a license.",
            "If a person is a doctor, they treat patients.",
            "John is a doctor and has a license.",
            "Everyone who is healthy does not need medicine.",
            "Every doctor has a license."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → TreatsPatients(x)) ::: All doctors treat patients.",
            "∀x (TreatsPatients(x) → CanDiagnose(x)) ::: Anyone who treats patients can diagnose.",
            "∀x ((CanDiagnose(x) ∧ HasLicense(x)) → PrescribesMedicine(x)) ::: Anyone who can diagnose can prescribe medicine if they have a license.",
            "∀x (Doctor(x) → TreatsPatients(x)) ::: If a person is a doctor, they treat patients.",
            "Doctor(john) ∧ HasLicense(john) ::: John is a doctor and has a license.",
            "∀x (IsHealthy(x) → ¬PrescribesMedicine(x)) ::: Everyone who is healthy does not need medicine.",
            "∀x (Doctor(x) → HasLicense(x)) ::: Every doctor has a license."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "Doctor(x) ::: x is a doctor.",
            "HasLicense(x) ::: x has a license.",
            "PrescribesMedicine(x) ::: x prescribes medicine.",
            "TreatsPatients(x) ::: x treats patients.",
            "IsHealthy(x) ::: x is healthy.",
            "CanDiagnose(x) ::: x can diagnose."
        ]
    },
    {
        "premises-NL": [
            "All students who have good grades are prepared.",
            "Anyone who is prepared will pass the exam.",
            "If someone attends all classes, they study.",
            "John is a student.",
            "Mary has good grades.",
            "If someone is a student, then they attend all classes.",
            "If a student studies, they pass the exam.",
            "Some students attend all classes.",
            "John has good grades.",
            "Mary studies.",
            "All who have good grades study.",
            "If someone is a student, they are prepared.",
            "If someone studies, then they will attend the classes.",
            "John attends all classes.",
            "Some students have good grades.",
            "Mary attends all classes."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ GoodGrades(x) → IsPrepared(x)) ::: All students who have good grades are prepared.",
            "∀x (IsPrepared(x) → PassExam(x)) ::: Anyone who is prepared will pass the exam.",
            "∀x (AttendsClasses(x) → Studies(x, AnySubject)) ::: If someone attends all classes, they study.",
            "Student(John) ::: John is a student.",
            "GoodGrades(Mary) ::: Mary has good grades.",
            "∀x (Student(x) → AttendsClasses(x)) ::: If someone is a student, then they attend all classes.",
            "∀x (Studies(x, AnySubject) → PassExam(x)) ::: If a student studies, they pass the exam.",
            "∃x (Student(x) ∧ AttendsClasses(x)) ::: Some students attend all classes.",
            "GoodGrades(John) ::: John has good grades.",
            "Studies(Mary, AnySubject) ::: Mary studies.",
            "∀x (GoodGrades(x) → Studies(x, AnySubject)) ::: All who have good grades study.",
            "∀x (Student(x) → IsPrepared(x)) ::: If someone is a student, they are prepared.",
            "∀x (Studies(x, AnySubject) → AttendsClasses(x)) ::: If someone studies, then they will attend the classes.",
            "AttendsClasses(John) ::: John attends all classes.",
            "∃x (Student(x) ∧ GoodGrades(x)) ::: Some students have good grades.",
            "AttendsClasses(Mary) ::: Mary attends all classes."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "GoodGrades(x) ::: x has good grades",
            "AttendsClasses(x) ::: x attends classes",
            "PassExam(x) ::: x will pass the exam",
            "Studies(x, y) ::: x studies y",
            "Likes(x, y) ::: x likes y",
            "IsPrepared(x) ::: x is prepared"
        ]
    },
    {
        "premises-NL": [
            "All students are friends.",
            "If someone likes someone else, then they are friends.",
            "Alice is a student.",
            "Alice likes Charlie.",
            "David is a student.",
            "David likes Eve."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Friend(x, x)) ::: All students are friends with themselves.",
            "∀x ∀y (Likes(x, y) → Friend(x, y)) ::: If someone likes someone else, then they are friends.",
            "Student(alice) ::: Alice is a student.",
            "Likes(alice, charlie) ::: Alice likes Charlie.",
            "Student(david) ::: David is a student.",
            "Likes(david, eve) ::: David likes Eve."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Friend(x, y) ::: x is a friend of y.",
            "Likes(x, y) ::: x likes y."
        ]
    },
    {
        "premises-NL": [
            "If someone studies, they will get a good grade.",
            "If someone gets a good grade, they will pass.",
            "John studies.",
            "If someone takes the exam, they will get a good grade.",
            "John attends class.",
            "John has a book.",
            "John takes the exam."
        ],
        "premises-FOL": [
            "∀x (Studies(x) → GoodGrade(x)) ::: If someone studies, they will get a good grade.",
            "∀x (GoodGrade(x) → Passes(x)) ::: If someone gets a good grade, they will pass.",
            "Studies(john) ::: John studies.",
            "∀x (TakesExam(x) → GoodGrade(x)) ::: If someone takes the exam, they will get a good grade.",
            "AttendsClass(john) ::: John attends class.",
            "HasBook(john) ::: John has a book.",
            "TakesExam(john) ::: John takes the exam."
        ],
        "predicates": [
            "Studies(x) ::: x studies.",
            "TakesExam(x) ::: x takes the exam.",
            "Passes(x) ::: x passes.",
            "GoodGrade(x) ::: x gets a good grade.",
            "AttendsClass(x) ::: x attends class.",
            "HasBook(x) ::: x has a book."
        ]
    },
    {
        "premises-NL": [
            "If a patient has a fever and coughs, then they have the flu.",
            "If a patient doesn't cough and visited the doctor, then they have a cold.",
            "The patient has a fever.",
            "The patient coughs.",
            "If a patient has the flu, they don't have a cold.",
            "The patient either has the flu or visited the doctor.",
            "If the patient visited the doctor, then they took medication.",
            "The patient does not take medication."
        ],
        "premises-FOL": [
            "∀x ((HasFever(x) ∧ Coughs(x)) → Flu(x)) ::: If a patient has a fever and coughs, then they have the flu.",
            "∀x ((¬Coughs(x) ∧ DoctorVisited(x)) → Cold(x)) ::: If a patient doesn't cough and visited the doctor, then they have a cold.",
            "HasFever(patient) ::: The patient has a fever.",
            "Coughs(patient) ::: The patient coughs.",
            "∀x (Flu(x) → ¬Cold(x)) ::: If a patient has the flu, they don't have a cold.",
            "Flu(patient) ∨ DoctorVisited(patient) ::: The patient either has the flu or visited the doctor.",
            "∀x (DoctorVisited(x) → MedicationTaken(x)) ::: If the patient visited the doctor, then they took medication.",
            "¬MedicationTaken(patient) ::: The patient does not take medication."
        ],
        "predicates": [
            "HasFever(x) ::: x has a fever.",
            "Coughs(x) ::: x coughs.",
            "Flu(x) ::: x has the flu.",
            "Cold(x) ::: x has a cold.",
            "DoctorVisited(x) ::: x visited the doctor.",
            "MedicationTaken(x) ::: x took medication."
        ]
    },
    {
        "premises-NL": [
            "If someone has a car and a license, and their car is working, then they can drive.",
            "If someone has a car, then they have keys.",
            "John has a car.",
            "If John can drive, John is a legal driver.",
            "If someone is awake, they want to drive.",
            "John has a license.",
            "If someone is a legal driver, then they have a license.",
            "John's car is working.",
            "John is awake.",
            "If someone wants to drive and can drive, then they are driving."
        ],
        "premises-FOL": [
            "∀x ((HasCar(x) ∧ HasLicense(x) ∧ CarWorking(x)) → CanDrive(x)) ::: If someone has a car and a license, and their car is working, then they can drive.",
            "∀x (HasCar(x) → HasKeys(x)) ::: If someone has a car, then they have keys.",
            "HasCar(john) ::: John has a car.",
            "∀x (CanDrive(x) → IsLegalDriver(x)) ::: If John can drive, John is a legal driver.",
            "∀x (IsAwake(x) → WantsToDrive(x)) ::: If someone is awake, they want to drive.",
            "HasLicense(john) ::: John has a license.",
            "∀x (IsLegalDriver(x) → HasLicense(x)) ::: If someone is a legal driver, then they have a license.",
            "CarWorking(john) ::: John's car is working.",
            "IsAwake(john) ::: John is awake.",
            "∀x ((WantsToDrive(x) ∧ CanDrive(x)) → IsDriving(x)) ::: If someone wants to drive and can drive, then they are driving."
        ],
        "predicates": [
            "HasCar(x) ::: x has a car.",
            "HasLicense(x) ::: x has a license.",
            "CanDrive(x) ::: x can drive.",
            "HasKeys(x) ::: x has keys.",
            "IsTired(x) ::: x is tired.",
            "IsAwake(x) ::: x is awake.",
            "CarWorking(x) ::: x's car is working.",
            "WantsToDrive(x) ::: x wants to drive.",
            "IsDriving(x) ::: x is driving.",
            "IsLegalDriver(x) ::: x is a legal driver."
        ]
    },
    {
        "premises-NL": [
            "All doctors study medicine.",
            "All researchers publish papers.",
            "Anyone who studies medicine is a doctor.",
            "If someone publishes a paper, then they are a researcher.",
            "Some doctors attend conferences.",
            "No one who studies medicine attends conferences.",
            "Anyone who attends a conference is a doctor.",
            "Some researchers study medicine.",
            "All doctors publish papers.",
            "If x publishes a paper, then x is a doctor.",
            "Anyone who is a doctor must publish a paper.",
            "If x studies medicine, then x attends conference."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → StudiesMedicine(x)) ::: All doctors study medicine.",
            "∀x (Researcher(x) → PublishesPaper(x)) ::: All researchers publish papers.",
            "∀x (StudiesMedicine(x) → Doctor(x)) ::: Anyone who studies medicine is a doctor.",
            "∀x (PublishesPaper(x) → Researcher(x)) ::: If someone publishes a paper, then they are a researcher.",
            "∃x Doctor(x) ∧ AttendsConference(x) ::: Some doctors attend conferences.",
            "¬∃x (StudiesMedicine(x) ∧ AttendsConference(x)) ::: No one who studies medicine attends conferences.",
            "∀x (AttendsConference(x) → Doctor(x)) ::: Anyone who attends a conference is a doctor.",
            "∃x (Researcher(x) ∧ StudiesMedicine(x)) ::: Some researchers study medicine.",
            "∀x (Doctor(x) → PublishesPaper(x)) ::: All doctors publish papers.",
            "∀x (PublishesPaper(x) → Doctor(x)) ::: If x publishes a paper, then x is a doctor.",
            "∀x (Doctor(x) → PublishesPaper(x)) ::: Anyone who is a doctor must publish a paper.",
            "∀x (StudiesMedicine(x) → AttendsConference(x)) ::: If x studies medicine, then x attends conference."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Researcher(x) ::: x is a researcher.",
            "StudiesMedicine(x) ::: x studies medicine.",
            "PublishesPaper(x) ::: x publishes a paper.",
            "AttendsConference(x) ::: x attends a conference."
        ]
    },
    {
        "premises-NL": [
            "All artists enjoy painting.",
            "All athletes play sports.",
            "Anyone who enjoys painting is creative.",
            "Anyone who plays sports is competitive.",
            "Some artists are creative.",
            "Some athletes are competitive.",
            "All creative people have talent.",
            "All competitive people have talent.",
            "If someone is an artist, then they have talent.",
            "If someone is an athlete, then they are competitive.",
            "Some people who enjoy painting are not athletes.",
            "All athletes are competitive people.",
            "If x is an artist, then x enjoys painting.",
            "Anyone who is creative is an artist."
        ],
        "premises-FOL": [
            "∀x (Artist(x) → EnjoysPainting(x)) ::: All artists enjoy painting.",
            "∀x (Athlete(x) → PlaysSport(x)) ::: All athletes play sports.",
            "∀x (EnjoysPainting(x) → IsCreative(x)) ::: Anyone who enjoys painting is creative.",
            "∀x (PlaysSport(x) → IsCompetitive(x)) ::: Anyone who plays sports is competitive.",
            "∃x (Artist(x) ∧ IsCreative(x)) ::: Some artists are creative.",
            "∃x (Athlete(x) ∧ IsCompetitive(x)) ::: Some athletes are competitive.",
            "∀x (IsCreative(x) → HasTalent(x)) ::: All creative people have talent.",
            "∀x (IsCompetitive(x) → HasTalent(x)) ::: All competitive people have talent.",
            "∀x (Artist(x) → HasTalent(x)) ::: If someone is an artist, then they have talent.",
            "∀x (Athlete(x) → IsCompetitive(x)) ::: If someone is an athlete, then they are competitive.",
            "∃x (EnjoysPainting(x) ∧ ¬Athlete(x)) ::: Some people who enjoy painting are not athletes.",
            "∀x (Athlete(x) → IsCompetitive(x)) ::: All athletes are competitive people.",
            "∀x (Artist(x) → EnjoysPainting(x)) ::: If x is an artist, then x enjoys painting.",
            "∀x (IsCreative(x) → Artist(x)) ::: Anyone who is creative is an artist."
        ],
        "predicates": [
            "Artist(x) ::: x is an artist.",
            "Athlete(x) ::: x is an athlete.",
            "EnjoysPainting(x) ::: x enjoys painting.",
            "PlaysSport(x) ::: x plays a sport.",
            "IsCreative(x) ::: x is creative.",
            "IsCompetitive(x) ::: x is competitive.",
            "HasTalent(x) ::: x has talent."
        ]
    },
    {
        "premises-NL": [
            "All writers write fiction.",
            "All writers have books.",
            "Some writers have movies.",
            "Anyone who writes fiction has their fiction published.",
            "Anyone whose fiction is published has a book.",
            "Some books are adapted to film.",
            "If someone has a book and a movie, then they are a writer.",
            "All writers who have books have movies.",
            "If a book is adapted to film, then someone has a movie.",
            "If someone has a book, then they are a writer.",
            "Everyone who has a book is a writer.",
            "Some writers do not have their books adapted to films.",
            "Everyone with a book had their book published.",
            "If someone has a movie, then they are a writer."
        ],
        "premises-FOL": [
            "∀x (Writer(x) → WritesFiction(x)) ::: All writers write fiction.",
            "∀x (Writer(x) → HasBook(x)) ::: All writers have books.",
            "∃x HasMovie(x) ∧ Writer(x) ::: Some writers have movies.",
            "∀x (WritesFiction(x) → BookPublished(x)) ::: Anyone who writes fiction has their fiction published.",
            "∀x (BookPublished(x) → HasBook(x)) ::: Anyone whose fiction is published has a book.",
            "∃x AdaptsToFilm(x, y) ::: Some books are adapted to film.",
            "∀x (HasBook(x) ∧ HasMovie(x) → Writer(x)) ::: If someone has a book and a movie, then they are a writer.",
            "∀x (Writer(x) ∧ HasBook(x) → HasMovie(x)) ::: All writers who have books have movies.",
            "∀x ∀y (AdaptsToFilm(x, y) → HasMovie(x)) ::: If a book is adapted to film, then someone has a movie.",
            "∀x (HasBook(x) → Writer(x)) ::: If someone has a book, then they are a writer.",
            "∀x (HasBook(x) → Writer(x)) ::: Everyone who has a book is a writer.",
            "∃x (Writer(x) ∧ ¬AdaptsToFilm(x, y)) ::: Some writers do not have their books adapted to films.",
            "∀x (HasBook(x) → BookPublished(x)) ::: Everyone with a book had their book published.",
            "∀x (HasMovie(x) → Writer(x)) ::: If someone has a movie, then they are a writer."
        ],
        "predicates": [
            "Writer(x) ::: x is a writer.",
            "HasBook(x) ::: x has a book.",
            "HasMovie(x) ::: x has a movie.",
            "WritesFiction(x) ::: x writes fiction.",
            "FictionPublished(x) ::: x's fiction is published.",
            "AdaptsToFilm(x,y) ::: x's book y is adapted to film.",
            "BookPublished(x) ::: x's book is published."
        ]
    },
    {
        "premises-NL": [
            "All students who study hard pass the exam.",
            "Anyone who passes the exam graduates.",
            "John is a student.",
            "John studies hard.",
            "Every student with a mentor is smart.",
            "If someone attends class, they take the exam.",
            "If someone knows logic, they study hard.",
            "John has a mentor.",
            "Anyone who is smart attends class.",
            "John knows logic."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) → PassesExam(x)) ::: All students who study hard pass the exam.",
            "∀x (PassesExam(x) → Graduates(x)) ::: Anyone who passes the exam graduates.",
            "Student(john) ::: John is a student.",
            "StudiesHard(john) ::: John studies hard.",
            "∀x (Student(x) ∧ HasMentor(x) → IsSmart(x)) ::: Every student with a mentor is smart.",
            "∀x (AttendsClass(x) → TakesExam(x)) ::: If someone attends class, they take the exam.",
            "∀x (KnowsLogic(x) → StudiesHard(x)) ::: If someone knows logic, they study hard.",
            "HasMentor(john) ::: John has a mentor.",
            "∀x (IsSmart(x) → AttendsClass(x)) ::: Anyone who is smart attends class.",
            "KnowsLogic(john) ::: John knows logic."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "HasMentor(x) ::: x has a mentor",
            "Graduates(x) ::: x graduates",
            "TakesExam(x) ::: x takes an exam",
            "PassesExam(x) ::: x passes the exam",
            "StudiesHard(x) ::: x studies hard",
            "KnowsLogic(x) ::: x knows logic",
            "IsSmart(x) ::: x is smart",
            "AttendsClass(x) ::: x attends class"
        ]
    },
    {
        "premises-NL": [
            "Mary is a runner.",
            "David is a runner.",
            "All runners have training.",
            "If someone has training and doesn't have an injury, then they regularly practice.",
            "If someone regularly practices and eats healthy, then they are a runner.",
            "Mary eats healthy.",
            "David is injured.",
            "If someone is a runner, then they have endurance.",
            "If someone has endurance and eats healthy, then they are faster than David.",
            "Mary has training.",
            "If Mary eats healthy and has training, then she is faster than David."
        ],
        "premises-FOL": [
            "Runner(mary) ::: Mary is a runner.",
            "Runner(david) ::: David is a runner.",
            "∀x (Runner(x) → HasTraining(x)) ::: All runners have training.",
            "∀x (HasTraining(x) ∧ ¬IsInjured(x) → RegularlyPractices(x)) ::: If someone has training and doesn't have an injury, then they regularly practice.",
            "∀x (RegularlyPractices(x) ∧ EatsHealthy(x) → Runner(x)) ::: If someone regularly practices and eats healthy, then they are a runner.",
            "EatsHealthy(mary) ::: Mary eats healthy.",
            "IsInjured(david) ::: David is injured.",
            "∀x (Runner(x) → HasEndurance(x)) ::: If someone is a runner, then they have endurance.",
            "∀x (HasEndurance(x) ∧ EatsHealthy(x) → FasterThan(x, david)) ::: If someone has endurance and eats healthy, then they are faster than David.",
            "HasTraining(mary) ::: Mary has training.",
            "EatsHealthy(mary) ∧ HasTraining(mary) → FasterThan(mary, david) ::: If Mary eats healthy and has training, then she is faster than David."
        ],
        "predicates": [
            "Runner(x) ::: x is a runner",
            "FasterThan(x, y) ::: x is faster than y",
            "HasTraining(x) ::: x has training",
            "IsInjured(x) ::: x is injured",
            "RegularlyPractices(x) ::: x regularly practices",
            "EatsHealthy(x) ::: x eats healthy food",
            "Weight(x, w) ::: x weighs w kilograms",
            "IsStrongerThan(x, y) ::: x is stronger than y",
            "HasEndurance(x) ::: x has endurance",
            "IsTallerThan(x, y) ::: x is taller than y",
            "HasGoodDiet(x) ::: x has a good diet"
        ]
    },
    {
        "premises-NL": [
            "All doctors work at the hospital.",
            "Anyone who works at the hospital lives in the city.",
            "Everyone who lives in the city is a resident or owns an apartment.",
            "If someone is a resident, they have a car.",
            "If someone is a doctor, they have a degree.",
            "John is a doctor.",
            "If someone is employed, they have insurance.",
            "If someone has a car, they drive a car.",
            "John has a car.",
            "Everyone who has a degree is employed.",
            "If someone has insurance, they are a resident.",
            "If a doctor drives a car, they are a resident."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → WorksAtHospital(x)) ::: All doctors work at the hospital.",
            "∀x (WorksAtHospital(x) → LivesInCity(x)) ::: Anyone who works at the hospital lives in the city.",
            "∀x (LivesInCity(x) → Resident(x) ∨ OwnsApartment(x)) ::: Everyone who lives in the city is a resident or owns an apartment.",
            "∀x (Resident(x) → HasCar(x)) ::: If someone is a resident, they have a car.",
            "∀x (Doctor(x) → HasDegree(x)) ::: If someone is a doctor, they have a degree.",
            "Doctor(john) ::: John is a doctor.",
            "∀x (IsEmployed(x) → HasInsurance(x)) ::: If someone is employed, they have insurance.",
            "∀x (HasCar(x) → DrivesCar(x)) ::: If someone has a car, they drive a car.",
            "HasCar(john) ::: John has a car.",
            "∀x (HasDegree(x) → IsEmployed(x)) ::: Everyone who has a degree is employed.",
            "∀x (HasInsurance(x) → Resident(x)) ::: If someone has insurance, they are a resident.",
            "∀x (Doctor(x) ∧ DrivesCar(x) → Resident(x)) ::: If a doctor drives a car, they are a resident."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "HasCar(x) ::: x has a car",
            "Resident(x) ::: x is a resident",
            "LivesInCity(x) ::: x lives in the city",
            "WorksAtHospital(x) ::: x works at a hospital",
            "IsMarriedTo(x, y) ::: x is married to y",
            "OwnsApartment(x) ::: x owns an apartment",
            "IsRich(x) ::: x is rich",
            "HasInsurance(x) ::: x has insurance",
            "HasDegree(x) ::: x has a degree",
            "DrivesCar(x) ::: x drives a car",
            "IsEmployed(x) ::: x is employed"
        ]
    },
    {
        "premises-NL": [
            "Alice always attends lectures.",
            "If someone attends lectures and is smart, they study hard.",
            "If someone studies hard, they will pass the exam.",
            "Alice is smart.",
            "Anyone who is smart studies hard.",
            "Alice attends lectures."
        ],
        "premises-FOL": [
            "∀x (AttendsLectures(x) → StudiesHard(x)) ::: If someone attends lectures and is smart, they study hard.",
            "∀x (StudiesHard(x) → PassesExam(x)) ::: If someone studies hard, they will pass the exam.",
            "∀x (Smart(x) → StudiesHard(x)) ::: Anyone who is smart studies hard.",
            "AttendsLectures(alice) ::: Alice attends lectures.",
            "Smart(alice) ::: Alice is smart.",
            "∀x (AttendsLectures(x) → StudiesHard(x)) ::: If someone attends lectures, they study hard."
        ],
        "predicates": [
            "StudiesHard(x) ::: x studies hard",
            "AttendsLectures(x) ::: x attends lectures",
            "PassesExam(x) ::: x passes the exam",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "Everyone likes what they eat.",
            "John eats apples.",
            "If someone eats apples, they like apples.",
            "If someone eats bananas, they like bananas.",
            "John eats bananas.",
            "John is a person.",
            "Everyone who likes apples also likes bananas."
        ],
        "premises-FOL": [
            "∀x ∀y (Eats(x, y) → Likes(x, y)) ::: Everyone likes what they eat.",
            "Eats(john, apples) ::: John eats apples.",
            "∀x (Eats(x, apples) → Likes(x, apples)) ::: If someone eats apples, they like apples.",
            "∀x (Eats(x, bananas) → Likes(x, bananas)) ::: If someone eats bananas, they like bananas.",
            "Eats(john, bananas) ::: John eats bananas.",
            "Person(john) ::: John is a person.",
            "∀x (Likes(x, apples) → Likes(x, bananas)) ::: Everyone who likes apples also likes bananas."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Person(x) ::: x is a person",
            "Eats(x, y) ::: x eats y"
        ]
    },
    {
        "premises-NL": [
            "All students attend classes.",
            "Anyone who attends classes and is hardworking passes exams.",
            "If someone is intelligent, they are hardworking.",
            "Some students are intelligent.",
            "John is a student.",
            "If someone passes exams, they are hardworking.",
            "John attends classes.",
            "John is intelligent."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClasses(x)) ::: All students attend classes.",
            "∀x ((AttendsClasses(x) ∧ Hardworking(x)) → PassesExams(x)) ::: Anyone who attends classes and is hardworking passes exams.",
            "∀x (Intelligent(x) → Hardworking(x)) ::: If someone is intelligent, they are hardworking.",
            "∃x (Student(x) ∧ Intelligent(x)) ::: Some students are intelligent.",
            "Student(john) ::: John is a student.",
            "∀x (PassesExams(x) → Hardworking(x)) ::: If someone passes exams, they are hardworking.",
            "AttendsClasses(john) ::: John attends classes.",
            "Intelligent(john) ::: John is intelligent."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Intelligent(x) ::: x is intelligent",
            "Hardworking(x) ::: x is hardworking",
            "AttendsClasses(x) ::: x attends classes",
            "PassesExams(x) ::: x passes exams"
        ]
    },
    {
        "premises-NL": [
            "All doctors have a high income.",
            "Anyone with a high income either spends money or saves money.",
            "If someone is wealthy, they save money.",
            "Some doctors spend money.",
            "Some doctors are not wealthy.",
            "Anyone who has a high income is either wealthy or spends money.",
            "Some people with high incomes are not wealthy.",
            "All people who save money are wealthy.",
            "If someone doesn't save money, they spend money."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HasHighIncome(x)) ::: All doctors have a high income.",
            "∀x (HasHighIncome(x) → (SpendsMoney(x) ∨ SavesMoney(x))) ::: Anyone with a high income either spends money or saves money.",
            "∀x (Wealthy(x) → SavesMoney(x)) ::: If someone is wealthy, they save money.",
            "∃x (Doctor(x) ∧ SpendsMoney(x)) ::: Some doctors spend money.",
            "∀x (HasHighIncome(x) → (Wealthy(x) ∨ SpendsMoney(x))) ::: Anyone who has a high income is either wealthy or spends money.",
            "∃x (HasHighIncome(x) ∧ ¬Wealthy(x)) ::: Some people with high incomes are not wealthy.",
            "∀x (SavesMoney(x) → Wealthy(x)) ::: All people who save money are wealthy.",
            "∀x (¬SavesMoney(x) → SpendsMoney(x)) ::: If someone doesn't save money, they spend money.",
            "∃x (Doctor(x) ∧ ¬Wealthy(x)) ::: Some doctors are not wealthy."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Wealthy(x) ::: x is wealthy",
            "HasHighIncome(x) ::: x has a high income",
            "SpendsMoney(x) ::: x spends money",
            "SavesMoney(x) ::: x saves money"
        ]
    },
    {
        "premises-NL": [
            "All students are either smart or attend lectures.",
            "Alice is a student.",
            "If Alice is smart, then Alice studies hard.",
            "If Alice attends lectures, then Alice has good grades.",
            "If Alice has good grades, then Alice will pass the exam.",
            "Bob is a student.",
            "If Bob is smart then Bob will pass the exam.",
            "Bob studies hard.",
            "If Bob is smart, then Bob has good grades.",
            "If Bob has good grades, Bob will pass the exam.",
            "Bob attends lectures.",
            "Alice is not smart.",
            "Alice attends lectures."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Smart(x) ∨ AttendsLectures(x))) ::: All students are either smart or attend lectures",
            "Student(alice) ::: Alice is a student",
            "Smart(alice) → StudyHard(alice) ::: If Alice is smart, then Alice studies hard",
            "AttendsLectures(alice) → HasGoodGrades(alice) ::: If Alice attends lectures, then Alice has good grades",
            "HasGoodGrades(alice) → PassExam(alice) ::: If Alice has good grades, then Alice will pass the exam",
            "Student(bob) ::: Bob is a student",
            "Smart(bob) → PassExam(bob) ::: If Bob is smart then Bob will pass the exam",
            "StudyHard(bob) ::: Bob studies hard",
            "Smart(bob) → HasGoodGrades(bob) ::: If Bob is smart, then Bob has good grades",
            "HasGoodGrades(bob) → PassExam(bob) ::: If Bob has good grades, Bob will pass the exam",
            "AttendsLectures(bob) ::: Bob attends lectures",
            "¬Smart(alice) ::: Alice is not smart",
            "AttendsLectures(alice) ::: Alice attends lectures"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudyHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "Smart(x) ::: x is smart",
            "HasGoodGrades(x) ::: x has good grades",
            "AttendsLectures(x) ::: x attends lectures"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "Anyone who treats patients cares about health.",
            "Everyone who cares about health is likely healthy.",
            "A doctor who doesn't smoke is healthy.",
            "If someone is healthy, they live a long life.",
            "Alice is a doctor.",
            "Bob smokes.",
            "If Bob is a doctor and smokes then he is not healthy.",
            "If a doctor has high blood pressure, they are likely unhealthy.",
            "Charlie is a doctor who smokes.",
            "David is a patient with high blood pressure.",
            "Everyone who has high blood pressure is unhealthy.",
            "Doctors do not smoke.",
            "Doctors care about health."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → TreatsPatients(x)) ::: All doctors treat patients",
            "∀x (TreatsPatients(x) → CaresAboutHealth(x)) ::: Anyone who treats patients cares about health",
            "∀x (CaresAboutHealth(x) → Healthy(x)) ::: Everyone who cares about health is likely healthy",
            "∀x ((Doctor(x) ∧ ¬Smokes(x)) → Healthy(x)) ::: A doctor who doesn't smoke is healthy",
            "∀x (Healthy(x) → LongLife(x)) ::: If someone is healthy, they live a long life",
            "Doctor(alice) ::: Alice is a doctor",
            "Smokes(bob) ::: Bob smokes",
            "(Doctor(bob) ∧ Smokes(bob)) → ¬Healthy(bob) ::: If Bob is a doctor and smokes then he is not healthy",
            "(Doctor(x) ∧ HasHighBloodPressure(x)) → ¬Healthy(x) ::: If a doctor has high blood pressure, they are likely unhealthy",
            "(Doctor(charlie) ∧ Smokes(charlie)) ::: Charlie is a doctor who smokes",
            "Patient(david) ∧ HasHighBloodPressure(david) ::: David is a patient with high blood pressure",
            "∀x (HasHighBloodPressure(x) → ¬Healthy(x)) ::: Everyone who has high blood pressure is unhealthy",
            "∀x (Doctor(x) → ¬Smokes(x)) ::: Doctors do not smoke",
            "∀x (Doctor(x) → CaresAboutHealth(x)) ::: Doctors care about health"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Smokes(x) ::: x smokes",
            "LongLife(x) ::: x lives a long life",
            "Healthy(x) ::: x is healthy",
            "TreatsPatients(x) ::: x treats patients",
            "Patient(x) ::: x is a patient",
            "HasHighBloodPressure(x) ::: x has high blood pressure"
        ]
    },
    {
        "premises-NL": [
            "All popular products are either advertised or have high demand.",
            "If a product is advertised, then it is sold in stores.",
            "If a product has high demand, it is sold online.",
            "Product A is popular.",
            "Product B is advertised and liked by customers.",
            "Product C has high demand.",
            "If a product is popular, it is expensive.",
            "Product A is not expensive.",
            "Product B is popular.",
            "If a product is sold online, it is not expensive.",
            "Product C is sold online.",
            "If a product is sold in stores then it's advertised.",
            "If a product is liked by customers then it's sold online.",
            "Product D is liked by customers.",
            "Product D is popular."
        ],
        "premises-FOL": [
            "∀x (PopularProduct(x) → (Advertised(x) ∨ HighDemand(x))) ::: All popular products are either advertised or have high demand",
            "∀x (Advertised(x) → SoldInStores(x)) ::: If a product is advertised, then it is sold in stores",
            "∀x (HighDemand(x) → SoldOnline(x)) ::: If a product has high demand, it is sold online",
            "PopularProduct(productA) ::: Product A is popular",
            "Advertised(productB) ∧ CustomerLikes(productB) ::: Product B is advertised and liked by customers",
            "HighDemand(productC) ::: Product C has high demand",
            "∀x (PopularProduct(x) → Expensive(x)) ::: If a product is popular, it is expensive",
            "¬Expensive(productA) ::: Product A is not expensive",
            "PopularProduct(productB) ::: Product B is popular",
            "∀x (SoldOnline(x) → ¬Expensive(x)) ::: If a product is sold online, it is not expensive",
            "SoldOnline(productC) ::: Product C is sold online",
            "∀x (SoldInStores(x) → Advertised(x)) ::: If a product is sold in stores then it's advertised",
            "∀x (CustomerLikes(x) → SoldOnline(x)) ::: If a product is liked by customers then it's sold online",
            "CustomerLikes(productD) ::: Product D is liked by customers",
            "PopularProduct(productD) ::: Product D is popular"
        ],
        "predicates": [
            "PopularProduct(x) ::: x is a popular product",
            "SoldInStores(x) ::: x is sold in stores",
            "SoldOnline(x) ::: x is sold online",
            "Advertised(x) ::: x is advertised",
            "HighDemand(x) ::: x has high demand",
            "CustomerLikes(x) ::: x is liked by customers",
            "Expensive(x) ::: x is expensive"
        ]
    },
    {
        "premises-NL": [
            "All teachers either grade papers or write lectures.",
            "If someone grades papers, then they have an office.",
            "If someone writes lectures, they attend meetings.",
            "John is a teacher.",
            "If John has an office, then he teaches students.",
            "John writes lectures.",
            "If John attends meetings, then John is an author.",
            "If John is an author, he teaches students.",
            "All people that have an office are teachers.",
            "All people who attend meetings are teachers.",
            "If John is a teacher and grades papers then John is an author.",
            "If John is an author, he attends meetings.",
            "John has an office.",
            "If a teacher has an office, they teach students.",
            "If John teaches students, then John attends meetings.",
            "If someone grades papers, they write lectures."
        ],
        "premises-FOL": [
            "∀x (Teacher(x) → (GradesPapers(x) ∨ WritesLectures(x))) ::: All teachers either grade papers or write lectures",
            "∀x (GradesPapers(x) → HasOffice(x)) ::: If someone grades papers, then they have an office",
            "∀x (WritesLectures(x) → AttendsMeetings(x)) ::: If someone writes lectures, they attend meetings",
            "Teacher(john) ::: John is a teacher",
            "HasOffice(john) → TeachesStudents(john) ::: If John has an office, then he teaches students",
            "WritesLectures(john) ::: John writes lectures",
            "AttendsMeetings(john) → IsAuthor(john) ::: If John attends meetings, then John is an author",
            "IsAuthor(john) → TeachesStudents(john) ::: If John is an author, he teaches students",
            "∀x (HasOffice(x) → Teacher(x)) ::: All people that have an office are teachers",
            "∀x (AttendsMeetings(x) → Teacher(x)) ::: All people who attend meetings are teachers",
            "(Teacher(john) ∧ GradesPapers(john)) → IsAuthor(john) ::: If John is a teacher and grades papers then John is an author",
            "IsAuthor(john) → AttendsMeetings(john) ::: If John is an author, he attends meetings",
            "HasOffice(john) ::: John has an office",
            "(Teacher(x) ∧ HasOffice(x)) → TeachesStudents(x) ::: If a teacher has an office, they teach students",
            "TeachesStudents(john) → AttendsMeetings(john) ::: If John teaches students, then John attends meetings",
            "∀x (GradesPapers(x) → WritesLectures(x)) ::: If someone grades papers, they write lectures"
        ],
        "predicates": [
            "Teacher(x) ::: x is a teacher",
            "GradesPapers(x) ::: x grades papers",
            "TeachesStudents(x) ::: x teaches students",
            "WritesLectures(x) ::: x writes lectures",
            "HasOffice(x) ::: x has an office",
            "AttendsMeetings(x) ::: x attends meetings",
            "IsAuthor(x) ::: x is author"
        ]
    },
    {
        "premises-NL": [
            "All students take exams.",
            "Anyone who studies hard passes the exam.",
            "If someone passes the exam, then they are successful.",
            "Some students study hard.",
            "No students are lazy."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakesExam(x)) ::: For all x, if x is a student, then x takes an exam.",
            "∀x (StudiesHard(x) → PassesExam(x)) ::: For all x, if x studies hard, then x passes the exam.",
            "∀x (PassesExam(x) → Successful(x)) ::: For all x, if x passes the exam, then x is successful.",
            "∃x (Student(x) ∧ StudiesHard(x)) ::: There exists a student who studies hard.",
            "∀x (Student(x) → ¬Lazy(x)) ::: For all x, if x is a student, then x is not lazy."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "TakesExam(x) ::: x takes an exam",
            "PassesExam(x) ::: x passes an exam",
            "Successful(x) ::: x is successful"
        ]
    },
    {
        "premises-NL": [
            "All researchers have funding.",
            "Anyone who has funding conducts research.",
            "Anyone who conducts research publishes a paper.",
            "Some researchers work at a university.",
            "All researchers are smart.",
            "Anyone smart has a degree.",
            "Some people who have a degree are researchers.",
            "Research is expensive."
        ],
        "premises-FOL": [
            "∀x (Researcher(x) → HasFunding(x)) ::: For all x, if x is a researcher, then x has funding.",
            "∀x (HasFunding(x) → ConductsResearch(x)) ::: For all x, if x has funding, then x conducts research.",
            "∀x (ConductsResearch(x) → PublishesPaper(x)) ::: For all x, if x conducts research, then x publishes a paper.",
            "∃x (Researcher(x) ∧ WorksAtUniversity(x)) ::: There exists a researcher who works at a university.",
            "∀x (Researcher(x) → IsSmart(x)) ::: For all x, if x is a researcher, then x is smart.",
            "∀x (IsSmart(x) → HasDegree(x)) ::: For all x, if x is smart, then x has a degree.",
            "∃x (HasDegree(x) ∧ Researcher(x)) ::: There exists someone who has a degree and is a researcher.",
            "∀x (ConductsResearch(x) → Expensive(x)) ::: For all x, if x conducts research then it's expensive."
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher",
            "HasFunding(x) ::: x has funding",
            "ConductsResearch(x) ::: x conducts research",
            "PublishesPaper(x) ::: x publishes a paper",
            "WorksAtUniversity(x) ::: x works at a university",
            "IsSmart(x) ::: x is smart",
            "HasDegree(x) ::: x has a degree"
        ]
    },
    {
        "premises-NL": [
            "All athletes train hard.",
            "Anyone who trains hard enters a competition.",
            "Anyone who enters a competition either wins or loses.",
            "Some athletes are healthy.",
            "Anyone who is healthy and has good equipment wins the competition.",
            "No athlete is injured.",
            "Anyone who enjoys the sport is an athlete.",
            "All athletes have a coach.",
            "If someone has a coach, they train hard.",
            "Losing the competition is bad."
        ],
        "premises-FOL": [
            "∀x (Athlete(x) → TrainsHard(x)) ::: For all x, if x is an athlete, then x trains hard.",
            "∀x (TrainsHard(x) → EntersCompetition(x)) ::: For all x, if x trains hard, then x enters a competition.",
            "∀x (EntersCompetition(x) → (WinsCompetition(x) ∨ LosesCompetition(x))) ::: For all x, if x enters a competition, then x wins or loses.",
            "∃x (Athlete(x) ∧ IsHealthy(x)) ::: There exists an athlete who is healthy.",
            "∀x (IsHealthy(x) ∧ HasGoodEquipment(x) → WinsCompetition(x)) ::: For all x, if x is healthy and has good equipment, then x wins the competition.",
            "∀x (Athlete(x) → ¬IsInjured(x)) ::: For all x, if x is an athlete, then x is not injured.",
            "∀x (EnjoysSport(x) → Athlete(x)) ::: For all x, if x enjoys the sport, then x is an athlete.",
            "∀x (Athlete(x) → HasCoach(x)) ::: For all x, if x is an athlete, then x has a coach.",
            "∀x (HasCoach(x) → TrainsHard(x)) ::: For all x, if x has a coach, they train hard.",
            "∀x (LosesCompetition(x) → Bad(x)) ::: For all x, if x loses the competition, then it is bad."
        ],
        "predicates": [
            "Athlete(x) ::: x is an athlete",
            "TrainsHard(x) ::: x trains hard",
            "EntersCompetition(x) ::: x enters a competition",
            "WinsCompetition(x) ::: x wins a competition",
            "IsHealthy(x) ::: x is healthy",
            "HasGoodEquipment(x) ::: x has good equipment",
            "IsInjured(x) ::: x is injured",
            "EnjoysSport(x) ::: x enjoys the sport",
            "HasCoach(x) ::: x has a coach"
        ]
    },
    {
        "premises-NL": [
            "All managers have authority.",
            "Anyone with authority makes decisions.",
            "Some managers work in a company.",
            "Anyone who works in a company supervises employees.",
            "Supervising employees means you're a manager.",
            "Some managers are competent.",
            "All managers are experienced.",
            "Anyone who is experienced attends meetings.",
            "Anyone who attends meetings gives instructions.",
            "Anyone who gives instructions has authority.",
            "If someone is promoted, they are experienced.",
            "Some managers manage projects.",
            "Anyone who manages projects is busy.",
            "If someone is busy, then they attend meetings.",
            "Some employees are competent."
        ],
        "premises-FOL": [
            "∀x (Manager(x) → HasAuthority(x)) ::: For all x, if x is a manager, then x has authority.",
            "∀x (HasAuthority(x) → MakesDecision(x)) ::: For all x, if x has authority, then x makes a decision.",
            "∃x (Manager(x) ∧ WorksInCompany(x)) ::: There exists a manager who works in a company.",
            "∀x (WorksInCompany(x) → SupervisesEmployees(x)) ::: For all x, if x works in a company, then x supervises employees.",
            "∀x (SupervisesEmployees(x) → Manager(x)) ::: For all x, if x supervises employees, then x is a manager.",
            "∃x (Manager(x) ∧ IsCompetent(x)) ::: There exists a manager who is competent.",
            "∀x (Manager(x) → IsExperienced(x)) ::: For all x, if x is a manager, then x is experienced.",
            "∀x (IsExperienced(x) → AttendsMeetings(x)) ::: For all x, if x is experienced, then x attends meetings.",
            "∀x (AttendsMeetings(x) → GivesInstructions(x)) ::: For all x, if x attends meetings, then x gives instructions.",
            "∀x (GivesInstructions(x) → HasAuthority(x)) ::: For all x, if x gives instructions, then x has authority.",
            "∀x (GetsPromoted(x) → IsExperienced(x)) ::: For all x, if x gets promoted, then x is experienced.",
            "∃x (Manager(x) ∧ ManagesProjects(x)) ::: There exists a manager who manages projects.",
            "∀x (ManagesProjects(x) → IsBusy(x)) ::: For all x, if x manages projects, then x is busy.",
            "∀x (IsBusy(x) → AttendsMeetings(x)) ::: For all x, if x is busy, then x attends meetings.",
            "∃x (Employee(x) ∧ IsCompetent(x)) ::: There exists an employee who is competent."
        ],
        "predicates": [
            "Manager(x) ::: x is a manager",
            "HasAuthority(x) ::: x has authority",
            "ReportsTo(x, y) ::: x reports to y",
            "MakesDecision(x) ::: x makes a decision",
            "WorksInCompany(x) ::: x works in a company",
            "SupervisesEmployees(x) ::: x supervises employees",
            "IsCompetent(x) ::: x is competent",
            "IsExperienced(x) ::: x is experienced",
            "AttendsMeetings(x) ::: x attends meetings",
            "GivesInstructions(x) ::: x gives instructions",
            "GetsPromoted(x) ::: x gets promoted",
            "ManagesProjects(x) ::: x manages projects",
            "IsBusy(x) ::: x is busy"
        ]
    },
    {
        "premises-NL": [
            "If John is a member then John likes the event.",
            "Mary is a member.",
            "If someone is a member and attends the event, then they like the event.",
            "If Mary likes the event, then John does not attend the event.",
            "John is a member.",
            "If John likes the event, then he attends the event.",
            "If Mary attends the event, then she likes it.",
            "If John is a member, then he attends the event.",
            "Either Mary likes the event, or John does not like the event.",
            "If Mary attends the event then she is a member.",
            "If John does not attend the event, Mary likes the event.",
            "Mary attends the event.",
            "John likes the event or Mary likes it.",
            "If Mary does not like the event then John is not a member.",
            "John is a member and so is Mary.",
            "If John attends the event and Mary attends, then John and Mary like the event.",
            "If John is a member then he likes the event.",
            "If John is a member, then he likes it."
        ],
        "premises-FOL": [
            "Member(john) → Likes(john, event) ::: If John is a member then John likes the event.",
            "Member(mary) ::: Mary is a member.",
            "∀x (Member(x) ∧ Attends(x, event) → Likes(x, event)) ::: If someone is a member and attends the event, then they like the event.",
            "Likes(mary, event) → ¬Attends(john, event) ::: If Mary likes the event, then John does not attend the event.",
            "Member(john) ::: John is a member.",
            "Likes(john, event) → Attends(john, event) ::: If John likes the event, then he attends the event.",
            "Attends(mary, event) → Likes(mary, event) ::: If Mary attends the event, then she likes it.",
            "Member(john) → Attends(john, event) ::: If John is a member, then he attends the event.",
            "Likes(mary, event) ∨ ¬Likes(john, event) ::: Either Mary likes the event, or John does not like the event.",
            "Attends(mary, event) → Member(mary) ::: If Mary attends the event then she is a member.",
            "¬Attends(john, event) → Likes(mary, event) ::: If John does not attend the event, Mary likes the event.",
            "Attends(mary, event) ::: Mary attends the event.",
            "Likes(john, event) ∨ Likes(mary, event) ::: John likes the event or Mary likes it.",
            "¬Likes(mary, event) → ¬Member(john) ::: If Mary does not like the event then John is not a member.",
            "Member(john) ∧ Member(mary) ::: John is a member and so is Mary.",
            "∀x ∀y (Attends(john, event) ∧ Attends(mary, event) → (Likes(john, event) ∧ Likes(mary, event))) ::: If John attends the event and Mary attends, then John and Mary like the event.",
            "Member(john) → Likes(john, event) ::: If John is a member then he likes the event.",
            "Member(john) → Likes(john, event) ::: If John is a member, then he likes it."
        ],
        "predicates": [
            "Member(x) ::: Person x is a member.",
            "Likes(x, y) ::: Person x likes event y.",
            "Attends(x, y) ::: Person x attends event y."
        ]
    },
    {
        "premises-NL": [
            "All doctors are healthcare professionals.",
            "Sarah is a doctor.",
            "All doctors treat patients.",
            "Nurses are healthcare professionals.",
            "If someone is a nurse and treats a patient, then the patient is recovering.",
            "John is a patient.",
            "Sarah treats John.",
            "If someone treats a patient, they work in a hospital."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HealthcareProfessional(x)) ::: All doctors are healthcare professionals.",
            "Doctor(Sarah) ::: Sarah is a doctor.",
            "∀x ∀y (Doctor(x) ∧ Patient(y) → Treats(x, y)) ::: All doctors treat patients.",
            "∀x (Nurse(x) → HealthcareProfessional(x)) ::: Nurses are healthcare professionals.",
            "∀x ∀y (Nurse(x) ∧ Treats(x, y) → Recovering(y)) ::: If someone is a nurse and treats a patient, then the patient is recovering.",
            "Patient(John) ::: John is a patient.",
            "Treats(Sarah, John) ::: Sarah treats John.",
            "∀x ∀y (Treats(x, y) → WorksInHospital(x)) ::: If someone treats a patient, they work in a hospital."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient.",
            "Doctor(x) ::: x is a doctor.",
            "Nurse(x) ::: x is a nurse.",
            "Treats(x, y) ::: x treats y.",
            "HealthcareProfessional(x) ::: x is a healthcare professional.",
            "WorksInHospital(x) ::: x works in a hospital."
        ]
    },
    {
        "premises-NL": [
            "All artists are creative.",
            "Some creative people are musicians.",
            "If someone is an artist and a musician, they are also performers.",
            "Anyone who is a performer enjoys music.",
            "If someone enjoys music, they are happy.",
            "No unhappy people are artists."
        ],
        "premises-FOL": [
            "∀x (Artist(x) → Creative(x)) ::: For all x, if x is an artist, then x is creative.",
            "∃x (Creative(x) ∧ Musician(x)) ::: There exists an x such that x is creative and x is a musician.",
            "∀x (Artist(x) ∧ Musician(x) → Performer(x)) ::: For all x, if x is an artist and a musician, then x is a performer.",
            "∀x (Performer(x) → EnjoysMusic(x)) ::: For all x, if x is a performer, then x enjoys music.",
            "∀x (EnjoysMusic(x) → Happy(x)) ::: For all x, if x enjoys music, then x is happy.",
            "∀x (¬Happy(x) → ¬Artist(x)) ::: For all x, if x is not happy, then x is not an artist."
        ],
        "predicates": [
            "Artist(x) ::: x is an artist",
            "Creative(x) ::: x is creative",
            "Musician(x) ::: x is a musician"
        ]
    },
    {
        "premises-NL": [
            "All plants need sunlight.",
            "All plants need water.",
            "If a plant receives sunlight, it grows.",
            "If a plant receives water, it grows.",
            "Some plants are not trees.",
            "All plants that grow receive nutrients.",
            "No plant exists that both lacks sunlight and lacks water."
        ],
        "premises-FOL": [
            "∀x (Plant(x) → Sunlight(x)) ::: For all x, if x is a plant, then x receives sunlight.",
            "∀x (Plant(x) → Water(x)) ::: For all x, if x is a plant, then x receives water.",
            "∀x (Plant(x) ∧ Sunlight(x) → Grows(x)) ::: For all x, if x is a plant and receives sunlight, then x grows.",
            "∀x (Plant(x) ∧ Water(x) → Grows(x)) ::: For all x, if x is a plant and receives water, then x grows.",
            "∃x (Plant(x) ∧ ¬Tree(x)) ::: There exists an x such that x is a plant and is not a tree.",
            "∀x (Plant(x) ∧ Grows(x) → ReceivesNutrients(x)) ::: For all x, if x is a plant that grows, then it receives nutrients.",
            "¬∃x (Plant(x) ∧ ¬Sunlight(x) ∧ ¬Water(x)) ::: There does not exist a plant that does not receive sunlight and does not receive water."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "Sunlight(x) ::: x receives sunlight",
            "Water(x) ::: x receives water",
            "Grows(x) ::: x grows",
            "ReceivesNutrients(x) ::: x receives nutrients"
        ]
    },
    {
        "premises-NL": [
            "All herbivores are animals.",
            "All herbivores eat plants.",
            "No carnivores eat plants.",
            "Some animals are herbivores.",
            "Some animals are carnivores.",
            "Every animal eats something.",
            "If an animal eats only plants, then it is a herbivore.",
            "If an animal is herbivore then it eats only plants.",
            "Herbivores are animals.",
            "There exists a herbivore."
        ],
        "premises-FOL": [
            "∀x (Herbivore(x) → Animal(x)) ::: All herbivores are animals",
            "∀x ∀y (Herbivore(x) ∧ Plant(y) → Eats(x, y)) ::: All herbivores eat plants",
            "∀x ∀y (Carnivore(x) ∧ Plant(y) → ¬Eats(x, y)) ::: No carnivores eat plants",
            "∃x (Animal(x) ∧ Herbivore(x)) ::: Some animals are herbivores",
            "∃x (Animal(x) ∧ Carnivore(x)) ::: Some animals are carnivores",
            "∀x ∃y (Animal(x) → Eats(x, y)) ::: Every animal eats something",
            "∀x (EatsOnlyPlants(x) → Herbivore(x)) ::: If an animal eats only plants, then it is a herbivore",
            "∀x (Herbivore(x) → EatsOnlyPlants(x)) ::: If an animal is herbivore then it eats only plants.",
            "∀x (Herbivore(x) → Animal(x)) ::: Herbivores are animals",
            "∃x Herbivore(x) ::: There exists a herbivore"
        ],
        "predicates": [
            "Animal(x) ::: x is an animal",
            "Eats(x, y) ::: x eats y",
            "Plant(x) ::: x is a plant",
            "Herbivore(x) ::: x is a herbivore",
            "Carnivore(x) ::: x is a carnivore",
            "EatsOnlyPlants(x) ::: x eats only plants"
        ]
    },
    {
        "premises-NL": [
            "All students passed the exam.",
            "John is a student.",
            "If someone is a student, then they are enrolled.",
            "If someone is enrolled, they have access to resources.",
            "If someone has access to resources, they can study.",
            "If someone studies and is a student, they will pass the exam.",
            "John is enrolled.",
            "Only students are enrolled.",
            "No one is enrolled without access to resources.",
            "Only those who study will pass the exam.",
            "Some students are studying.",
            "No one can study without the right resources.",
            "If someone has the right resources they will study."
        ],
        "premises-FOL": [
            "∀x (Student(x) → PassedExam(x)) ::: All students passed the exam.",
            "Student(john) ::: John is a student.",
            "∀x (Student(x) → Enrolled(x)) ::: If someone is a student, then they are enrolled.",
            "∀x (Enrolled(x) → AccessResources(x)) ::: If someone is enrolled, they have access to resources.",
            "∀x (AccessResources(x) → CanStudy(x)) ::: If someone has access to resources, they can study.",
            "∀x (CanStudy(x) ∧ Student(x) → PassedExam(x)) ::: If someone studies and is a student, they will pass the exam.",
            "Enrolled(john) ::: John is enrolled.",
            "∀x (Enrolled(x) → Student(x)) ::: Only students are enrolled.",
            "∀x (¬Enrolled(x) ∨ AccessResources(x)) ::: No one is enrolled without access to resources.",
            "∀x (PassedExam(x) → CanStudy(x)) ::: Only those who study will pass the exam.",
            "∃x (Student(x) ∧ CanStudy(x)) ::: Some students are studying.",
            "∀x (¬CanStudy(x) ∨ AccessResources(x)) ::: No one can study without the right resources.",
            "∀x (AccessResources(x) → CanStudy(x)) ::: If someone has the right resources they will study."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PassedExam(x) ::: x passed the exam"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "Some doctors are healthcare professionals.",
            "Every surgeon treats patients.",
            "All healthcare professionals can treat patients.",
            "Every surgeon is a healthcare professional.",
            "Anyone who treats a patient is a healthcare professional."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∃x (Doctor(x) ∧ HealthcareProfessional(x)) ::: Some doctors are healthcare professionals.",
            "∀x ∀y (Surgeon(x) ∧ Patient(y) → TreatsPatients(x, y)) ::: Every surgeon treats patients.",
            "∀x ∀y (HealthcareProfessional(x) ∧ Patient(y) → TreatsPatients(x, y)) ::: All healthcare professionals can treat patients.",
            "∀x (Surgeon(x) → HealthcareProfessional(x)) ::: Every surgeon is a healthcare professional.",
            "∀x ∀y (TreatsPatients(x, y) → HealthcareProfessional(x)) ::: Anyone who treats a patient is a healthcare professional."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "HealthcareProfessional(x) ::: x is a healthcare professional",
            "TreatsPatients(x, y) ::: x treats y",
            "Patient(x) ::: x is a patient"
        ]
    },
    {
        "premises-NL": [
            "All mammals are animals.",
            "No birds are mammals.",
            "All birds have feathers.",
            "Anything that has fur is a mammal.",
            "All carnivores eat meat.",
            "All mammals don't eat meat or are carnivores.",
            "If it is an animal, it is a mammal or a bird."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → Animal(x)) ::: All mammals are animals.",
            "∀x (Bird(x) → ¬Mammal(x)) ::: No birds are mammals.",
            "∀x (Bird(x) → HasFeathers(x)) ::: All birds have feathers.",
            "∀x (HasFur(x) → Mammal(x)) ::: Anything that has fur is a mammal.",
            "∀x (Carnivore(x) → EatsMeat(x)) ::: All carnivores eat meat.",
            "∀x (Mammal(x) → (¬EatsMeat(x) ∨ Carnivore(x))) ::: All mammals don't eat meat or are carnivores.",
            "∀x (Animal(x) → (Mammal(x) ∨ Bird(x))) ::: If it is an animal, it is a mammal or a bird."
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal",
            "Bird(x) ::: x is a bird",
            "HasFeathers(x) ::: x has feathers",
            "HasFur(x) ::: x has fur",
            "Animal(x) ::: x is an animal",
            "EatsMeat(x) ::: x eats meat",
            "Carnivore(x) ::: x is a carnivore"
        ]
    },
    {
        "premises-NL": [
            "All programmers have computers.",
            "Anyone who has a computer uses software.",
            "All programmers are good at programming.",
            "If someone is good at programming, they write code.",
            "Anyone who uses software creates software.",
            "Every programmer uses software.",
            "If someone creates software, they write code.",
            "Every programmer is a programmer."
        ],
        "premises-FOL": [
            "∀x ∃y (Programmer(x) → HasComputer(x, y)) ::: All programmers have computers.",
            "∀x ∀y (HasComputer(x, y) → UsesSoftware(x, y)) ::: Anyone who has a computer uses software.",
            "∀x (Programmer(x) → GoodAtProgramming(x)) ::: All programmers are good at programming.",
            "∀x (GoodAtProgramming(x) → WritesCode(x)) ::: If someone is good at programming, they write code.",
            "∀x ∀y (UsesSoftware(x, y) → CreatesSoftware(x, y)) ::: Anyone who uses software creates software.",
            "∀x ∃y (Programmer(x) → UsesSoftware(x, y)) ::: Every programmer uses software.",
            "∀x ∀y (CreatesSoftware(x, y) → WritesCode(x)) ::: If someone creates software, they write code.",
            "∀x (Programmer(x) → Programmer(x)) ::: Every programmer is a programmer."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "HasComputer(x, y) ::: x has computer y",
            "WritesCode(x) ::: x writes code",
            "UsesSoftware(x, y) ::: x uses software y",
            "Software(x) ::: x is software",
            "CreatesSoftware(x, y) ::: x creates software y",
            "Computer(x) ::: x is a computer",
            "GoodAtProgramming(x) ::: x is good at programming"
        ]
    },
    {
        "premises-NL": [
            "Everyone who understands the material will pass the exam.",
            "If someone attends the lecture, they will understand the material.",
            "Sarah attends the lecture.",
            "Everyone is either a student or an instructor.",
            "If someone is a student, they will either attend the lecture or study."
        ],
        "premises-FOL": [
            "∀x (UnderstandsMaterial(x) → PassExam(x)) ::: Everyone who understands the material will pass the exam.",
            "∀x (AttendsLecture(x) → UnderstandsMaterial(x)) ::: If someone attends the lecture, they will understand the material.",
            "AttendsLecture(sarah) ::: Sarah attends the lecture.",
            "∀x (Student(x) ∨ Instructor(x)) ::: Everyone is either a student or an instructor.",
            "∀x (Student(x) → (AttendsLecture(x) ∨ Study(x))) ::: If someone is a student, they will either attend the lecture or study.",
            "∀x (Instructor(x) → ¬Study(x)) ::: If someone is an instructor, they will not study."
        ],
        "predicates": [
            "AttendsLecture(x) ::: x attends the lecture",
            "UnderstandsMaterial(x) ::: x understands the material",
            "PassExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "If the stock price increases, the company becomes profitable.",
            "If the company is profitable, the company will be successful.",
            "If there is high demand, the company becomes profitable.",
            "Either the stock price increases or there is high demand.",
            "If the stock price does not increase, but there is a high demand, people will invest.",
            "If people invest, the company becomes profitable.",
            "The company has not gone bankrupt.",
            "The company is on the market.",
            "If a company is on the market and has high demand then the company is not bankrupt."
        ],
        "premises-FOL": [
            "Increases(stockPrice) → Profitable(company) ::: If the stock price increases, the company becomes profitable.",
            "Profitable(company) → Successful(company) ::: If the company is profitable, the company will be successful.",
            "HighDemand(company) → Profitable(company) ::: If there is high demand, the company becomes profitable.",
            "Increases(stockPrice) ∨ HighDemand(company) ::: Either the stock price increases or there is high demand.",
            "¬Increases(stockPrice) ∧ HighDemand(company) → Invests(people, company) ::: If the stock price does not increase, but there is a high demand, people will invest.",
            "Invests(people, company) → Profitable(company) ::: If people invest, the company becomes profitable.",
            "¬Bankrupt(company) ::: The company has not gone bankrupt.",
            "OnMarket(company) ::: The company is on the market.",
            "OnMarket(company) ∧ HighDemand(company) → ¬Bankrupt(company) ::: If a company is on the market and has high demand then the company is not bankrupt."
        ],
        "predicates": [
            "Increases(x) ::: x increases",
            "Profitable(x) ::: x is profitable",
            "Successful(x) ::: x is successful",
            "Invests(x, y) ::: x invests in y",
            "HighDemand(x) ::: x has high demand"
        ]
    },
    {
        "premises-NL": [
            "All professors teach students.",
            "All students are enrolled in some course.",
            "Anyone who teaches is a teacher.",
            "Some people are professors.",
            "All courses have students."
        ],
        "premises-FOL": [
            "∀x ∀y (Professor(x) ∧ Student(y) ∧ Teach(x, y) ) ::: All professors teach students.",
            "∀x ∃y (Student(x) → Enrolled(x, y)) ::: All students are enrolled in some course.",
            "∀x (Teach(x, y) → Teacher(x)) ::: Anyone who teaches is a teacher.",
            "∃x Professor(x) ::: Some people are professors.",
            "∀x ∀y (Enrolled(x, y) → Student(x)) ::: All courses have students.",
            "∀x (Professor(x) → Teach(x, y)) ::: All professors teach",
            "∀x (Student(x) ∧ Teach(x, y)) ::: All students are enrolled in some course.",
            "∀x ∀y (Teacher(x) ∧ Student(y) → Teach(x, y)) ::: Anyone who teaches is a teacher."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "Teach(x, y) ::: x teaches y",
            "Student(x) ::: x is a student",
            "Teacher(x) ::: x is a teacher",
            "Enrolled(x, y) ::: x is enrolled in y"
        ]
    },
    {
        "premises-NL": [
            "All books are products.",
            "All books are sold online.",
            "All products sold online are available.",
            "Some books are expensive.",
            "Online stores sell all products.",
            "Products can be electronic.",
            "All products have a price.",
            "Some products are discounted.",
            "All books have authors.",
            "All books have reviews."
        ],
        "premises-FOL": [
            "∀x (Book(x) → Product(x)) ::: All books are products.",
            "∀x (Book(x) → SoldOnline(x)) ::: All books are sold online.",
            "∀x (SoldOnline(x) → Available(x)) ::: All products sold online are available.",
            "∃x (Book(x) ∧ Expensive(x)) ::: Some books are expensive.",
            "∀x (OnlineStore(x) → SoldOnline(x)) ::: Online stores sell all products.",
            "∃x Electronic(x) ::: Products can be electronic.",
            "∀x ∃y HasPrice(x, y) ::: All products have a price.",
            "∃x Discounted(x) ::: Some products are discounted.",
            "∀x ∃y (Book(x) → Authors(x, y)) ::: All books have authors.",
            "∀x ∃y (Book(x) → Reviews(x, y)) ::: All books have reviews.",
            "∀x (Book(x) ∧ SoldOnline(x) → Available(x)) ::: If a book is sold online, it is available."
        ],
        "predicates": [
            "SoldOnline(x) ::: x is sold online",
            "Book(x) ::: x is a book",
            "Available(x) ::: x is available",
            "Product(x) ::: x is a product",
            "Expensive(x) ::: x is expensive",
            "OnlineStore(x) ::: x is online store",
            "Electronic(x) ::: x is electronic",
            "HasPrice(x, y) ::: x has price y",
            "Discounted(x) ::: x is discounted",
            "Authors(x, y) ::: x is written by authors y",
            "Reviews(x, y) ::: x has reviews y"
        ]
    },
    {
        "premises-NL": [
            "All mammals are animals.",
            "Some mammals can fly.",
            "All reptiles are animals.",
            "No reptiles can fly.",
            "All animals live in some place.",
            "Some animals are carnivores.",
            "All birds have feathers.",
            "Reptiles have scales.",
            "Carnivores eat meat.",
            "All animals are either mammals, reptiles or birds.",
            "All animals are in the zoo.",
            "All protected species migrates."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → Animal(x)) ::: All mammals are animals.",
            "∃x (Mammal(x) ∧ CanFly(x)) ::: Some mammals can fly.",
            "∀x (Reptile(x) → Animal(x)) ::: All reptiles are animals.",
            "∀x (Reptile(x) → ¬ CanFly(x)) ::: No reptiles can fly.",
            "∀x ∃y LivesIn(x, y) ::: All animals live in some place.",
            "∃x IsCarnivore(x) ::: Some animals are carnivores.",
            "∀x (Bird(x) → HasFeathers(x)) ::: All birds have feathers.",
            "∀x (Reptile(x) → HasScales(x)) ::: Reptiles have scales.",
            "∀x ∀y (IsCarnivore(x) → Eats(x, y)) ::: Carnivores eat meat.",
            "∀x (Animal(x) → (Mammal(x) ∨ Reptile(x) ∨ Bird(x))) ::: All animals are either mammals, reptiles or birds.",
            "∀x InZoo(x) ::: All animals are in the zoo.",
            "∀x (ProtectedSpecies(x) → Migrates(x)) ::: All protected species migrates.",
            "∀x (Mammal(x) ∧ CanFly(x) → ¬ Reptile(x)) ::: If an animal is a mammal and can fly, then it is not a reptile."
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal",
            "CanFly(x) ::: x can fly",
            "Reptile(x) ::: x is a reptile",
            "Animal(x) ::: x is an animal",
            "LivesIn(x, y) ::: x lives in y",
            "IsCarnivore(x) ::: x is a carnivore",
            "HasFeathers(x) ::: x has feathers",
            "HasScales(x) ::: x has scales",
            "Eats(x, y) ::: x eats y",
            "InZoo(x) ::: x is in a zoo",
            "ProtectedSpecies(x) ::: x is a protected species",
            "Migrates(x) ::: x migrates"
        ]
    },
    {
        "premises-NL": [
            "All squares are rectangles.",
            "This shape is a square.",
            "All circles are round.",
            "All squares have sides.",
            "If something is a square, it is also blue.",
            "If something is a rectangle, it is also red.",
            "A square is a shape.",
            "If a shape is blue, it is also a square.",
            "If a shape is red, it is a rectangle.",
            "If something has sides, it is a square.",
            "If something is a circle, it is round."
        ],
        "premises-FOL": [
            "∀x (Square(x) → Rectangle(x)) ::: All squares are rectangles.",
            "Square(shape) ::: This shape is a square.",
            "∀x (Circle(x) → Round(x)) ::: All circles are round.",
            "∀x (Square(x) → HasSides(x)) ::: All squares have sides.",
            "∀x (Square(x) → IsBlue(x)) ::: If something is a square, it is also blue.",
            "∀x (Rectangle(x) → IsRed(x)) ::: If something is a rectangle, it is also red.",
            "Square(shape) ∨ Rectangle(shape) ∨ Circle(shape) ::: A square is a shape.",
            "∀x (IsBlue(x) → Square(x)) ::: If a shape is blue, it is also a square.",
            "∀x (IsRed(x) → Rectangle(x)) ::: If a shape is red, it is a rectangle.",
            "∀x (HasSides(x) → Square(x)) ::: If something has sides, it is a square.",
            "∀x (Circle(x) → Round(x)) ::: If something is a circle, it is round."
        ],
        "predicates": [
            "Square(x) ::: x is a square",
            "Rectangle(x) ::: x is a rectangle",
            "Circle(x) ::: x is a circle",
            "HasSides(x) ::: x has sides",
            "IsBlue(x) ::: x is blue",
            "IsRed(x) ::: x is red"
        ]
    },
    {
        "premises-NL": [
            "All athletes eat well.",
            "Anyone who eats well and exercises regularly is healthy.",
            "All healthy people are strong.",
            "Some athletes exercise regularly.",
            "Some people eat well.",
            "Some athletes are also people.",
            "Anyone who eats well is not unhealthy.",
            "Anyone who eats well is either strong or not strong.",
            "Every athlete is a person.",
            "Everyone who exercises is not unhealthy.",
            "Every healthy person is not unhealthy."
        ],
        "premises-FOL": [
            "∀x (Athlete(x) → EatsWell(x)) ::: All athletes eat well.",
            "∀x ((EatsWell(x) ∧ ExercisesRegularly(x)) → Healthy(x)) ::: Anyone who eats well and exercises regularly is healthy.",
            "∀x (Healthy(x) → Strong(x)) ::: All healthy people are strong.",
            "∃x (Athlete(x) ∧ ExercisesRegularly(x)) ::: Some athletes exercise regularly.",
            "∃x EatsWell(x) ::: Some people eat well.",
            "∃x (Athlete(x) ∧ Person(x)) ::: Some athletes are also people.",
            "∀x (EatsWell(x) → ¬Unhealthy(x)) ::: Anyone who eats well is not unhealthy.",
            "∀x (EatsWell(x) → Strong(x) ∨ ¬Strong(x)) ::: Anyone who eats well is either strong or not strong.",
            "∀x (Athlete(x) → Person(x)) ::: Every athlete is a person.",
            "∀x (ExercisesRegularly(x) → ¬Unhealthy(x)) ::: Everyone who exercises is not unhealthy.",
            "∀x (Healthy(x) → ¬Unhealthy(x)) ::: Every healthy person is not unhealthy."
        ],
        "predicates": [
            "Athlete(x) ::: x is an athlete",
            "EatsWell(x) ::: x eats well",
            "ExercisesRegularly(x) ::: x exercises regularly",
            "Healthy(x) ::: x is healthy",
            "Strong(x) ::: x is strong"
        ]
    },
    {
        "premises-NL": [
            "All students attend lectures.",
            "Anyone who studies hard and attends lectures understands the material.",
            "If someone understands the material, they will pass the exam.",
            "Some students study hard.",
            "All students either pass or fail the exam.",
            "Everyone that studies hard and attends lectures is also a student.",
            "Anyone who does not pass the exam fails the exam.",
            "If someone does not fail the exam, they will pass.",
            "Some students are hard workers.",
            "Some students study hard and attend lectures.",
            "Anyone who does not attend lectures, does not pass the exam.",
            "Anyone who does not attend lectures fails."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsLectures(x)) ::: All students attend lectures.",
            "∀x ((StudiesHard(x) ∧ AttendsLectures(x)) → UnderstandsMaterial(x)) ::: Anyone who studies hard and attends lectures understands the material.",
            "∀x (UnderstandsMaterial(x) → PassExam(x)) ::: If someone understands the material, they will pass the exam.",
            "∃x (Student(x) ∧ StudiesHard(x)) ::: Some students study hard.",
            "∀x (Student(x) → PassExam(x) ∨ FailExam(x)) ::: All students either pass or fail the exam.",
            "∀x ((StudiesHard(x) ∧ AttendsLectures(x)) → Student(x)) ::: Everyone that studies hard and attends lectures is also a student.",
            "∀x (¬PassExam(x) → FailExam(x)) ::: Anyone who does not pass the exam fails the exam.",
            "∀x (¬FailExam(x) → PassExam(x)) ::: If someone does not fail the exam, they will pass.",
            "∃x (Student(x) ∧ HardWorker(x)) ::: Some students are hard workers.",
            "∃x (Student(x) ∧ StudiesHard(x) ∧ AttendsLectures(x)) ::: Some students study hard and attend lectures.",
            "∀x (¬AttendsLectures(x) → ¬PassExam(x)) ::: Anyone who does not attend lectures, does not pass the exam.",
            "∀x (¬AttendsLectures(x) → FailExam(x)) ::: Anyone who does not attend lectures fails."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "AttendsLectures(x) ::: x attends lectures",
            "PassExam(x) ::: x passes the exam",
            "UnderstandsMaterial(x) ::: x understands the material"
        ]
    },
    {
        "premises-NL": [
            "All patients either have a fever or took medicine.",
            "Some patients do not have a fever.",
            "All patients are either sick or healthy.",
            "Some patients are not healthy.",
            "If a patient has a fever, they are sick.",
            "If a patient took medicine, they are healthy.",
            "Some sick patients are patients.",
            "Some healthy patients are patients.",
            "Patients are either sick or healthy."
        ],
        "premises-FOL": [
            "∀x (Patient(x) → (Fever(x) ∨ TookMedicine(x))) ::: For all x, if x is a patient, then x has a fever or took medicine.",
            "∃x (Patient(x) ∧ ¬Fever(x)) ::: There exists a patient who does not have a fever.",
            "∀x (Patient(x) → (Sick(x) ∨ Healthy(x))) ::: All patients are either sick or healthy.",
            "∃x (Patient(x) ∧ ¬Healthy(x)) ::: There exists a patient who is not healthy.",
            "∀x (Fever(x) → Sick(x)) ::: If x has a fever, then x is sick.",
            "∀x (TookMedicine(x) → Healthy(x)) ::: If x took medicine, then x is healthy.",
            "∃x (Sick(x) ∧ Patient(x)) ::: There exists someone who is sick and is a patient.",
            "∃x (Healthy(x) ∧ Patient(x)) ::: There exists someone who is healthy and is a patient.",
            "∀x (Patient(x) → (Sick(x) ∨ Healthy(x))) ::: If someone is a patient, that person is either sick or healthy."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient.",
            "Fever(x) ::: x has a fever.",
            "TookMedicine(x) ::: x took medicine."
        ]
    },
    {
        "premises-NL": [
            "All scientists are researchers.",
            "Some researchers study genetics.",
            "All researchers study either genetics or biology.",
            "Some scientists do not study biology.",
            "All scientists study either physics or biology.",
            "Some researchers study physics.",
            "If someone studies physics, they are not studying genetics.",
            "Some who studies biology is a scientist.",
            "All who study genetics are scientists.",
            "Some scientists study physics.",
            "No scientists study both genetics and physics."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Researcher(x)) ::: For all x, if x is a scientist, then x is a researcher.",
            "∃x (Researcher(x) ∧ StudiesGenetics(x)) ::: There exists a researcher who studies genetics.",
            "∀x (Researcher(x) → (StudiesGenetics(x) ∨ StudiesBiology(x))) :::  All researchers study either genetics or biology.",
            "∃x (Scientist(x) ∧ ¬StudiesBiology(x)) ::: There exists a scientist who does not study biology.",
            "∀x (Scientist(x) → (StudiesPhysics(x) ∨ StudiesBiology(x))) ::: All scientists study physics or biology.",
            "∃x (Researcher(x) ∧ StudiesPhysics(x)) :::  There exists a researcher who studies physics.",
            "∀x (StudiesPhysics(x) → ¬StudiesGenetics(x)) ::: If x studies physics, then x does not study genetics.",
            "∃x (StudiesBiology(x) ∧ Scientist(x)) ::: There exists someone who studies biology and is a scientist.",
            "∀x (StudiesGenetics(x) → Scientist(x)) ::: All who study genetics are scientists.",
            "∃x (Scientist(x) ∧ StudiesPhysics(x)) ::: There exists a scientist who studies physics.",
            "¬∃x (Scientist(x) ∧ StudiesGenetics(x) ∧ StudiesPhysics(x)) ::: There are no scientists who study both genetics and physics."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist.",
            "StudiesGenetics(x) ::: x studies genetics.",
            "StudiesBiology(x) ::: x studies biology.",
            "StudiesPhysics(x) ::: x studies physics.",
            "Researcher(x) ::: x is a researcher."
        ]
    },
    {
        "premises-NL": [
            "All doctors study medicine.",
            "Anyone who studies medicine is intelligent.",
            "All doctors are passionate about helping others.",
            "Anyone passionate about helping others is compassionate.",
            "John is a doctor.",
            "If someone is a doctor, they treat patients.",
            "Doctors must be intelligent."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → StudiesMedicine(x)) ::: All doctors study medicine.",
            "∀x (StudiesMedicine(x) → Intelligent(x)) ::: Anyone who studies medicine is intelligent.",
            "∀x (Doctor(x) → PassionateAboutHelping(x)) ::: All doctors are passionate about helping others.",
            "∀x (PassionateAboutHelping(x) → Compassionate(x)) ::: Anyone passionate about helping others is compassionate.",
            "Doctor(John) ::: John is a doctor.",
            "∀x (Doctor(x) → Treats(x, y)) ::: If someone is a doctor, they treat patients.",
            "∀x (Doctor(x) → Intelligent(x)) ::: Doctors must be intelligent."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Intelligent(x) ::: x is intelligent",
            "Compassionate(x) ::: x is compassionate",
            "StudiesMedicine(x) ::: x studies medicine",
            "PassionateAboutHelping(x) ::: x is passionate about helping others",
            "Patient(x) ::: x is a patient"
        ]
    },
    {
        "premises-NL": [
            "Alice is a person.",
            "Bob is a person.",
            "If someone likes both Alice and Bob, then they are friends.",
            "Someone likes both Alice and Bob.",
            "Alice likes Bob.",
            "Bob likes Alice.",
            "If someone likes someone, that person is a friend."
        ],
        "premises-FOL": [
            "Person(alice) ::: Alice is a person",
            "Person(bob) ::: Bob is a person",
            "∀x (Likes(x, alice) ∧ Likes(x, bob) → Friends(alice, bob)) ::: If someone likes both Alice and Bob, then they are friends.",
            "∃x (Likes(x, alice) ∧ Likes(x, bob)) ::: Someone likes both Alice and Bob.",
            "Likes(alice, bob) ::: Alice likes Bob.",
            "Likes(bob, alice) ::: Bob likes Alice.",
            "∀x ∀y (Likes(x, y) → Friends(x, y)) ::: If someone likes someone, that person is a friend."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Likes(x, y) ::: x likes y",
            "Friends(x, y) ::: x and y are friends"
        ]
    },
    {
        "premises-NL": [
            "All cats are animals.",
            "Every cat has fur.",
            "All cats eat meat.",
            "All cats are felines.",
            "All cats are domesticated.",
            "All felines are mammals.",
            "All mammals are warm-blooded.",
            "Some animals are cats.",
            "If something is a cat, then it likes milk.",
            "If someone is a cat, it lives in a house."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → Animal(x)) ::: All cats are animals.",
            "∀x (Cat(x) → HasFur(x)) ::: Every cat has fur.",
            "∀x (Cat(x) → EatsMeat(x)) ::: All cats eat meat.",
            "∀x (Cat(x) → IsFeline(x)) ::: All cats are felines.",
            "∀x (Cat(x) → IsDomesticated(x)) ::: All cats are domesticated.",
            "∀x (IsFeline(x) → Mammal(x)) ::: All felines are mammals.",
            "∀x (Mammal(x) → WarmBlooded(x)) ::: All mammals are warm-blooded.",
            "∃x Cat(x) ::: Some animals are cats.",
            "∀x (Cat(x) → LikesMilk(x)) ::: If something is a cat, then it likes milk.",
            "∀x (Cat(x) → LivesInHouse(x)) ::: If someone is a cat, it lives in a house."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Mammal(x) ::: x is a mammal",
            "WarmBlooded(x) ::: x is warm-blooded",
            "Animal(x) ::: x is an animal",
            "HasFur(x) ::: x has fur",
            "EatsMeat(x) ::: x eats meat",
            "IsFeline(x) ::: x is a feline",
            "IsDomesticated(x) ::: x is domesticated",
            "LikesMilk(x) ::: x likes milk",
            "LivesInHouse(x) ::: x lives in a house"
        ]
    },
    {
        "premises-NL": [
            "All doctors study medicine.",
            "If someone studies a disease, they know about it.",
            "If a doctor knows about a disease, they can treat it.",
            "John is a doctor.",
            "If someone is a patient, then they are sick.",
            "If someone has a disease, they have symptoms.",
            "If someone is a specialist, then that person is doctor.",
            "If someone studies a disease, then the person is specialist in it.",
            "If someone has symptoms, the person is sick.",
            "If John is a doctor, John understands the disease.",
            "If John understands the disease, then he knows about it."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Studies(x, medicine)) ::: All doctors study medicine.",
            "∀x ∀y (Studies(x, y) → KnowsAbout(x, y)) ::: If someone studies a disease, they know about it.",
            "∀x ∀y (Doctor(x) ∧ KnowsAbout(x, y) → CanTreat(x, y)) ::: If a doctor knows about a disease, they can treat it.",
            "Doctor(john) ::: John is a doctor.",
            "∀x (Patient(x) → IsSick(x)) ::: If someone is a patient, then they are sick.",
            "∀x ∀y (HasDisease(x, y) → HasSymptoms(x, y)) ::: If someone has a disease, they have symptoms.",
            "∀x ∀y (IsSpecialist(x, y) → Doctor(x)) ::: If someone is a specialist, then that person is doctor.",
            "∀x ∀y (Studies(x, y) → IsSpecialist(x, y)) ::: If someone studies a disease, then the person is specialist in it.",
            "∀x ∀y (HasSymptoms(x, y) → IsSick(x)) ::: If someone has symptoms, the person is sick.",
            "∀x (Doctor(john) → Understands(john, x)) ::: If John is a doctor, John understands the disease.",
            "∀x (Understands(john, x) → KnowsAbout(john, x)) ::: If John understands the disease, then he knows about it."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "KnowsAbout(x, y) ::: x knows about disease y",
            "CanTreat(x, y) ::: x can treat disease y",
            "Patient(x) ::: x is a patient",
            "HasDisease(x, y) ::: x has disease y",
            "Studies(x, y) ::: x studies y",
            "IsSick(x) ::: x is sick",
            "HasSymptoms(x, y) ::: x has symptoms y",
            "Cures(x, y) ::: x cures y",
            "Understands(x, y) ::: x understands y",
            "IsSpecialist(x, y) ::: x is specialist in y"
        ]
    },
    {
        "premises-NL": [
            "All students take either Math or Physics.",
            "No student takes only Physics.",
            "x is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (TakesMath(x) ∨ TakesPhysics(x))) ::: All students take either Math or Physics.",
            "¬∃x (Student(x) ∧ ¬TakesMath(x) ∧ TakesPhysics(x)) ::: No student takes only Physics.",
            "Student(john) ::: John is a student.",
            "Student(mary) ::: Mary is a student.",
            "Student(tom) ::: Tom is a student.",
            "Student(sara) ::: Sara is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "TakesMath(x) ::: x takes Math",
            "TakesPhysics(x) ::: x takes Physics"
        ]
    },
    {
        "premises-NL": [
            "All professors have a PhD.",
            "Every professor teaches at the University.",
            "John is a professor.",
            "If John is a professor, then John has a PhD",
            "If John is a professor, then John teaches at the University.",
            "John teaches at the University.",
            "If someone has a PhD, then someone is a professor."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → HasPhD(x)) ::: All professors have a PhD.",
            "∀x (Professor(x) → TeachesAt(x, University)) ::: Every professor teaches at the University.",
            "Professor(john) ::: John is a professor.",
            "∀x (Professor(x) → HasPhD(x)) ::: If John is a professor, then John has a PhD.",
            "∀x (Professor(x) → TeachesAt(x, University)) ::: If John is a professor, then John teaches at the University.",
            "TeachesAt(john, University) ::: John teaches at the University.",
            "∀x (HasPhD(x) → Professor(x)) ::: If someone has a PhD, then someone is a professor.",
            "HasPhD(john) ::: John has a PhD."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "HasPhD(x) ::: x has a PhD",
            "TeachesAt(x, y) ::: x teaches at y",
            "University(x) ::: x is the University"
        ]
    },
    {
        "premises-NL": [
            "All cats chase mice.",
            "Garfield is a cat.",
            "If something is a cat, it chases mice.",
            "If something is a cat, then it is a mammal.",
            "If something is a mammal, it breathes.",
            "If something chases mice, it has paws.",
            "If something is a cat and chases mice, then the thing has paws.",
            "There is a mouse."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → Chases(x, mice)) ::: All cats chase mice.",
            "Cat(garfield) ::: Garfield is a cat.",
            "∀x (Cat(x) → Chases(x, mice)) ::: If something is a cat, it chases mice.",
            "∀x (Cat(x) → Mammal(x)) ::: If something is a cat, then it is a mammal.",
            "∀x (Mammal(x) → Breathes(x)) ::: If something is a mammal, it breathes.",
            "∀x ∀y (Chases(x, y) → HasPaws(x)) ::: If something chases mice, it has paws.",
            "∀x (Cat(x) ∧ Chases(x, mice) → HasPaws(x)) ::: If something is a cat and chases mice, then the thing has paws.",
            "∃x Mouse(x) ::: There is a mouse.",
            "Chases(garfield, mice) ::: Garfield chases mice."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Chases(x, y) ::: x chases y",
            "Mouse(x) ::: x is a mouse"
        ]
    },
    {
        "premises-NL": [
            "All programmers use either Python or Java.",
            "Someone uses Java.",
            "Someone does not use Java.",
            "If someone does not use Python, then they use Java.",
            "If someone uses Java, then they use Python.",
            "If a programmer uses Python, they are an expert.",
            "If a programmer uses Python, then they use Java.",
            "John is a programmer.",
            "John uses Python.",
            "Mary uses Java."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → (UsesPython(x) ∨ UsesJava(x))) ::: All programmers use either Python or Java.",
            "∃x UsesJava(x) ::: Someone uses Java.",
            "∃x ¬UsesJava(x) ::: Someone does not use Java.",
            "∀x (¬UsesPython(x) → UsesJava(x)) ::: If someone does not use Python, then they use Java.",
            "∀x (UsesJava(x) → UsesPython(x)) ::: If someone uses Java, then they use Python.",
            "∀x (Programmer(x) ∧ UsesPython(x) → Expert(x)) ::: If a programmer uses Python, they are an expert.",
            "∀x (Programmer(x) ∧ UsesPython(x) → UsesJava(x)) ::: If a programmer uses Python, then they use Java.",
            "Programmer(john) ::: John is a programmer.",
            "UsesPython(john) ::: John uses Python.",
            "UsesJava(mary) ::: Mary uses Java."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "UsesPython(x) ::: x uses Python",
            "UsesJava(x) ::: x uses Java"
        ]
    },
    {
        "premises-NL": [
            "All doctors are employed.",
            "John is a doctor.",
            "If someone is a doctor then they are employed and vice versa.",
            "John is a doctor"
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Employed(x)) ::: All doctors are employed",
            "Doctor(john) ::: John is a doctor",
            "∀x (Doctor(x) ↔ Employed(x)) ::: If someone is a doctor then they are employed and vice versa",
            "Doctor(john) ::: John is a doctor"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Employed(x) ::: x is employed"
        ]
    },
    {
        "premises-NL": [
            "All researchers study biology or physics.",
            "Some researchers use microscopes.",
            "Anyone who studies biology is a researcher.",
            "If someone is a researcher and uses a microscope, they studies biology",
            "If someone studies physics, they do not use microscopes."
        ],
        "premises-FOL": [
            "∀x (Researcher(x) → (StudiesBiology(x) ∨ StudiesPhysics(x))) ::: All researchers study biology or physics.",
            "∃x (Researcher(x) ∧ MicroscopeUser(x)) ::: Some researchers use microscopes.",
            "∀x (StudiesBiology(x) → Researcher(x)) ::: Anyone who studies biology is a researcher.",
            "∀x ((Researcher(x) ∧ MicroscopeUser(x)) → StudiesBiology(x)) ::: If someone is a researcher and uses a microscope, they studies biology",
            "∀x (StudiesPhysics(x) → ¬MicroscopeUser(x)) ::: If someone studies physics, they do not use microscopes."
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher",
            "StudiesBiology(x) ::: x studies biology",
            "MicroscopeUser(x) ::: x uses a microscope"
        ]
    },
    {
        "premises-NL": [
            "All cats are either playful or chase mice.",
            "Some cats are not playful.",
            "All things that chase mice are cats.",
            "If something chases mice, then it is a cat.",
            "Everything is either a cat, or not a cat."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → (Playful(x) ∨ ChasesMice(x))) ::: All cats are either playful or chase mice.",
            "∃x (Cat(x) ∧ ¬Playful(x)) ::: Some cats are not playful.",
            "∀x (ChasesMice(x) → Cat(x)) ::: All things that chase mice are cats.",
            "∀x (ChasesMice(x) → Cat(x)) ::: If something chases mice, then it is a cat.",
            "∀x (Cat(x) ∨ ¬Cat(x)) ::: Everything is either a cat, or not a cat."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Playful(x) ::: x is playful",
            "ChasesMice(x) ::: x chases mice"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "Some doctors are not surgeons.",
            "Anyone who performs surgery is a surgeon.",
            "Doctors specialize in medicine or surgery.",
            "Surgeons specialize in surgery.",
            "If x is a doctor and not a surgeon, then x does not specialize in surgery."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∃x (Doctor(x) ∧ ¬Surgeon(x)) ::: Some doctors are not surgeons.",
            "∀x (PerformsSurgery(x) → Surgeon(x)) ::: Anyone who performs surgery is a surgeon.",
            "∀x (Doctor(x) → (SpecializesIn(x, Medicine) ∨ SpecializesIn(x, Surgery))) ::: Doctors specialize in medicine or surgery.",
            "∀x (Surgeon(x) → SpecializesIn(x, Surgery)) ::: Surgeons specialize in surgery.",
            "∀x (Doctor(x) ∧ ¬Surgeon(x) → ¬SpecializesIn(x, Surgery)) ::: If x is a doctor and not a surgeon, then x does not specialize in surgery."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "PerformsSurgery(x) ::: x performs surgery",
            "SpecializesIn(x, y) ::: x specializes in y",
            "IsA(x, y) ::: x is a y"
        ]
    },
    {
        "premises-NL": [
            "All computer science students take courses.",
            "A student takes a course if and only if they study it.",
            "Anyone who studies math or physics does not study both.",
            "If someone studies math or physics, then they take a course.",
            "No computer science student studies physics.",
            "All Computer Science students have degrees in computer science.",
            "Some students do not study both math and physics."
        ],
        "premises-FOL": [
            "∀x (ComputerScienceStudent(x) → TakesCourse(x, z)) ::: All computer science students take courses.",
            "∀x ∀y (TakesCourse(x, y) ↔ Studies(x, y)) ::: A student takes a course if and only if they study it.",
            "∀x (Studies(x, Math) ∨ Studies(x, Physics) → ¬(Studies(x, Math) ∧ Studies(x, Physics))) ::: Anyone who studies math or physics does not study both.",
            "∀x ((Studies(x, Math) ∨ Studies(x, Physics)) → TakesCourse(x, z)) ::: If someone studies math or physics, then they take a course.",
            "∀x (ComputerScienceStudent(x) → ¬Studies(x, Physics)) ::: No computer science student studies physics.",
            "∀x (ComputerScienceStudent(x) → HasDegree(x, ComputerScience)) ::: All Computer Science students have degrees in computer science.",
            "∃x (¬(Studies(x, Math) ∧ Studies(x, Physics))) ::: Some students do not study both math and physics."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "ComputerScienceStudent(x) ::: x is a computer science student",
            "Studies(x, y) ::: x studies y",
            "Math(x) ::: x is math",
            "Physics(x) ::: x is physics",
            "TakesCourse(x, y) ::: x takes course y",
            "HasDegree(x, y) ::: x has a degree in y"
        ]
    },
    {
        "premises-NL": [
            "Anyone who has a disease needs medication.",
            "Anyone who needs medication should get treatment.",
            "If someone is healthy, they don't need medication.",
            "If someone is sick, they need medication.",
            "Anyone who gets treatment takes medicine.",
            "Everyone who has symptoms has a disease.",
            "Anyone who is contagious should be isolated.",
            "If someone is isolated, they avoid contact.",
            "If someone is vaccinated, they won't get sick.",
            "If someone can spread a disease, they should be isolated.",
            "Anyone who has pain is sick.",
            "Anyone who feels weak has a disease.",
            "If someone is sick, they will get better.",
            "If someone gets better, they do not have the disease.",
            "If someone has a disease they should get treatment."
        ],
        "premises-FOL": [
            "∀x (HasDisease(x) → NeedsMedication(x)) ::: Anyone who has a disease needs medication.",
            "∀x (NeedsMedication(x) → ShouldGetTreatment(x)) ::: Anyone who needs medication should get treatment.",
            "∀x (IsHealthy(x) → ¬NeedsMedication(x)) ::: If someone is healthy, they don't need medication.",
            "∀x (IsSick(x) → NeedsMedication(x)) ::: If someone is sick, they need medication.",
            "∀x (ShouldGetTreatment(x) → TakesMedicine(x)) ::: Anyone who gets treatment takes medicine.",
            "∀x (HasSymptoms(x) → HasDisease(x)) ::: Everyone who has symptoms has a disease.",
            "∀x (IsContagious(x) → IsIsolated(x)) ::: Anyone who is contagious should be isolated.",
            "∀x ∀y (IsIsolated(x) → AvoidsContact(x, y)) ::: If someone is isolated, they avoid contact.",
            "∀x (IsVaccinated(x) → ¬IsSick(x)) ::: If someone is vaccinated, they won't get sick.",
            "∀x (CanSpreadDisease(x) → IsIsolated(x)) ::: If someone can spread a disease, they should be isolated.",
            "∀x (HasPain(x) → IsSick(x)) ::: Anyone who has pain is sick.",
            "∀x (FeelsWeak(x) → HasDisease(x)) ::: Anyone who feels weak has a disease.",
            "∀x (IsSick(x) → GetsBetter(x)) ::: If someone is sick, they will get better.",
            "∀x (GetsBetter(x) → ¬HasDisease(x)) ::: If someone gets better, they do not have the disease.",
            "∀x (HasDisease(x) → ShouldGetTreatment(x)) ::: If someone has a disease they should get treatment."
        ],
        "predicates": [
            "HasDisease(x) ::: x has a disease",
            "NeedsMedication(x) ::: x needs medication",
            "IsHealthy(x) ::: x is healthy",
            "IsSick(x) ::: x is sick",
            "ShouldGetTreatment(x) ::: x should get treatment",
            "TakesMedicine(x) ::: x takes medicine",
            "HasSymptoms(x) ::: x has symptoms",
            "IsContagious(x) ::: x is contagious",
            "IsIsolated(x) ::: x is isolated",
            "IsVaccinated(x) ::: x is vaccinated",
            "CanSpreadDisease(x) ::: x can spread disease",
            "AvoidsContact(x, y) ::: x avoids contact with y",
            "HasPain(x) ::: x has pain",
            "FeelsWeak(x) ::: x feels weak",
            "GetsBetter(x) ::: x gets better"
        ]
    },
    {
        "premises-NL": [
            "All researchers study a field.",
            "If a researcher studies a field, they write papers about the field.",
            "If a researcher needs funding, they will receive funding if they are awarded an award.",
            "If a researcher is funded, they publish papers.",
            "Researchers often collaborate with each other.",
            "If a paper is cited, then it is peer-reviewed.",
            "If a paper is innovative, it is cited.",
            "If a paper is published, then it is cited.",
            "If a researcher attends a conference, they are awarded an award.",
            "Researchers who study a field attend seminars.",
            "Researchers who study a field attend conferences.",
            "If someone wins an award, then they are awarded an award.",
            "If a paper is peer-reviewed, then it contributes to science.",
            "If a researcher writes a paper, then he publishes the paper.",
            "If a researcher is awarded an award, they contribute to the advancement of science.",
            "If someone publishes a paper, they write a paper."
        ],
        "premises-FOL": [
            "∀x ∃y (Researcher(x) → StudiesField(x, y)) ::: All researchers study a field.",
            "∀x ∀y (Researcher(x) ∧ StudiesField(x, y) → WritesPaper(x)) ::: If a researcher studies a field, they write papers about the field.",
            "∀x (Researcher(x) ∧ NeedsFunding(x) ∧ WinsAward(x) → IsFunded(x)) ::: If a researcher needs funding, they will receive funding if they are awarded an award.",
            "∀x (Researcher(x) ∧ IsFunded(x) → PublishesPaper(x)) ::: If a researcher is funded, they publish papers.",
            "∀x ∃y CollaboratesWith(x, y) ::: Researchers often collaborate with each other.",
            "∀x ∀y (CitesPaper(x, y) → IsPeerReviewed(y)) ::: If a paper is cited, then it is peer-reviewed.",
            "∀x (IsInnovative(x) → CitesPaper(x, y)) ::: If a paper is innovative, it is cited.",
            "∀x (PublishesPaper(x) → IsCited(x)) ::: If a paper is published, then it is cited.",
            "∀x (Researcher(x) ∧ AttendsConference(x) → IsAwarded(x)) ::: If a researcher attends a conference, they are awarded an award.",
            "∀x (Researcher(x) ∧ StudiesField(x, y) → AttendsSeminar(x)) ::: Researchers who study a field attend seminars.",
            "∀x (Researcher(x) ∧ StudiesField(x, y) → AttendsConference(x)) ::: Researchers who study a field attend conferences.",
            "∀x (WinsAward(x) → IsAwarded(x)) ::: If someone wins an award, then they are awarded an award.",
            "∀x (IsPeerReviewed(x) → ContributesToScience(x)) ::: If a paper is peer-reviewed, then it contributes to science.",
            "∀x (Researcher(x) ∧ WritesPaper(x) → PublishesPaper(x)) ::: If a researcher writes a paper, then he publishes the paper.",
            "∀x (Researcher(x) ∧ IsAwarded(x) → ContributesToScience(x)) ::: If a researcher is awarded an award, they contribute to the advancement of science.",
            "∀x (PublishesPaper(x) → WritesPaper(x)) ::: If someone publishes a paper, they write a paper."
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher",
            "PublishesPaper(x) ::: x publishes a paper",
            "ContributesToScience(x) ::: x contributes to science",
            "StudiesField(x, y) ::: x studies field y",
            "GrantsFunding(x, y) ::: x grants funding to y",
            "NeedsFunding(x) ::: x needs funding",
            "IsFunded(x) ::: x is funded",
            "CollaboratesWith(x, y) ::: x collaborates with y",
            "CitesPaper(x, y) ::: x cites paper y",
            "IsPeerReviewed(x) ::: x is peer reviewed",
            "IsInnovative(x) ::: x is innovative",
            "IsCited(x) ::: x is cited",
            "WritesPaper(x) ::: x writes a paper",
            "AttendsConference(x) ::: x attends a conference",
            "IsAwarded(x) ::: x is awarded",
            "WinsAward(x) ::: x wins an award",
            "AttendsSeminar(x) ::: x attends a seminar"
        ]
    },
    {
        "premises-NL": [
            "All people own something.",
            "Everyone who owns a car needs a driver's license.",
            "If someone owns something and that thing is a car, then they can drive the car.",
            "A car can be driven if and only if the driver has a license.",
            "If someone owns a car, it means it's registered to them.",
            "There is a car.",
            "Not all car owners have driver's licenses.",
            "If something is a car, then it is a vehicle.",
            "If you own a car and you do not have a license, it is illegal to drive."
        ],
        "premises-FOL": [
            "∀x ∃y Owns(x, y) ::: All people own something.",
            "∀x ∀y (Owns(x, y) ∧ Car(y) → HasLicense(x)) ::: Everyone who owns a car needs a driver's license.",
            "∀x ∀y (Owns(x, y) ∧ Car(y) → CanDrive(x, y)) ::: If someone owns something and that thing is a car, then they can drive the car.",
            "∀x ∀y (CanDrive(x, y) ↔ HasLicense(x)) ::: A car can be driven if and only if the driver has a license.",
            "∀x ∀y (Owns(x, y) ∧ Car(y) → IsRegistered(y, x)) ::: If someone owns a car, it means it's registered to them.",
            "∃x Car(x) ::: There is a car.",
            "∃x (Owns(x, car1) ∧ ¬HasLicense(x)) ::: Not all car owners have driver's licenses.",
            "∀x (Car(x) → Vehicle(x)) ::: If something is a car, then it is a vehicle.",
            "∀x ∀y ((Owns(x, y) ∧ Car(y)) ∧ ¬HasLicense(x) → ¬Legal(x, drive)) ::: If you own a car and you do not have a license, it is illegal to drive."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Owns(x, y) ::: x owns y",
            "Car(x) ::: x is a car",
            "HasLicense(x) ::: x has a driver's license",
            "CanDrive(x, y) ::: x can drive y",
            "IsRegistered(y, z) ::: y is registered to z",
            "Legal(x, y) ::: x is legal to do y"
        ]
    },
    {
        "premises-NL": [
            "Anyone who studies hard and attends lectures is prepared.",
            "If someone is prepared, then they will pass the exam.",
            "Alice attends lectures.",
            "If someone gets good grades, then they will pass the exam.",
            "Studying hard implies getting good grades or attending lectures.",
            "Alice studies hard.",
            "If a student is prepared, they will study hard.",
            "Getting good grades always implies passing the exam.",
            "If someone studies hard, they will be prepared or get good grades.",
            "Alice is prepared.",
            "If a student studies hard, they will either pass the exam or attend lectures."
        ],
        "premises-FOL": [
            "∀x ((StudyHard(x) ∧ AttendsLectures(x)) → Prepared(x)) ::: Anyone who studies hard and attends lectures is prepared.",
            "∀x (Prepared(x) → PassExam(x)) ::: If someone is prepared, then they will pass the exam.",
            "AttendsLectures(alice) ::: Alice attends lectures.",
            "∀x (GetsGoodGrades(x) → PassExam(x)) ::: If someone gets good grades, then they will pass the exam.",
            "∀x (StudyHard(x) → (GetsGoodGrades(x) ∨ AttendsLectures(x))) ::: Studying hard implies getting good grades or attending lectures.",
            "StudyHard(alice) ::: Alice studies hard.",
            "∀x (Prepared(x) → StudyHard(x)) ::: If a student is prepared, they will study hard.",
            "∀x (GetsGoodGrades(x) → PassExam(x)) ::: Getting good grades always implies passing the exam.",
            "∀x (StudyHard(x) → (Prepared(x) ∨ GetsGoodGrades(x))) ::: If someone studies hard, they will be prepared or get good grades.",
            "Prepared(alice) ::: Alice is prepared.",
            "∀x (StudyHard(x) → (PassExam(x) ∨ AttendsLectures(x))) ::: If a student studies hard, they will either pass the exam or attend lectures."
        ],
        "predicates": [
            "StudyHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "AttendsLectures(x) ::: x attends lectures",
            "GetsGoodGrades(x) ::: x gets good grades",
            "Prepared(x) ::: x is prepared"
        ]
    },
    {
        "premises-NL": [
            "If someone likes another, they are not friends if the second person hates the first.",
            "If John likes Mary, then they have a mutual friendship or Mary hates John.",
            "If someone has a mutual friendship, then they like each other.",
            "If John and Mary are friends, they like each other.",
            "If someone hates someone, then they don't have mutual friendship.",
            "If two people like each other, then they are friends or have mutual friendship.",
            "John knows Mary.",
            "If John likes Mary, Mary hates John or Mary knows John.",
            "If John likes Mary, then Mary doesn't know John.",
            "If Mary knows John, they are friends.",
            "If John and Mary are friends, then they are friends.",
            "If someone has mutual friendship, then they are friends or like each other.",
            "If someone hates another, then they don't like each other."
        ],
        "premises-FOL": [
            "∀x ∀y (Likes(x, y) → ¬(Friends(x, y) ∧ Hates(y, x))) ::: If someone likes another, they are not friends if the second person hates the first.",
            "Likes(john, mary) → (MutualFriendship(john, mary) ∨ Hates(mary, john)) ::: If John likes Mary, then they have a mutual friendship or Mary hates John.",
            "∀x ∀y (MutualFriendship(x, y) → Likes(x, y)) ::: If someone has a mutual friendship, then they like each other.",
            "∀x ∀y (Friends(x, y) → Likes(x, y)) ::: If John and Mary are friends, they like each other.",
            "∀x ∀y (Hates(x, y) → ¬MutualFriendship(x, y)) ::: If someone hates someone, then they don't have mutual friendship.",
            "∀x ∀y (Likes(x, y) ∧ Likes(y, x) → (Friends(x, y) ∨ MutualFriendship(x, y))) ::: If two people like each other, then they are friends or have mutual friendship.",
            "Knows(john, mary) ::: John knows Mary.",
            "Likes(john, mary) → (Hates(mary, john) ∨ Knows(mary, john)) ::: If John likes Mary, Mary hates John or Mary knows John.",
            "Likes(john, mary) → ¬Knows(mary, john) ::: If John likes Mary, then Mary doesn't know John.",
            "∀x ∀y (Knows(x, y) → Friends(x, y)) ::: If Mary knows John, they are friends.",
            "∀x ∀y (Friends(x, y) → Friends(x, y)) ::: If John and Mary are friends, then they are friends.",
            "∀x ∀y (MutualFriendship(x, y) → (Friends(x, y) ∨ Likes(x, y))) ::: If someone has mutual friendship, then they are friends or like each other.",
            "∀x ∀y (Hates(x, y) → ¬Likes(x, y)) ::: If someone hates another, then they don't like each other."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Hates(x, y) ::: x hates y",
            "Friends(x, y) ::: x and y are friends",
            "Knows(x, y) ::: x knows y",
            "MutualFriendship(x, y) ::: x and y have mutual friendship"
        ]
    },
    {
        "premises-NL": [
            "All students study hard.",
            "If someone studies hard and knows the professor, they will pass the exam.",
            "If someone passes the exam, they will get a good grade.",
            "Some students know the professor.",
            "John is a student.",
            "John knows the professor.",
            "If John knows the professor and studies hard he will pass the exam.",
            "If John passes the exam then John will get a good grade."
        ],
        "premises-FOL": [
            "∀x (Student(x) → StudyHard(x)) ::: All students study hard.",
            "(StudyHard(x) ∧ KnowsProfessor(x)) → PassExam(x) ::: If someone studies hard and knows the professor, they will pass the exam.",
            "∀x (PassExam(x) → GoodGrade(x)) ::: If someone passes the exam, they will get a good grade.",
            "∃x (Student(x) ∧ KnowsProfessor(x)) ::: Some students know the professor.",
            "Student(john) ::: John is a student.",
            "KnowsProfessor(john) ::: John knows the professor.",
            "(StudyHard(john) ∧ KnowsProfessor(john)) → PassExam(john) ::: If John knows the professor and studies hard he will pass the exam.",
            "PassExam(john) → GoodGrade(john) ::: If John passes the exam then John will get a good grade."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudyHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "GoodGrade(x) ::: x gets a good grade",
            "KnowsProfessor(x) ::: x knows the professor"
        ]
    },
    {
        "premises-NL": [
            "All surgeons perform surgery.",
            "All doctors who specialize in surgery are surgeons.",
            "If someone has a medical license and attends a hospital, they are a doctor.",
            "If someone performs surgery, they are a doctor.",
            "John specializes in surgery.",
            "John has a medical license.",
            "John attends a hospital.",
            "All doctors who attends hospitals are doctors.",
            "If someone is a surgeon then they perform surgery."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → PerformsSurgery(x)) ::: All surgeons perform surgery.",
            "∀x (Doctor(x) ∧ SpecializesInSurgery(x) → Surgeon(x)) ::: All doctors who specialize in surgery are surgeons.",
            "∀x (HasMedicalLicense(x) ∧ AttendsHospital(x) → Doctor(x)) ::: If someone has a medical license and attends a hospital, they are a doctor.",
            "∀x (PerformsSurgery(x) → Doctor(x)) ::: If someone performs surgery, they are a doctor.",
            "SpecializesInSurgery(john) ::: John specializes in surgery.",
            "HasMedicalLicense(john) ::: John has a medical license.",
            "AttendsHospital(john) ::: John attends a hospital.",
            "∀x (AttendsHospital(x) → Doctor(x)) ::: All doctors who attends hospitals are doctors.",
            "∀x (Surgeon(x) → PerformsSurgery(x)) ::: If someone is a surgeon then they perform surgery."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "SpecializesInSurgery(x) ::: x specializes in surgery",
            "Surgeon(x) ::: x is a surgeon",
            "PerformsSurgery(x) ::: x performs surgery",
            "HasMedicalLicense(x) ::: x has a medical license",
            "AttendsHospital(x) ::: x attends hospital"
        ]
    },
    {
        "premises-NL": [
            "John owns a car.",
            "The car John owns is red.",
            "If someone owns a car and the car is red, then the person has a red car.",
            "All Fords are cars.",
            "All red cars are expensive.",
            "John owns a fast car.",
            "If something is a Ford, then it's a car.",
            "If John owns a car and the car is expensive, then John is rich.",
            "If John owns a blue car, then John is happy.",
            "If John owns a Ford then John owns a car."
        ],
        "premises-FOL": [
            "∃y (Owns(john, y) ∧ Car(y)) ::: John owns a car.",
            "∃y (Owns(john, y) ∧ Red(y)) ::: The car John owns is red.",
            "∀x ∀y (Owns(x, y) ∧ Car(y) ∧ Red(y) → HasRedCar(x)) ::: If someone owns a car and the car is red, then the person has a red car.",
            "∀x (Ford(x) → Car(x)) ::: All Fords are cars.",
            "∀x (Red(x) ∧ Car(x) → Expensive(x)) ::: All red cars are expensive.",
            "∃y (Owns(john, y) ∧ Fast(y)) ::: John owns a fast car.",
            "∀x (Ford(x) → Car(x)) ::: If something is a Ford, then it's a car.",
            "∀x ∀y (Owns(x, y) ∧ Car(y) ∧ Expensive(y) → Rich(x)) ::: If John owns a car and the car is expensive, then John is rich.",
            "∀x ∀y (Owns(x, y) ∧ Car(y) ∧ Blue(y) → Happy(x)) ::: If John owns a blue car, then John is happy.",
            "∀x ∀y (Owns(john, x) ∧ Ford(x) → Car(x)) ::: If John owns a Ford then John owns a car."
        ],
        "predicates": [
            "Owns(x, y) ::: x owns y",
            "Car(x) ::: x is a car",
            "Red(x) ::: x is red",
            "HasRedCar(x) ::: x has a red car",
            "Person(x) ::: x is a person",
            "Blue(x) ::: x is blue",
            "Expensive(x) ::: x is expensive",
            "Fast(x) ::: x is fast",
            "Ford(x) ::: x is a Ford"
        ]
    },
    {
        "premises-NL": [
            "All students who attend lectures and study hard will pass the exam.",
            "If someone studies hard and passes the exam, they get a good grade.",
            "John is a student.",
            "John attends all lectures.",
            "If John studies hard, he will pass the exam.",
            "If someone passes the exam, they get a good grade.",
            "John studies hard.",
            "If John attends lectures and studies hard, he will pass the exam.",
            "If John passes exam and sleeps enough he will pass the exam.",
            "John likes coffee.",
            "John eats healthy."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ AttendsLectures(x) ∧ StudyHard(x) → PassExam(x)) ::: All students who attend lectures and study hard will pass the exam.",
            "∀x (StudyHard(x) ∧ PassExam(x) → GoodGrade(x)) ::: If someone studies hard and passes the exam, they get a good grade.",
            "Student(john) ::: John is a student.",
            "AttendsLectures(john) ::: John attends all lectures.",
            "StudyHard(john) → PassExam(john) ::: If John studies hard, he will pass the exam.",
            "∀x (PassExam(x) → GoodGrade(x)) ::: If someone passes the exam, they get a good grade.",
            "StudyHard(john) ::: John studies hard.",
            "(AttendsLectures(john) ∧ StudyHard(john)) → PassExam(john) ::: If John attends lectures and studies hard, he will pass the exam.",
            "(PassExam(john) ∧ SleepsEnough(john)) → GoodGrade(john) ::: If John passes exam and sleeps enough he will pass the exam.",
            "LikesCoffee(john) ::: John likes coffee.",
            "EatsHealthy(john) ::: John eats healthy."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsLectures(x) ::: x attends all lectures",
            "StudyHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "LikesCoffee(x) ::: x likes coffee",
            "KnowsProfessor(x) ::: x knows the professor",
            "SleepsEnough(x) ::: x sleeps enough",
            "EatsHealthy(x) ::: x eats healthy"
        ]
    },
    {
        "premises-NL": [
            "John is a person.",
            "John is a member of the chess club.",
            "The chess club is a club.",
            "If a person is a member of a club and attends all meetings, they are considered an active member.",
            "If someone is an active member, they pay dues.",
            "John attends all meetings.",
            "If someone is an active member they like social events.",
            "If someone pays dues they know the president.",
            "If someone participates in social events and likes social events then they know the president.",
            "If someone is an active member and volunteers, they are considered.",
            "John pays dues.",
            "John likes social events.",
            "John volunteers."
        ],
        "premises-FOL": [
            "Person(john) ::: John is a person.",
            "MemberOf(john, chessClub) ::: John is a member of the chess club.",
            "Club(chessClub) ::: The chess club is a club.",
            "∀x ∀y (Person(x) ∧ MemberOf(x, y) ∧ AttendsMeetings(x) ∧ PaysDues(x) → ActiveMember(x)) ::: If a person is a member of a club and attends all meetings, they are considered an active member.",
            "∀x (ActiveMember(x) → PaysDues(x)) ::: If someone is an active member, they pay dues.",
            "AttendsMeetings(john) ::: John attends all meetings.",
            "∀x (ActiveMember(x) → LikesSocialEvents(x)) ::: If someone is an active member they like social events.",
            "∀x (PaysDues(x) → KnowsPresident(x)) ::: If someone pays dues they know the president.",
            "∀x ∀y (Participates(x, y) ∧ LikesSocialEvents(x) → KnowsPresident(x)) ::: If someone participates in social events and likes social events then they know the president.",
            "∀x (ActiveMember(x) ∧ Volunteers(x) → Considered(x)) ::: If someone is an active member and volunteers, they are considered.",
            "PaysDues(john) ::: John pays dues.",
            "LikesSocialEvents(john) ::: John likes social events.",
            "Volunteers(john) ::: John volunteers."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "MemberOf(x, y) ::: x is a member of club y",
            "AttendsMeetings(x) ::: x attends all meetings",
            "PaysDues(x) ::: x pays dues",
            "ActiveMember(x) ::: x is an active member",
            "LikesSocialEvents(x) ::: x likes social events",
            "OrganizesEvents(x) ::: x organizes events",
            "Club(y) ::: y is a club",
            "Volunteers(x) ::: x volunteers",
            "KnowsPresident(x) ::: x knows the president",
            "HasRole(x, y) ::: x has role y",
            "Participates(x, y) ::: x participates in y"
        ]
    },
    {
        "premises-NL": [
            "All doctors are skilled.",
            "Some skilled people are wealthy.",
            "Anyone who is both a doctor and skilled is also a good doctor.",
            "Anyone who is wealthy enjoys their job.",
            "Not all doctors are not wealthy.",
            "Some skilled people are not doctors.",
            "If someone is a doctor they have a degree.",
            "If someone is wealthy they also contribute to society.",
            "All doctors are either wealthy or they have a degree.",
            "If someone is skilled and has a degree, they are a doctor.",
            "Some doctors are not good doctors."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Skilled(x)) ::: All doctors are skilled.",
            "∃x (Skilled(x) ∧ Wealthy(x)) ::: Some skilled people are wealthy.",
            "∀x ((Doctor(x) ∧ Skilled(x)) → GoodDoctor(x)) ::: Anyone who is both a doctor and skilled is also a good doctor.",
            "∀x (Wealthy(x) → EnjoyJob(x)) ::: Anyone who is wealthy enjoys their job.",
            "¬∀x (Doctor(x) → ¬Wealthy(x)) ::: Not all doctors are not wealthy.",
            "∃x (Skilled(x) ∧ ¬Doctor(x)) ::: Some skilled people are not doctors.",
            "∀x (Doctor(x) → HasDegree(x)) ::: If someone is a doctor they have a degree.",
            "∀x (Wealthy(x) → ContributesToSociety(x)) ::: If someone is wealthy they also contribute to society.",
            "∀x (Doctor(x) → (Wealthy(x) ∨ HasDegree(x))) ::: All doctors are either wealthy or they have a degree.",
            "∀x ((Skilled(x) ∧ HasDegree(x)) → Doctor(x)) ::: If someone is skilled and has a degree, they are a doctor.",
            "∃x (Doctor(x) ∧ ¬GoodDoctor(x)) ::: Some doctors are not good doctors."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Skilled(x) ::: x is skilled",
            "Wealthy(x) ::: x is wealthy"
        ]
    },
    {
        "premises-NL": [
            "All artists are creative.",
            "Some creative people paint.",
            "Anyone who is both an artist and creative creates masterpieces.",
            "Anyone who paints uses brushes.",
            "If someone is an artist, they have a talent.",
            "If someone is creative, they have an imagination.",
            "All artists are either painters or they teach.",
            "Some painters are not artists.",
            "If someone is creative and has an imagination, they are an artist.",
            "If someone is an artist, they love art.",
            "Some creative people are not artists.",
            "Everyone who teaches is an artist."
        ],
        "premises-FOL": [
            "∀x (Artist(x) → Creative(x)) ::: All artists are creative.",
            "∃x (Creative(x) ∧ Paints(x)) ::: Some creative people paint.",
            "∀x ((Artist(x) ∧ Creative(x)) → CreatesMasterpieces(x)) ::: Anyone who is both an artist and creative creates masterpieces.",
            "∀x (Paints(x) → UsesBrushes(x)) ::: Anyone who paints uses brushes.",
            "∀x (Artist(x) → HasTalent(x)) ::: If someone is an artist, they have a talent.",
            "∀x (Creative(x) → HasImagination(x)) ::: If someone is creative, they have an imagination.",
            "∀x (Artist(x) → (Paints(x) ∨ Teaches(x))) ::: All artists are either painters or they teach.",
            "∃x (Paints(x) ∧ ¬Artist(x)) ::: Some painters are not artists.",
            "∀x ((Creative(x) ∧ HasImagination(x)) → Artist(x)) ::: If someone is creative and has an imagination, they are an artist.",
            "∀x (Artist(x) → LovesArt(x)) ::: If someone is an artist, they love art.",
            "∃x (Creative(x) ∧ ¬Artist(x)) ::: Some creative people are not artists.",
            "∀x (Teaches(x) → Artist(x)) ::: Everyone who teaches is an artist."
        ],
        "predicates": [
            "Artist(x) ::: x is an artist",
            "Creative(x) ::: x is creative",
            "Paints(x) ::: x paints"
        ]
    },
    {
        "premises-NL": [
            "All scientists are curious.",
            "Some curious people read books.",
            "Anyone who is both a scientist and curious conducts experiments.",
            "Anyone who reads books gains knowledge.",
            "If someone is a scientist, they have a degree.",
            "If someone is curious, they ask questions.",
            "All scientists are either readers or they teach.",
            "Some readers are not scientists.",
            "If someone is curious and asks questions, they are a scientist.",
            "If someone is a scientist, they love science.",
            "Some curious people are not scientists.",
            "Everyone who teaches is a scientist.",
            "If someone reads books, they gain knowledge."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Curious(x)) ::: All scientists are curious.",
            "∃x (Curious(x) ∧ ReadsBooks(x)) ::: Some curious people read books.",
            "∀x ((Scientist(x) ∧ Curious(x)) → ConductsExperiments(x)) ::: Anyone who is both a scientist and curious conducts experiments.",
            "∀x (ReadsBooks(x) → GainsKnowledge(x)) ::: Anyone who reads books gains knowledge.",
            "∀x (Scientist(x) → HasDegree(x)) ::: If someone is a scientist, they have a degree.",
            "∀x (Curious(x) → AsksQuestions(x)) ::: If someone is curious, they ask questions.",
            "∀x (Scientist(x) → (ReadsBooks(x) ∨ Teaches(x))) ::: All scientists are either readers or they teach.",
            "∃x (ReadsBooks(x) ∧ ¬Scientist(x)) ::: Some readers are not scientists.",
            "∀x ((Curious(x) ∧ AsksQuestions(x)) → Scientist(x)) ::: If someone is curious and asks questions, they are a scientist.",
            "∀x (Scientist(x) → LovesScience(x)) ::: If someone is a scientist, they love science.",
            "∃x (Curious(x) ∧ ¬Scientist(x)) ::: Some curious people are not scientists.",
            "∀x (Teaches(x) → Scientist(x)) ::: Everyone who teaches is a scientist.",
            "∀x (ReadsBooks(x) → GainsKnowledge(x)) ::: If someone reads books, they gain knowledge."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Curious(x) ::: x is curious",
            "ReadsBooks(x) ::: x reads books"
        ]
    },
    {
        "premises-NL": [
            "All programmers write code.",
            "Some code writers are employed.",
            "Anyone who is both a programmer and writes code creates software.",
            "Anyone who is employed earns money.",
            "If someone is a programmer, they have skills.",
            "If someone writes code, they have knowledge.",
            "All programmers are either employed or they are freelancers.",
            "Some employed people are not programmers.",
            "If someone writes code and has knowledge, they are a programmer.",
            "If someone is a programmer, they enjoy programming.",
            "Some writers are not programmers.",
            "Everyone who is a freelancer is a programmer.",
            "Anyone who writes code has knowledge of programming.",
            "If someone is employed, they are contributing to a project."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → WritesCode(x)) ::: All programmers write code.",
            "∃x (WritesCode(x) ∧ Employed(x)) ::: Some code writers are employed.",
            "∀x ((Programmer(x) ∧ WritesCode(x)) → CreatesSoftware(x)) ::: Anyone who is both a programmer and writes code creates software.",
            "∀x (Employed(x) → EarnsMoney(x)) ::: Anyone who is employed earns money.",
            "∀x (Programmer(x) → HasSkills(x)) ::: If someone is a programmer, they have skills.",
            "∀x (WritesCode(x) → HasKnowledge(x)) ::: If someone writes code, they have knowledge.",
            "∀x (Programmer(x) → (Employed(x) ∨ Freelancer(x))) ::: All programmers are either employed or they are freelancers.",
            "∃x (Employed(x) ∧ ¬Programmer(x)) ::: Some employed people are not programmers.",
            "∀x ((WritesCode(x) ∧ HasKnowledge(x)) → Programmer(x)) ::: If someone writes code and has knowledge, they are a programmer.",
            "∀x (Programmer(x) → EnjoysProgramming(x)) ::: If someone is a programmer, they enjoy programming.",
            "∃x (WritesCode(x) ∧ ¬Programmer(x)) ::: Some writers are not programmers.",
            "∀x (Freelancer(x) → Programmer(x)) ::: Everyone who is a freelancer is a programmer.",
            "∀x (WritesCode(x) → HasProgrammingKnowledge(x)) ::: Anyone who writes code has knowledge of programming.",
            "∀x (Employed(x) → ContributesToProject(x)) ::: If someone is employed, they are contributing to a project."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "WritesCode(x) ::: x writes code",
            "Employed(x) ::: x is employed"
        ]
    },
    {
        "premises-NL": [
            "All mammals are warm-blooded.",
            "Some mammals eat meat.",
            "Some animals that eat meat live in a forest.",
            "Some animals live in a forest are not mammals.",
            "If something is a mammal, then it's not a reptile.",
            "If something eats meat, then it is an animal.",
            "If something lives in a forest, then it is an animal.",
            "All reptiles are cold-blooded.",
            "No animal is both a mammal and a reptile.",
            "A certain animal is a mammal.",
            "If something is warm-blooded, it is an animal.",
            "Some animals are reptiles.",
            "Some animals eat meat and live in a forest.",
            "Something is both warm-blooded and eats meat.",
            "If an animal is cold-blooded, it does not eat meat.",
            "Something lives in a forest is an animal."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → WarmBlooded(x)) ::: All mammals are warm-blooded.",
            "∃x (Mammal(x) ∧ EatsMeat(x)) ::: Some mammals eat meat.",
            "∃x (EatsMeat(x) ∧ LivesInForest(x)) ::: Some animals that eat meat live in a forest.",
            "∃x (LivesInForest(x) ∧ ¬Mammal(x)) ::: Some animals live in a forest are not mammals.",
            "∀x (Mammal(x) → ¬Reptile(x)) ::: If something is a mammal, then it's not a reptile.",
            "∀x (EatsMeat(x) → Animal(x)) ::: If something eats meat, then it is an animal.",
            "∀x (LivesInForest(x) → Animal(x)) ::: If something lives in a forest, then it is an animal.",
            "∀x (Reptile(x) → ColdBlooded(x)) ::: All reptiles are cold-blooded.",
            "∀x ¬(Mammal(x) ∧ Reptile(x)) ::: No animal is both a mammal and a reptile.",
            "Mammal(a) ::: A certain animal is a mammal.",
            "∀x (WarmBlooded(x) → Animal(x)) ::: If something is warm-blooded, it is an animal.",
            "∃x (Animal(x) ∧ Reptile(x)) ::: Some animals are reptiles.",
            "∃x (EatsMeat(x) ∧ LivesInForest(x)) ::: Some animals eat meat and live in a forest.",
            "∃x (WarmBlooded(x) ∧ EatsMeat(x)) ::: Something is both warm-blooded and eats meat.",
            "∀x (ColdBlooded(x) → ¬EatsMeat(x)) ::: If an animal is cold-blooded, it does not eat meat.",
            "∃x (LivesInForest(x) ∧ Animal(x)) ::: Something lives in a forest is an animal."
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal.",
            "WarmBlooded(x) ::: x is warm-blooded.",
            "EatsMeat(x) ::: x eats meat.",
            "LivesInForest(x) ::: x lives in a forest."
        ]
    },
    {
        "premises-NL": [
            "All whales are mammals.",
            "All dolphins are mammals.",
            "All whales swim.",
            "All dolphins swim.",
            "All whales live in water.",
            "Dolphins live in water.",
            "A whale is an aquatic animal.",
            "A dolphin is an aquatic animal.",
            "Whales are mammals."
        ],
        "premises-FOL": [
            "∀x (Whale(x) → Mammal(x)) ::: All whales are mammals.",
            "∀x (Dolphin(x) → Mammal(x)) ::: All dolphins are mammals.",
            "∀x (Whale(x) → Swims(x)) ::: All whales swim.",
            "∀x (Dolphin(x) → Swims(x)) ::: All dolphins swim.",
            "∀x (Whale(x) → LivesInWater(x)) ::: All whales live in water.",
            "∀x (Dolphin(x) → LivesInWater(x)) ::: Dolphins live in water.",
            "∀x (Whale(x) → Aquatic(x)) ::: A whale is an aquatic animal.",
            "∀x (Dolphin(x) → Aquatic(x)) ::: A dolphin is an aquatic animal.",
            "∀x (Whale(x) → Mammal(x)) ::: Whales are mammals.",
            "∃x Dolphin(x) ::: There is a dolphin.",
            "∃x Whale(x) ::: There is a whale."
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal",
            "Swims(x) ::: x swims",
            "LivesInWater(x) ::: x lives in water",
            "Aquatic(x) ::: x is aquatic",
            "Whale(x) ::: x is a whale",
            "Dolphin(x) ::: x is a dolphin"
        ]
    },
    {
        "premises-NL": [
            "All researchers are invited.",
            "Anyone invited to the conference attends.",
            "Some people work for a company.",
            "Anyone who works for a company is a researcher.",
            "The conference invited some people."
        ],
        "premises-FOL": [
            "∀x (Researcher(x) → Invited(x, conference)) ::: All researchers are invited",
            "∀x (Invited(x, conference) → AttendsConference(x)) ::: Anyone invited to the conference attends",
            "∃x ∃y WorksFor(x, y) ::: Some people work for a company",
            "∀x ∀y (WorksFor(x, y) → Researcher(x)) ::: Anyone who works for a company is a researcher",
            "∃x Invited(x, conference) ::: The conference invited some people"
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher",
            "AttendsConference(x) ::: x attends the conference",
            "WorksFor(x, y) ::: x works for y",
            "Company(x) ::: x is a company",
            "Invited(x, y) ::: x is invited by y"
        ]
    },
    {
        "premises-NL": [
            "John is a human.",
            "All dogs are animals.",
            "Every animal is friendly if it's cute.",
            "If John owns something, and it's a dog, then that dog is cute.",
            "If John loves something, then he is that things friend.",
            "If something is cute, it is not hated by John.",
            "If John hates something, then he doesn't own it.",
            "If John does not own a dog, John does not love a dog.",
            "John hates everything he does not love."
        ],
        "premises-FOL": [
            "Human(john) ::: John is a human.",
            "∀x (Dog(x) → Animal(x)) ::: All dogs are animals.",
            "∀x (Animal(x) ∧ Cute(x) → Friendly(x)) ::: Every animal is friendly if it's cute.",
            "∀x (Owns(john, x) ∧ Dog(x) → Cute(x)) ::: If John owns something, and it's a dog, then that dog is cute.",
            "∀x (Loves(john, x) → IsFriendOf(john, x)) ::: If John loves something, then he is that things friend.",
            "∀x (Cute(x) → ¬Hates(john, x)) ::: If something is cute, it is not hated by John.",
            "∀x (Hates(john, x) → ¬Owns(john, x)) ::: If John hates something, then he doesn't own it.",
            "∀x (¬Owns(john, x) ∧ Dog(x) → ¬Loves(john, x)) ::: If John does not own a dog, John does not love a dog.",
            "∀x (¬Loves(john, x) → Hates(john, x)) ::: John hates everything he does not love."
        ],
        "predicates": [
            "Owns(x, y) ::: x owns y.",
            "Dog(x) ::: x is a dog.",
            "Loves(x, y) ::: x loves y.",
            "Friendly(x) ::: x is friendly.",
            "Animal(x) ::: x is an animal.",
            "IsFriendOf(x, y) ::: x is a friend of y.",
            "Cute(x) ::: x is cute.",
            "Hates(x, y) ::: x hates y.",
            "Human(x) ::: x is a human."
        ]
    },
    {
        "premises-NL": [
            "All friends like each other.",
            "John and Mary are friends.",
            "If John and Mary are friends, then Mary likes John.",
            "If John likes Mary, then Mary likes John.",
            "If Mary likes John, then John likes Mary."
        ],
        "premises-FOL": [
            "∀x ∀y (Friend(x, y) → Likes(x, y) ∧ Likes(y, x)) ::: All friends like each other.",
            "Friend(john, mary) ::: John and Mary are friends.",
            "Friend(john, mary) → Likes(mary, john) ::: If John and Mary are friends, then Mary likes John.",
            "Likes(john, mary) → Likes(mary, john) ::: If John likes Mary, then Mary likes John.",
            "Likes(mary, john) → Likes(john, mary) ::: If Mary likes John, then John likes Mary."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Friend(x, y) ::: x and y are friends"
        ]
    },
    {
        "premises-NL": [
            "All programmers write code.",
            "Bob is a programmer.",
            "If someone writes code, they use a computer.",
            "If someone uses a computer, then they have a laptop.",
            "Bob writes code.",
            "Programmers write code and Bob has a laptop.",
            "Bob is a programmer and Bob has a laptop.",
            "All programmers use computers.",
            "Everyone who uses a computer has a laptop.",
            "If someone has a laptop, they write code.",
            "Bob is a programmer, Bob writes code, and Bob uses a computer.",
            "If someone is a programmer, they write code."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → WritesCode(x)) ::: All programmers write code.",
            "Programmer(bob) ::: Bob is a programmer.",
            "∀x (WritesCode(x) → UsesComputer(x)) ::: If someone writes code, they use a computer.",
            "∀x (UsesComputer(x) → HasLaptop(x)) ::: If someone uses a computer, then they have a laptop.",
            "WritesCode(bob) ::: Bob writes code.",
            "(Programmer(x) ∧ HasLaptop(x)) ::: Programmers write code and Bob has a laptop.",
            "(Programmer(bob) ∧ HasLaptop(bob)) ::: Bob is a programmer and Bob has a laptop.",
            "∀x (Programmer(x) → UsesComputer(x)) ::: All programmers use computers.",
            "∀x (UsesComputer(x) → HasLaptop(x)) ::: Everyone who uses a computer has a laptop.",
            "∀x (HasLaptop(x) → WritesCode(x)) ::: If someone has a laptop, they write code.",
            "(Programmer(bob) ∧ WritesCode(bob) ∧ UsesComputer(bob)) ::: Bob is a programmer, Bob writes code, and Bob uses a computer.",
            "∀x (Programmer(x) → WritesCode(x)) ::: If someone is a programmer, they write code."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer.",
            "UsesComputer(x) ::: x uses a computer.",
            "WritesCode(x) ::: x writes code.",
            "HasLaptop(x) ::: x has a laptop."
        ]
    },
    {
        "premises-NL": [
            "All doctors treat illness.",
            "Charlie is a doctor.",
            "If someone treats illness, they help patients.",
            "If someone helps patients, they prescribe medication.",
            "Charlie treats illness.",
            "Doctors treat illness and Charlie prescribes medication.",
            "Charlie is a doctor and Charlie prescribes medication.",
            "All doctors help patients.",
            "If someone helps patients, they treat illness.",
            "If someone prescribes medication, they help patients.",
            "Charlie is a doctor, Charlie treats illness, and Charlie helps patients.",
            "If someone is a doctor, they help patients.",
            "Charlie is a doctor and Charlie helps patients."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → TreatsIllness(x)) ::: All doctors treat illness.",
            "Doctor(charlie) ::: Charlie is a doctor.",
            "∀x (TreatsIllness(x) → HelpsPatients(x)) ::: If someone treats illness, they help patients.",
            "∀x (HelpsPatients(x) → PrescribesMedication(x)) ::: If someone helps patients, they prescribe medication.",
            "TreatsIllness(charlie) ::: Charlie treats illness.",
            "(Doctor(x) ∧ PrescribesMedication(x)) ::: Doctors treat illness and Charlie prescribes medication.",
            "(Doctor(charlie) ∧ PrescribesMedication(charlie)) ::: Charlie is a doctor and Charlie prescribes medication.",
            "∀x (Doctor(x) → HelpsPatients(x)) ::: All doctors help patients.",
            "∀x (HelpsPatients(x) → TreatsIllness(x)) ::: If someone helps patients, they treat illness.",
            "∀x (PrescribesMedication(x) → HelpsPatients(x)) ::: If someone prescribes medication, they help patients.",
            "(Doctor(charlie) ∧ TreatsIllness(charlie) ∧ HelpsPatients(charlie)) ::: Charlie is a doctor, Charlie treats illness, and Charlie helps patients.",
            "∀x (Doctor(x) → HelpsPatients(x)) ::: If someone is a doctor, they help patients.",
            "(Doctor(charlie) ∧ HelpsPatients(charlie)) ::: Charlie is a doctor and Charlie helps patients."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "HelpsPatients(x) ::: x helps patients.",
            "TreatsIllness(x) ::: x treats illness.",
            "PrescribesMedication(x) ::: x prescribes medication."
        ]
    },
    {
        "premises-NL": [
            "All engineers design buildings.",
            "David is an engineer.",
            "If someone designs buildings, they build bridges.",
            "If someone builds bridges, they use CAD software.",
            "David designs buildings.",
            "Engineers design buildings and David uses CAD software.",
            "David is an engineer and David uses CAD software.",
            "All engineers build bridges.",
            "If someone builds bridges, they design buildings.",
            "If someone uses CAD software, they build bridges.",
            "David is an engineer, David designs buildings, and David builds bridges.",
            "If someone is an engineer, they build bridges.",
            "David is an engineer and David builds bridges.",
            "All engineers use CAD software."
        ],
        "premises-FOL": [
            "∀x (Engineer(x) → DesignsBuildings(x)) ::: All engineers design buildings.",
            "Engineer(david) ::: David is an engineer.",
            "∀x (DesignsBuildings(x) → BuildsBridges(x)) ::: If someone designs buildings, they build bridges.",
            "∀x (BuildsBridges(x) → UsesCADSoftware(x)) ::: If someone builds bridges, they use CAD software.",
            "DesignsBuildings(david) ::: David designs buildings.",
            "(Engineer(x) ∧ UsesCADSoftware(x)) ::: Engineers design buildings and David uses CAD software.",
            "(Engineer(david) ∧ UsesCADSoftware(david)) ::: David is an engineer and David uses CAD software.",
            "∀x (Engineer(x) → BuildsBridges(x)) ::: All engineers build bridges.",
            "∀x (BuildsBridges(x) → DesignsBuildings(x)) ::: If someone builds bridges, they design buildings.",
            "∀x (UsesCADSoftware(x) → BuildsBridges(x)) ::: If someone uses CAD software, they build bridges.",
            "(Engineer(david) ∧ DesignsBuildings(david) ∧ BuildsBridges(david)) ::: David is an engineer, David designs buildings, and David builds bridges.",
            "∀x (Engineer(x) → BuildsBridges(x)) ::: If someone is an engineer, they build bridges.",
            "(Engineer(david) ∧ BuildsBridges(david)) ::: David is an engineer and David builds bridges.",
            "∀x (Engineer(x) → UsesCADSoftware(x)) ::: All engineers use CAD software."
        ],
        "predicates": [
            "Engineer(x) ::: x is an engineer.",
            "BuildsBridges(x) ::: x builds bridges.",
            "DesignsBuildings(x) ::: x designs buildings.",
            "UsesCADSoftware(x) ::: x uses CAD software."
        ]
    },
    {
        "premises-NL": [
            "All scientists analyze data.",
            "Eve is a scientist.",
            "If someone analyzes data, they conduct experiments.",
            "If someone conducts experiments, they write reports.",
            "Eve analyzes data.",
            "Scientists analyze data and Eve writes reports.",
            "Eve is a scientist and Eve writes reports.",
            "All scientists conduct experiments.",
            "If someone conducts experiments, they analyze data.",
            "If someone writes reports, they conduct experiments.",
            "Eve is a scientist, Eve analyzes data, and Eve conducts experiments.",
            "If someone is a scientist, they conduct experiments.",
            "Eve is a scientist and Eve conducts experiments.",
            "All scientists write reports.",
            "If someone analyzes data, they write reports."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → AnalyzesData(x)) ::: All scientists analyze data.",
            "Scientist(eve) ::: Eve is a scientist.",
            "∀x (AnalyzesData(x) → ConductsExperiments(x)) ::: If someone analyzes data, they conduct experiments.",
            "∀x (ConductsExperiments(x) → WritesReports(x)) ::: If someone conducts experiments, they write reports.",
            "AnalyzesData(eve) ::: Eve analyzes data.",
            "(Scientist(x) ∧ WritesReports(x)) ::: Scientists analyze data and Eve writes reports.",
            "(Scientist(eve) ∧ WritesReports(eve)) ::: Eve is a scientist and Eve writes reports.",
            "∀x (Scientist(x) → ConductsExperiments(x)) ::: All scientists conduct experiments.",
            "∀x (ConductsExperiments(x) → AnalyzesData(x)) ::: If someone conducts experiments, they analyze data.",
            "∀x (WritesReports(x) → ConductsExperiments(x)) ::: If someone writes reports, they conduct experiments.",
            "(Scientist(eve) ∧ AnalyzesData(eve) ∧ ConductsExperiments(eve)) ::: Eve is a scientist, Eve analyzes data, and Eve conducts experiments.",
            "∀x (Scientist(x) → ConductsExperiments(x)) ::: If someone is a scientist, they conduct experiments.",
            "(Scientist(eve) ∧ ConductsExperiments(eve)) ::: Eve is a scientist and Eve conducts experiments.",
            "∀x (Scientist(x) → WritesReports(x)) ::: All scientists write reports.",
            "∀x (AnalyzesData(x) → WritesReports(x)) ::: If someone analyzes data, they write reports."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist.",
            "ConductsExperiments(x) ::: x conducts experiments.",
            "AnalyzesData(x) ::: x analyzes data.",
            "WritesReports(x) ::: x writes reports."
        ]
    },
    {
        "premises-NL": [
            "If someone is invited, they can accept the invitation.",
            "If someone accepts the invitation, and likes parties, then they will attend.",
            "If someone attends, then they are at the party.",
            "Alice is invited.",
            "Bob is invited.",
            "If someone is invited, then they are a member.",
            "If someone is a member and does not attend, then they are bored.",
            "Alice likes parties.",
            "If Alice likes parties, then Alice wants to attend.",
            "If Bob does not attend, then he is bored.",
            "If someone is bored, then they do not want to attend.",
            "Alice is a member.",
            "Bob is a member.",
            "If someone wants to attend, then they attend.",
            "Alice attends."
        ],
        "premises-FOL": [
            "∀x (Invited(x) → AcceptsInvitation(x)) ::: If someone is invited, they can accept the invitation.",
            "∀x (AcceptsInvitation(x) ∧ LikesParty(x) → Attends(x)) ::: If someone accepts the invitation, and likes parties, then they will attend.",
            "∀x (Attends(x) → IsAtParty(x)) ::: If someone attends, then they are at the party.",
            "Invited(alice) ::: Alice is invited.",
            "Invited(bob) ::: Bob is invited.",
            "∀x (Invited(x) → Member(x)) ::: If someone is invited, then they are a member.",
            "∀x (Member(x) ∧ ¬Attends(x) → IsBored(x)) ::: If someone is a member and does not attend, then they are bored.",
            "LikesParty(alice) ::: Alice likes parties.",
            "LikesParty(alice) → WantsToAttend(alice) ::: If Alice likes parties, then Alice wants to attend.",
            "¬Attends(bob) → IsBored(bob) ::: If Bob does not attend, then he is bored.",
            "∀x (IsBored(x) → ¬WantsToAttend(x)) ::: If someone is bored, then they do not want to attend.",
            "Member(alice) ::: Alice is a member.",
            "Member(bob) ::: Bob is a member.",
            "∀x (WantsToAttend(x) → Attends(x)) ::: If someone wants to attend, then they attend.",
            "Attends(alice) ::: Alice attends."
        ],
        "predicates": [
            "Member(x) ::: x is a member",
            "Attends(x) ::: x attends",
            "Invited(x) ::: x is invited",
            "AcceptsInvitation(x) ::: x accepts invitation",
            "LikesParty(x) ::: x likes party",
            "IsAtParty(x) ::: x is at party",
            "Knows(x, y) ::: x knows y",
            "IsFriendOf(x, y) ::: x is a friend of y",
            "WantsToAttend(x) ::: x wants to attend",
            "IsDancing(x) ::: x is dancing",
            "IsSinging(x) ::: x is singing",
            "IsHappy(x) ::: x is happy",
            "Drinks(x, y) ::: x drinks y",
            "Alcohol(x) ::: x is alcohol",
            "IsBored(x) ::: x is bored"
        ]
    },
    {
        "premises-NL": [
            "All students attend lectures.",
            "Alice is a student.",
            "Students learn from lectures.",
            "Alice is a smart person.",
            "If someone is a student and attends lectures, then he/she is a successful student.",
            "Successful students are happy students.",
            "Happiness is important in life.",
            "If one is happy, then one has a good life.",
            "A good life is a life full of achievements.",
            "If Alice is a student, then she needs to learn.",
            "Learning leads to knowledge."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsLecture(x)) ::: All students attend lectures",
            "Student(Alice) ::: Alice is a student",
            "∀x (Student(x) → LearnsFromLecture(x)) ::: Students learn from lectures",
            "Smart(Alice) ::: Alice is a smart person",
            "∀x ((Student(x) ∧ AttendsLecture(x)) → SuccessfulStudent(x)) ::: If someone is a student and attends lectures, then he/she is a successful student",
            "∀x (SuccessfulStudent(x) → HappyStudent(x)) ::: Successful students are happy students",
            "Important(Happiness, Life) ::: Happiness is important in life",
            "∀x (HappyStudent(x) → GoodLife(x)) ::: If one is happy, then one has a good life",
            "∀x (GoodLife(x) → Achievements(x)) ::: A good life is a life full of achievements",
            "Student(Alice) → NeedsToLearn(Alice) ::: If Alice is a student, then she needs to learn",
            "NeedsToLearn(Alice) → Knowledge(Alice) ::: Learning leads to knowledge",
            "AttendsLecture(Alice) ::: Alice attends lectures"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsLecture(x) ::: x attends lectures"
        ]
    },
    {
        "premises-NL": [
            "Every student either attends class or likes reading.",
            "If someone attends class, they study hard.",
            "Some students have books.",
            "John is a student.",
            "All students who like reading do not study hard.",
            "If someone studies hard, then they pass the exam.",
            "Everyone who has books about biology knows the biology professor.",
            "Mary is a student.",
            "Some student knows professor Smith.",
            "If someone is a student they either knows professor Smith or John studies hard.",
            "Every student knows either professor Smith or Mary does not study hard.",
            "If someone is a student and Mary does not study hard, then they do not studies hard.",
            "If Mary studies hard, she passes the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (AttendsClass(x) ∨ LikesReading(x))) ::: For all x, if x is a student, then x attends class or likes reading.",
            "∀x (AttendsClass(x) → StudiesHard(x)) ::: For all x, if x attends class, then x studies hard.",
            "∃x ∃y (Student(x) ∧ HasBooks(x, y)) ::: There exists x and y, such that x is a student and x has books.",
            "Student(john) ::: John is a student.",
            "∀x (Student(x) ∧ LikesReading(x) → ¬StudiesHard(x)) ::: For all x, if x is a student and likes reading, then x does not study hard.",
            "∀x (StudiesHard(x) → PassesExam(x)) ::: For all x, if x studies hard, then x passes the exam.",
            "∀x ∀y (HasBooks(x, y) ∧ Subject(y, biology) → KnowsProfessor(x, biologyProfessor)) ::: For all x and y, if x has books about y and y is biology, then x knows the biology professor.",
            "Student(mary) ::: Mary is a student.",
            "∃x KnowsProfessor(x, smith) ::: There exists x such that x knows professor Smith.",
            "∀x (Student(x) → (KnowsProfessor(x, smith) ∨ StudiesHard(john))) ::: For all x, if x is a student, then x knows professor Smith or John studies hard.",
            "∀x (Student(x) → (KnowsProfessor(x, smith) ∨ ¬StudiesHard(mary))) ::: For all x, if x is a student, then x knows professor Smith or Mary does not study hard.",
            "∀x (Student(x) ∧ ¬StudiesHard(mary) → ¬StudiesHard(x)) ::: For all x, if x is a student and Mary does not study hard, then x does not study hard.",
            "StudiesHard(mary) → PassesExam(mary) ::: If Mary studies hard, then she passes the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassesExam(x) ::: x passes the exam",
            "AttendsClass(x) ::: x attends class",
            "LikesReading(x) ::: x likes reading",
            "HasBooks(x, y) ::: x has books about y",
            "KnowsProfessor(x, y) ::: x knows professor y"
        ]
    },
    {
        "premises-NL": [
            "All members are people.",
            "If someone is a member, they enjoy the club.",
            "If someone enjoys a club, they are happy.",
            "A club is either exclusive or not exclusive.",
            "If a person plays games and is not a member, they are not happy.",
            "Someone is a member and is playing games.",
            "The person enjoys the club.",
            "If a club is not exclusive, then everyone enjoys it."
        ],
        "premises-FOL": [
            "∀x (Member(x) → Person(x)) ::: All members are people.",
            "∀x (Member(x) → Enjoys(x, Club)) ::: If someone is a member, they enjoy the club.",
            "∀x (Enjoys(x, Club) → Happy(x)) ::: If someone enjoys a club, they are happy.",
            "Exclusive(Club) ∨ ¬Exclusive(Club) ::: A club is either exclusive or not exclusive.",
            "∀x (Plays(x, Games) ∧ ¬Member(x) → ¬Happy(x)) ::: If a person plays games and is not a member, they are not happy.",
            "∃x (Member(x) ∧ Plays(x, Games)) ::: Someone is a member and is playing games.",
            "∀x (Member(x) → Enjoys(x, Club)) ::: The person enjoys the club.",
            "∀x (¬Exclusive(Club) → Enjoys(x, Club)) ::: If a club is not exclusive, then everyone enjoys it."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Member(x) ::: x is a member",
            "Club(x) ::: x is a club",
            "Exclusive(x) ::: x is exclusive",
            "Happy(x) ::: x is happy",
            "Enjoys(x, y) ::: x enjoys y",
            "Plays(x, y) ::: x plays y"
        ]
    },
    {
        "premises-NL": [
            "All animals are either carnivores, herbivores, or omnivores.",
            "If an animal is a carnivore, then it eats meat.",
            "If an animal is a herbivore, then it eats plants.",
            "If an animal is an omnivore, it eats both plants and meat.",
            "No person is an animal.",
            "If an animal does not eat meat, then it only eats plants.",
            "A creature either eats meat or doesn't eat meat.",
            "Some animal is a carnivore.",
            "Something eats plants."
        ],
        "premises-FOL": [
            "∀x (Animal(x) → (Carnivore(x) ∨ Herbivore(x) ∨ Omnivore(x))) ::: All animals are either carnivores, herbivores, or omnivores.",
            "∀x (Carnivore(x) → Eats(x, Meat)) ::: If an animal is a carnivore, then it eats meat.",
            "∀x (Herbivore(x) → Eats(x, Plants)) ::: If an animal is a herbivore, then it eats plants.",
            "∀x (Omnivore(x) → (Eats(x, Plants) ∧ Eats(x, Meat))) ::: If an animal is an omnivore, it eats both plants and meat.",
            "∀x (Person(x) → ¬Animal(x)) ::: No person is an animal.",
            "∀x (Animal(x) ∧ ¬Eats(x, Meat) → Eats(x, Plants)) ::: If an animal does not eat meat, then it only eats plants.",
            "∀x (Eats(x, Meat) ∨ ¬Eats(x, Meat)) ::: A creature either eats meat or doesn't eat meat.",
            "∃x (Animal(x) ∧ Carnivore(x)) ::: Some animal is a carnivore.",
            "∃x Eats(x, Plants) ::: Something eats plants."
        ],
        "predicates": [
            "Animal(x) ::: x is an animal",
            "Eats(x, y) ::: x eats y",
            "Plants(x) ::: x is a plant",
            "Lives(x) ::: x lives",
            "Carnivore(x) ::: x is a carnivore",
            "Herbivore(x) ::: x is a herbivore",
            "Omnivore(x) ::: x is an omnivore",
            "Meat(x) ::: x is meat",
            "Person(x) ::: x is a person"
        ]
    },
    {
        "premises-NL": [
            "All doctors are licensed.",
            "Some people are doctors.",
            "Doctors prescribe medication.",
            "No person can be a doctor and not be licensed."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Licensed(x)) ::: For all x, if x is a doctor, then x is licensed.",
            "∃x Doctor(x) ::: There exists an x such that x is a doctor.",
            "∀x (Doctor(x) → PrescribesMedication(x)) ::: For all x, if x is a doctor, then x prescribes medication.",
            "¬∃x (Doctor(x) ∧ ¬Licensed(x)) ::: It is not the case that there exists an x such that x is a doctor and is not licensed."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Licensed(x) ::: x is licensed",
            "PrescribesMedication(x) ::: x prescribes medication"
        ]
    },
    {
        "premises-NL": [
            "All programmers work hard.",
            "Everyone who works hard is also a student or an athlete.",
            "Someone who is both a programmer and an athlete works hard.",
            "All athletes have free time.",
            "No student has free time.",
            "Anyone who works hard is a student or an athlete"
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → WorksHard(x)) ::: For all x, if x is a programmer, then x works hard.",
            "∀x (WorksHard(x) → (Student(x) ∨ Athlete(x))) ::: For all x, if x works hard, then x is a student or an athlete.",
            "∃x (Programmer(x) ∧ Athlete(x) ∧ WorksHard(x)) ::: There exists an x such that x is a programmer and an athlete and works hard.",
            "∀x (Athlete(x) → HasFreeTime(x)) ::: For all x, if x is an athlete, then x has free time.",
            "¬∃x (Student(x) ∧ HasFreeTime(x)) ::: It is not the case that there exists an x such that x is a student and has free time.",
            "∀x (WorksHard(x) → (Student(x) ∨ Athlete(x))) ::: For all x, if x works hard, then x is a student or an athlete."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "Athlete(x) ::: x is an athlete",
            "Student(x) ::: x is a student",
            "WorksHard(x) ::: x works hard",
            "HasFreeTime(x) ::: x has free time"
        ]
    },
    {
        "premises-NL": [
            "All products with a high demand and low supply will increase in price.",
            "Some products are essential and have high demand.",
            "Some products are luxury goods, but not locally produced.",
            "Products that are not locally produced are imported.",
            "Some essential products have a low supply.",
            "All luxury products have high demand.",
            "All essential products have a low supply and are not luxury products.",
            "Some products are luxury and not essential."
        ],
        "premises-FOL": [
            "∀x ((HighDemand(x) ∧ LowSupply(x)) → IncreasesPrice(x)) ::: For all x, if x has high demand and low supply, then its price increases.",
            "∃x (Essential(x) ∧ HighDemand(x)) ::: There exists an x such that x is essential and has high demand.",
            "∃x (Luxury(x) ∧ ¬ProducedLocally(x)) ::: There exists an x such that x is a luxury good and is not produced locally.",
            "∀x (¬ProducedLocally(x) → Imported(x)) ::: For all x, if x is not produced locally, then x is imported.",
            "∃x (Essential(x) ∧ LowSupply(x)) ::: There exists an x such that x is essential and has low supply.",
            "∀x (Luxury(x) → HighDemand(x)) ::: For all x, if x is a luxury good, then it has high demand.",
            "∀x (Essential(x) → (LowSupply(x) ∧ ¬Luxury(x))) ::: For all x, if x is essential, then it has low supply and it is not a luxury good.",
            "∃x (Luxury(x) ∧ ¬Essential(x)) ::: There exists an x such that x is a luxury good and it is not essential."
        ],
        "predicates": [
            "Product(x) ::: x is a product",
            "HighDemand(x) ::: x has high demand",
            "LowSupply(x) ::: x has low supply",
            "IncreasesPrice(x) ::: x increases in price",
            "Essential(x) ::: x is essential",
            "Luxury(x) ::: x is a luxury",
            "ProducedLocally(x) ::: x is produced locally",
            "Imported(x) ::: x is imported"
        ]
    },
    {
        "premises-NL": [
            "All people with PhDs publish research regularly or attend conferences.",
            "Everyone who publishes research regularly is an expert.",
            "Some experts teach and conduct research.",
            "Anyone who attends conferences and receives grants is a researcher.",
            "All researchers have at least a master's degree.",
            "People with a PhD either publish regularly or attends conferences.",
            "Some people have PhD and also have masters.",
            "Anyone that has a masters degree conducts research.",
            "There are people with PhDs."
        ],
        "premises-FOL": [
            "∀x (HasPhD(x) → (PublishesRegularly(x) ∨ AttendsConferences(x))) ::: For all x, if x has a PhD, then x publishes regularly or attends conferences.",
            "∀x (PublishesRegularly(x) → Expert(x)) ::: For all x, if x publishes regularly, then x is an expert.",
            "∃x (Expert(x) ∧ Teaches(x) ∧ ConductsResearch(x)) ::: There exists an x such that x is an expert and teaches and conducts research.",
            "∀x ((AttendsConferences(x) ∧ ReceivesGrants(x)) → IsResearcher(x)) ::: For all x, if x attends conferences and receives grants, then x is a researcher.",
            "∀x (IsResearcher(x) → HasMasters(x)) ::: For all x, if x is a researcher, then x has a master's degree.",
            "∀x (HasPhD(x) → (PublishesRegularly(x) ∨ AttendsConferences(x))) ::: For all x, if x has a PhD, then x publishes regularly or attends conferences.",
            "∃x (HasPhD(x) ∧ HasMasters(x)) ::: There exists an x such that x has a PhD and also has a master's degree.",
            "∀x (HasMasters(x) → ConductsResearch(x)) ::: For all x, if x has a master's degree, then x conducts research.",
            "∃x HasPhD(x) ::: There exists an x that has PhD."
        ],
        "predicates": [
            "HasPhD(x) ::: x has a PhD",
            "PublishesRegularly(x) ::: x publishes research regularly",
            "Expert(x) ::: x is an expert",
            "AttendsConferences(x) ::: x attends conferences",
            "Teaches(x) ::: x teaches",
            "ConductsResearch(x) ::: x conducts research",
            "ReceivesGrants(x) ::: x receives grants",
            "IsResearcher(x) ::: x is a researcher",
            "HasMasters(x) ::: x has a masters degree"
        ]
    },
    {
        "premises-NL": [
            "All cats like fish.",
            "Some cats hate fish.",
            "If something hates something, it is not black.",
            "Every cat is a cat.",
            "Every cat is a mammal."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → Likes(x, Fish)) ::: All cats like fish.",
            "∃x (Cat(x) ∧ Hates(x, Fish)) ::: Some cats hate fish.",
            "∀x ∀y (Hates(x, y) → ¬Black(x)) ::: If something hates something, it is not black.",
            "∀x (Cat(x) → Cat(x)) ::: Every cat is a cat.",
            "∀x (Cat(x) → Mammal(x)) ::: Every cat is a mammal."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Black(x) ::: x is black",
            "Likes(x, y) ::: x likes y",
            "Hates(x, y) ::: x hates y"
        ]
    },
    {
        "premises-NL": [
            "All cats are furry.",
            "All cats are domesticated.",
            "All cats hunt mice.",
            "All cats like cream.",
            "All cats are animals.",
            "If something is a cat, then it is a mammal.",
            "If x is a mammal, then x is furry or x likes cream."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → Furry(x)) ::: For all x, if x is a cat, then x is furry.",
            "∀x (Cat(x) → Domesticated(x)) ::: For all x, if x is a cat, then x is domesticated.",
            "∀x (Cat(x) → HuntsMice(x)) ::: For all x, if x is a cat, then x hunts mice.",
            "∀x (Cat(x) → LikesCream(x)) ::: For all x, if x is a cat, then x likes cream.",
            "∀x (Cat(x) → Animal(x)) ::: For all x, if x is a cat, then x is an animal.",
            "∀x (Cat(x) → Mammal(x)) ::: For all x, if x is a cat, then x is a mammal.",
            "∀x (Mammal(x) → (Furry(x) ∨ LikesCream(x))) ::: For all x, if x is a mammal, then x is furry or likes cream."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Mammal(x) ::: x is a mammal",
            "Furry(x) ::: x is furry",
            "Domesticated(x) ::: x is domesticated",
            "HuntsMice(x) ::: x hunts mice",
            "LikesCream(x) ::: x likes cream",
            "Animal(x) ::: x is an animal"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard either pass or fail the exam.",
            "If a student is smart, they study hard.",
            "No smart student fails the exam.",
            "John is a student.",
            "John studies hard.",
            "John has the book on logic.",
            "Anyone who has the book on logic is smart.",
            "If someone is a student and they have the book on logic, then they study hard.",
            "If someone is a student and does not pass the exam, then they failed the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) → PassesExam(x) ∨ FailsExam(x)) ::: All students who study hard either pass or fail the exam.",
            "∀x (Smart(x) → StudiesHard(x)) ::: If a student is smart, they study hard.",
            "∀x (Smart(x) → ¬FailsExam(x)) ::: No smart student fails the exam.",
            "Student(john) ::: John is a student.",
            "StudiesHard(john) ::: John studies hard.",
            "HasBook(john, logicBook) ::: John has the book on logic.",
            "∀x (HasBook(x, logicBook) → Smart(x)) ::: Anyone who has the book on logic is smart.",
            "∀x (Student(x) ∧ HasBook(x, logicBook) → StudiesHard(x)) ::: If someone is a student and they have the book on logic, then they study hard.",
            "∀x (Student(x) ∧ ¬PassesExam(x) → FailsExam(x)) ::: If someone is a student and does not pass the exam, then they failed the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "FailsExam(x) ::: x fails the exam",
            "PassesExam(x) ::: x passes the exam",
            "Smart(x) ::: x is smart",
            "HasBook(x, y) ::: x has book y"
        ]
    },
    {
        "premises-NL": [
            "All plants are either green or have flowers.",
            "If a plant gets sunlight, it is healthy.",
            "If a plant is watered, it is healthy.",
            "Healthy plants grow.",
            "A plant gets sunlight.",
            "A plant gets water.",
            "This is a plant.",
            "If a plant has leaves, then it is healthy.",
            "If a plant eats nutrients, then it is healthy.",
            "If a plant has flowers, then it eats nutrients."
        ],
        "premises-FOL": [
            "∀x (Plant(x) → IsGreen(x) ∨ IsFlower(x)) ::: All plants are either green or have flowers.",
            "∀x (Plant(x) ∧ GetsSunlight(x) → IsHealthy(x)) ::: If a plant gets sunlight, it is healthy.",
            "∀x (Plant(x) ∧ GetsWater(x) → IsHealthy(x)) ::: If a plant is watered, it is healthy.",
            "∀x (Plant(x) ∧ IsHealthy(x) → Grows(x)) ::: Healthy plants grow.",
            "GetsSunlight(plant1) ::: A plant gets sunlight.",
            "GetsWater(plant1) ::: A plant gets water.",
            "Plant(plant1) ::: This is a plant.",
            "∀x (Plant(x) ∧ HasLeaves(x) → IsHealthy(x)) ::: If a plant has leaves, then it is healthy.",
            "∀x (Plant(x) ∧ EatsNutrients(x) → IsHealthy(x)) ::: If a plant eats nutrients, then it is healthy.",
            "∀x (Plant(x) ∧ IsFlower(x) → EatsNutrients(x)) ::: If a plant has flowers, then it eats nutrients."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "GetsSunlight(x) ::: x gets sunlight",
            "GetsWater(x) ::: x gets water",
            "Grows(x) ::: x grows",
            "IsGreen(x) ::: x is green",
            "IsHealthy(x) ::: x is healthy",
            "IsWatered(x) ::: x is watered",
            "HasLeaves(x) ::: x has leaves",
            "IsFlower(x) ::: x is a flower",
            "EatsNutrients(x) ::: x eats nutrients"
        ]
    },
    {
        "premises-NL": [
            "All employees who work hard either attend meetings or follow instructions.",
            "If an employee attends meetings, then they have good communication.",
            "If an employee has good communication and is skilled, then they meet deadlines.",
            "If an employee meets deadlines, they are reliable.",
            "If an employee is reliable and experienced, then they will be promoted.",
            "If an employee is promoted and reports to a manager, then they are skilled.",
            "John is an employee.",
            "John works hard.",
            "If John is an employee and follows instructions, John will complete tasks.",
            "John follows instructions.",
            "If someone is an employee and does not get promoted, then they don't meet deadlines",
            "If someone does not follow instructions, then they are not reliable.",
            "If an employee is skilled and meets deadlines, the employee is experienced."
        ],
        "premises-FOL": [
            "∀x (Employee(x) ∧ WorksHard(x) → AttendsMeetings(x) ∨ FollowsInstructions(x)) ::: All employees who work hard either attend meetings or follow instructions.",
            "∀x (Employee(x) ∧ AttendsMeetings(x) → GoodCommunication(x)) ::: If an employee attends meetings, then they have good communication.",
            "∀x (Employee(x) ∧ GoodCommunication(x) ∧ Skilled(x) → MeetsDeadlines(x)) ::: If an employee has good communication and is skilled, then they meet deadlines.",
            "∀x (Employee(x) ∧ MeetsDeadlines(x) → Reliable(x)) ::: If an employee meets deadlines, they are reliable.",
            "∀x (Employee(x) ∧ Reliable(x) ∧ Experienced(x) → Promoted(x)) ::: If an employee is reliable and experienced, then they will be promoted.",
            "∀x ∀y (Promoted(x) ∧ ReportsTo(x, y) ∧ Manager(y) → Skilled(x)) ::: If an employee is promoted and reports to a manager, then they are skilled.",
            "Employee(john) ::: John is an employee.",
            "WorksHard(john) ::: John works hard.",
            "∀x (Employee(x) ∧ FollowsInstructions(x) → CompletesTasks(x)) ::: If John is an employee and follows instructions, John will complete tasks.",
            "FollowsInstructions(john) ::: John follows instructions.",
            "∀x (Employee(x) ∧ ¬Promoted(x) → ¬MeetsDeadlines(x)) ::: If someone is an employee and does not get promoted, then they don't meet deadlines",
            "∀x (¬FollowsInstructions(x) → ¬Reliable(x)) ::: If someone does not follow instructions, then they are not reliable.",
            "∀x (Skilled(x) ∧ MeetsDeadlines(x) → Experienced(x)) ::: If an employee is skilled and meets deadlines, the employee is experienced."
        ],
        "predicates": [
            "Employee(x) ::: x is an employee",
            "WorksHard(x) ::: x works hard",
            "Skilled(x) ::: x is skilled",
            "FollowsInstructions(x) ::: x follows instructions",
            "Promoted(x) ::: x is promoted",
            "AttendsMeetings(x) ::: x attends meetings",
            "GoodCommunication(x) ::: x has good communication",
            "MeetsDeadlines(x) ::: x meets deadlines",
            "Experienced(x) ::: x is experienced",
            "Reliable(x) ::: x is reliable",
            "ReportsTo(x, y) ::: x reports to y",
            "Manager(x) ::: x is a manager",
            "CompletesTasks(x) ::: x completes tasks"
        ]
    },
    {
        "premises-NL": [
            "All students attend class.",
            "Anyone who attends class studies.",
            "If someone studies, they will pass the exam.",
            "If someone doesn't get help, they fail the exam.",
            "No student fails the exam.",
            "If someone attends class and is smart, they get help.",
            "John is a student.",
            "John attends class.",
            "John studies.",
            "John doesn't fail the exam.",
            "All students are smart.",
            "If a student gets help, they pass the exam.",
            "If someone is smart, they study.",
            "John is smart."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClass(x)) ::: All students attend class.",
            "∀x (AttendsClass(x) → Studies(x)) ::: Anyone who attends class studies.",
            "∀x (Studies(x) → PassesExam(x)) ::: If someone studies, they will pass the exam.",
            "∀x (¬GetsHelp(x) → FailsExam(x)) ::: If someone doesn't get help, they fail the exam.",
            "∀x (Student(x) → ¬FailsExam(x)) ::: No student fails the exam.",
            "∀x (AttendsClass(x) ∧ Smart(x) → GetsHelp(x)) ::: If someone attends class and is smart, they get help.",
            "Student(John) ::: John is a student.",
            "AttendsClass(John) ::: John attends class.",
            "Studies(John) ::: John studies.",
            "¬FailsExam(John) ::: John doesn't fail the exam.",
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "∀x (Student(x) ∧ GetsHelp(x) → PassesExam(x)) ::: If a student gets help, they pass the exam.",
            "∀x (Smart(x) → Studies(x)) ::: If someone is smart, they study.",
            "Smart(John) ::: John is smart."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Studies(x) ::: x studies.",
            "PassesExam(x) ::: x passes the exam.",
            "AttendsClass(x) ::: x attends class.",
            "GetsHelp(x) ::: x gets help.",
            "FailsExam(x) ::: x fails the exam.",
            "Smart(x) ::: x is smart."
        ]
    },
    {
        "premises-NL": [
            "All professors teach classes.",
            "All professors conduct research.",
            "Anyone who conducts research publishes papers.",
            "Anyone who teaches classes is an excellent teacher.",
            "Anyone who publishes papers receives a grant.",
            "If someone has a Ph.D. and receives a grant, they are promoted.",
            "If someone is an excellent teacher and a good researcher, they have a Ph.D.",
            "Dr. Smith is a professor.",
            "Dr. Smith conducts research.",
            "Dr. Smith teaches classes.",
            "Dr. Smith publishes papers.",
            "Dr. Smith receives a grant.",
            "If Dr. Smith teaches classes and conducts research, Dr. Smith is a good researcher.",
            "If a professor has a Ph.D., they conduct research.",
            "If Dr. Smith conducts research and is a professor, Dr. Smith is a good researcher."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → TeachesClasses(x)) ::: All professors teach classes.",
            "∀x (Professor(x) → ConductsResearch(x)) ::: All professors conduct research.",
            "∀x (ConductsResearch(x) → PublishesPapers(x)) ::: Anyone who conducts research publishes papers.",
            "∀x (TeachesClasses(x) → ExcellentTeacher(x)) ::: Anyone who teaches classes is an excellent teacher.",
            "∀x (PublishesPapers(x) → ReceivesGrant(x)) ::: Anyone who publishes papers receives a grant.",
            "∀x (HasPhD(x) ∧ ReceivesGrant(x) → Promoted(x)) ::: If someone has a Ph.D. and receives a grant, they are promoted.",
            "∀x (ExcellentTeacher(x) ∧ GoodResearcher(x) → HasPhD(x)) ::: If someone is an excellent teacher and a good researcher, they have a Ph.D.",
            "Professor(Smith) ::: Dr. Smith is a professor.",
            "ConductsResearch(Smith) ::: Dr. Smith conducts research.",
            "TeachesClasses(Smith) ::: Dr. Smith teaches classes.",
            "PublishesPapers(Smith) ::: Dr. Smith publishes papers.",
            "ReceivesGrant(Smith) ::: Dr. Smith receives a grant.",
            "TeachesClasses(Smith) ∧ ConductsResearch(Smith) → GoodResearcher(Smith) ::: If Dr. Smith teaches classes and conducts research, Dr. Smith is a good researcher.",
            "∀x (Professor(x) ∧ HasPhD(x) → ConductsResearch(x)) ::: If a professor has a Ph.D., they conduct research.",
            "Professor(Smith) ∧ ConductsResearch(Smith) → GoodResearcher(Smith) ::: If Dr. Smith conducts research and is a professor, Dr. Smith is a good researcher."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor.",
            "HasPhD(x) ::: x has a Ph.D.",
            "PublishesPapers(x) ::: x publishes papers.",
            "Promoted(x) ::: x is promoted.",
            "TeachesClasses(x) ::: x teaches classes.",
            "ConductsResearch(x) ::: x conducts research.",
            "ReceivesGrant(x) ::: x receives a grant.",
            "ExcellentTeacher(x) ::: x is an excellent teacher.",
            "GoodResearcher(x) ::: x is a good researcher."
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "Anyone who treats patients helps patients.",
            "Surgeons are specialists.",
            "All specialists practice medicine.",
            "All doctors have degrees.",
            "Anyone who practices medicine and is in a hospital helps patients.",
            "Dr. Jones is a doctor.",
            "Dr. Jones is a surgeon.",
            "Dr. Jones has a degree.",
            "Dr. Jones works in a hospital.",
            "Dr. Jones practices medicine.",
            "Dr. Jones is a specialist.",
            "If Dr. Jones is a doctor and is in a hospital, Dr. Jones helps patients.",
            "If a surgeon works in a hospital, they are a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → TreatsPatients(x)) ::: All doctors treat patients.",
            "∀x (TreatsPatients(x) → HelpsPatients(x)) ::: Anyone who treats patients helps patients.",
            "∀x (Surgeon(x) → Specialist(x)) ::: Surgeons are specialists.",
            "∀x (Specialist(x) → PracticesMedicine(x)) ::: All specialists practice medicine.",
            "∀x (Doctor(x) → HasDegree(x)) ::: All doctors have degrees.",
            "∀x (PracticesMedicine(x) ∧ InHospital(x) → HelpsPatients(x)) ::: Anyone who practices medicine and is in a hospital helps patients.",
            "Doctor(Jones) ::: Dr. Jones is a doctor.",
            "Surgeon(Jones) ::: Dr. Jones is a surgeon.",
            "HasDegree(Jones) ::: Dr. Jones has a degree.",
            "WorksInHospital(Jones) ::: Dr. Jones works in a hospital.",
            "PracticesMedicine(Jones) ::: Dr. Jones practices medicine.",
            "Specialist(Jones) ::: Dr. Jones is a specialist.",
            "Doctor(Jones) ∧ InHospital(Jones) → HelpsPatients(Jones) ::: If Dr. Jones is a doctor and is in a hospital, Dr. Jones helps patients.",
            "∀x (Surgeon(x) ∧ WorksInHospital(x) → Doctor(x)) ::: If a surgeon works in a hospital, they are a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "PracticesMedicine(x) ::: x practices medicine.",
            "InHospital(x) ::: x is in a hospital.",
            "HelpsPatients(x) ::: x helps patients.",
            "TreatsPatients(x) ::: x treats patients.",
            "Specialist(x) ::: x is a specialist.",
            "WorksInHospital(x) ::: x works in a hospital.",
            "Surgeon(x) ::: x is a surgeon.",
            "HasDegree(x) ::: x has a degree."
        ]
    },
    {
        "premises-NL": [
            "All students attend class.",
            "If someone attends class, they study hard or smart.",
            "If someone likes the professor, they study hard.",
            "If someone cheats, they do not get a good grade.",
            "No student cheats.",
            "Everyone who attends class likes the professor.",
            "If professor teaches something, student studies hard or smart.",
            "All students are students."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClass(x)) ::: All students attend class.",
            "∀x (AttendsClass(x) → (StudiesHard(x) ∨ StudiesSmart(x))) ::: If someone attends class, they study hard or smart.",
            "∀x (LikesProfessor(x) → StudiesHard(x)) ::: If someone likes the professor, they study hard.",
            "∀x (Cheats(x) → ¬GetsGoodGrade(x)) ::: If someone cheats, they do not get a good grade.",
            "∀x (Student(x) → ¬Cheats(x)) ::: No student cheats.",
            "∀x (AttendsClass(x) → LikesProfessor(x)) ::: Everyone who attends class likes the professor.",
            "∀x (ProfessorTeaches(x) → (StudiesHard(x) ∨ StudiesSmart(x))) ::: If professor teaches something, student studies hard or smart.",
            "∀x (Student(x)) ::: All students are students."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "StudiesSmart(x) ::: x studies smart",
            "GetsGoodGrade(x) ::: x gets a good grade",
            "AttendsClass(x) ::: x attends class",
            "LikesProfessor(x) ::: x likes professor",
            "ProfessorTeaches(x) ::: professor teaches x",
            "Cheats(x) ::: x cheats"
        ]
    },
    {
        "premises-NL": [
            "All leaders are members.",
            "All leaders attend meetings.",
            "Anyone who attends meetings, follows rules.",
            "Anyone who is active, is a contributor.",
            "Anyone who is a member and attends meetings is active.",
            "Anyone who knows the policy, is a leader.",
            "Anyone who votes, attends meetings.",
            "If someone speaks, then they are a member and knows the policy.",
            "Someone is a leader."
        ],
        "premises-FOL": [
            "∀x (Leader(x) → Member(x)) ::: All leaders are members.",
            "∀x (Leader(x) → AttendsMeetings(x)) ::: All leaders attend meetings.",
            "∀x (AttendsMeetings(x) → FollowsRules(x)) ::: Anyone who attends meetings, follows rules.",
            "∀x (IsActive(x) → Contributor(x)) ::: Anyone who is active, is a contributor.",
            "∀x (Member(x) ∧ AttendsMeetings(x) → IsActive(x)) ::: Anyone who is a member and attends meetings is active.",
            "∀x (KnowsPolicy(x) → Leader(x)) ::: Anyone who knows the policy, is a leader.",
            "∀x (Votes(x) → AttendsMeetings(x)) ::: Anyone who votes, attends meetings.",
            "∀x (Speaks(x) → (Member(x) ∧ KnowsPolicy(x))) ::: If someone speaks, then they are a member and knows the policy.",
            "∃x Leader(x) ::: Someone is a leader."
        ],
        "predicates": [
            "Member(x) ::: x is a member",
            "Leader(x) ::: x is a leader",
            "Contributor(x) ::: x is a contributor",
            "AttendsMeetings(x) ::: x attends meetings",
            "FollowsRules(x) ::: x follows rules",
            "IsActive(x) ::: x is active",
            "KnowsPolicy(x) ::: x knows the policy",
            "Votes(x) ::: x votes",
            "Speaks(x) ::: x speaks"
        ]
    },
    {
        "premises-NL": [
            "If someone has a virus and is treated with a drug, then that person can be cured.",
            "If someone takes medicine, they will have the symptoms.",
            "If someone has a virus, then that person has a disease.",
            "If someone has symptoms, then that person has a disease.",
            "If someone has a virus, they are contagious.",
            "If someone takes a vaccine, then they are immune.",
            "If someone is not contagious and is not having symptoms, then that person is healthy.",
            "If someone is healthy, then their disease can be cured.",
            "If someone is taking a medicine, then he is not healthy.",
            "Everyone who is treated with a drug is taking a medicine."
        ],
        "premises-FOL": [
            "∀x ((HasVirus(x) ∧ TreatedWithDrug(x)) → DiseaseCured(x)) ::: If someone has a virus and is treated with a drug, then that person can be cured.",
            "∀x (TakesMedicine(x) → HasSymptoms(x)) ::: If someone takes medicine, they will have the symptoms.",
            "∀x (HasVirus(x) → HasDisease(x)) ::: If someone has a virus, then that person has a disease.",
            "∀x (HasSymptoms(x) → HasDisease(x)) ::: If someone has symptoms, then that person has a disease.",
            "∀x (HasVirus(x) → IsContagious(x)) ::: If someone has a virus, they are contagious.",
            "∀x (TakesVaccine(x) → IsImmune(x)) ::: If someone takes a vaccine, then they are immune.",
            "∀x ((¬IsContagious(x) ∧ ¬HasSymptoms(x)) → IsHealthy(x)) ::: If someone is not contagious and is not having symptoms, then that person is healthy.",
            "∀x (IsHealthy(x) → DiseaseCured(x)) ::: If someone is healthy, then their disease can be cured.",
            "∀x (TakesMedicine(x) → ¬IsHealthy(x)) ::: If someone is taking a medicine, then he is not healthy.",
            "∀x (TreatedWithDrug(x) → TakesMedicine(x)) ::: Everyone who is treated with a drug is taking a medicine."
        ],
        "predicates": [
            "HasDisease(x) ::: x has a disease",
            "DiseaseCured(x) ::: x's disease can be cured",
            "TreatedWithDrug(x) ::: x is treated with a drug",
            "TakesMedicine(x) ::: x takes medicine",
            "IsHealthy(x) ::: x is healthy",
            "HasSymptoms(x) ::: x has symptoms",
            "HasVirus(x) ::: x has a virus",
            "IsContagious(x) ::: x is contagious",
            "TakesVaccine(x) ::: x takes a vaccine",
            "IsImmune(x) ::: x is immune"
        ]
    },
    {
        "premises-NL": [
            "If something is an antique and rare, then that thing is valuable.",
            "If something is both valuable and demanded, then it is popular.",
            "If something is both popular and sold, then it is expensive.",
            "If something is rare, then it is not available.",
            "If something is old and has history, then that thing is antique.",
            "If something is an antique and is unique, then it is valuable.",
            "If something is old and not available, then it is rare.",
            "If something is demanded, then that thing is both valuable and sold.",
            "If something has history and is collectible, then it is demanded.",
            "If something is valuable and rare, then it is expensive.",
            "If something is sold, then it is expensive.",
            "If something is collectible, then that thing is unique."
        ],
        "premises-FOL": [
            "∀x (Antique(x) ∧ Rare(x) → Valuable(x)) ::: If something is an antique and rare, then that thing is valuable.",
            "∀x (Valuable(x) ∧ IsDemanded(x) → IsPopular(x)) ::: If something is both valuable and demanded, then it is popular.",
            "∀x (IsPopular(x) ∧ IsSold(x) → Expensive(x)) ::: If something is both popular and sold, then it is expensive.",
            "∀x (Rare(x) → ¬IsAvailable(x)) ::: If something is rare, then it is not available.",
            "∀x (IsOld(x) ∧ HasHistory(x) → Antique(x)) ::: If something is old and has history, then that thing is antique.",
            "∀x (Antique(x) ∧ IsUnique(x) → Valuable(x)) ::: If something is an antique and is unique, then it is valuable.",
            "∀x (IsOld(x) ∧ ¬IsAvailable(x) → Rare(x)) ::: If something is old and not available, then it is rare.",
            "∀x (IsDemanded(x) → (Valuable(x) ∧ IsSold(x))) ::: If something is demanded, then that thing is both valuable and sold.",
            "∀x (HasHistory(x) ∧ IsCollectible(x) → IsDemanded(x)) ::: If something has history and is collectible, then it is demanded.",
            "∀x (Valuable(x) ∧ Rare(x) → Expensive(x)) ::: If something is valuable and rare, then it is expensive.",
            "∀x (IsSold(x) → Expensive(x)) ::: If something is sold, then it is expensive.",
            "∀x (IsCollectible(x) → IsUnique(x)) ::: If something is collectible, then that thing is unique."
        ],
        "predicates": [
            "Valuable(x) ::: x is valuable",
            "Rare(x) ::: x is rare",
            "Expensive(x) ::: x is expensive",
            "IsCollectible(x) ::: x is collectible",
            "IsAntique(x) ::: x is an antique",
            "IsOld(x) ::: x is old",
            "HasHistory(x) ::: x has a history",
            "IsPopular(x) ::: x is popular",
            "IsDemanded(x) ::: x is demanded",
            "IsUnique(x) ::: x is unique",
            "IsAvailable(x) ::: x is available",
            "IsSold(x) ::: x is sold"
        ]
    },
    {
        "premises-NL": [
            "All students are studying.",
            "Some students are enrolled in a seminar.",
            "Everyone who is a student and enrolled in a seminar likes logic.",
            "Alice is a student.",
            "Bob is enrolled in a seminar.",
            "Charlie is studying."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Studying(x)) ::: All students are studying.",
            "∃x (Student(x) ∧ EnrolledInSeminar(x)) ::: Some students are enrolled in a seminar.",
            "∀x ((Student(x) ∧ EnrolledInSeminar(x)) → LikesLogic(x)) ::: Everyone who is a student and enrolled in a seminar likes logic.",
            "Student(alice) ::: Alice is a student.",
            "EnrolledInSeminar(bob) ::: Bob is enrolled in a seminar.",
            "Studying(charlie) ::: Charlie is studying."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studying(x) ::: x is studying",
            "EnrolledInSeminar(x) ::: x is enrolled in a seminar"
        ]
    },
    {
        "premises-NL": [
            "All plants are green or have leaves.",
            "Some plants get sunlight.",
            "All plants that are green get water.",
            "If a plant gets sunlight and is green, then it grows.",
            "Every plant either gets sunlight or does not have leaves.",
            "Rose is a plant.",
            "Rose gets sunlight."
        ],
        "premises-FOL": [
            "∀x (Plant(x) → (IsGreen(x) ∨ HasLeaves(x))) ::: All plants are green or have leaves.",
            "∃x (Plant(x) ∧ GetsSunlight(x)) ::: Some plants get sunlight.",
            "∀x ((Plant(x) ∧ IsGreen(x)) → GetsWater(x)) ::: All plants that are green get water.",
            "∀x ((Plant(x) ∧ GetsSunlight(x) ∧ IsGreen(x)) → Grows(x)) ::: If a plant gets sunlight and is green, then it grows.",
            "∀x (Plant(x) → (GetsSunlight(x) ∨ ¬HasLeaves(x))) ::: Every plant either gets sunlight or does not have leaves.",
            "Plant(rose) ::: Rose is a plant.",
            "GetsSunlight(rose) ::: Rose gets sunlight."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "GetsSunlight(x) ::: x gets sunlight",
            "GetsWater(x) ::: x gets water",
            "Grows(x) ::: x grows",
            "IsGreen(x) ::: x is green",
            "HasLeaves(x) ::: x has leaves"
        ]
    },
    {
        "premises-NL": [
            "All students are studying or lazy.",
            "Some students like coffee.",
            "All students who attend class are studying.",
            "Anyone who studies and likes coffee passes the exam.",
            "If someone passes the exam, they are not lazy.",
            "Alice is a student and attends class.",
            "Alice likes coffee.",
            "Bob is lazy.",
            "Alice has a book and reads it."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Studying(x) ∨ Lazy(x))) ::: All students are studying or lazy.",
            "∃x (Student(x) ∧ LikesCoffee(x)) ::: Some students like coffee.",
            "∀x (Student(x) ∧ AttendsClass(x) → Studying(x)) ::: All students who attend class are studying.",
            "∀x (Studying(x) ∧ LikesCoffee(x) → PassesExam(x)) ::: Anyone who studies and likes coffee passes the exam.",
            "∀x (PassesExam(x) → ¬Lazy(x)) ::: If someone passes the exam, they are not lazy.",
            "Student(alice) ∧ AttendsClass(alice) ::: Alice is a student and attends class.",
            "LikesCoffee(alice) ::: Alice likes coffee.",
            "Lazy(bob) ::: Bob is lazy.",
            "∃y (HasBook(alice, y) ∧ ReadsBook(alice, y)) ::: Alice has a book and reads it."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studying(x) ::: x is studying",
            "Lazy(x) ::: x is lazy",
            "LikesCoffee(x) ::: x likes coffee",
            "AttendsClass(x) ::: x attends class",
            "PassesExam(x) ::: x passes the exam",
            "HasBook(x, y) ::: x has book y",
            "ReadsBook(x, y) ::: x reads book y"
        ]
    },
    {
        "premises-NL": [
            "All cats are mammals.",
            "Felix is a cat.",
            "Felix likes to play."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → Mammal(x)) ::: All cats are mammals.",
            "Cat(felix) ::: Felix is a cat.",
            "Likes(felix, play) ::: Felix likes to play.",
            "Cat(whiskers) ::: Whiskers is a cat.",
            "Likes(whiskers, play) ::: Whiskers likes to play."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Mammal(x) ::: x is a mammal",
            "Likes(x, y) ::: x likes y"
        ]
    },
    {
        "premises-NL": [
            "All students who attend the lecture are enrolled in the course.",
            "Some students attend the lecture.",
            "All students take the exam.",
            "Alice is a student.",
            "Bob attends the lecture.",
            "If someone takes the exam they are enrolled in the course."
        ],
        "premises-FOL": [
            "∀x ((Student(x) ∧ AttendLecture(x)) → EnrolledInCourse(x)) ::: All students who attend the lecture are enrolled in the course.",
            "∃x (Student(x) ∧ AttendLecture(x)) ::: Some students attend the lecture.",
            "∀x (Student(x) → TakesExam(x)) ::: All students take the exam.",
            "Student(alice) ::: Alice is a student.",
            "AttendLecture(bob) ::: Bob attends the lecture.",
            "∀x (TakesExam(x) → EnrolledInCourse(x)) ::: If someone takes the exam they are enrolled in the course."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "AttendLecture(x) ::: x attends the lecture.",
            "EnrolledInCourse(x) ::: x is enrolled in the course.",
            "TakesExam(x) ::: x takes the exam"
        ]
    },
    {
        "premises-NL": [
            "All doctors are kind.",
            "No doctor is a liar.",
            "If someone treats a patient, they are helpful.",
            "Every doctor speaks the truth.",
            "Dr. Smith is a doctor.",
            "Dr. Smith treats John.",
            "If someone is a doctor and treats a patient, then they are kind.",
            "Dr. Smith is not a liar.",
            "John is a patient.",
            "All helpful people speak the truth.",
            "Some doctors are helpful.",
            "If someone is a doctor, they are kind.",
            "If someone is a doctor, they are not a liar.",
            "Dr. Smith speaks the truth."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Kind(x)) ::: All doctors are kind.",
            "∀x (Doctor(x) → ¬Liar(x)) ::: No doctor is a liar.",
            "∀x ∀y (Treats(x, y) → Helpful(x)) ::: If someone treats a patient, they are helpful.",
            "∀x (Doctor(x) → SpeaksTruth(x)) ::: Every doctor speaks the truth.",
            "Doctor(smith) ::: Dr. Smith is a doctor.",
            "Treats(smith, john) ::: Dr. Smith treats John.",
            "∀x ∀y ((Doctor(x) ∧ Treats(x, y)) → Kind(x)) ::: If someone is a doctor and treats a patient, then they are kind.",
            "¬Liar(smith) ::: Dr. Smith is not a liar.",
            "Patient(john) ::: John is a patient.",
            "∀x (Helpful(x) → SpeaksTruth(x)) ::: All helpful people speak the truth.",
            "∃x (Doctor(x) ∧ Helpful(x)) ::: Some doctors are helpful.",
            "∀x (Doctor(x) → Kind(x)) ::: If someone is a doctor, they are kind.",
            "∀x (Doctor(x) → ¬Liar(x)) ::: If someone is a doctor, they are not a liar.",
            "SpeaksTruth(smith) ::: Dr. Smith speaks the truth."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Kind(x) ::: x is kind",
            "Liar(x) ::: x is a liar",
            "Patient(x) ::: x is a patient",
            "Treats(x, y) ::: x treats y",
            "Helpful(x) ::: x is helpful",
            "SpeaksTruth(x) ::: x speaks the truth"
        ]
    },
    {
        "premises-NL": [
            "All productive employees meet their quota.",
            "All employees who are team players are also collaborative.",
            "If an employee meets their quota, they get a bonus.",
            "If an employee is collaborative and has good ideas, then they work hard.",
            "If an employee is productive and works hard, they are promoted.",
            "Alice is an employee.",
            "Alice is productive.",
            "Alice is a team player.",
            "Bob is an employee.",
            "Bob meets his quota.",
            "Bob is collaborative and has good ideas.",
            "If someone is productive, they meet the quota.",
            "If someone is collaborative, they are a team player.",
            "If an employee meets the quota and is collaborative, they will receive a bonus.",
            "If someone is productive and collaborative, then they receive a bonus."
        ],
        "premises-FOL": [
            "∀x (Productive(x) → MeetsQuota(x)) ::: All productive employees meet their quota.",
            "∀x (TeamPlayer(x) → Collaborative(x)) ::: All employees who are team players are also collaborative.",
            "∀x (MeetsQuota(x) → ReceivesBonus(x)) ::: If an employee meets their quota, they get a bonus.",
            "∀x ((Collaborative(x) ∧ HasGoodIdeas(x)) → WorksHard(x)) ::: If an employee is collaborative and has good ideas, then they work hard.",
            "∀x ((Productive(x) ∧ WorksHard(x)) → Promoted(x)) ::: If an employee is productive and works hard, they are promoted.",
            "Employee(alice) ::: Alice is an employee.",
            "Productive(alice) ::: Alice is productive.",
            "TeamPlayer(alice) ::: Alice is a team player.",
            "Employee(bob) ::: Bob is an employee.",
            "MeetsQuota(bob) ::: Bob meets his quota.",
            "Collaborative(bob) ∧ HasGoodIdeas(bob) ::: Bob is collaborative and has good ideas.",
            "∀x (Productive(x) → MeetsQuota(x)) ::: If someone is productive, they meet the quota.",
            "∀x (Collaborative(x) → TeamPlayer(x)) ::: If someone is collaborative, they are a team player.",
            "∀x ((MeetsQuota(x) ∧ Collaborative(x)) → ReceivesBonus(x)) ::: If an employee meets the quota and is collaborative, they will receive a bonus.",
            "∀x ((Productive(x) ∧ Collaborative(x)) → ReceivesBonus(x)) ::: If someone is productive and collaborative, then they receive a bonus."
        ],
        "predicates": [
            "Employee(x) ::: x is an employee",
            "Productive(x) ::: x is productive",
            "Collaborative(x) ::: x is collaborative",
            "ReceivesBonus(x) ::: x receives a bonus",
            "Promoted(x) ::: x is promoted",
            "MeetsQuota(x) ::: x meets the quota",
            "TeamPlayer(x) ::: x is a team player",
            "WorksHard(x) ::: x works hard",
            "HasGoodIdeas(x) ::: x has good ideas"
        ]
    },
    {
        "premises-NL": [
            "All students who attend the lecture are smart.",
            "All smart people study.",
            "Some students attend the lecture.",
            "Everyone who likes coffee is smart.",
            "Some students like coffee.",
            "Every smart person studies.",
            "All people who study are students."
        ],
        "premises-FOL": [
            "∀x (AttendsLecture(x) ∧ Student(x) → Smart(x)) ::: All students who attend the lecture are smart.",
            "∀x (Smart(x) → Study(x)) ::: All smart people study.",
            "∃x (Student(x) ∧ AttendsLecture(x)) ::: Some students attend the lecture.",
            "∀x (LikesCoffee(x) → Smart(x)) ::: Everyone who likes coffee is smart.",
            "∃x (Student(x) ∧ LikesCoffee(x)) ::: Some students like coffee.",
            "∀x (Smart(x) → Study(x)) ::: Every smart person studies.",
            "∀x (Study(x) → Student(x)) ::: All people who study are students."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsLecture(x) ::: x attends the lecture",
            "Study(x) ::: x studies",
            "Smart(x) ::: x is smart",
            "LikesCoffee(x) ::: x likes coffee"
        ]
    },
    {
        "premises-NL": [
            "All doctors work long hours.",
            "Everyone who works long hours has patients.",
            "All doctors' jobs are stressful.",
            "Anyone whose job is stressful is not happy.",
            "Some doctors take breaks.",
            "People who take breaks are relaxed.",
            "All relaxed people are happy.",
            "Every doctor has patients."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → WorksLongHours(x)) ::: All doctors work long hours.",
            "∀x (WorksLongHours(x) → HasPatients(x)) ::: Everyone who works long hours has patients.",
            "∀x (Doctor(x) → IsStressful(x)) ::: All doctors' jobs are stressful.",
            "∀x (IsStressful(x) → ¬Happy(x)) ::: Anyone whose job is stressful is not happy.",
            "∃x (Doctor(x) ∧ TakesBreaks(x)) ::: Some doctors take breaks.",
            "∀x (TakesBreaks(x) → Relaxed(x)) ::: People who take breaks are relaxed.",
            "∀x (Relaxed(x) → Happy(x)) ::: All relaxed people are happy.",
            "∀x (Doctor(x) → HasPatients(x)) ::: Every doctor has patients."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Happy(x) ::: x is happy",
            "WorksLongHours(x) ::: x works long hours",
            "HasPatients(x) ::: x has patients",
            "IsStressful(x) ::: x's job is stressful",
            "TakesBreaks(x) ::: x takes breaks",
            "Relaxed(x) ::: x is relaxed"
        ]
    },
    {
        "premises-NL": [
            "All scientists read books.",
            "Everyone who reads books is curious.",
            "Some scientists study nature.",
            "All who study nature are curious.",
            "Everyone who is curious loves knowledge.",
            "Anyone who loves knowledge writes reports.",
            "Some scientists write reports.",
            "All writers publish papers.",
            "All who publish papers attend conferences."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → ReadsBooks(x)) ::: All scientists read books.",
            "∀x (ReadsBooks(x) → IsCurious(x)) ::: Everyone who reads books is curious.",
            "∃x (Scientist(x) ∧ StudiesNature(x)) ::: Some scientists study nature.",
            "∀x (StudiesNature(x) → IsCurious(x)) ::: All who study nature are curious.",
            "∀x (IsCurious(x) → LovesKnowledge(x)) ::: Everyone who is curious loves knowledge.",
            "∀x (LovesKnowledge(x) → WritesReports(x)) ::: Anyone who loves knowledge writes reports.",
            "∃x (Scientist(x) ∧ WritesReports(x)) ::: Some scientists write reports.",
            "∀x (Writer(x) → PublishesPapers(x)) ::: All writers publish papers.",
            "∀x (PublishesPapers(x) → AttendsConferences(x)) ::: All who publish papers attend conferences."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Writer(x) ::: x is a writer",
            "ReadsBooks(x) ::: x reads books",
            "StudiesNature(x) ::: x studies nature",
            "IsCurious(x) ::: x is curious",
            "WritesReports(x) ::: x writes reports",
            "PublishesPapers(x) ::: x publishes papers",
            "LovesKnowledge(x) ::: x loves knowledge",
            "AttendsConferences(x) ::: x attends conferences"
        ]
    },
    {
        "premises-NL": [
            "Everyone who likes cats likes pets.",
            "Everyone who likes pets owns cats or dogs.",
            "Some people like cats.",
            "All people who own cats like cats.",
            "Anyone who owns dogs likes dogs.",
            "Some people are friendly.",
            "All friendly people are social.",
            "All social people help people.",
            "All people who feed animals like pets.",
            "Some people feed animals."
        ],
        "premises-FOL": [
            "∀x (LikesCats(x) → LikesPets(x)) ::: Everyone who likes cats likes pets.",
            "∀x (LikesPets(x) → (OwnsCats(x) ∨ OwnsDogs(x))) ::: Everyone who likes pets owns cats or dogs.",
            "∃x LikesCats(x) ::: Some people like cats.",
            "∀x (OwnsCats(x) → LikesCats(x)) ::: All people who own cats like cats.",
            "∀x (OwnsDogs(x) → LikesDogs(x)) ::: Anyone who owns dogs likes dogs.",
            "∃x IsFriendly(x) ::: Some people are friendly.",
            "∀x (IsFriendly(x) → IsSocial(x)) ::: All friendly people are social.",
            "∀x (IsSocial(x) → HelpsPeople(x)) ::: All social people help people.",
            "∀x (FeedsAnimals(x) → LikesPets(x)) ::: All people who feed animals like pets.",
            "∃x FeedsAnimals(x) ::: Some people feed animals."
        ],
        "predicates": [
            "LikesCats(x) ::: x likes cats",
            "HasDogs(x) ::: x has dogs",
            "LikesPets(x) ::: x likes pets",
            "OwnsCats(x) ::: x owns cats",
            "OwnsDogs(x) ::: x owns dogs",
            "LikesDogs(x) ::: x likes dogs",
            "IsFriendly(x) ::: x is friendly",
            "IsSocial(x) ::: x is social",
            "HelpsPeople(x) ::: x helps people",
            "FeedsAnimals(x) ::: x feeds animals"
        ]
    },
    {
        "premises-NL": [
            "All people who run marathons are athletic.",
            "All athletic people are healthy.",
            "Everyone who loves sports participates in sports.",
            "Some tall people are athletic.",
            "All who eat vegetables are healthy.",
            "All people who are healthy enjoys outdoors.",
            "Anyone who enjoys outdoors watches sports.",
            "All who participate in sports play basketball.",
            "Some tall people love sports.",
            "All competitive people play basketball.",
            "Some people are competitive."
        ],
        "premises-FOL": [
            "∀x (RunsMarathons(x) → IsAthletic(x)) ::: All people who run marathons are athletic.",
            "∀x (IsAthletic(x) → IsHealthy(x)) ::: All athletic people are healthy.",
            "∀x (LovesSports(x) → ParticipatesInSports(x)) ::: Everyone who loves sports participates in sports.",
            "∃x (Tall(x) ∧ IsAthletic(x)) ::: Some tall people are athletic.",
            "∀x (EatsVegetables(x) → IsHealthy(x)) ::: All who eat vegetables are healthy.",
            "∀x (IsHealthy(x) → EnjoysOutdoors(x)) ::: All people who are healthy enjoys outdoors.",
            "∀x (EnjoysOutdoors(x) → WatchesSports(x)) ::: Anyone who enjoys outdoors watches sports.",
            "∀x (ParticipatesInSports(x) → PlaysBasketball(x)) ::: All who participate in sports play basketball.",
            "∃x (Tall(x) ∧ LovesSports(x)) ::: Some tall people love sports.",
            "∀x (IsCompetitive(x) → PlaysBasketball(x)) ::: All competitive people play basketball.",
            "∃x IsCompetitive(x) ::: Some people are competitive."
        ],
        "predicates": [
            "Tall(x) ::: x is tall",
            "PlaysBasketball(x) ::: x plays basketball",
            "IsAthletic(x) ::: x is athletic",
            "LovesSports(x) ::: x loves sports",
            "IsHealthy(x) ::: x is healthy",
            "EatsVegetables(x) ::: x eats vegetables",
            "EnjoysOutdoors(x) ::: x enjoys outdoors",
            "RunsMarathons(x) ::: x runs marathons",
            "ParticipatesInSports(x) ::: x participates in sports",
            "WatchesSports(x) ::: x watches sports",
            "IsCompetitive(x) ::: x is competitive"
        ]
    },
    {
        "premises-NL": [
            "All students attend a lecture or study.",
            "Some students study.",
            "Anyone who studies, passes the exam.",
            "No one who passes the exam is unhappy.",
            "David is a student.",
            "David does not pass the exam.",
            "Alice is a student.",
            "Alice attends a lecture.",
            "Alice is not happy."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (AttendsLecture(x) ∨ Studies(x))) ::: All students attend a lecture or study.",
            "∃x (Student(x) ∧ Studies(x)) ::: Some students study.",
            "∀x (Studies(x) → PassesExam(x)) ::: Anyone who studies, passes the exam.",
            "∀x (PassesExam(x) → Happy(x)) ::: No one who passes the exam is unhappy.",
            "Student(David) ::: David is a student.",
            "¬PassesExam(David) ::: David does not pass the exam.",
            "Student(Alice) ::: Alice is a student.",
            "AttendsLecture(Alice) ::: Alice attends a lecture.",
            "¬Happy(Alice) ::: Alice is not happy."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "AttendsLecture(x) ::: x attends a lecture.",
            "Happy(x) ::: x is happy.",
            "PassesExam(x) ::: x passes the exam.",
            "Studies(x) ::: x studies."
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "No worker is a student.",
            "Some students live in the city.",
            "Anyone who lives in the city works or is a student.",
            "John is a student.",
            "The city is located in the country.",
            "Everyone is either a worker or a student.",
            "Some people who live in the country are not workers.",
            "No student teaches anyone.",
            "There is a city.",
            "John does not teach anyone.",
            "John lives in the country."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "∀x (Worker(x) → ¬Student(x)) ::: No worker is a student.",
            "∃x (Student(x) ∧ LivesIn(x, city)) ::: Some students live in the city.",
            "∀x (LivesIn(x, city) → (Worker(x) ∨ Student(x))) ::: Anyone who lives in the city works or is a student.",
            "Student(John) ::: John is a student.",
            "LocatedIn(city, country) ::: The city is located in the country.",
            "∀x (Worker(x) ∨ Student(x)) ::: Everyone is either a worker or a student.",
            "∃x (LivesIn(x, country) ∧ ¬Worker(x)) ::: Some people who live in the country are not workers.",
            "∀x ∀y (Student(x) → ¬Teaches(x, y)) ::: No student teaches anyone.",
            "∃x LocatedIn(x, country) ::: There is a city.",
            "∀y ¬Teaches(John, y) ::: John does not teach anyone.",
            "LivesIn(John, country) ::: John lives in the country."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Worker(x) ::: x is a worker.",
            "LivesIn(x, y) ::: x lives in y.",
            "Smart(x) ::: x is smart.",
            "LocatedIn(x, y) ::: x is located in y.",
            "Teaches(x, y) ::: x teaches y."
        ]
    },
    {
        "premises-NL": [
            "All students like either math or science.",
            "Some students study math.",
            "Some students study science.",
            "If a student studies math and science, then they like both.",
            "Some students like math.",
            "If someone likes something, then they study that subject.",
            "If someone studies science they study something.",
            "If someone studies math they study something.",
            "If x studies science and math, then x studies both."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Studies(x, math) ∨ Studies(x, science))) ::: All students like either math or science.",
            "∃x (Student(x) ∧ Studies(x, math)) ::: Some students study math.",
            "∃x (Student(x) ∧ Studies(x, science)) ::: Some students study science.",
            "∀x (Student(x) ∧ Studies(x, math) ∧ Studies(x, science) → Likes(x, math) ∧ Likes(x, science)) ::: If a student studies math and science, then they like both.",
            "∃x (Student(x) ∧ Likes(x, math)) ::: Some students like math.",
            "∀x ∀y (Likes(x, y) → Studies(x, y)) ::: If someone likes something, then they study that subject.",
            "∀x ∃y (Studies(x, science) → Studies(x, y)) ::: If someone studies science they study something.",
            "∀x ∃y (Studies(x, math) → Studies(x, y)) ::: If someone studies math they study something.",
            "∀x (Studies(x, science) ∧ Studies(x, math) → Studies(x, science) ∧ Studies(x, math)) ::: If x studies science and math, then x studies both."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x, y) ::: x studies y",
            "Math(x) ::: x is math",
            "Science(x) ::: x is science",
            "Likes(x, y) ::: x likes y"
        ]
    },
    {
        "premises-NL": [
            "All programmers are smart.",
            "Some students are programmers.",
            "All smart people know how to code.",
            "Everyone who is enrolled in a CS course is a student.",
            "If someone is a programmer, they are good at coding.",
            "There exists a CS course.",
            "If someone is good at coding, they know how to code."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → Smart(x)) ::: All programmers are smart.",
            "∃x (Student(x) ∧ Programmer(x)) ::: Some students are programmers.",
            "∀x (Smart(x) → KnowsCode(x)) ::: All smart people know how to code.",
            "∀x ∀y (CSCourse(y) ∧ Enrolled(x, y) → Student(x)) ::: Everyone who is enrolled in a CS course is a student.",
            "∀x (Programmer(x) → GoodAtCoding(x)) ::: If someone is a programmer, they are good at coding.",
            "∃x CSCourse(x) ::: There exists a CS course.",
            "∀x (GoodAtCoding(x) → KnowsCode(x)) ::: If someone is good at coding, they know how to code."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "Student(x) ::: x is a student",
            "Smart(x) ::: x is smart",
            "KnowsCode(x) ::: x knows how to code",
            "Enrolled(x, y) ::: x is enrolled in y",
            "CSCourse(x) ::: x is a CS course",
            "GoodAtCoding(x) ::: x is good at coding"
        ]
    },
    {
        "premises-NL": [
            "All students who are intelligent study hard.",
            "Some students are intelligent.",
            "Everyone is either a student or not intelligent.",
            "If someone is a student and not intelligent, they don't study hard.",
            "If x studies hard, then x is a student.",
            "If x is not a student, then x is not intelligent.",
            "Some students are not intelligent.",
            "Some students are both intelligent and study hard.",
            "Some people are not students.",
            "Every student is either intelligent or they don't study hard.",
            "If someone is a student and intelligent, then they study hard.",
            "If x is intelligent, then x is a student.",
            "If x is a student, then x is intelligent.",
            "If x studies hard, then x is intelligent."
        ],
        "premises-FOL": [
            "∀x ((Student(x) ∧ Intelligent(x)) → StudyHard(x)) ::: All intelligent students study hard.",
            "∃x (Student(x) ∧ Intelligent(x)) ::: Some students are intelligent.",
            "∀x (Student(x) ∨ ¬Intelligent(x)) ::: Everyone is either a student or not intelligent.",
            "∀x ((Student(x) ∧ ¬Intelligent(x)) → ¬StudyHard(x)) ::: If a student is not intelligent, they don't study hard.",
            "∀x (StudyHard(x) → Student(x)) ::: If someone studies hard, then they are a student.",
            "∀x (¬Student(x) → ¬Intelligent(x)) ::: If someone is not a student, then they are not intelligent.",
            "∃x (Student(x) ∧ ¬Intelligent(x)) ::: Some students are not intelligent.",
            "∃x (Student(x) ∧ Intelligent(x) ∧ StudyHard(x)) ::: Some students are both intelligent and study hard.",
            "∃x ¬Student(x) ::: Some people are not students.",
            "∀x (Student(x) → (Intelligent(x) ∨ ¬StudyHard(x))) ::: Every student is either intelligent or they don't study hard.",
            "∀x ((Student(x) ∧ Intelligent(x)) → StudyHard(x)) ::: If someone is a student and intelligent, then they study hard.",
            "∀x (Intelligent(x) → Student(x)) ::: If x is intelligent, then x is a student.",
            "∀x (Student(x) → Intelligent(x)) ::: If x is a student, then x is intelligent.",
            "∀x (StudyHard(x) → Intelligent(x)) ::: If x studies hard, then x is intelligent."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Intelligent(x) ::: x is intelligent",
            "StudyHard(x) ::: x studies hard"
        ]
    },
    {
        "premises-NL": [
            "All mammals are warm-blooded.",
            "Fido is a mammal.",
            "Fido is a dog.",
            "All dogs are mammals.",
            "No cats are dogs.",
            "If something is a dog, it is a mammal.",
            "If something is a mammal, it is an animal.",
            "Every cat is an animal.",
            "No animal is a rock.",
            "Fido is not a rock.",
            "If x is a mammal, x is warm-blooded.",
            "If x is a dog, then x is a mammal.",
            "If x is a cat, then x is an animal.",
            "If x is not warm-blooded, then x is not a mammal.",
            "No mammal is a rock."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → WarmBlooded(x)) ::: All mammals are warm-blooded.",
            "Mammal(fido) ::: Fido is a mammal.",
            "Dog(fido) ::: Fido is a dog.",
            "∀x (Dog(x) → Mammal(x)) ::: All dogs are mammals.",
            "∀x (¬Cat(x) ∨ ¬Dog(x)) ::: No cats are dogs.",
            "∀x (Dog(x) → Mammal(x)) ::: If something is a dog, it is a mammal.",
            "∀x (Mammal(x) → Animal(x)) ::: If something is a mammal, it is an animal.",
            "∀x (Cat(x) → Animal(x)) ::: Every cat is an animal.",
            "∀x (¬Animal(x) ∨ ¬Rock(x)) ::: No animal is a rock.",
            "¬Rock(fido) ::: Fido is not a rock.",
            "∀x (Mammal(x) → WarmBlooded(x)) ::: If x is a mammal, x is warm-blooded.",
            "∀x (Dog(x) → Mammal(x)) ::: If x is a dog, then x is a mammal.",
            "∀x (Cat(x) → Animal(x)) ::: If x is a cat, then x is an animal.",
            "∀x (¬WarmBlooded(x) → ¬Mammal(x)) ::: If x is not warm-blooded, then x is not a mammal.",
            "∀x (Mammal(x) → ¬Rock(x)) ::: No mammal is a rock."
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal",
            "WarmBlooded(x) ::: x is warm-blooded",
            "Dog(x) ::: x is a dog",
            "Cat(x) ::: x is a cat"
        ]
    },
    {
        "premises-NL": [
            "All roses are flowers.",
            "All flowers are plants.",
            "Some plants are red.",
            "If something is a rose then it is a plant.",
            "If something is a plant, it is a flower.",
            "If something is a flower it is red.",
            "Some roses are red.",
            "Some flowers are red.",
            "Some plants are not roses.",
            "All red things are flowers.",
            "If something is red it's a plant.",
            "If something is a flower and not red, it is not a rose.",
            "Some plants are roses.",
            "All roses are red.",
            "Some plants are not red.",
            "If x is red, then x is a flower."
        ],
        "premises-FOL": [
            "∀x (Rose(x) → Flower(x)) ::: All roses are flowers.",
            "∀x (Flower(x) → Plant(x)) ::: All flowers are plants.",
            "∃x (Plant(x) ∧ Red(x)) ::: Some plants are red.",
            "∀x (Rose(x) → Plant(x)) ::: If something is a rose then it is a plant.",
            "∀x (Plant(x) → Flower(x)) ::: If something is a plant, it is a flower.",
            "∀x (Flower(x) → Red(x)) ::: If something is a flower it is red.",
            "∃x (Rose(x) ∧ Red(x)) ::: Some roses are red.",
            "∃x (Flower(x) ∧ Red(x)) ::: Some flowers are red.",
            "∃x (Plant(x) ∧ ¬Rose(x)) ::: Some plants are not roses.",
            "∀x (Red(x) → Flower(x)) ::: All red things are flowers.",
            "∀x (Red(x) → Plant(x)) ::: If something is red it's a plant.",
            "∀x ((Flower(x) ∧ ¬Red(x)) → ¬Rose(x)) ::: If something is a flower and not red, it is not a rose.",
            "∃x (Plant(x) ∧ Rose(x)) ::: Some plants are roses.",
            "∀x (Rose(x) → Red(x)) ::: All roses are red.",
            "∃x (Plant(x) ∧ ¬Red(x)) ::: Some plants are not red.",
            "∀x (Red(x) → Flower(x)) ::: If x is red, then x is a flower."
        ],
        "predicates": [
            "Rose(x) ::: x is a rose",
            "Red(x) ::: x is red",
            "Flower(x) ::: x is a flower",
            "Plant(x) ::: x is a plant"
        ]
    },
    {
        "premises-NL": [
            "All students are individuals.",
            "Every course is either easy or difficult.",
            "If a student is enrolled in a course, then the student studies the course.",
            "If a student studies a course and the course is difficult, then the student struggles.",
            "If a student studies a course and the course is easy, then the student passes.",
            "Alice is a student.",
            "Alice is enrolled in Calculus.",
            "Calculus is a course.",
            "Either Calculus is easy or Calculus is difficult.",
            "Bob is a student.",
            "Bob is enrolled in Physics.",
            "Physics is a course.",
            "Physics is difficult."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Individual(x)) ::: All students are individuals.",
            "∀x (Course(x) → (Easy(x) ∨ Difficult(x))) ::: Every course is either easy or difficult.",
            "∀x ∀y (Student(x) ∧ EnrolledIn(x, y) → Studies(x, y)) ::: If a student is enrolled in a course, then the student studies the course.",
            "∀x ∀y (Studies(x, y) ∧ Difficult(y) → Struggles(x)) ::: If a student studies a course and the course is difficult, then the student struggles.",
            "∀x ∀y (Studies(x, y) ∧ Easy(y) → Passes(x, y)) ::: If a student studies a course and the course is easy, then the student passes.",
            "Student(alice) ::: Alice is a student.",
            "EnrolledIn(alice, calculus) ::: Alice is enrolled in Calculus.",
            "Course(calculus) ::: Calculus is a course.",
            "(Easy(calculus) ∨ Difficult(calculus)) ::: Either Calculus is easy or Calculus is difficult.",
            "Student(bob) ::: Bob is a student.",
            "EnrolledIn(bob, physics) ::: Bob is enrolled in Physics.",
            "Course(physics) ::: Physics is a course.",
            "Difficult(physics) ::: Physics is difficult."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "EnrolledIn(x, y) ::: x is enrolled in course y.",
            "Difficult(x) ::: Course x is difficult.",
            "Passes(x, y) ::: Student x passes course y.",
            "Struggles(x) ::: Student x struggles."
        ]
    },
    {
        "premises-NL": [
            "Sarah attends the conference.",
            "The conference is a valid conference.",
            "Anyone who attends the conference is an attendee.",
            "All attendees must be registered.",
            "Sarah is at the conference.",
            "The conference requires registration.",
            "If registration is required and someone attends, they must register.",
            "If someone is at a conference, they are an attendee.",
            "If someone attends, then they must register.",
            "All attendees are registered."
        ],
        "premises-FOL": [
            "Attends(sarah, conference1) ::: Sarah attends the conference.",
            "Conference(conference1) ::: The conference is a valid conference.",
            "∀x (Attends(x, conference1) → Attendee(x, conference1)) ::: Anyone who attends the conference is an attendee.",
            "∀x (Attendee(x, conference1) → Registered(x)) ::: All attendees must be registered.",
            "At(sarah, conference1) ::: Sarah is at the conference.",
            "RegistrationRequired(conference1) ::: The conference requires registration.",
            "∀x (RegistrationRequired(x) ∧ Attends(y, x) → Registered(y)) ::: If registration is required and someone attends, they must register.",
            "∀x (At(x, conference1) → Attendee(x, conference1)) ::: If someone is at a conference, they are an attendee.",
            "∀x (Attends(x, conference1) → Registered(x)) ::: If someone attends, then they must register.",
            "∀x (Attendee(x, conference1) → Registered(x)) ::: All attendees are registered."
        ],
        "predicates": [
            "Attends(x, y) ::: x attends conference y.",
            "Attendee(x, y) ::: x is an attendee of conference y.",
            "Registered(x) ::: x is registered.",
            "Conference(x) ::: x is a conference.",
            "RegistrationRequired(x) ::: Registration is required for conference x."
        ]
    },
    {
        "premises-NL": [
            "All people are either vegetarian or they eat meat.",
            "No vegetarian eats meat.",
            "People who have a dog eat meat.",
            "John has a dog.",
            "John is a person.",
            "Mary is a person.",
            "Mary eats meat.",
            "Someone has a dog.",
            "If someone has a dog and eats meat, then they are not a vegetarian.",
            "If someone is a person and a vegetarian, they are not someone who eats meat."
        ],
        "premises-FOL": [
            "∀x (Person(x) → (Vegetarian(x) ∨ EatsMeat(x))) ::: All people are either vegetarian or they eat meat.",
            "∀x (Vegetarian(x) → ¬EatsMeat(x)) ::: No vegetarian eats meat.",
            "∀x (HasDog(x) → EatsMeat(x)) ::: People who have a dog eat meat.",
            "HasDog(john) ::: John has a dog.",
            "Person(john) ::: John is a person.",
            "Person(mary) ::: Mary is a person.",
            "EatsMeat(mary) ::: Mary eats meat.",
            "∃x HasDog(x) ::: Someone has a dog.",
            "∀x (HasDog(x) ∧ EatsMeat(x) → ¬Vegetarian(x)) ::: If someone has a dog and eats meat, then they are not a vegetarian.",
            "∀x (Person(x) ∧ Vegetarian(x) → ¬EatsMeat(x)) ::: If someone is a person and a vegetarian, they are not someone who eats meat."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "HasDog(x) ::: x has a dog",
            "Vegetarian(x) ::: x is a vegetarian",
            "EatsMeat(x) ::: x eats meat"
        ]
    },
    {
        "premises-NL": [
            "All doctors are qualified.",
            "Anyone who is qualified treats a patient.",
            "If someone treats a patient, they have experience.",
            "John is a doctor.",
            "Mary is a patient.",
            "John treats Mary.",
            "All who treat patients have experience.",
            "Anyone who is a doctor is qualified or not a patient.",
            "If someone is qualified they treat Mary.",
            "If someone treats someone they are a doctor.",
            "There exists a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Qualified(x)) ::: All doctors are qualified.",
            "∀x ∀y (Qualified(x) → Treats(x, y)) ::: Anyone who is qualified treats a patient.",
            "∀x ∀y (Treats(x, y) → HasExperience(x)) ::: If someone treats a patient, they have experience.",
            "Doctor(john) ::: John is a doctor.",
            "Patient(mary) ::: Mary is a patient.",
            "Treats(john, mary) ::: John treats Mary.",
            "∀x ∃y (Treats(x, y) → HasExperience(x)) ::: All who treat patients have experience.",
            "∀x (Doctor(x) → (Qualified(x) ∨ ¬Patient(x))) ::: Anyone who is a doctor is qualified or not a patient.",
            "∀x (Qualified(x) → Treats(x, mary)) ::: If someone is qualified they treat Mary.",
            "∀x ∀y (Treats(x, y) → Doctor(x)) ::: If someone treats someone they are a doctor.",
            "∃x Doctor(x) ::: There exists a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Patient(x) ::: x is a patient",
            "Treats(x, y) ::: x treats y",
            "HasExperience(x) ::: x has experience",
            "Qualified(x) ::: x is qualified"
        ]
    },
    {
        "premises-NL": [
            "Every student attends class.",
            "Every student who attends class takes notes.",
            "Every student who takes notes studies hard.",
            "If a student studies hard, they understand the material.",
            "If a student understands the material, they pass the exam.",
            "All students are smart",
            "There is a student.",
            "All smart students studies hard.",
            "If a student is a student and studies hard then he understands the material.",
            "If student attends class, and student takes notes, then student studies hard.",
            "Student attends class and takes notes.",
            "If a student studies hard, then student takes notes"
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClass(x)) ::: Every student attends class.",
            "∀x (AttendsClass(x) → TakesNotes(x)) ::: Every student who attends class takes notes.",
            "∀x (TakesNotes(x) → StudiesHard(x)) ::: Every student who takes notes studies hard.",
            "∀x (StudiesHard(x) → UnderstandsMaterial(x)) ::: If a student studies hard, they understand the material.",
            "∀x (UnderstandsMaterial(x) → PassExam(x)) ::: If a student understands the material, they pass the exam.",
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "∃x Student(x) ::: There is a student.",
            "∀x (Student(x) ∧ Smart(x) → StudiesHard(x)) ::: All smart students studies hard.",
            "∀x (Student(x) ∧ StudiesHard(x) → UnderstandsMaterial(x)) ::: If a student is a student and studies hard then he understands the material.",
            "∀x (AttendsClass(x) ∧ TakesNotes(x) → StudiesHard(x)) ::: If student attends class, and student takes notes, then student studies hard.",
            "∃x (AttendsClass(x) ∧ TakesNotes(x)) ::: Student attends class and takes notes.",
            "∀x (StudiesHard(x) → TakesNotes(x)) ::: If a student studies hard, then student takes notes."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "AttendsClass(x) ::: x attends the class",
            "UnderstandsMaterial(x) ::: x understands the material",
            "TakesNotes(x) ::: x takes notes"
        ]
    },
    {
        "premises-NL": [
            "Every person with a cold either coughs or sneezes.",
            "Anyone who coughs feels unwell.",
            "Anyone who sneezes feels unwell.",
            "If someone has a cold and takes medicine, they won't feel unwell.",
            "If someone has a cold, they either take medicine or they don't.",
            "Every person is either healthy or has a cold.",
            "Some people have colds.",
            "Anyone who has a cold doesn't have a fever.",
            "If a person has a cold and coughs, then that person is not healthy.",
            "If a person doesn't have a fever, that person is healthy or has a cold.",
            "A person has a cold and sneezes.",
            "If someone feels unwell they have a cold.",
            "A person does not take medicine."
        ],
        "premises-FOL": [
            "∀x (HasCold(x) → (Coughs(x) ∨ Sneezes(x))) ::: Every person with a cold either coughs or sneezes.",
            "∀x (Coughs(x) → FeelsUnwell(x)) ::: Anyone who coughs feels unwell.",
            "∀x (Sneezes(x) → FeelsUnwell(x)) ::: Anyone who sneezes feels unwell.",
            "∀x (HasCold(x) ∧ TakesMedicine(x) → ¬FeelsUnwell(x)) ::: If someone has a cold and takes medicine, they won't feel unwell.",
            "∀x (HasCold(x) → (TakesMedicine(x) ∨ ¬TakesMedicine(x))) ::: If someone has a cold, they either take medicine or they don't.",
            "∀x (Person(x) → (Healthy(x) ∨ HasCold(x))) ::: Every person is either healthy or has a cold.",
            "∃x HasCold(x) ::: Some people have colds.",
            "∀x (HasCold(x) → ¬HasFever(x)) ::: Anyone who has a cold doesn't have a fever.",
            "∀x (HasCold(x) ∧ Coughs(x) → ¬Healthy(x)) ::: If a person has a cold and coughs, then that person is not healthy.",
            "∀x (¬HasFever(x) → (Healthy(x) ∨ HasCold(x))) ::: If a person doesn't have a fever, that person is healthy or has a cold.",
            "∃x (HasCold(x) ∧ Sneezes(x)) ::: A person has a cold and sneezes.",
            "∀x (FeelsUnwell(x) → HasCold(x)) ::: If someone feels unwell they have a cold.",
            "∃x ¬TakesMedicine(x) ::: A person does not take medicine."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "HasCold(x) ::: x has a cold",
            "TakesMedicine(x) ::: x takes medicine",
            "FeelsUnwell(x) ::: x feels unwell",
            "Cough(x) ::: x coughs",
            "Sneezes(x) ::: x sneezes",
            "HasFever(x) ::: x has a fever"
        ]
    },
    {
        "premises-NL": [
            "All apples are fruits.",
            "Some apples are red.",
            "All red fruits are delicious.",
            "If something is a fruit and grows on a tree, then it is an apple.",
            "Anything that is an apple is red or green.",
            "No bananas are red.",
            "All bananas are yellow.",
            "Some fruits are not apples.",
            "If something is delicious, it is a fruit.",
            "If something is not an apple and is not a banana, then it is not red.",
            "All apples are red.",
            "If something is a fruit, then it grows on a tree.",
            "If a fruit is red, it is delicious.",
            "There is at least one fruit"
        ],
        "premises-FOL": [
            "∀x (IsApple(x) → Fruit(x)) ::: All apples are fruits.",
            "∃x (IsApple(x) ∧ IsRed(x)) ::: Some apples are red.",
            "∀x (Fruit(x) ∧ IsRed(x) → Delicious(x)) ::: All red fruits are delicious.",
            "∀x (Fruit(x) ∧ GrowsOnTree(x) → IsApple(x)) ::: If something is a fruit and grows on a tree, then it is an apple.",
            "∀x (IsApple(x) → (IsRed(x) ∨ IsGreen(x))) ::: Anything that is an apple is red or green.",
            "∀x (IsBanana(x) → ¬IsRed(x)) ::: No bananas are red.",
            "∀x (IsBanana(x) → IsYellow(x)) ::: All bananas are yellow.",
            "∃x (Fruit(x) ∧ ¬IsApple(x)) ::: Some fruits are not apples.",
            "∀x (Delicious(x) → Fruit(x)) ::: If something is delicious, it is a fruit.",
            "∀x ((¬IsApple(x) ∧ ¬IsBanana(x)) → ¬IsRed(x)) ::: If something is not an apple and is not a banana, then it is not red.",
            "∀x (IsApple(x) → IsRed(x)) ::: All apples are red.",
            "∀x (Fruit(x) → GrowsOnTree(x)) ::: If something is a fruit, then it grows on a tree.",
            "∀x (Fruit(x) ∧ IsRed(x) → Delicious(x)) ::: If a fruit is red, it is delicious.",
            "∃x Fruit(x) ::: There is at least one fruit"
        ],
        "predicates": [
            "Fruit(x) ::: x is a fruit",
            "IsApple(x) ::: x is an apple",
            "IsRed(x) ::: x is red",
            "Delicious(x) ::: x is delicious",
            "GrowsOnTree(x) ::: x grows on a tree",
            "IsBanana(x) ::: x is a banana",
            "IsYellow(x) ::: x is yellow"
        ]
    },
    {
        "premises-NL": [
            "Every user is either active or inactive.",
            "If a page is popular, it posts content.",
            "If a user follows a page, the user sees the content of the page.",
            "If a user is active, they share content.",
            "If a user shares content, the user sees content.",
            "All popular pages post content.",
            "Every user follows some page.",
            "If a user is active and follows a popular page, then the user sees content.",
            "If a page posts content, then it is popular.",
            "A user follows a page.",
            "If a user follows a page and the page posts content, then the user sees content.",
            "Every page is either popular or not.",
            "Every active user shares the content.",
            "Every page that is posted by the user"
        ],
        "premises-FOL": [
            "∀x (User(x) → (IsActive(x) ∨ ¬IsActive(x))) ::: Every user is either active or inactive.",
            "∀y (IsPopular(y) → PostsContent(y)) ::: If a page is popular, it posts content.",
            "∀x ∀y (User(x) ∧ Page(y) ∧ Follows(x, y) → SeesContent(x)) ::: If a user follows a page, the user sees the content of the page.",
            "∀x (IsActive(x) → SharesContent(x, y)) ::: If a user is active, they share content.",
            "∀x (SharesContent(x, y) → SeesContent(x)) ::: If a user shares content, the user sees content.",
            "∀y (IsPopular(y) → PostsContent(y)) ::: All popular pages post content.",
            "∀x ∃y (User(x) → Follows(x, y)) ::: Every user follows some page.",
            "∀x ∀y (User(x) ∧ Page(y) ∧ IsPopular(y) ∧ Follows(x, y) → SeesContent(x)) ::: If a user is active and follows a popular page, then the user sees content.",
            "∀y (PostsContent(y) → IsPopular(y)) ::: If a page posts content, then it is popular.",
            "∃x ∃y (User(x) ∧ Follows(x, y)) ::: A user follows a page.",
            "∀x ∀y (User(x) ∧ Page(y) ∧ Follows(x, y) ∧ PostsContent(y) → SeesContent(x)) ::: If a user follows a page and the page posts content, then the user sees content.",
            "∀y (Page(y) → (IsPopular(y) ∨ ¬IsPopular(y))) ::: Every page is either popular or not.",
            "∀x (IsActive(x) → SharesContent(x, y)) ::: Every active user shares the content.",
            "∀y (Page(y) → PostsContent(y)) ::: Every page that is posted by the user"
        ],
        "predicates": [
            "User(x) ::: x is a user",
            "Page(y) ::: y is a page",
            "Follows(x, y) ::: x follows y",
            "PostsContent(y) ::: y posts content",
            "SeesContent(x) ::: x sees content",
            "IsActive(x) ::: x is active",
            "IsPopular(y) ::: y is popular",
            "SharesContent(x, y) ::: x shares content of y"
        ]
    },
    {
        "premises-NL": [
            "All patients are human beings.",
            "Having a fever and cough are symptoms of a flu or a cold.",
            "The flu and cold are caused by virus infections.",
            "Patients with flu receive treatment.",
            "If a patient receives a prescription, they take medication.",
            "Mary is a patient with a fever and a cough.",
            "A cough is a symptom of the flu or cold.",
            "The flu causes a cough.",
            "The cold causes a cough.",
            "If a patient has the flu, they receive treatment for the flu.",
            "If a patient has a fever, they could have the flu or a cold."
        ],
        "premises-FOL": [
            "∀x (Patient(x) → Human(x)) ::: All patients are human beings.",
            "∀x (Patient(x) ∧ Fever(x) ∧ Cough(x) → (HasFlu(x) ∨ HasCold(x))) ::: Having a fever and cough are symptoms of a flu or a cold.",
            "∀x ((HasFlu(x) ∨ HasCold(x)) → VirusInfection(x)) ::: The flu and cold are caused by virus infections.",
            "∀x (HasFlu(x) → ReceivesTreatment(x, FluTreatment)) ::: Patients with flu receive treatment.",
            "∀x ∀y (ReceivesTreatment(x, y) ∧ Prescription(y) → TakesMedication(x, y)) ::: If a patient receives a prescription, they take medication.",
            "Patient(Mary) ∧ Fever(Mary) ∧ Cough(Mary) ::: Mary is a patient with a fever and a cough.",
            "∀x (Cough(x) → (Symptom(x, Flu) ∨ Symptom(x, Cold))) ::: A cough is a symptom of the flu or cold.",
            "∀x (HasFlu(x) → Cough(x)) ::: The flu causes a cough.",
            "∀x (HasCold(x) → Cough(x)) ::: The cold causes a cough.",
            "∀x (HasFlu(x) → ReceivesTreatment(x, FluTreatment)) ::: If a patient has the flu, they receive treatment for the flu.",
            "∀x (Patient(x) ∧ Fever(x) → (HasFlu(x) ∨ HasCold(x))) ::: If a patient has a fever, they could have the flu or a cold."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient.",
            "Fever(x) ::: x has a fever.",
            "Cough(x) ::: x has a cough.",
            "HasFlu(x) ::: x has the flu.",
            "HasCold(x) ::: x has a cold.",
            "ReceivesTreatment(x, y) ::: Patient x receives treatment y.",
            "Prescription(x) ::: x is a prescription.",
            "TakesMedication(x, y) ::: Patient x takes medication y.",
            "Symptom(x, y) ::: x is a symptom of y.",
            "VirusInfection(x) ::: x is a virus infection.",
            "Causes(x, y) ::: x causes y."
        ]
    },
    {
        "premises-NL": [
            "If it is raining, the ground is wet.",
            "If the ground is wet, then the event is canceled.",
            "The event is happening.",
            "If the event is happening, the ground is wet.",
            "If the event is not cancelled, then it is happening.",
            "If it is not raining, then the event is not canceled.",
            "The event either happens or is canceled.",
            "If the ground is not wet then it is not raining.",
            "If something is an event and the event is happening, it's happening somewhere.",
            "There is at least one event.",
            "If the event is happening, and it is raining, it must be cancelled.",
            "If it is not raining, then the event does not happen.",
            "If the ground is wet, it is raining.",
            "If it is raining, then the event happens or is cancelled.",
            "If the event is cancelled, then it isn't happening."
        ],
        "premises-FOL": [
            "∀x (Raining(x) → WetGround(x)) ::: If it is raining, the ground is wet.",
            "∀x (WetGround(x) → CancelEvent(x)) ::: If the ground is wet, then the event is canceled.",
            "∃x Event(x) ∧ Happening(x) ::: The event is happening.",
            "∀x (Happening(x) → WetGround(x)) ::: If the event is happening, the ground is wet.",
            "∀x (¬CancelEvent(x) → Happening(x)) ::: If the event is not cancelled, then it is happening.",
            "∀x (¬Raining(x) → ¬CancelEvent(x)) ::: If it is not raining, then the event is not canceled.",
            "∀x (Happening(x) ∨ CancelEvent(x)) ::: The event either happens or is canceled.",
            "∀x (¬WetGround(x) → ¬Raining(x)) ::: If the ground is not wet then it is not raining.",
            "∀x ∀y (Event(x) ∧ Happening(x) → Happening(y)) ::: If something is an event and the event is happening, it's happening somewhere.",
            "∃x Event(x) ::: There is at least one event.",
            "∀x ((Event(x) ∧ Happening(x)) ∧ Raining(x) → CancelEvent(x)) ::: If the event is happening, and it is raining, it must be cancelled.",
            "∀x (¬Raining(x) → ¬Happening(x)) ::: If it is not raining, then the event does not happen.",
            "∀x (WetGround(x) → Raining(x)) ::: If the ground is wet, it is raining.",
            "∀x (Raining(x) → Happening(x) ∨ CancelEvent(x)) ::: If it is raining, then the event happens or is cancelled.",
            "∀x (CancelEvent(x) → ¬Happening(x)) ::: If the event is cancelled, then it isn't happening."
        ],
        "predicates": [
            "Raining(x) ::: x is raining.",
            "WetGround(x) ::: The ground is wet at x.",
            "Event(x) ::: x is an event.",
            "CancelEvent(x) ::: x is cancelled.",
            "Happening(x) ::: x is happening."
        ]
    },
    {
        "premises-NL": [
            "All doctors can prescribe medication.",
            "If someone can prescribe medication, they can help the patient.",
            "There is a patient who has a condition.",
            "If a doctor treats a patient, the doctor can help the patient.",
            "If a doctor can not treat a patient, then the doctor cannot help the patient.",
            "If someone has a condition and a doctor treats the patient, the doctor can prescribe medication.",
            "If someone has a condition and can help the patient, then the patient can be treated.",
            "A doctor is a person.",
            "If the doctor is able to prescribe and can help the patient, then the patient can be helped.",
            "If a doctor treats a patient, then the doctor can help the patient.",
            "If a doctor is treating a patient, the doctor is a doctor.",
            "If a doctor is treating a patient, the patient has a condition.",
            "Every patient has a condition.",
            "If a doctor helps a patient and the patient has a condition, the doctor is able to treat them.",
            "If a patient has a condition and is treated, then they can be helped.",
            "If a doctor treats a patient, then they help the patient."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → CanPrescribe(x)) ::: All doctors can prescribe medication.",
            "∀x (CanPrescribe(x) → CanHelpPatient(x)) ::: If someone can prescribe medication, they can help the patient.",
            "∃x Patient(x) ∧ HasCondition(x) ::: There is a patient who has a condition.",
            "∀x ∀y (Doctor(x) ∧ Treats(x, y) → CanHelpPatient(x)) ::: If a doctor treats a patient, the doctor can help the patient.",
            "∀x ∀y (¬Treats(x, y) → ¬CanHelpPatient(x)) ::: If a doctor can not treat a patient, then the doctor cannot help the patient.",
            "∀x ∀y (HasCondition(y) ∧ Treats(x, y) → CanPrescribe(x)) ::: If someone has a condition and a doctor treats the patient, the doctor can prescribe medication.",
            "∀x ∀y (HasCondition(y) ∧ CanHelpPatient(x) → Treats(x, y)) ::: If someone has a condition and can help the patient, then the patient can be treated.",
            "∀x Doctor(x) ::: A doctor is a person.",
            "∀x ∀y ((Doctor(x) ∧ CanPrescribe(x)) ∧ CanHelpPatient(y) → CanHelpPatient(y)) ::: If the doctor is able to prescribe and can help the patient, then the patient can be helped.",
            "∀x ∀y (Treats(x, y) → CanHelpPatient(x)) ::: If a doctor treats a patient, then the doctor can help the patient.",
            "∀x ∀y (Treats(x, y) → Doctor(x)) ::: If a doctor is treating a patient, the doctor is a doctor.",
            "∀x ∀y (Treats(x, y) → HasCondition(y)) ::: If a doctor is treating a patient, the patient has a condition.",
            "∀x (Patient(x) → HasCondition(x)) ::: Every patient has a condition.",
            "∀x ∀y (CanHelpPatient(x) ∧ HasCondition(y) → Treats(x, y)) ::: If a doctor helps a patient and the patient has a condition, the doctor is able to treat them.",
            "∀x ∀y (HasCondition(y) ∧ Treats(x, y) → CanHelpPatient(y)) ::: If a patient has a condition and is treated, then they can be helped.",
            "∀x ∀y (Treats(x, y) → CanHelpPatient(x)) ::: If a doctor treats a patient, then they help the patient."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "CanPrescribe(x) ::: x can prescribe medication.",
            "Patient(x) ::: x is a patient.",
            "HasCondition(x) ::: x has a medical condition.",
            "CanHelpPatient(x) ::: x can help the patient.",
            "Treats(x, y) ::: x treats y."
        ]
    },
    {
        "premises-NL": [
            "All scientists are either involved in research or they publish papers.",
            "If someone is involved in research, they have a grant.",
            "If someone publishes papers, they work at a university.",
            "No one who does not have a grant publishes papers.",
            "If someone works at a university, then that person is involved in research or publishes papers.",
            "If someone is a scientist, they either have a grant or work at a university.",
            "If someone does not publish papers, then they have no grant.",
            "If someone has a grant, then they work at a university.",
            "Everyone who works at the university is a scientist.",
            "Anyone who is a scientist and has no grant will not publish papers.",
            "If someone is not involved in research, then the person has no grant.",
            "If a person has a grant, the person is involved in research.",
            "If someone does not have a grant, then they do not work at the university.",
            "If someone works at a university, then the person does research.",
            "If a person is a scientist and is involved in research, then the person has a grant.",
            "There is a person who is a scientist.",
            "If a person publishes papers, they are a scientist.",
            "If a person works at a university, that person publishes papers or does not have a grant."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → InvolvedInResearch(x) ∨ PublishesPapers(x)) ::: All scientists are either involved in research or they publish papers.",
            "∀x (InvolvedInResearch(x) → HasGrant(x)) ::: If someone is involved in research, they have a grant.",
            "∀x (PublishesPapers(x) → WorksAt(x, university)) ::: If someone publishes papers, they work at a university.",
            "∀x (¬HasGrant(x) → ¬PublishesPapers(x)) ::: No one who does not have a grant publishes papers.",
            "∀x (WorksAt(x, university) → InvolvedInResearch(x) ∨ PublishesPapers(x)) ::: If someone works at a university, then that person is involved in research or publishes papers.",
            "∀x (Scientist(x) → HasGrant(x) ∨ WorksAt(x, university)) ::: If someone is a scientist, they either have a grant or work at a university.",
            "∀x (¬PublishesPapers(x) → ¬HasGrant(x)) ::: If someone does not publish papers, then they have no grant.",
            "∀x (HasGrant(x) → WorksAt(x, university)) ::: If someone has a grant, then they work at a university.",
            "∀x (WorksAt(x, university) → Scientist(x)) ::: Everyone who works at the university is a scientist.",
            "∀x (Scientist(x) ∧ ¬HasGrant(x) → ¬PublishesPapers(x)) ::: Anyone who is a scientist and has no grant will not publish papers.",
            "∀x (¬InvolvedInResearch(x) → ¬HasGrant(x)) ::: If someone is not involved in research, then the person has no grant.",
            "∀x (HasGrant(x) → InvolvedInResearch(x)) ::: If a person has a grant, the person is involved in research.",
            "∀x (¬HasGrant(x) → ¬WorksAt(x, university)) ::: If someone does not have a grant, then they do not work at the university.",
            "∀x (WorksAt(x, university) → InvolvedInResearch(x)) ::: If someone works at a university, then the person does research.",
            "∀x (Scientist(x) ∧ InvolvedInResearch(x) → HasGrant(x)) ::: If a person is a scientist and is involved in research, then the person has a grant.",
            "∃x Scientist(x) ::: There is a person who is a scientist.",
            "∀x (PublishesPapers(x) → Scientist(x)) ::: If a person publishes papers, they are a scientist.",
            "∀x (WorksAt(x, university) → (PublishesPapers(x) ∨ ¬HasGrant(x))) ::: If a person works at a university, that person publishes papers or does not have a grant."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist.",
            "InvolvedInResearch(x) ::: x is involved in research.",
            "PublishesPapers(x) ::: x publishes papers.",
            "HasGrant(x) ::: x has a grant.",
            "WorksAt(x, y) ::: x works at y."
        ]
    },
    {
        "premises-NL": [
            "All students are smart or they study.",
            "John is a student.",
            "John does not study.",
            "Anyone who doesn't study, doesn't pass the exam.",
            "John does not pass the exam.",
            "If someone is smart, they will pass the exam.",
            "All students either pass the exam or are smart.",
            "Mary is a student.",
            "Mary studies.",
            "Mary is smart.",
            "Peter is a student.",
            "Peter studies or is smart."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Smart(x) ∨ Studies(x))) ::: All students are smart or they study.",
            "Student(john) ::: John is a student.",
            "¬Studies(john) ::: John does not study.",
            "∀x (¬Studies(x) → ¬PassesExam(x)) ::: Anyone who doesn't study, doesn't pass the exam.",
            "¬PassesExam(john) ::: John does not pass the exam.",
            "∀x (Smart(x) → PassesExam(x)) ::: If someone is smart, they will pass the exam.",
            "∀x (Student(x) → (PassesExam(x) ∨ Smart(x))) ::: All students either pass the exam or are smart.",
            "Student(mary) ::: Mary is a student.",
            "Studies(mary) ::: Mary studies.",
            "Smart(mary) ::: Mary is smart.",
            "Student(peter) ::: Peter is a student.",
            "Studies(peter) ∨ Smart(peter) ::: Peter studies or is smart."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Smart(x) ::: x is smart",
            "Studies(x) ::: x studies",
            "PassesExam(x) ::: x passes exam"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All specialists treat diseases.",
            "Some doctors are surgeons.",
            "Some specialists help patients.",
            "If someone is a doctor, they either help patients or they are specialists.",
            "Some doctors treat diseases.",
            "All surgeons help patients.",
            "John is a surgeon.",
            "If someone treats a disease, they help patients.",
            "Mary is a doctor.",
            "Every doctor is a specialist or a surgeon.",
            "Some doctors are not specialists.",
            "If someone is a specialist, they treat the disease."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Specialist(x) → TreatsDisease(x, y)) ::: All specialists treat diseases.",
            "∃x (Doctor(x) ∧ Surgeon(x)) ::: Some doctors are surgeons.",
            "∃x (Specialist(x) ∧ HelpsPatient(x)) ::: Some specialists help patients.",
            "∀x (Doctor(x) → (HelpsPatient(x) ∨ Specialist(x))) ::: If someone is a doctor, they either help patients or they are specialists.",
            "∃x (Doctor(x) ∧ TreatsDisease(x, y)) ::: Some doctors treat diseases.",
            "∀x (Surgeon(x) → HelpsPatient(x)) ::: All surgeons help patients.",
            "Surgeon(john) ::: John is a surgeon.",
            "∀x (TreatsDisease(x, y) → HelpsPatient(x)) ::: If someone treats a disease, they help patients.",
            "Doctor(mary) ::: Mary is a doctor.",
            "∀x (Doctor(x) → (Specialist(x) ∨ Surgeon(x))) ::: Every doctor is a specialist or a surgeon.",
            "∃x (Doctor(x) ∧ ¬Specialist(x)) ::: Some doctors are not specialists.",
            "∀x (Specialist(x) → TreatsDisease(x, y)) ::: If someone is a specialist, they treat the disease."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "HelpsPatient(x) ::: x helps patients",
            "Specialist(x) ::: x is a specialist",
            "TreatsDisease(x, y) ::: x treats disease y"
        ]
    },
    {
        "premises-NL": [
            "All programmers enjoy coding.",
            "Some programmers are creative.",
            "Everyone who enjoys coding is a programmer.",
            "If someone is creative, they are also a musician or a programmer.",
            "Not all creative people play music.",
            "John is a programmer.",
            "John is creative.",
            "John enjoys coding.",
            "If someone plays music, then they are a musician."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → EnjoysCoding(x)) ::: All programmers enjoy coding.",
            "∃x (Programmer(x) ∧ Creative(x)) ::: Some programmers are creative.",
            "∀x (EnjoysCoding(x) → Programmer(x)) ::: Everyone who enjoys coding is a programmer.",
            "∀x (Creative(x) → (Musician(x) ∨ Programmer(x))) ::: If someone is creative, they are also a musician or a programmer.",
            "¬∀x (Creative(x) → PlaysMusic(x)) ::: Not all creative people play music.",
            "Programmer(john) ::: John is a programmer.",
            "Creative(john) ::: John is creative.",
            "EnjoysCoding(john) ::: John enjoys coding.",
            "∀x (PlaysMusic(x) → Musician(x)) ::: If someone plays music, then they are a musician."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer.",
            "Musician(x) ::: x is a musician.",
            "Creative(x) ::: x is creative.",
            "EnjoysCoding(x) ::: x enjoys coding.",
            "PlaysMusic(x) ::: x plays music."
        ]
    },
    {
        "premises-NL": [
            "All students who have exams study hard.",
            "All students who study hard are not happy.",
            "Everyone who uses the library studies in the library.",
            "Some students have exams.",
            "Some students use the library.",
            "John is a student.",
            "John has an exam.",
            "If someone studies hard, then they use the library.",
            "If someone is happy, they do not have exams.",
            "Mary is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ HasExam(x) → StudyHard(x)) ::: All students who have exams study hard.",
            "∀x (StudyHard(x) → ¬Happy(x)) ::: All students who study hard are not happy.",
            "∀x (UsesLibrary(x) → StudyInLibrary(x)) ::: Everyone who uses the library studies in the library.",
            "∃x (Student(x) ∧ HasExam(x)) ::: Some students have exams.",
            "∃x (Student(x) ∧ UsesLibrary(x)) ::: Some students use the library.",
            "Student(john) ::: John is a student.",
            "HasExam(john) ::: John has an exam.",
            "∀x (StudyHard(x) → UsesLibrary(x)) ::: If someone studies hard, then they use the library.",
            "∀x (Happy(x) → ¬HasExam(x)) ::: If someone is happy, they do not have exams.",
            "Student(mary) ::: Mary is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudyInLibrary(x) ::: x studies in the library.",
            "Happy(x) ::: x is happy.",
            "HasExam(x) ::: x has an exam.",
            "StudyHard(x) ::: x studies hard.",
            "UsesLibrary(x) ::: x uses the library."
        ]
    },
    {
        "premises-NL": [
            "All biology students take Biology101.",
            "Alice is a biology student.",
            "Anyone who takes Biology101 does not teach it.",
            "No teacher takes Biology101.",
            "Alice is a student."
        ],
        "premises-FOL": [
            "∀x (BiologyStudent(x) → TakesCourse(x, Biology101)) ::: All biology students take Biology101.",
            "BiologyStudent(alice) ::: Alice is a biology student.",
            "∀x ∀y (TakesCourse(x, y) → ¬Teaches(x, y)) ::: Anyone who takes course y does not teach it.",
            "∀x ∀y (Teacher(x) → ¬TakesCourse(x, y)) ::: No teacher takes Biology101.",
            "Student(alice) ::: Alice is a student."
        ],
        "predicates": [
            "BiologyStudent(x) ::: x is a biology student.",
            "Teacher(x) ::: x is a teacher.",
            "TakesCourse(x, y) ::: x takes course y.",
            "Teaches(x, y) ::: x teaches course y."
        ]
    },
    {
        "premises-NL": [
            "Bob owns a car.",
            "All cars require a driver's license to drive.",
            "Bob has a driver's license.",
            "If someone owns something and has a license, they can drive the thing.",
            "car1 is a car."
        ],
        "premises-FOL": [
            "Owns(bob, car1) ::: Bob owns a car.",
            "∀x (Car(x) → RequiresLicense(x)) ::: All cars require a driver's license to drive.",
            "HasLicense(bob) ::: Bob has a driver's license.",
            "∀x ∀y (Owns(x, y) ∧ HasLicense(x) → Drives(x, y)) ::: If someone owns something and has a license, they can drive the thing.",
            "Car(car1) ::: car1 is a car.",
            "∀x (RequiresLicense(x) → HasLicense(bob)) :::  If something requires a license, then Bob has a license.",
            "∀x (Drives(bob, x) → Owns(bob, x)) ::: If Bob drives a car, then he owns a car."
        ],
        "predicates": [
            "Owns(x, y) ::: x owns y.",
            "Drives(x, y) ::: x drives y.",
            "Car(x) ::: x is a car.",
            "HasLicense(x) ::: x has a driver's license."
        ]
    },
    {
        "premises-NL": [
            "Everyone who enjoys reading reads newspapers.",
            "Anyone who reads newspapers is well-informed.",
            "Some people enjoy reading."
        ],
        "premises-FOL": [
            "∀x (EnjoysReading(x) → ReadsNewspapers(x)) ::: Everyone who enjoys reading reads newspapers.",
            "∀x (ReadsNewspapers(x) → WellInformed(x)) ::: Anyone who reads newspapers is well-informed.",
            "∃x EnjoysReading(x) ::: Some people enjoy reading."
        ],
        "predicates": [
            "EnjoysReading(x) ::: x enjoys reading",
            "ReadsNewspapers(x) ::: x reads newspapers",
            "WellInformed(x) ::: x is well-informed"
        ]
    },
    {
        "premises-NL": [
            "All doctors who specialize in cardiology are surgeons.",
            "All surgeons can perform heart surgeries.",
            "Some people are doctors and specialize in cardiology."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) ∧ SpecializesIn(x, \"Cardiology\") → Surgeon(x)) ::: All doctors who specialize in cardiology are surgeons.",
            "∀x (Surgeon(x) → CanPerformSurgery(x, \"Heart\")) ::: All surgeons can perform heart surgeries.",
            "∃x (Doctor(x) ∧ SpecializesIn(x, \"Cardiology\")) ::: Some people are doctors and specialize in cardiology."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "SpecializesIn(x, y) ::: x specializes in y",
            "CanPerformSurgery(x, y) ::: x can perform surgery on y",
            "Surgeon(x) ::: x is a surgeon"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard pass their exams.",
            "Students who attend all classes are likely to pass their exams.",
            "Anyone who passes exams is likely to succeed.",
            "Some students study hard and attend all classes.",
            "All students are people."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) → PassesExams(x)) ::: All students who study hard pass their exams.",
            "∀x (Student(x) ∧ AttendsClasses(x) → PassesExams(x)) ::: Students who attend all classes are likely to pass their exams.",
            "∀x (PassesExams(x) → LikelySucceeds(x)) ::: Anyone who passes exams is likely to succeed.",
            "∃x (Student(x) ∧ StudiesHard(x) ∧ AttendsClasses(x)) ::: Some students study hard and attend all classes.",
            "∀x Student(x) ::: All students are people."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "AttendsClasses(x) ::: x attends classes",
            "PassesExams(x) ::: x passes exams",
            "LikelySucceeds(x) ::: x likely succeeds"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard will pass the exam.",
            "Sarah is a student.",
            "If a student attends lectures, they will study hard.",
            "Sarah attends lectures.",
            "All students who attend lectures study hard.",
            "If someone studies hard they will pass the exam.",
            "Sarah is a student who attends lectures."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudyHard(x) → PassExam(x)) ::: All students who study hard will pass the exam",
            "Student(Sarah) ::: Sarah is a student",
            "∀x (Student(x) ∧ AttendLectures(x) → StudyHard(x)) ::: If a student attends lectures, they will study hard",
            "AttendLectures(Sarah) ::: Sarah attends lectures",
            "∀x (Student(x) ∧ AttendLectures(x) → StudyHard(x)) ::: All students who attend lectures study hard",
            "∀x (StudyHard(x) → PassExam(x)) ::: If someone studies hard they will pass the exam",
            "Student(Sarah) ∧ AttendLectures(Sarah) ::: Sarah is a student who attends lectures"
        ],
        "predicates": [
            "StudyHard(x) ::: x studies hard",
            "AttendLectures(x) ::: x attends lectures",
            "PassExam(x) ::: x passes the exam",
            "Student(x) ::: x is a student"
        ]
    },
    {
        "premises-NL": [
            "If someone is employed and works hard, they have a high salary.",
            "If someone has a high salary, they spend money.",
            "If someone works hard and has a high salary, they will get a bonus.",
            "Anyone who has a high salary saves money.",
            "If someone spends money or saves money, they have a large house.",
            "If someone is employed and receives a bonus, they will have a large house.",
            "If someone works hard, they will be employed.",
            "John is employed.",
            "John works hard.",
            "John has a high salary."
        ],
        "premises-FOL": [
            "∀x (Employed(x) ∧ WorksHard(x) → HighSalary(x)) ::: If someone is employed and works hard, they have a high salary",
            "∀x (HighSalary(x) → SpendsMoney(x)) ::: If someone has a high salary, they spend money",
            "∀x (WorksHard(x) ∧ HighSalary(x) → ReceivesBonus(x)) ::: If someone works hard and has a high salary, they will get a bonus",
            "∀x (HighSalary(x) → SavesMoney(x)) ::: Anyone who has a high salary saves money",
            "∀x (SpendsMoney(x) ∨ SavesMoney(x) → HasLargeHouse(x)) ::: If someone spends money or saves money, they have a large house",
            "∀x (Employed(x) ∧ ReceivesBonus(x) → HasLargeHouse(x)) ::: If someone is employed and receives a bonus, they will have a large house",
            "∀x (WorksHard(x) → Employed(x)) ::: If someone works hard, they will be employed",
            "Employed(John) ::: John is employed",
            "WorksHard(John) ::: John works hard",
            "HighSalary(John) ::: John has a high salary"
        ],
        "predicates": [
            "HighSalary(x) ::: x has a high salary",
            "WorksHard(x) ::: x works hard",
            "HasLargeHouse(x) ::: x has a large house",
            "Employed(x) ::: x is employed",
            "ReceivesBonus(x) ::: x receives a bonus",
            "SpendsMoney(x) ::: x spends money",
            "SavesMoney(x) ::: x saves money"
        ]
    },
    {
        "premises-NL": [
            "All cats are either playful or lazy.",
            "All playful cats chase mice.",
            "No cat is both lazy and chases mice.",
            "Some cats exist.",
            "If something is a cat, it is playful or lazy.",
            "Playful cats hunt mice.",
            "No lazy cat hunts mice.",
            "Every cat plays or is lazy.",
            "Some cats aren't lazy.",
            "All cats chase mice or are lazy.",
            "If something chases mice, it's not lazy.",
            "All cats don't hate mice.",
            "Some cats chase mice.",
            "Cats only chase mice.",
            "All cats are fast or slow.",
            "No dog is a cat."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → (Playful(x) ∨ Lazy(x))) ::: For all x, if x is a cat, then x is playful or lazy.",
            "∀x (Playful(x) → Chase(x, Mouse)) ::: For all x, if x is playful, then x chases mice.",
            "¬∃x (Lazy(x) ∧ Chase(x, Mouse)) ::: There is no x such that x is lazy and chases mice.",
            "∃x Cat(x) ::: There exists a cat.",
            "∀x (Cat(x) → (Playful(x) ∨ Lazy(x))) ::: If something is a cat, it is playful or lazy.",
            "∀x (Playful(x) → Chase(x, Mouse)) ::: Playful cats hunt mice.",
            "¬∃x (Lazy(x) ∧ Chase(x, Mouse)) ::: No lazy cat hunts mice.",
            "∀x (Cat(x) → (Playful(x) ∨ Lazy(x))) ::: Every cat plays or is lazy.",
            "∃x (Cat(x) ∧ ¬Lazy(x)) ::: Some cats aren't lazy.",
            "∀x (Cat(x) → (Chase(x, Mouse) ∨ Lazy(x))) ::: All cats chase mice or are lazy.",
            "∀x (Chase(x, Mouse) → ¬Lazy(x)) ::: If something chases mice, it's not lazy.",
            "¬∃x (Cat(x) ∧ Hates(x, Mouse)) ::: All cats don't hate mice.",
            "∃x (Cat(x) ∧ Chase(x, Mouse)) ::: Some cats chase mice.",
            "∀x (Cat(x) → Chase(x, Mouse)) ::: Cats only chase mice.",
            "∀x (Cat(x) → (Fast(x) ∨ Lazy(x))) ::: All cats are fast or slow.",
            "∀x ¬(Dog(x) ∧ Cat(x)) ::: No dog is a cat."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Chase(x, y) ::: x chases y",
            "Mouse(x) ::: x is a mouse",
            "Lazy(x) ::: x is lazy",
            "Playful(x) ::: x is playful",
            "Fast(x) ::: x is fast",
            "Dog(x) ::: x is a dog",
            "Hates(x, y) ::: x hates y"
        ]
    },
    {
        "premises-NL": [
            "All students attend lectures.",
            "Some students study hard.",
            "x is a student implies x studies hard or x attends lectures.",
            "If a student attends lectures, then the student is not lazy.",
            "If a student doesn't study hard, then the student is lazy.",
            "A student is either lazy or studies hard.",
            "No student studies hard and is lazy at the same time.",
            "There is a student.",
            "A student is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendLecture(x)) ::: All students attend lectures.",
            "∃x (Student(x) ∧ StudyHard(x)) ::: Some students study hard.",
            "∀x (Student(x) → (StudyHard(x) ∨ AttendLecture(x))) ::: x is a student implies x studies hard or x attends lectures.",
            "∀x (AttendLecture(x) → ¬Lazy(x)) ::: If a student attends lectures, then the student is not lazy.",
            "∀x (¬StudyHard(x) → Lazy(x)) ::: If a student doesn't study hard, then the student is lazy.",
            "∀x (Student(x) → (Lazy(x) ∨ StudyHard(x))) ::: A student is either lazy or studies hard.",
            "∀x (¬(StudyHard(x) ∧ Lazy(x))) ::: No student studies hard and is lazy at the same time.",
            "∃x Student(x) ::: There is a student.",
            "∀x (Student(x) → Student(x)) ::: A student is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendLecture(x) ::: x attends lectures",
            "StudyHard(x) ::: x studies hard"
        ]
    },
    {
        "premises-NL": [
            "All cats are mammals.",
            "All mammals are animals.",
            "Cats chase mice or eat fish.",
            "Cats like milk if they chase mice.",
            "Some cats chase mice.",
            "If something is a mammal, then it's an animal.",
            "If a cat eats fish, then it chases mice.",
            "Something is a cat if and only if it eats fish.",
            "Cats like milk.",
            "If something chases a mouse, then it is a cat.",
            "Some animals are cats."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → Mammal(x)) ::: All cats are mammals.",
            "∀x (Mammal(x) → Animal(x)) ::: All mammals are animals.",
            "∀x (Cat(x) → (ChasesMouse(x) ∨ EatsFish(x))) ::: Cats chase mice or eat fish.",
            "∀x (Cat(x) ∧ ChasesMouse(x) → LikesMilk(x)) ::: Cats like milk if they chase mice.",
            "∃x (Cat(x) ∧ ChasesMouse(x)) ::: Some cats chase mice.",
            "∀x (Mammal(x) → Animal(x)) ::: If something is a mammal, then it's an animal.",
            "∀x (Cat(x) ∧ EatsFish(x) → ChasesMouse(x)) ::: If a cat eats fish, then it chases mice.",
            "∀x (Cat(x) ↔ EatsFish(x)) ::: Something is a cat if and only if it eats fish.",
            "∀x (Cat(x) → LikesMilk(x)) ::: Cats like milk.",
            "∀x (ChasesMouse(x) → Cat(x)) ::: If something chases a mouse, then it is a cat.",
            "∃x (Animal(x) ∧ Cat(x)) ::: Some animals are cats."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Mammal(x) ::: x is a mammal",
            "Animal(x) ::: x is an animal",
            "EatsFish(x) ::: x eats fish",
            "ChasesMouse(x) ::: x chases a mouse",
            "LikesMilk(x) ::: x likes milk"
        ]
    },
    {
        "premises-NL": [
            "All students are diligent.",
            "Every student has a scholarship.",
            "If a student has a scholarship, they study hard.",
            "If a student studies hard, they succeed."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Diligence(x)) ::: All students are diligent.",
            "∀x (Student(x) → Scholarship(x)) ::: Every student has a scholarship.",
            "∀x (Scholarship(x) → Studies(x, hard)) ::: If a student has a scholarship, they study hard.",
            "∀x (Studies(x, hard) → Succeeds(x)) ::: If a student studies hard, they succeed."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Diligence(x) ::: x is diligent",
            "Scholarship(x) ::: x has a scholarship",
            "Succeeds(x) ::: x succeeds",
            "Studies(x, y) ::: x studies y"
        ]
    },
    {
        "premises-NL": [
            "All plants require sunlight and water.",
            "If a plant gets sufficient sunlight and water, it grows.",
            "All plants require nutrients.",
            "A plant needs nutrients if it grows.",
            "The rose is a plant",
            "The rose gets sunlight.",
            "The rose gets water."
        ],
        "premises-FOL": [
            "∀x (Plant(x) → (Sunlight(x) ∧ Water(x))) ::: All plants require sunlight and water.",
            "∀x ((Sunlight(x) ∧ Water(x)) → Grows(x)) ::: If a plant gets sufficient sunlight and water, it grows.",
            "∀x (Plant(x) → RequiresNutrients(x)) ::: All plants require nutrients.",
            "∀x (Grows(x) → RequiresNutrients(x)) ::: A plant needs nutrients if it grows.",
            "Plant(rose) ::: The rose is a plant.",
            "Sunlight(rose) ::: The rose gets sunlight.",
            "Water(rose) ::: The rose gets water."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "Sunlight(x) ::: x gets sunlight",
            "Water(x) ::: x gets water",
            "Grows(x) ::: x grows",
            "RequiresNutrients(x) ::: x requires nutrients"
        ]
    },
    {
        "premises-NL": [
            "All politicians make promises.",
            "Some politicians lie.",
            "If a politician lies, they deceive people.",
            "If a politician deceives people, they are not honest.",
            "All politicians support the people.",
            "If a politician supports a policy, they vote for it.",
            "Some politicians do not vote for the policy.",
            "Politicians are either honest or lie."
        ],
        "premises-FOL": [
            "∀x (Politician(x) → Promises(x, people)) ::: All politicians make promises.",
            "∃x (Politician(x) ∧ Lies(x)) ::: Some politicians lie.",
            "∀x (Lies(x) → Deceives(x, people)) ::: If a politician lies, they deceive people.",
            "∀x (Deceives(x, people) → ¬Honest(x)) ::: If a politician deceives people, they are not honest.",
            "∀x (Politician(x) → Supports(x, people)) ::: All politicians support the people.",
            "∀x ∀y (Supports(x, y) → Votes(x)) ::: If a politician supports a policy, they vote for it.",
            "∃x (Politician(x) ∧ ¬Votes(x)) ::: Some politicians do not vote for the policy.",
            "∀x (Politician(x) → (Honest(x) ∨ Lies(x))) ::: Politicians are either honest or lie."
        ],
        "predicates": [
            "Politician(x) ::: x is a politician",
            "Honest(x) ::: x is honest",
            "Lies(x) ::: x lies",
            "Deceives(x, y) ::: x deceives y",
            "Votes(x) ::: x votes",
            "Supports(x, y) ::: x supports y",
            "Promises(x, y) ::: x promises y"
        ]
    },
    {
        "premises-NL": [
            "All professors are knowledgeable.",
            "All teachers are experts.",
            "All students attend classes.",
            "Everyone who attends classes is a student.",
            "If someone is a student and a teacher, they study and teach.",
            "If someone is a professor, they give lectures.",
            "If someone gives lectures they are an expert.",
            "If someone is an expert they are knowledgeable.",
            "All teachers teach courses.",
            "All students study courses."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Knowledgeable(x)) ::: All professors are knowledgeable.",
            "∀x (Teacher(x) → Expert(x, subject)) ::: All teachers are experts.",
            "∀x (Student(x) → Attends(x, classes)) ::: All students attend classes.",
            "∀x (Attends(x, classes) → Student(x)) ::: Everyone who attends classes is a student.",
            "∀x (Student(x) ∧ Teacher(x) → (Studies(x, course) ∧ Teaches(x, course))) ::: If someone is a student and a teacher, they study and teach.",
            "∀x (Professor(x) → GivesLecture(x, topic)) ::: If someone is a professor, they give lectures.",
            "∀x (GivesLecture(x, topic) → Expert(x, topic)) ::: If someone gives lectures they are an expert.",
            "∀x (Expert(x, topic) → Knowledgeable(x)) ::: If someone is an expert they are knowledgeable.",
            "∀x (Teacher(x) → Teaches(x, courses)) ::: All teachers teach courses.",
            "∀x (Student(x) → Studies(x, courses)) ::: All students study courses."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Teacher(x) ::: x is a teacher",
            "Professor(x) ::: x is a professor",
            "Studies(x, y) ::: x studies y",
            "Teaches(x, y) ::: x teaches y",
            "Knowledgeable(x) ::: x is knowledgeable",
            "Expert(x, y) ::: x is an expert in y",
            "Attends(x, y) ::: x attends y",
            "GivesLecture(x, y) ::: x gives lecture on y"
        ]
    },
    {
        "premises-NL": [
            "All doctors are medical professionals.",
            "Some medical professionals have no patients.",
            "If someone is a medical professional and has no patients, then they are a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → MedicalProfessional(x)) ::: All doctors are medical professionals.",
            "∃x (MedicalProfessional(x) ∧ ¬HasPatient(x)) ::: Some medical professionals have no patients.",
            "∀x ((MedicalProfessional(x) ∧ ¬HasPatient(x)) → Doctor(x)) ::: If someone is a medical professional and has no patients, then they are a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Patient(x) ::: x is a patient",
            "HasPatient(x) ::: x has at least one patient"
        ]
    },
    {
        "premises-NL": [
            "All professors are researchers.",
            "Some professors publish research.",
            "Anyone who publishes research is a researcher.",
            "Some researchers do not publish research.",
            "If someone is a professor they are a researcher."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Researcher(x)) ::: All professors are researchers.",
            "∃x (Professor(x) ∧ PublishesResearch(x)) ::: Some professors publish research.",
            "∀x (PublishesResearch(x) → Researcher(x)) ::: Anyone who publishes research is a researcher.",
            "∃x (Researcher(x) ∧ ¬PublishesResearch(x)) ::: Some researchers do not publish research.",
            "∀x (Professor(x) → Researcher(x)) ::: If someone is a professor they are a researcher."
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher",
            "Professor(x) ::: x is a professor",
            "PublishesResearch(x) ::: x publishes research"
        ]
    },
    {
        "premises-NL": [
            "All professors teach courses.",
            "All courses are taught by someone.",
            "Anyone who teaches a course is educated.",
            "Some courses are taught by professors.",
            "Someone is a professor"
        ],
        "premises-FOL": [
            "∀x ∀y (Professor(x) ∧ Course(y) → Teach(x, y)) ::: All professors teach courses.",
            "∀y ∃x (Course(y) → Teach(x, y)) ::: All courses are taught by someone.",
            "∀x ∀y (Teach(x, y) → Educated(x)) ::: Anyone who teaches a course is educated.",
            "∃x ∃y (Professor(x) ∧ Teach(x, y)) ::: Some courses are taught by professors.",
            "∃x Professor(x) ::: Someone is a professor."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "Teach(x, y) ::: x teaches y",
            "Course(y) ::: y is a course",
            "Educated(x) ::: x is educated",
            "Enrolled(x, y) ::: x is enrolled in y"
        ]
    },
    {
        "premises-NL": [
            "All mammals have lungs.",
            "All mammals have a heart.",
            "Any creature that has lungs and a heart is an animal.",
            "All carnivores eat meat.",
            "All lions are carnivores.",
            "All lions are mammals"
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → HasLungs(x)) ::: All mammals have lungs.",
            "∀x (Mammal(x) → HasHeart(x)) ::: All mammals have a heart.",
            "∀x ((HasLungs(x) ∧ HasHeart(x)) → Animal(x)) ::: Any creature that has lungs and a heart is an animal.",
            "∀x (IsCarnivore(x) → EatsMeat(x)) ::: All carnivores eat meat.",
            "∀x (Lion(x) → IsCarnivore(x)) ::: All lions are carnivores.",
            "∀x (Lion(x) → Mammal(x)) ::: All lions are mammals"
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal",
            "HasLungs(x) ::: x has lungs",
            "HasHeart(x) ::: x has a heart",
            "Animal(x) ::: x is an animal",
            "EatsMeat(x) ::: x eats meat",
            "IsCarnivore(x) ::: x is a carnivore"
        ]
    },
    {
        "premises-NL": [
            "All researchers publish papers.",
            "Anyone who publishes papers works at a university.",
            "Anyone who works at a university is employed.",
            "Anyone employed with a degree can get funding.",
            "All researchers have a degree.",
            "If someone gets funding, they can hire assistants.",
            "Some researchers are employed"
        ],
        "premises-FOL": [
            "∀x (Researcher(x) → PublishesPapers(x)) ::: All researchers publish papers.",
            "∀x (PublishesPapers(x) → WorksAtUniversity(x)) ::: Anyone who publishes papers works at a university.",
            "∀x (WorksAtUniversity(x) → IsEmployed(x)) ::: Anyone who works at a university is employed.",
            "∀x (IsEmployed(x) ∧ HasDegree(x) → GetsFunding(x)) ::: Anyone employed with a degree can get funding.",
            "∀x (Researcher(x) → HasDegree(x)) ::: All researchers have a degree.",
            "∀x (GetsFunding(x) → CanHireAssistants(x)) ::: If someone gets funding, they can hire assistants.",
            "∃x (Researcher(x) ∧ IsEmployed(x)) ::: Some researchers are employed."
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher.",
            "GetsFunding(x) ::: x gets funding.",
            "CanHireAssistants(x) ::: x can hire assistants.",
            "PublishesPapers(x) ::: x publishes papers.",
            "WorksAtUniversity(x) ::: x works at a university.",
            "IsEmployed(x) ::: x is employed.",
            "HasDegree(x) ::: x has a degree."
        ]
    },
    {
        "premises-NL": [
            "All researchers have a grant.",
            "Some professors do not have a grant.",
            "Anyone who teaches is a professor.",
            "Alice is a student.",
            "Bob teaches Alice.",
            "Anyone who teaches Alice must be a professor.",
            "All professors are researchers.",
            "Charlie is a professor.",
            "David teaches Alice and has a grant."
        ],
        "premises-FOL": [
            "∀x (Researcher(x) → HasGrant(x)) ::: All researchers have a grant.",
            "∃x (Professor(x) ∧ ¬HasGrant(x)) ::: Some professors do not have a grant.",
            "∀x ∀y (Teaches(x, y) → Professor(x)) ::: Anyone who teaches is a professor.",
            "Student(alice) ::: Alice is a student.",
            "Teaches(bob, alice) ::: Bob teaches Alice.",
            "∀x (Teaches(x, alice) → Professor(x)) ::: Anyone who teaches Alice must be a professor.",
            "∀x (Professor(x) → Researcher(x)) ::: All professors are researchers.",
            "Professor(charlie) ::: Charlie is a professor.",
            "HasGrant(david) ∧ Teaches(david, alice) ::: David teaches Alice and has a grant."
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher",
            "Professor(x) ::: x is a professor",
            "HasGrant(x) ::: x has a grant",
            "Teaches(x, y) ::: x teaches y",
            "Student(x) ::: x is a student"
        ]
    },
    {
        "premises-NL": [
            "All students take courses.",
            "Some courses are difficult.",
            "If a student takes a course and it is difficult, then the student will study.",
            "If a student takes a difficult course, they study.",
            "If a course is difficult, students will study for it.",
            "Some students take difficult courses.",
            "If a student studies, they will pass a course.",
            "If a student takes a course, then they are a student.",
            "A student studies only if they take a difficult course.",
            "If a student passes a course, they studied.",
            "Some students do not study.",
            "If a student is not studying, then they did not pass the course.",
            "If someone takes a course, they will pass the course.",
            "If a student is taking a difficult course, they will pass the course.",
            "If a student is studying, then they are taking a course.",
            "Every difficult course has a student.",
            "If a student does not study, they are not taking a difficult course.",
            "A student takes a difficult course if and only if they study."
        ],
        "premises-FOL": [
            "∀x ∃y (Student(x) → Takes(x, y)) ::: All students take courses.",
            "∃y DifficultCourse(y) ::: Some courses are difficult.",
            "∀x ∀y (Student(x) ∧ Takes(x, y) ∧ DifficultCourse(y) → Studies(x)) ::: If a student takes a course and it is difficult, then the student will study.",
            "∀x ∀y (Student(x) ∧ DifficultCourse(y) ∧ Takes(x, y) → Studies(x)) ::: If a student takes a difficult course, they study.",
            "∀y ∀x (DifficultCourse(y) ∧ Takes(x, y) → Studies(x)) ::: If a course is difficult, students will study for it.",
            "∃x ∃y (Student(x) ∧ Takes(x, y) ∧ DifficultCourse(y)) ::: Some students take difficult courses.",
            "∀x ∀y (Studies(x) ∧ Takes(x, y) → Passes(x, y)) ::: If a student studies, they will pass a course.",
            "∀x ∀y (Takes(x, y) → Student(x)) ::: If a student takes a course, then they are a student.",
            "∀x ∀y (Studies(x) → Takes(x, y) ∧ DifficultCourse(y)) ::: A student studies only if they take a difficult course.",
            "∀x ∀y (Passes(x, y) → Studies(x)) ::: If a student passes a course, they studied.",
            "∃x ¬Studies(x) ::: Some students do not study.",
            "∀x ∀y (¬Studies(x) → ¬Passes(x, y)) ::: If a student is not studying, then they did not pass the course.",
            "∀x ∀y (Takes(x, y) → Passes(x, y)) ::: If someone takes a course, they will pass the course.",
            "∀x ∀y (Student(x) ∧ Takes(x, y) ∧ DifficultCourse(y) → Passes(x, y)) ::: If a student is taking a difficult course, they will pass the course.",
            "∀x ∀y (Studies(x) → Takes(x, y)) ::: If a student is studying, then they are taking a course.",
            "∀y ∃x (DifficultCourse(y) ∧ Takes(x, y)) ::: Every difficult course has a student.",
            "∀x ∀y (¬Studies(x) → ¬(Takes(x, y) ∧ DifficultCourse(y))) ::: If a student does not study, they are not taking a difficult course.",
            "∀x ∀y (Takes(x, y) ∧ DifficultCourse(y) ↔ Studies(x)) ::: A student takes a difficult course if and only if they study."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Takes(x, y) ::: x takes course y",
            "DifficultCourse(y) ::: y is a difficult course",
            "Studies(x) ::: x studies",
            "Passes(x, y) ::: x passes course y"
        ]
    },
    {
        "premises-NL": [
            "Everyone likes someone.",
            "John likes Mary.",
            "If someone likes someone, then they are friends.",
            "Mary is a friend of John.",
            "If John likes someone, that person likes John.",
            "Mary likes John."
        ],
        "premises-FOL": [
            "∃x ∀y Likes(x, y) ::: Everyone likes someone.",
            "Likes(john, mary) ::: John likes Mary.",
            "∀x ∀y (Likes(x, y) → Friend(x, y)) ::: If someone likes someone, then they are friends.",
            "Friend(mary, john) ::: Mary is a friend of John.",
            "∀x ∀y (Likes(x, y) → Likes(y, x)) ::: If John likes someone, that person likes John.",
            "Likes(john, mary) ::: Mary likes John."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y.",
            "Friend(x, y) ::: x and y are friends."
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "If someone is smart, they study.",
            "John is a student.",
            "John studies.",
            "If someone studies, they will pass.",
            "If someone is smart and studies, they pass.",
            "A student studies and passes."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "∀x (Smart(x) → Studies(x)) ::: If someone is smart, they study.",
            "Student(john) ::: John is a student.",
            "Studies(john) ::: John studies.",
            "∀x (Studies(x) → Passes(x)) ::: If someone studies, they will pass.",
            "∀x (Smart(x) ∧ Studies(x) → Passes(x)) ::: If someone is smart and studies, they pass.",
            "∃x (Student(x) ∧ Studies(x) ∧ Passes(x)) ::: A student studies and passes."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Studies(x) ::: x studies.",
            "Passes(x) ::: x passes.",
            "Smart(x) ::: x is smart."
        ]
    },
    {
        "premises-NL": [
            "All students are diligent.",
            "Some students pass.",
            "If someone is a student, then they are either diligent or pass.",
            "If someone is diligent, then they are not a student.",
            "Every student is either diligent or passes.",
            "There exists a student.",
            "If someone passes, then they are not a student.",
            "There is at least one student.",
            "Each student is diligent.",
            "If something is a student then they pass.",
            "Some student is passing."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Diligence(x)) ::: All students are diligent.",
            "∃x (Student(x) ∧ Pass(x)) ::: Some students pass.",
            "∀x (Student(x) → (Diligence(x) ∨ Pass(x))) ::: If someone is a student, then they are either diligent or pass.",
            "∀x (Diligence(x) → ¬Student(x)) ::: If someone is diligent, then they are not a student.",
            "∀x (Student(x) → (Diligence(x) ∨ Pass(x))) ::: Every student is either diligent or passes.",
            "∃x Student(x) ::: There exists a student.",
            "∀x (Pass(x) → ¬Student(x)) ::: If someone passes, then they are not a student.",
            "∃x Student(x) ::: There is at least one student.",
            "∀x (Student(x) → Diligence(x)) ::: Each student is diligent.",
            "∀x (Student(x) → Pass(x)) ::: If something is a student then they pass.",
            "∃x (Student(x) ∧ Pass(x)) ::: Some student is passing."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Diligence(x) ::: x is diligent",
            "Pass(x) ::: x passes"
        ]
    },
    {
        "premises-NL": [
            "All doctors are skilled.",
            "Some skilled people are helpful.",
            "If someone is a doctor, then they are skilled.",
            "Anyone skilled is helpful.",
            "A doctor is skilled.",
            "At least one doctor is skilled.",
            "If anyone is helpful, they are not a doctor.",
            "Each skilled person is helpful.",
            "If a doctor is skilled, they're helpful.",
            "There exists a doctor.",
            "If someone is a doctor, then they are either skilled or helpful.",
            "Everyone is either skilled or helpful.",
            "If someone is skilled, they are not a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Skilled(x)) ::: All doctors are skilled.",
            "∃x (Skilled(x) ∧ Helpful(x)) ::: Some skilled people are helpful.",
            "∀x (Doctor(x) → Skilled(x)) ::: If someone is a doctor, then they are skilled.",
            "∀x (Skilled(x) → Helpful(x)) ::: Anyone skilled is helpful.",
            "∀x (Doctor(x) → Skilled(x)) ::: A doctor is skilled.",
            "∃x (Doctor(x) ∧ Skilled(x)) ::: At least one doctor is skilled.",
            "∀x (Helpful(x) → ¬Doctor(x)) ::: If anyone is helpful, they are not a doctor.",
            "∀x (Skilled(x) → Helpful(x)) ::: Each skilled person is helpful.",
            "∀x (Doctor(x) ∧ Skilled(x) → Helpful(x)) ::: If a doctor is skilled, they're helpful.",
            "∃x Doctor(x) ::: There exists a doctor.",
            "∀x (Doctor(x) → (Skilled(x) ∨ Helpful(x))) ::: If someone is a doctor, then they are either skilled or helpful.",
            "∀x (Skilled(x) ∨ Helpful(x)) ::: Everyone is either skilled or helpful.",
            "∀x (Skilled(x) → ¬Doctor(x)) ::: If someone is skilled, they are not a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Skilled(x) ::: x is skilled",
            "Helpful(x) ::: x is helpful"
        ]
    },
    {
        "premises-NL": [
            "All scientists are curious.",
            "Some curious people are innovative.",
            "If someone is a scientist, then they are curious.",
            "Anyone curious is innovative.",
            "A scientist is curious.",
            "At least one scientist is curious.",
            "If anyone is innovative, they are not a scientist.",
            "Each curious person is innovative.",
            "If a scientist is curious, they're innovative.",
            "There exists a scientist.",
            "If someone is a scientist, then they are either curious or innovative.",
            "Everyone is either curious or innovative.",
            "If someone is curious, they are not a scientist.",
            "Each scientist is innovative."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Curious(x)) ::: All scientists are curious.",
            "∃x (Curious(x) ∧ Innovative(x)) ::: Some curious people are innovative.",
            "∀x (Scientist(x) → Curious(x)) ::: If someone is a scientist, then they are curious.",
            "∀x (Curious(x) → Innovative(x)) ::: Anyone curious is innovative.",
            "∀x (Scientist(x) → Curious(x)) ::: A scientist is curious.",
            "∃x (Scientist(x) ∧ Curious(x)) ::: At least one scientist is curious.",
            "∀x (Innovative(x) → ¬Scientist(x)) ::: If anyone is innovative, they are not a scientist.",
            "∀x (Curious(x) → Innovative(x)) ::: Each curious person is innovative.",
            "∀x (Scientist(x) ∧ Curious(x) → Innovative(x)) ::: If a scientist is curious, they're innovative.",
            "∃x Scientist(x) ::: There exists a scientist.",
            "∀x (Scientist(x) → (Curious(x) ∨ Innovative(x))) ::: If someone is a scientist, then they are either curious or innovative.",
            "∀x (Curious(x) ∨ Innovative(x)) ::: Everyone is either curious or innovative.",
            "∀x (Curious(x) → ¬Scientist(x)) ::: If someone is curious, they are not a scientist.",
            "∀x (Scientist(x) → Innovative(x)) ::: Each scientist is innovative."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Curious(x) ::: x is curious",
            "Innovative(x) ::: x is innovative"
        ]
    },
    {
        "premises-NL": [
            "All programmers are logical.",
            "Some logical people are efficient.",
            "If someone is a programmer, then they are logical.",
            "Anyone logical is efficient.",
            "A programmer is logical.",
            "At least one programmer is logical.",
            "If anyone is efficient, they are not a programmer.",
            "Each logical person is efficient.",
            "If a programmer is logical, they're efficient.",
            "There exists a programmer.",
            "If someone is a programmer, then they are either logical or efficient.",
            "Everyone is either logical or efficient.",
            "If someone is logical, they are not a programmer.",
            "Each programmer is efficient.",
            "Some programmer is efficient."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → Logical(x)) ::: All programmers are logical.",
            "∃x (Logical(x) ∧ Efficient(x)) ::: Some logical people are efficient.",
            "∀x (Programmer(x) → Logical(x)) ::: If someone is a programmer, then they are logical.",
            "∀x (Logical(x) → Efficient(x)) ::: Anyone logical is efficient.",
            "∀x (Programmer(x) → Logical(x)) ::: A programmer is logical.",
            "∃x (Programmer(x) ∧ Logical(x)) ::: At least one programmer is logical.",
            "∀x (Efficient(x) → ¬Programmer(x)) ::: If anyone is efficient, they are not a programmer.",
            "∀x (Logical(x) → Efficient(x)) ::: Each logical person is efficient.",
            "∀x (Programmer(x) ∧ Logical(x) → Efficient(x)) ::: If a programmer is logical, they're efficient.",
            "∃x Programmer(x) ::: There exists a programmer.",
            "∀x (Programmer(x) → (Logical(x) ∨ Efficient(x))) ::: If someone is a programmer, then they are either logical or efficient.",
            "∀x (Logical(x) ∨ Efficient(x)) ::: Everyone is either logical or efficient.",
            "∀x (Logical(x) → ¬Programmer(x)) ::: If someone is logical, they are not a programmer.",
            "∀x (Programmer(x) → Efficient(x)) ::: Each programmer is efficient.",
            "∃x (Programmer(x) ∧ Efficient(x)) ::: Some programmer is efficient."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "Logical(x) ::: x is logical",
            "Efficient(x) ::: x is efficient"
        ]
    },
    {
        "premises-NL": [
            "All engineers are problem-solvers.",
            "Some problem-solvers are innovative.",
            "If someone is an engineer, then they are a problem-solver.",
            "Anyone who is a problem-solver is innovative.",
            "An engineer is a problem-solver.",
            "At least one engineer is a problem-solver.",
            "If someone is innovative, then they are not an engineer.",
            "Each problem-solver is innovative.",
            "If an engineer is a problem-solver, then they are innovative.",
            "There exists an engineer.",
            "If someone is an engineer, then they are either a problem-solver or innovative.",
            "Everyone is either a problem-solver or innovative.",
            "If someone is a problem-solver, then they are not an engineer.",
            "Each engineer is innovative.",
            "Some engineers are innovators."
        ],
        "premises-FOL": [
            "∀x (Engineer(x) → ProblemSolver(x)) ::: All engineers are problem-solvers.",
            "∃x (ProblemSolver(x) ∧ Innovative(x)) ::: Some problem-solvers are innovative.",
            "∀x (Engineer(x) → ProblemSolver(x)) ::: If someone is an engineer, then they are a problem-solver.",
            "∀x (ProblemSolver(x) → Innovative(x)) ::: Anyone who is a problem-solver is innovative.",
            "∀x (Engineer(x) → ProblemSolver(x)) ::: An engineer is a problem-solver.",
            "∃x (Engineer(x) ∧ ProblemSolver(x)) ::: At least one engineer is a problem-solver.",
            "∀x (Innovative(x) → ¬Engineer(x)) ::: If someone is innovative, then they are not an engineer.",
            "∀x (ProblemSolver(x) → Innovative(x)) ::: Each problem-solver is innovative.",
            "∀x (Engineer(x) ∧ ProblemSolver(x) → Innovative(x)) ::: If an engineer is a problem-solver, then they are innovative.",
            "∃x Engineer(x) ::: There exists an engineer.",
            "∀x (Engineer(x) → (ProblemSolver(x) ∨ Innovative(x))) ::: If someone is an engineer, then they are either a problem-solver or innovative.",
            "∀x (ProblemSolver(x) ∨ Innovative(x)) ::: Everyone is either a problem-solver or innovative.",
            "∀x (ProblemSolver(x) → ¬Engineer(x)) ::: If someone is a problem-solver, then they are not an engineer.",
            "∀x (Engineer(x) → Innovative(x)) ::: Each engineer is innovative.",
            "∃x (Engineer(x) ∧ Innovative(x)) ::: Some engineers are innovators."
        ],
        "predicates": [
            "Engineer(x) ::: x is an engineer",
            "ProblemSolver(x) ::: x is a problem solver",
            "Innovative(x) ::: x is innovative"
        ]
    },
    {
        "premises-NL": [
            "All birds have feathers.",
            "All birds are warm-blooded.",
            "Some birds lay eggs.",
            "All birds fly.",
            "No mammal lays eggs.",
            "Something is a bird.",
            "All mammals are warm-blooded."
        ],
        "premises-FOL": [
            "∀x (Bird(x) → HasFeathers(x)) ::: All birds have feathers.",
            "∀x (Bird(x) → IsWarmBlooded(x)) ::: All birds are warm-blooded.",
            "∃x (Bird(x) ∧ EggLayer(x)) ::: Some birds lay eggs.",
            "∀x (Bird(x) → Flies(x)) ::: All birds fly.",
            "∀x (Mammal(x) → ¬EggLayer(x)) ::: No mammal lays eggs.",
            "∃x Bird(x) ::: Something is a bird.",
            "∀x (Mammal(x) → IsWarmBlooded(x)) ::: All mammals are warm-blooded."
        ],
        "predicates": [
            "Bird(x) ::: x is a bird",
            "Mammal(x) ::: x is a mammal",
            "HasFeathers(x) ::: x has feathers",
            "IsWarmBlooded(x) ::: x is warm-blooded",
            "EggLayer(x) ::: x is an egg layer",
            "Flies(x) ::: x flies",
            "Aquatic(x) ::: x is aquatic"
        ]
    },
    {
        "premises-NL": [
            "All intelligent students study.",
            "All students who study attend class.",
            "Those who attend class and like to learn get good grades.",
            "Some students are intelligent.",
            "Some students like to learn.",
            "Some students attend class.",
            "Some students are intelligent and like to learn."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ Intelligent(x) → Studies(x)) ::: All intelligent students study.",
            "∀x (Student(x) ∧ Studies(x) → AttendsClass(x)) ::: All students who study attend class.",
            "∀x (AttendsClass(x) ∧ LikesToLearn(x) → GetsGoodGrades(x)) ::: Those who attend class and like to learn get good grades.",
            "∃x (Student(x) ∧ Intelligent(x)) ::: Some students are intelligent.",
            "∃x (Student(x) ∧ LikesToLearn(x)) ::: Some students like to learn.",
            "∃x AttendsClass(x) ::: Some students attend class.",
            "∃x (Student(x) ∧ Intelligent(x) ∧ LikesToLearn(x)) ::: Some students are intelligent and like to learn."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Intelligent(x) ::: x is intelligent",
            "Studies(x) ::: x studies",
            "GetsGoodGrades(x) ::: x gets good grades",
            "AttendsClass(x) ::: x attends class",
            "LikesToLearn(x) ::: x likes to learn",
            "∀x (Student(x) ∧ Intelligent(x) → Studies(x)) ::: All intelligent students study.",
            "∀x (Student(x) ∧ Studies(x) → AttendsClass(x)) ::: All students who study attend class.",
            "∀x (AttendsClass(x) ∧ LikesToLearn(x) → GetsGoodGrades(x)) ::: Those who attend class and like to learn get good grades."
        ]
    },
    {
        "premises-NL": [
            "Products sold in a store are not sold online.",
            "Expensive and available products are sold online.",
            "Popular products are expensive.",
            "Some popular products are available.",
            "All products sold online are available.",
            "Products not sold online are sold in store.",
            "Some products are popular and available, therefore they are expensive."
        ],
        "premises-FOL": [
            "∀x (Product(x) ∧ SoldInStore(x) → ¬SoldOnline(x)) ::: Products sold in a store are not sold online.",
            "∀x (Expensive(x) ∧ Available(x) → SoldOnline(x)) ::: Expensive and available products are sold online.",
            "∀x (Popular(x) → Expensive(x)) ::: Popular products are expensive.",
            "∃x (Product(x) ∧ Popular(x) ∧ Available(x)) ::: Some popular products are available.",
            "∀x (Product(x) ∧ SoldOnline(x) → Available(x)) ::: All products sold online are available.",
            "∀x (Product(x) ∧ ¬SoldOnline(x) → SoldInStore(x)) ::: Products not sold online are sold in store.",
            "∀x (Product(x) ∧ Popular(x) ∧ Available(x) → Expensive(x)) ::: Some products are popular and available, therefore they are expensive."
        ],
        "predicates": [
            "Product(x) ::: x is a product",
            "SoldOnline(x) ::: x is sold online",
            "SoldInStore(x) ::: x is sold in a store",
            "Expensive(x) ::: x is expensive",
            "Popular(x) ::: x is popular",
            "Available(x) ::: x is available",
            "∀x (Product(x) ∧ SoldInStore(x) → ¬SoldOnline(x)) ::: Products sold in a store are not sold online.",
            "∀x (Expensive(x) ∧ Available(x) → SoldOnline(x)) ::: Expensive and available products are sold online.",
            "∀x (Popular(x) → Expensive(x)) ::: Popular products are expensive.",
            "∃x (Product(x) ∧ Popular(x) ∧ Available(x)) ::: Some popular products are available.",
            "∀x (Product(x) ∧ SoldOnline(x) → Available(x)) ::: All products sold online are available.",
            "∀x (Product(x) ∧ ¬SoldOnline(x) → SoldInStore(x)) ::: Products not sold online are sold in store."
        ]
    },
    {
        "premises-NL": [
            "David is a student.",
            "All students who study hard pass the exam.",
            "David studies hard.",
            "Students who like coffee study hard.",
            "David likes coffee.",
            "If a student likes coffee they study hard.",
            "Some students are smart.",
            "All smart students studies hard.",
            "David is a smart student.",
            "Students that study hard, likes coffee",
            "David is either a student or likes coffee.",
            "If a student is smart they like coffee.",
            "David is a student and smart.",
            "If a student is a student then they likes coffee"
        ],
        "premises-FOL": [
            "Student(david) ::: David is a student",
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: All students who study hard pass the exam",
            "StudiesHard(david) ::: David studies hard",
            "∀x (Student(x) ∧ LikesCoffee(x) → StudiesHard(x)) ::: Students who like coffee study hard",
            "LikesCoffee(david) ::: David likes coffee",
            "∀x (Student(x) ∧ LikesCoffee(x) → StudiesHard(x)) ::: If a student likes coffee they study hard",
            "∃x (Student(x) ∧ Smart(x)) ::: Some students are smart",
            "∀x (Smart(x) → StudiesHard(x)) ::: All smart students studies hard",
            "Smart(david) ::: David is a smart student",
            "∀x (StudiesHard(x) → LikesCoffee(x)) ::: Students that study hard, likes coffee",
            "Student(david) ∨ LikesCoffee(david) ::: David is either a student or likes coffee",
            "∀x (Smart(x) → LikesCoffee(x)) ::: If a student is smart they like coffee",
            "Student(david) ∧ Smart(david) ::: David is a student and smart",
            "∀x (Student(x) → LikesCoffee(x)) ::: If a student is a student then they likes coffee"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "LikesCoffee(x) ::: x likes coffee"
        ]
    },
    {
        "premises-NL": [
            "All patients who have the flu have a fever.",
            "All patients who have the flu have a cough.",
            "Some patients have the flu.",
            "Some patients take medicine.",
            "If a patient has the flu, they take medicine.",
            "If a patient takes medicine, they have a fever.",
            "If a patient has a fever, they have a cough.",
            "Patients who have a fever and cough takes medicine.",
            "If patient takes medicine, they have a fever or cough.",
            "Patients has flu or fever or cough",
            "If patient does not have a fever, they have a cough.",
            "If patient has a fever and cough they have flu.",
            "Patients that take medicine, have a fever and cough.",
            "Patients does not have a flu and have fever and cough.",
            "Patients takes medicine and have flu",
            "Patients does not have fever."
        ],
        "premises-FOL": [
            "∀x (Patient(x) ∧ HasFlu(x) → HasFever(x)) ::: All patients who have the flu have a fever",
            "∀x (Patient(x) ∧ HasFlu(x) → HasCough(x)) ::: All patients who have the flu have a cough",
            "∃x (Patient(x) ∧ HasFlu(x)) ::: Some patients have the flu",
            "∃x (Patient(x) ∧ TakesMedicine(x)) ::: Some patients take medicine",
            "∀x (Patient(x) ∧ HasFlu(x) → TakesMedicine(x)) ::: If a patient has the flu, they take medicine",
            "∀x (Patient(x) ∧ TakesMedicine(x) → HasFever(x)) ::: If a patient takes medicine, they have a fever",
            "∀x (Patient(x) ∧ HasFever(x) → HasCough(x)) ::: If a patient has a fever, they have a cough",
            "∀x (Patient(x) ∧ HasFever(x) ∧ HasCough(x) → TakesMedicine(x)) ::: Patients who have a fever and cough takes medicine",
            "∀x (Patient(x) ∧ TakesMedicine(x) → HasFever(x) ∨ HasCough(x)) ::: If patient takes medicine, they have a fever or cough",
            "∀x (Patient(x) → HasFlu(x) ∨ HasFever(x) ∨ HasCough(x)) ::: Patients has flu or fever or cough",
            "∀x (Patient(x) ∧ ¬HasFever(x) → HasCough(x)) ::: If patient does not have a fever, they have a cough",
            "∀x (Patient(x) ∧ HasFever(x) ∧ HasCough(x) → HasFlu(x)) ::: If patient has a fever and cough they have flu",
            "∀x (Patient(x) ∧ TakesMedicine(x) → HasFever(x) ∧ HasCough(x)) ::: Patients that take medicine, have a fever and cough",
            "∀x (Patient(x) ∧ ¬HasFlu(x) → HasFever(x) ∧ HasCough(x)) ::: Patients does not have a flu and have fever and cough",
            "∀x (Patient(x) ∧ TakesMedicine(x) → HasFlu(x)) ::: Patients takes medicine and have flu",
            "∀x (Patient(x) → ¬HasFever(x)) ::: Patients does not have fever"
        ],
        "predicates": [
            "Patient(x) ::: x is a patient",
            "HasFlu(x) ::: x has the flu",
            "HasFever(x) ::: x has a fever",
            "HasCough(x) ::: x has a cough",
            "TakesMedicine(x) ::: x takes medicine"
        ]
    },
    {
        "premises-NL": [
            "All doctors are highly educated or have significant experience.",
            "Some people are doctors.",
            "If someone is a doctor, they specialize in medicine.",
            "If someone is highly educated, then they are a doctor.",
            "Some doctors have significant experience.",
            "If a person specializes in medicine, then they are highly educated.",
            "If a person has significant experience, they are a doctor.",
            "If a person is a doctor, they are not highly educated.",
            "If a person does not have significant experience, they are doctor.",
            "A person is a doctor if they are highly educated and have significant experience.",
            "If a person is a doctor, they are highly educated and have significant experience.",
            "Some people are highly educated and have significant experience.",
            "If a person specializes in medicine and has significant experience, then they are highly educated.",
            "If a person is a doctor then they are highly educated and specializes in medicine.",
            "If a person is a doctor and highly educated, they have significant experience.",
            "If a person is highly educated and has significant experience, they specialize in medicine."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HighlyEducated(x) ∨ SignificantExperience(x)) ::: All doctors are highly educated or have significant experience",
            "∃x Doctor(x) ::: Some people are doctors",
            "∀x (Doctor(x) → SpecializesIn(x, medicine)) ::: If someone is a doctor, they specialize in medicine",
            "∀x (HighlyEducated(x) → Doctor(x)) ::: If someone is highly educated, then they are a doctor",
            "∃x (Doctor(x) ∧ SignificantExperience(x)) ::: Some doctors have significant experience",
            "∀x (SpecializesIn(x, medicine) → HighlyEducated(x)) ::: If a person specializes in medicine, then they are highly educated",
            "∀x (SignificantExperience(x) → Doctor(x)) ::: If a person has significant experience, they are a doctor",
            "∀x (Doctor(x) → ¬HighlyEducated(x)) ::: If a person is a doctor, they are not highly educated",
            "∀x (¬SignificantExperience(x) → Doctor(x)) ::: If a person does not have significant experience, they are doctor",
            "∀x (Doctor(x) ↔ HighlyEducated(x) ∧ SignificantExperience(x)) ::: A person is a doctor if they are highly educated and have significant experience",
            "∀x (Doctor(x) → HighlyEducated(x) ∧ SignificantExperience(x)) ::: If a person is a doctor, they are highly educated and have significant experience",
            "∃x (HighlyEducated(x) ∧ SignificantExperience(x)) ::: Some people are highly educated and have significant experience",
            "∀x (SpecializesIn(x, medicine) ∧ SignificantExperience(x) → HighlyEducated(x)) ::: If a person specializes in medicine and has significant experience, then they are highly educated",
            "∀x (Doctor(x) → HighlyEducated(x) ∧ SpecializesIn(x, medicine)) ::: If a person is a doctor then they are highly educated and specializes in medicine",
            "∀x (Doctor(x) ∧ HighlyEducated(x) → SignificantExperience(x)) ::: If a person is a doctor and highly educated, they have significant experience",
            "∀x (HighlyEducated(x) ∧ SignificantExperience(x) → SpecializesIn(x, medicine)) ::: If a person is highly educated and has significant experience, they specialize in medicine"
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Doctor(x) ::: x is a doctor",
            "HighlyEducated(x) ::: x is highly educated",
            "SignificantExperience(x) ::: x has significant experience",
            "SpecializesIn(x, y) ::: x specializes in y"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "Alice is a doctor.",
            "If someone treats a patient, then they help people.",
            "There exists a patient."
        ],
        "premises-FOL": [
            "∀x ∀y (Doctor(x) ∧ Patient(y) → Treats(x, y)) ::: All doctors treat patients.",
            "Doctor(Alice) ::: Alice is a doctor.",
            "∀x ∀y (Treats(x, y) → Helps(x, y)) ::: If someone treats a patient, then they help people.",
            "∃x Patient(x) ::: There exists a patient."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Patient(x) ::: x is a patient.",
            "Helps(x, y) ::: x helps y.",
            "Treats(x, y) ::: x treats y."
        ]
    },
    {
        "premises-NL": [
            "All students who study hard will pass the exam.",
            "Sarah is a student.",
            "Sarah studies hard.",
            "If someone likes coffee, then they are a student.",
            "Sarah likes coffee.",
            "If Sarah is a student, then she will pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: All students who study hard will pass the exam.",
            "Student(sarah) ::: Sarah is a student.",
            "StudiesHard(sarah) ::: Sarah studies hard.",
            "∀x (LikesCoffee(x) → Student(x)) ::: If someone likes coffee, then they are a student.",
            "LikesCoffee(sarah) ::: Sarah likes coffee.",
            "Student(sarah) → PassExam(sarah) ::: If Sarah is a student, then she will pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesHard(x) ::: x studies hard.",
            "PassExam(x) ::: x will pass the exam.",
            "LikesCoffee(x) ::: x likes coffee."
        ]
    },
    {
        "premises-NL": [
            "Everyone who attends the workshop and has a mentor is eligible for promotion.",
            "John attends the workshop.",
            "John has a mentor.",
            "If someone is an expert, they help everyone.",
            "John's mentor is an expert.",
            "If someone is promoted, they get a bonus.",
            "John gets promoted."
        ],
        "premises-FOL": [
            "∀x (AttendsWorkshop(x) ∧ HasMentor(x) → Promoted(x)) ::: Everyone who attends the workshop and has a mentor is eligible for promotion.",
            "AttendsWorkshop(john) ::: John attends the workshop.",
            "HasMentor(john) ::: John has a mentor.",
            "∀x ∀y (Expert(x) → Helps(x, y)) ::: If someone is an expert, they help everyone.",
            "Expert(johnsMentor) ::: John's mentor is an expert.",
            "∀x (Promoted(x) → GetsBonus(x)) ::: If someone is promoted, they get a bonus.",
            "Promoted(john) ::: John gets promoted."
        ],
        "predicates": [
            "AttendsWorkshop(x) ::: x attends the workshop.",
            "HasMentor(x) ::: x has a mentor.",
            "Promoted(x) ::: x will get promoted.",
            "Expert(x) ::: x is an expert.",
            "Helps(x, y) ::: x helps y."
        ]
    },
    {
        "premises-NL": [
            "Patients with fever and cough who test positive for the virus need to be quarantined.",
            "Patient A has a fever.",
            "Patient A has a cough.",
            "Patient A tested positive for the virus.",
            "If someone is infected with a virus, they have symptoms.",
            "If someone socializes with an infected person, and the infected person transmits the virus, the person is infected.",
            "Patient A is a patient.",
            "Patient A socializes with Patient B.",
            "Patient B is infected with the virus."
        ],
        "premises-FOL": [
            "∀x ∀y (HasFever(x) ∧ HasCough(x) ∧ TestedPositive(x, y) → Quarantine(x)) ::: Patients with fever and cough who test positive for the virus need to be quarantined.",
            "HasFever(patientA) ::: Patient A has a fever.",
            "HasCough(patientA) ::: Patient A has a cough.",
            "TestedPositive(patientA, virus) ::: Patient A tested positive for the virus.",
            "∀x ∀y (Infected(x, y) → HasSymptom(x, y)) ::: If someone is infected with a virus, they have symptoms.",
            "∀x ∀y ∀z (Socializes(x, y) ∧ Transmits(y, virus, x) → Infected(x, virus)) ::: If someone socializes with an infected person, and the infected person transmits the virus, the person is infected.",
            "IsPatient(patientA) ::: Patient A is a patient.",
            "Socializes(patientA, patientB) ::: Patient A socializes with Patient B.",
            "Infected(patientB, virus) ::: Patient B is infected with the virus."
        ],
        "predicates": [
            "HasFever(x) ::: x has a fever.",
            "HasCough(x) ::: x has a cough.",
            "TestedPositive(x, y) ::: x tested positive for virus y.",
            "Quarantine(x) ::: x needs to be quarantined.",
            "IsPatient(x) ::: x is a patient.",
            "HasSymptom(x, y) ::: x has symptom y.",
            "Infected(x, y) ::: x is infected with y.",
            "Transmits(x, y, z) ::: x transmits virus y to z.",
            "Socializes(x, y) ::: x socializes with y."
        ]
    },
    {
        "premises-NL": [
            "Seniors who study hard and have good mentors are eligible for honors and scholarships, unless they fail the important exam.",
            "John is a senior.",
            "John studies hard.",
            "John has a good mentor.",
            "Students who are eligible for honors and scholarships will graduate with honors and get a scholarship.",
            "If someone maintains a good GPA, attends classes, and participates in research, then they are eligible.",
            "John maintains a good GPA.",
            "John attends classes.",
            "John participates in research.",
            "If someone fails an important exam, they are not eligible.",
            "John did not fail the important exam."
        ],
        "premises-FOL": [
            "∀x (Senior(x) ∧ StudiesHard(x) ∧ HasGoodMentor(x)) ∧ ¬FailsExam(x, importantExam) → (HonorsGraduate(x) ∧ GetsScholarship(x)) ::: Seniors who study hard and have good mentors are eligible for honors and scholarships, unless they fail the important exam.",
            "Senior(john) ::: John is a senior.",
            "StudiesHard(john) ::: John studies hard.",
            "HasGoodMentor(john) ::: John has a good mentor.",
            "∀x (IsEligible(x) → (HonorsGraduate(x) ∧ GetsScholarship(x))) ::: Students who are eligible for honors and scholarships will graduate with honors and get a scholarship.",
            "∀x (MaintainsGPA(x) ∧ AttendsClasses(x) ∧ ParticipatesInResearch(x) → IsEligible(x)) ::: If someone maintains a good GPA, attends classes, and participates in research, then they are eligible.",
            "MaintainsGPA(john) ::: John maintains a good GPA.",
            "AttendsClasses(john) ::: John attends classes.",
            "ParticipatesInResearch(john) ::: John participates in research.",
            "∀x (FailsExam(x, importantExam) → ¬IsEligible(x)) ::: If someone fails an important exam, they are not eligible.",
            "¬FailsExam(john, importantExam) ::: John did not fail the important exam."
        ],
        "predicates": [
            "Senior(x) ::: x is a senior.",
            "StudiesHard(x) ::: x studies hard.",
            "HasGoodMentor(x) ::: x has a good mentor.",
            "HonorsGraduate(x) ::: x graduates with honors.",
            "GetsScholarship(x) ::: x gets a scholarship.",
            "FailsExam(x, y) ::: x fails exam y.",
            "IsEligible(x) ::: x is eligible.",
            "MaintainsGPA(x) ::: x maintains a good GPA.",
            "AttendsClasses(x) ::: x attends classes.",
            "ParticipatesInResearch(x) ::: x participates in research.",
            "HasPublications(x) ::: x has publications."
        ]
    },
    {
        "premises-NL": [
            "If the plant is watered, then it needs sunlight.",
            "If the plant is exposed to sunlight and fertilized, then it grows.",
            "If the plant is watered, it is fertilized.",
            "If the plant is fertilized, then it is healthy.",
            "The plant needs water.",
            "The plant is watered.",
            "If the plant needs water, the plant is watered.",
            "If the plant is healthy and exposed to sunlight, then it will grow.",
            "If the plant is exposed to sunlight, then it is healthy.",
            "If the plant is fertilized and exposed to sunlight, it is healthy.",
            "If the plant is watered and exposed to sunlight, then it will grow.",
            "The plant is either watered or exposed to sunlight.",
            "If the plant is not watered, it doesn't grow.",
            "If the plant is exposed to sunlight and is healthy, then it grows.",
            "If the plant is watered and fertilized, then it is exposed to sunlight.",
            "If the plant is watered, then it grows."
        ],
        "premises-FOL": [
            "Watered(plant) → Sunlight(plant) ::: If the plant is watered, then it needs sunlight.",
            "(Sunlight(plant) ∧ Fertilized(plant)) → Grows(plant) ::: If the plant is exposed to sunlight and fertilized, then it grows.",
            "Watered(plant) → Fertilized(plant) ::: If the plant is watered, it is fertilized.",
            "Fertilized(plant) → Healthy(plant) ::: If the plant is fertilized, then it is healthy.",
            "NeedsWater(plant) ::: The plant needs water.",
            "Watered(plant) ::: The plant is watered.",
            "NeedsWater(plant) → Watered(plant) ::: If the plant needs water, the plant is watered.",
            "(Healthy(plant) ∧ Sunlight(plant)) → Grows(plant) ::: If the plant is healthy and exposed to sunlight, then it will grow.",
            "Sunlight(plant) → Healthy(plant) ::: If the plant is exposed to sunlight, then it is healthy.",
            "(Fertilized(plant) ∧ Sunlight(plant)) → Healthy(plant) ::: If the plant is fertilized and exposed to sunlight, it is healthy.",
            "(Watered(plant) ∧ Sunlight(plant)) → Grows(plant) ::: If the plant is watered and exposed to sunlight, then it will grow.",
            "Watered(plant) ∨ Sunlight(plant) ::: The plant is either watered or exposed to sunlight.",
            "¬Watered(plant) → ¬Grows(plant) ::: If the plant is not watered, it doesn't grow.",
            "(Sunlight(plant) ∧ Healthy(plant)) → Grows(plant) ::: If the plant is exposed to sunlight and is healthy, then it grows.",
            "(Watered(plant) ∧ Fertilized(plant)) → Sunlight(plant) ::: If the plant is watered and fertilized, then it is exposed to sunlight.",
            "Watered(plant) → Grows(plant) ::: If the plant is watered, then it grows."
        ],
        "predicates": [
            "Watered(x) ::: x is watered",
            "Sunlight(x) ::: x is exposed to sunlight",
            "Grows(x) ::: x grows",
            "Fertilized(x) ::: x is fertilized",
            "Healthy(x) ::: x is healthy",
            "NeedsWater(x) ::: x needs water"
        ]
    },
    {
        "premises-NL": [
            "All people are members of a club.",
            "Some clubs have meetings.",
            "If someone is a member of a club, then that person is a club member.",
            "If a club has meetings, then people who are members of the club attend those meetings.",
            "All the people are member of at least one club."
        ],
        "premises-FOL": [
            "∀x ∃y MemberOf(x, y) ::: All people are members of a club.",
            "∃x HasMeetings(x) ::: Some clubs have meetings.",
            "∀x ∀y (MemberOf(x, y) → Member(x, y)) ::: If someone is a member of a club, then that person is a club member.",
            "∀x ∀y (HasMeetings(y) ∧ MemberOf(x, y) → AttendsMeeting(x, y)) ::: If a club has meetings, then people who are members of the club attend those meetings.",
            "∀x ∃y (Person(x) → MemberOf(x, y)) ::: All the people are member of at least one club."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "MemberOf(x, y) ::: x is a member of y.",
            "Club(x) ::: x is a club.",
            "HasMeetings(x) ::: x has meetings.",
            "AttendsMeeting(x, y) ::: x attends the meeting of y.",
            "Meeting(x) ::: x is a meeting."
        ]
    },
    {
        "premises-NL": [
            "All artists are creative.",
            "Some creative people are famous.",
            "John is an artist.",
            "John is creative.",
            "John is not famous.",
            "If someone is an artist then that person is creative.",
            "If someone is creative, and not famous, then that person is not an artist.",
            "There is some creative person",
            "If someone is famous, then that person is creative"
        ],
        "premises-FOL": [
            "∀x (Artist(x) → Creative(x)) ::: All artists are creative.",
            "∃x (Creative(x) ∧ Famous(x)) ::: Some creative people are famous.",
            "Artist(john) ::: John is an artist.",
            "Creative(john) ::: John is creative.",
            "¬Famous(john) ::: John is not famous.",
            "∀x (Artist(x) → Creative(x)) ::: If someone is an artist then that person is creative.",
            "∀x ((Creative(x) ∧ ¬Famous(x)) → ¬Artist(x)) ::: If someone is creative, and not famous, then that person is not an artist.",
            "∃x Creative(x) ::: There is some creative person",
            "∀x (Famous(x) → Creative(x)) ::: If someone is famous, then that person is creative"
        ],
        "predicates": [
            "Artist(x) ::: x is an artist.",
            "Creative(x) ::: x is creative.",
            "Famous(x) ::: x is famous."
        ]
    },
    {
        "premises-NL": [
            "Some people like apples.",
            "Some people like bananas.",
            "Everyone who likes apples also likes fruit.",
            "Everyone who likes bananas also likes fruit.",
            "If someone likes apples, then they are a person.",
            "If someone likes bananas, then they are a person.",
            "If x likes apples and y likes bananas, then x and y are friends.",
            "John likes apples and John likes bananas.",
            "If John likes apples and bananas, then John likes apples and bananas.",
            "There is someone who likes both apples and bananas."
        ],
        "premises-FOL": [
            "∃x Likes(x, apples) ::: Some people like apples.",
            "∃x Likes(x, bananas) ::: Some people like bananas.",
            "∀x (Likes(x, apples) → Likes(x, fruit)) ::: Everyone who likes apples also likes fruit.",
            "∀x (Likes(x, bananas) → Likes(x, fruit)) ::: Everyone who likes bananas also likes fruit.",
            "∀x (Likes(x, apples) → Person(x)) ::: If someone likes apples, then they are a person.",
            "∀x (Likes(x, bananas) → Person(x)) ::: If someone likes bananas, then they are a person.",
            "∀x ∀y ((Likes(x, apples) ∧ Likes(y, bananas)) → Friends(x, y)) ::: If x likes apples and y likes bananas, then x and y are friends.",
            "Likes(john, apples) ∧ Likes(john, bananas) ::: John likes apples and John likes bananas.",
            "∀x (Likes(john, apples) ∧ Likes(john, bananas) → (Likes(john, apples) ∧ Likes(john, bananas))) ::: If John likes apples and bananas, then John likes apples and bananas.",
            "∃x (Likes(x, apples) ∧ Likes(x, bananas)) ::: There is someone who likes both apples and bananas."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "Likes(x, y) ::: x likes y.",
            "Apples(x) ::: x likes apples.",
            "Bananas(x) ::: x likes bananas."
        ]
    },
    {
        "premises-NL": [
            "All students must pass the exam.",
            "Some students like the course.",
            "If a student studies hard, then that student passes the exam.",
            "Everyone who studies hard passes the exam.",
            "John is a student.",
            "John studies hard.",
            "John passes the exam.",
            "If John studies hard then John passes the exam.",
            "If someone passes the exam, then that person is a student.",
            "If a student likes the course, then they will study hard.",
            "Some students study hard.",
            "Not all students like the course."
        ],
        "premises-FOL": [
            "∀x (Student(x) → PassesExam(x)) ::: All students must pass the exam.",
            "∃x ∃y (Student(x) ∧ Likes(x, y) ∧ Course(y)) ::: Some students like the course.",
            "∀x (StudiesHard(x) → PassesExam(x)) ::: If a student studies hard, then that student passes the exam.",
            "∀x (StudiesHard(x) → PassesExam(x)) ::: Everyone who studies hard passes the exam.",
            "Student(john) ::: John is a student.",
            "StudiesHard(john) ::: John studies hard.",
            "PassesExam(john) ::: John passes the exam.",
            "∀x (StudiesHard(john) → PassesExam(john)) ::: If John studies hard then John passes the exam.",
            "∀x (PassesExam(x) → Student(x)) ::: If someone passes the exam, then that person is a student.",
            "∀x ∀y ((Student(x) ∧ Likes(x, y) ∧ Course(y)) → StudiesHard(x)) ::: If a student likes the course, then they will study hard.",
            "∃x (Student(x) ∧ StudiesHard(x)) ::: Some students study hard.",
            "¬∀x ∃y (Student(x) ∧ Likes(x, y) ∧ Course(y)) ::: Not all students like the course."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesHard(x) ::: x studies hard.",
            "PassesExam(x) ::: x passes the exam.",
            "Likes(x, y) ::: x likes y.",
            "Course(x) ::: x is a course."
        ]
    },
    {
        "premises-NL": [
            "All programmers are good at logic.",
            "Some people are programmers.",
            "John is a programmer.",
            "If someone is a programmer then that person is good at logic.",
            "If someone is good at logic, then that person is a person.",
            "If a person knows a programming language, then the person is a programmer.",
            "Every programmer knows how to code.",
            "If John is a programmer, then John is good at logic.",
            "If John is good at logic, then John is a person.",
            "John is a person.",
            "If John knows Python, then John is a programmer.",
            "Some people know Python.",
            "If someone is a programmer, then they are a person."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → GoodAtLogic(x)) ::: All programmers are good at logic.",
            "∃x (Person(x) ∧ Programmer(x)) ::: Some people are programmers.",
            "Programmer(john) ::: John is a programmer.",
            "∀x (Programmer(x) → GoodAtLogic(x)) ::: If someone is a programmer then that person is good at logic.",
            "∀x (GoodAtLogic(x) → Person(x)) ::: If someone is good at logic, then that person is a person.",
            "∀x ∀y ((Person(x) ∧ Knows(x, y) ∧ Language(y)) → Programmer(x)) ::: If a person knows a programming language, then the person is a programmer.",
            "∀x (Programmer(x) → KnowsHowToCode(x)) ::: Every programmer knows how to code.",
            "∀x (Programmer(john) → GoodAtLogic(john)) ::: If John is a programmer, then John is good at logic.",
            "∀x (GoodAtLogic(john) → Person(john)) ::: If John is good at logic, then John is a person.",
            "Person(john) ::: John is a person.",
            "∀x ((Knows(john, python) ∧ Language(python)) → Programmer(john)) ::: If John knows Python, then John is a programmer.",
            "∃x (Person(x) ∧ Knows(x, python) ∧ Language(python)) ::: Some people know Python.",
            "∀x (Programmer(x) → Person(x)) ::: If someone is a programmer, then they are a person."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer.",
            "GoodAtLogic(x) ::: x is good at logic.",
            "Person(x) ::: x is a person.",
            "Knows(x, y) ::: x knows y.",
            "Language(x) ::: x is a programming language."
        ]
    },
    {
        "premises-NL": [
            "All professors are researchers.",
            "All researchers write papers.",
            "All professors teach courses or write papers.",
            "If someone is a professor, then they have a PhD.",
            "All students are enrolled in a course.",
            "All researchers publish papers.",
            "If someone has a PhD, they are a professor.",
            "Some students are professors.",
            "Some students are enrolled in a course.",
            "Some researchers teach courses.",
            "All those who teach courses are professors.",
            "If someone teaches a course, then they are a professor.",
            "If someone writes a paper, they publish it.",
            "If someone publishes something, they write something.",
            "A student is a professor only if they teach a course."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Researcher(x)) ::: All professors are researchers.",
            "∀x (Researcher(x) → Writes(x, Paper)) ::: All researchers write papers.",
            "∀x (Professor(x) → (Teaches(x, Course) ∨ Writes(x, Paper))) ::: All professors teach courses or write papers.",
            "∀x (Professor(x) → PhD(x)) ::: If someone is a professor, then they have a PhD.",
            "∀x ∃y (Student(x) → Enrolled(x, y)) ::: All students are enrolled in a course.",
            "∀x (Researcher(x) → Publishes(x, Paper)) ::: All researchers publish papers.",
            "∀x (PhD(x) → Professor(x)) ::: If someone has a PhD, they are a professor.",
            "∃x (Student(x) ∧ Professor(x)) ::: Some students are professors.",
            "∃x ∃y (Student(x) ∧ Enrolled(x, y)) ::: Some students are enrolled in a course.",
            "∃x ∃y (Researcher(x) ∧ Teaches(x, y)) ::: Some researchers teach courses.",
            "∀x (Teaches(x, Course) → Professor(x)) ::: All those who teach courses are professors.",
            "∀x (Teaches(x, Course) → Professor(x)) ::: If someone teaches a course, then they are a professor.",
            "∀x ∀y (Writes(x, y) → Publishes(x, y)) ::: If someone writes a paper, they publish it.",
            "∀x ∀y (Publishes(x, y) → Writes(x, y)) ::: If someone publishes something, they write something.",
            "∀x (Student(x) ∧ Professor(x) → Teaches(x, Course)) ::: A student is a professor only if they teach a course."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches y",
            "Course(x) ::: x is a course",
            "Writes(x, y) ::: x writes y",
            "Paper(x) ::: x is a paper",
            "Researcher(x) ::: x is a researcher",
            "Publishes(x, y) ::: x publishes y",
            "PhD(x) ::: x has a PhD",
            "Student(x) ::: x is a student",
            "Enrolled(x, y) ::: x is enrolled in y"
        ]
    },
    {
        "premises-NL": [
            "All doctors work in hospitals.",
            "All surgeons are doctors.",
            "All surgeons operate on patients.",
            "All specialists are doctors.",
            "Doctors treat patients.",
            "All those who work in a hospital are doctors.",
            "If someone is a doctor, they are a specialist.",
            "If someone treats patients, then they work in a hospital.",
            "If someone operates, then they are a surgeon.",
            "If someone is a researcher, they publish papers.",
            "If someone publishes a paper, they are a researcher.",
            "If someone is a doctor, they can administer medicine.",
            "Some doctors are surgeons.",
            "Some doctors treat patients.",
            "If someone works in a hospital, they treat patients.",
            "If someone administers medicine, they work in a hospital."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → WorksIn(x, Hospital)) ::: All doctors work in hospitals.",
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Surgeon(x) → Operates(x, Patient)) ::: All surgeons operate on patients.",
            "∀x (Specialist(x) → Doctor(x)) ::: All specialists are doctors.",
            "∀x (Doctor(x) → Treats(x, Patient)) ::: Doctors treat patients.",
            "∀x (WorksIn(x, Hospital) → Doctor(x)) ::: All those who work in a hospital are doctors.",
            "∀x (Doctor(x) → Specialist(x)) ::: If someone is a doctor, they are a specialist.",
            "∀x (Treats(x, Patient) → WorksIn(x, Hospital)) ::: If someone treats patients, then they work in a hospital.",
            "∀x (Operates(x, y) → Surgeon(x)) ::: If someone operates, then they are a surgeon.",
            "∀x (Researcher(x) → Publishes(x, Paper)) ::: If someone is a researcher, they publish papers.",
            "∀x (Publishes(x, Paper) → Researcher(x)) ::: If someone publishes a paper, they are a researcher.",
            "∀x (Doctor(x) → Administers(x, Medicine)) ::: If someone is a doctor, they can administer medicine.",
            "∃x (Doctor(x) ∧ Surgeon(x)) ::: Some doctors are surgeons.",
            "∃x (Doctor(x) ∧ Treats(x, Patient)) ::: Some doctors treat patients.",
            "∀x (WorksIn(x, Hospital) → Treats(x, Patient)) ::: If someone works in a hospital, they treat patients.",
            "∀x (Administers(x, Medicine) → WorksIn(x, Hospital)) ::: If someone administers medicine, they work in a hospital."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "WorksIn(x, y) ::: x works in y",
            "Hospital(x) ::: x is a hospital",
            "Treats(x, y) ::: x treats y",
            "Patient(x) ::: x is a patient",
            "Surgeon(x) ::: x is a surgeon",
            "Operates(x, y) ::: x operates on y",
            "Specialist(x) ::: x is a specialist",
            "Disease(x) ::: x is a disease",
            "Researcher(x) ::: x is a researcher",
            "Publishes(x, y) ::: x publishes y",
            "Paper(x) ::: x is a paper",
            "Administers(x, y) ::: x administers y"
        ]
    },
    {
        "premises-NL": [
            "All students who studied hard passed the exam.",
            "If a student passed the exam, they are happy.",
            "Some students studied hard.",
            "All students who are happy passed the course.",
            "John is a student.",
            "John studied hard.",
            "If someone is a student, then they are taking a course.",
            "Jane is a student.",
            "If someone passed the course, they are happy.",
            "Every student that studies hard will pass the exam.",
            "If a student is happy, then they will not be sad.",
            "Every happy person passes the course."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiedHard(x) → PassedExam(x)) ::: For all x, if x is a student and studied hard, then x passed the exam.",
            "∀x (PassedExam(x) → Happy(x)) ::: For all x, if x passed the exam, then x is happy.",
            "∃x (Student(x) ∧ StudiedHard(x)) ::: There exists a student who studied hard.",
            "∀x (Happy(x) → PassedCourse(x)) ::: For all x, if x is happy, then x passed the course.",
            "Student(john) ::: John is a student.",
            "StudiedHard(john) ::: John studied hard.",
            "∀x (Student(x) → TakingCourse(x)) ::: For all x, if x is a student, then x is taking a course.",
            "Student(jane) ::: Jane is a student.",
            "∀x (PassedCourse(x) → Happy(x)) ::: For all x, if x passed the course, then x is happy.",
            "∀x (Student(x) ∧ StudiedHard(x) → PassedExam(x)) ::: Every student that studies hard will pass the exam.",
            "∀x (Happy(x) → ¬Sad(x)) ::: If a student is happy, then they will not be sad.",
            "∀x (Happy(x) → PassedCourse(x)) ::: Every happy person passes the course."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PassedExam(x) ::: x passed the exam",
            "Happy(x) ::: x is happy",
            "StudiedHard(x) ::: x studied hard",
            "PassedCourse(x) ::: x passed the course"
        ]
    },
    {
        "premises-NL": [
            "Everyone who owns a car and a house has a job.",
            "If someone has a job and works hard, they earn a high income.",
            "John owns a car.",
            "John owns a house.",
            "If someone has a job, they are working.",
            "Someone who works hard saves money.",
            "Everyone who saves money buys property.",
            "If someone buys property, they own a house.",
            "Jane owns a car.",
            "Jane owns a house.",
            "Everyone who owns a car has a job.",
            "Anyone who works hard will save money.",
            "If anyone saves money, then they have a high income."
        ],
        "premises-FOL": [
            "∀x (Owns(x, car) ∧ Owns(x, house) → HasJob(x)) ::: For all x, if x owns a car and a house, then x has a job.",
            "∀x (HasJob(x) ∧ WorksHard(x) → HighIncome(x)) ::: For all x, if x has a job and works hard, then x has a high income.",
            "Owns(john, car) ::: John owns a car.",
            "Owns(john, house) ::: John owns a house.",
            "∀x (HasJob(x) → Working(x)) ::: For all x, if x has a job, then x is working.",
            "∃x (WorksHard(x) → SavesMoney(x)) ::: Someone who works hard saves money.",
            "∀x (SavesMoney(x) → BuysProperty(x,y)) ::: Everyone who saves money buys property.",
            "∀x (BuysProperty(x, house) → Owns(x, house)) ::: If someone buys property, they own a house.",
            "Owns(jane, car) ::: Jane owns a car.",
            "Owns(jane, house) ::: Jane owns a house.",
            "∀x (Owns(x, car) → HasJob(x)) ::: Everyone who owns a car has a job.",
            "∀x (WorksHard(x) → SavesMoney(x)) ::: Anyone who works hard will save money.",
            "∀x (SavesMoney(x) → HighIncome(x)) ::: If anyone saves money, then they have a high income."
        ],
        "predicates": [
            "Owns(x, y) ::: x owns y",
            "Car(x) ::: x is a car",
            "House(x) ::: x is a house",
            "HighIncome(x) ::: x has a high income",
            "HasJob(x) ::: x has a job",
            "WorksHard(x) ::: x works hard",
            "SavesMoney(x) ::: x saves money",
            "BuysProperty(x,y) ::: x buys y"
        ]
    },
    {
        "premises-NL": [
            "All council members are attending the meeting or are not voting.",
            "If someone is attending the meeting, they can speak.",
            "If someone knows the policy, they will be voting.",
            "John is a council member.",
            "John is not voting.",
            "If someone is not voting, they are attending the meeting.",
            "Jane is a council member.",
            "Jane is not voting.",
            "All the council members are present at the meeting.",
            "Anyone who follows the rules is voting.",
            "If anyone is attending the meeting, then they are present.",
            "Every council member follows the rules.",
            "If anyone is speaking, they know the policy.",
            "If someone is not voting they cannot speak."
        ],
        "premises-FOL": [
            "∀x (CouncilMember(x) → (AttendingMeeting(x) ∨ ¬Voting(x))) ::: For all x, if x is a council member, then x is attending the meeting or not voting.",
            "∀x (AttendingMeeting(x) → CanSpeak(x)) ::: For all x, if x is attending the meeting, then they can speak.",
            "∀x (KnowsPolicy(x) → Voting(x)) ::: For all x, if x knows the policy, then they will be voting.",
            "CouncilMember(john) ::: John is a council member.",
            "¬Voting(john) ::: John is not voting.",
            "∀x (¬Voting(x) → AttendingMeeting(x)) ::: For all x, if someone is not voting, they are attending the meeting.",
            "CouncilMember(jane) ::: Jane is a council member.",
            "¬Voting(jane) ::: Jane is not voting.",
            "∀x (CouncilMember(x) → IsPresent(x)) ::: All the council members are present at the meeting.",
            "∀x (FollowsRules(x) → Voting(x)) ::: Anyone who follows the rules is voting.",
            "∀x (AttendingMeeting(x) → IsPresent(x)) ::: If anyone is attending the meeting, then they are present.",
            "∀x (CouncilMember(x) → FollowsRules(x)) ::: Every council member follows the rules.",
            "∀x (CanSpeak(x) → KnowsPolicy(x)) ::: If anyone is speaking, they know the policy.",
            "∀x (¬Voting(x) → ¬CanSpeak(x)) ::: If someone is not voting they cannot speak."
        ],
        "predicates": [
            "CouncilMember(x) ::: x is a member of the council",
            "AttendingMeeting(x) ::: x is attending the meeting",
            "Voting(x) ::: x is voting",
            "CanSpeak(x) ::: x can speak",
            "KnowsPolicy(x) ::: x knows the policy",
            "IsPresent(x) ::: x is present",
            "FollowsRules(x) ::: x follows the rules"
        ]
    },
    {
        "premises-NL": [
            "All students who are taking a course attend lectures.",
            "If a student attends lectures and studies, they will pass the exam.",
            "If a student passes the exam and has a good grade, they will succeed.",
            "John is a student.",
            "John is taking a course.",
            "John studies.",
            "If a student is enrolled, they are taking the course.",
            "Jane is a student.",
            "Jane reads books.",
            "Anyone who reads books and studies has a good grade.",
            "If anyone has a good grade, then they will succeed.",
            "If someone studies and is a student, they will attend lectures.",
            "Any student taking a course is enrolled.",
            "Every student who takes a course studies.",
            "Jane is enrolled."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ TakingCourse(x) → AttendsLectures(x)) ::: All students who are taking a course attend lectures.",
            "∀x (AttendsLectures(x) ∧ Studies(x) → PassExam(x)) ::: If a student attends lectures and studies, they will pass the exam.",
            "∀x (PassExam(x) ∧ GoodGrade(x) → Succeed(x)) ::: If a student passes the exam and has a good grade, they will succeed.",
            "Student(john) ::: John is a student.",
            "TakingCourse(john) ::: John is taking a course.",
            "Studies(john) ::: John studies.",
            "∀x ∀y (Enrolled(x, y) → TakingCourse(x)) ::: If a student is enrolled, they are taking the course.",
            "Student(jane) ::: Jane is a student.",
            "ReadsBooks(jane) ::: Jane reads books.",
            "∀x (ReadsBooks(x) ∧ Studies(x) → GoodGrade(x)) ::: Anyone who reads books and studies has a good grade.",
            "∀x (GoodGrade(x) → Succeed(x)) ::: If anyone has a good grade, then they will succeed.",
            "∀x (Studies(x) ∧ Student(x) → AttendsLectures(x)) ::: If someone studies and is a student, they will attend lectures.",
            "∀x (Student(x) ∧ TakingCourse(x) → Enrolled(x, y)) ::: Any student taking a course is enrolled.",
            "∀x (Student(x) ∧ TakingCourse(x) → Studies(x)) ::: Every student who takes a course studies.",
            "Enrolled(jane, course) ::: Jane is enrolled."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "TakingCourse(x) ::: x is taking a course",
            "GoodGrade(x) ::: x has a good grade",
            "Succeed(x) ::: x will succeed",
            "AttendsLectures(x) ::: x attends lectures",
            "Studies(x) ::: x studies",
            "ReadsBooks(x) ::: x reads books",
            "PassExam(x) ::: x passes the exam",
            "Enrolled(x,y) ::: x is enrolled in y"
        ]
    },
    {
        "premises-NL": [
            "All cities with good infrastructure have parks.",
            "All cities with good infrastructure have good schools.",
            "A city with low pollution is safe.",
            "If a city is safe and has jobs, it has good infrastructure.",
            "If a city has public transport, it provides services.",
            "New York is a city.",
            "New York has good schools.",
            "New York has low pollution.",
            "If a city has good schools and provides services, it has good infrastructure.",
            "New York has public transport.",
            "A city with public transport has low crime.",
            "A safe city has jobs.",
            "A city with good transportation has low crime."
        ],
        "premises-FOL": [
            "∀x (City(x) ∧ GoodInfrastructure(x) → HasParks(x)) ::: All cities with good infrastructure have parks.",
            "∀x (City(x) ∧ GoodInfrastructure(x) → HasGoodSchools(x)) ::: All cities with good infrastructure have good schools.",
            "∀x (City(x) ∧ LowPollution(x) → IsSafe(x)) ::: A city with low pollution is safe.",
            "∀x (City(x) ∧ IsSafe(x) ∧ HasJobs(x) → GoodInfrastructure(x)) ::: If a city is safe and has jobs, it has good infrastructure.",
            "∀x (City(x) ∧ PublicTransport(x) → ProvidesServices(x)) ::: If a city has public transport, it provides services.",
            "City(NewYork) ::: New York is a city.",
            "HasGoodSchools(NewYork) ::: New York has good schools.",
            "LowPollution(NewYork) ::: New York has low pollution.",
            "∀x (City(x) ∧ HasGoodSchools(x) ∧ ProvidesServices(x) → GoodInfrastructure(x)) ::: If a city has good schools and provides services, it has good infrastructure.",
            "PublicTransport(NewYork) ::: New York has public transport.",
            "∀x (City(x) ∧ PublicTransport(x) → LowCrime(x)) ::: A city with public transport has low crime.",
            "∀x (City(x) ∧ IsSafe(x) → HasJobs(x)) ::: A safe city has jobs.",
            "∀x (City(x) ∧ HasGoodTransportation(x) → LowCrime(x)) ::: A city with good transportation has low crime."
        ],
        "predicates": [
            "City(x) ::: x is a city.",
            "GoodInfrastructure(x) ::: x has good infrastructure.",
            "LowCrime(x) ::: x has low crime.",
            "DesirablePlaceToLive(x) ::: x is a desirable place to live.",
            "HasParks(x) ::: x has parks.",
            "HasGoodSchools(x) ::: x has good schools.",
            "PollutionLevel(x, y) ::: x has a pollution level of y",
            "LowPollution(x) ::: x has low pollution.",
            "IsSafe(x) ::: x is safe",
            "HasJobs(x) ::: x has jobs.",
            "HasGoodTransportation(x) ::: x has good transportation.",
            "ProvidesServices(x) ::: x provides services",
            "PublicTransport(x) ::: x has public transport"
        ]
    },
    {
        "premises-NL": [
            "All students are either taking Calculus or Physics.",
            "Some students take Calculus.",
            "No student takes both Calculus and Physics."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (TakesCalculus(x) ∨ TakesPhysics(x))) ::: For all x, if x is a student, then x takes Calculus or Physics.",
            "∃x (Student(x) ∧ TakesCalculus(x)) ::: There exists an x such that x is a student and takes Calculus.",
            "¬∃x (TakesCalculus(x) ∧ TakesPhysics(x)) ::: It is not the case that there exists an x who takes both Calculus and Physics.",
            "∀x (TakesCalculus(x) → PassedCalculus(x)) ::: For all x, if x takes Calculus, then x passed Calculus.",
            "Student(Alice) ::: Alice is a student.",
            "TakesCalculus(Alice) ::: Alice takes Calculus.",
            "TakesPhysics(Bob) ::: Bob takes Physics.",
            "Student(Bob) ::: Bob is a student.",
            "¬TakesCalculus(Bob) ::: Bob does not take Calculus.",
            "¬TakesPhysics(Alice) ::: Alice does not take Physics."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "TakesCalculus(x) ::: x takes Calculus.",
            "TakesPhysics(x) ::: x takes Physics.",
            "PassedCalculus(x) ::: x passed Calculus."
        ]
    },
    {
        "premises-NL": [
            "All doctors either publish a paper or study a disease.",
            "All researchers study diseases.",
            "Some doctors are researchers.",
            "Anyone who publishes a paper is a researcher.",
            "Someone is a doctor.",
            "Someone studies a disease.",
            "Anyone who studies a disease is a researcher.",
            "All researchers publish papers.",
            "If anyone is a doctor, then they either publish a paper or study a disease.",
            "If anyone is a doctor and studies a disease, they are a researcher.",
            "If anyone is a researcher and studies a disease, they are a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → (PublishesPaper(x) ∨ StudiesDisease(x))) ::: If x is a doctor, then x publishes a paper or studies a disease.",
            "∀x (Researcher(x) → StudiesDisease(x)) ::: If x is a researcher, then x studies a disease.",
            "∃x (Doctor(x) ∧ Researcher(x)) ::: There exists an x who is both a doctor and a researcher.",
            "∀x (PublishesPaper(x) → Researcher(x)) ::: If x publishes a paper, then x is a researcher.",
            "∃x Doctor(x) ::: There exists someone who is a doctor.",
            "∃x StudiesDisease(x) ::: There exists someone who studies a disease.",
            "∀x (StudiesDisease(x) → Researcher(x)) ::: If x studies a disease, then x is a researcher.",
            "∀x (Researcher(x) → PublishesPaper(x)) ::: If x is a researcher, then x publishes papers.",
            "∀x (Doctor(x) → (PublishesPaper(x) ∨ StudiesDisease(x))) ::: If anyone is a doctor, then they either publish a paper or study a disease.",
            "∀x ((Doctor(x) ∧ StudiesDisease(x)) → Researcher(x)) ::: If anyone is a doctor and studies a disease, they are a researcher.",
            "∀x ((Researcher(x) ∧ StudiesDisease(x)) → Doctor(x)) ::: If anyone is a researcher and studies a disease, they are a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Researcher(x) ::: x is a researcher.",
            "PublishesPaper(x) ::: x publishes a paper.",
            "StudiesDisease(x) ::: x studies a disease."
        ]
    },
    {
        "premises-NL": [
            "All mammals are warm-blooded.",
            "All carnivores eat meat.",
            "All things that eat meat hunt.",
            "All carnivores have teeth.",
            "Some mammals are carnivores.",
            "If something is a mammal and a carnivore, then it has teeth.",
            "All warm-blooded animals are mammals.",
            "If something hunts, it has teeth.",
            "Some things are carnivores and hunt.",
            "All things that have teeth hunt.",
            "If something is a mammal, then it is warm-blooded.",
            "No mammal eats only plants."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → WarmBlooded(x)) ::: If x is a mammal, then x is warm-blooded.",
            "∀x (Carnivore(x) → EatsMeat(x)) ::: If x is a carnivore, then x eats meat.",
            "∀x (EatsMeat(x) → Hunts(x)) ::: If x eats meat, then x hunts.",
            "∀x (Carnivore(x) → HasTeeth(x)) ::: If x is a carnivore, then x has teeth.",
            "∃x (Mammal(x) ∧ Carnivore(x)) ::: There exists an x that is both a mammal and a carnivore.",
            "∀x ((Mammal(x) ∧ Carnivore(x)) → HasTeeth(x)) ::: If x is a mammal and a carnivore, then x has teeth.",
            "∀x (WarmBlooded(x) → Mammal(x)) ::: If x is warm-blooded, then x is a mammal.",
            "∀x (Hunts(x) → HasTeeth(x)) ::: If x hunts, then x has teeth.",
            "∃x (Carnivore(x) ∧ Hunts(x)) ::: There exists an x that is both a carnivore and hunts.",
            "∀x (HasTeeth(x) → Hunts(x)) ::: If x has teeth, then x hunts.",
            "∀x (Mammal(x) → WarmBlooded(x)) ::: If x is a mammal, then it is warm-blooded.",
            "¬∃x (Mammal(x) ∧ ¬EatsMeat(x)) ::: It is not the case that there exists an x that is a mammal and does not eat meat."
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal.",
            "Carnivore(x) ::: x is a carnivore.",
            "Hunts(x) ::: x hunts.",
            "EatsMeat(x) ::: x eats meat.",
            "HasTeeth(x) ::: x has teeth."
        ]
    },
    {
        "premises-NL": [
            "All citizens are eligible.",
            "All eligible people are registered.",
            "All registered people have the right to vote.",
            "Some citizens vote.",
            "All people who vote are registered.",
            "All people who pay taxes are citizens.",
            "Some citizens pay taxes.",
            "All citizens pay taxes or do not vote.",
            "If someone is eligible, then they pay taxes.",
            "If someone votes, they are eligible.",
            "Everyone who is registered has the right to vote.",
            "Some citizens are eligible and vote.",
            "If someone has a right to vote, then they are registered."
        ],
        "premises-FOL": [
            "∀x (Citizen(x) → IsEligible(x)) ::: If x is a citizen, then x is eligible.",
            "∀x (IsEligible(x) → IsRegistered(x)) ::: If x is eligible, then x is registered.",
            "∀x (IsRegistered(x) → HasRightToVote(x)) ::: If x is registered, then x has the right to vote.",
            "∃x (Citizen(x) ∧ Votes(x)) ::: There exists an x such that x is a citizen and votes.",
            "∀x (Votes(x) → IsRegistered(x)) ::: If x votes, then x is registered.",
            "∀x (PaysTaxes(x) → Citizen(x)) ::: If x pays taxes, then x is a citizen.",
            "∃x (Citizen(x) ∧ PaysTaxes(x)) ::: There exists an x who is a citizen and pays taxes.",
            "∀x (Citizen(x) → (PaysTaxes(x) ∨ ¬Votes(x))) ::: If x is a citizen, then x pays taxes or does not vote.",
            "∀x (IsEligible(x) → PaysTaxes(x)) ::: If x is eligible, then x pays taxes.",
            "∀x (Votes(x) → IsEligible(x)) ::: If x votes, then x is eligible.",
            "∀x (IsRegistered(x) → HasRightToVote(x)) ::: Everyone who is registered has the right to vote.",
            "∃x (Citizen(x) ∧ IsEligible(x) ∧ Votes(x)) ::: Some citizens are eligible and vote.",
            "∀x (HasRightToVote(x) → IsRegistered(x)) ::: If someone has a right to vote, then they are registered."
        ],
        "predicates": [
            "Citizen(x) ::: x is a citizen.",
            "Votes(x) ::: x votes.",
            "HasRightToVote(x) ::: x has a right to vote.",
            "IsEligible(x) ::: x is eligible.",
            "IsRegistered(x) ::: x is registered.",
            "PaysTaxes(x) ::: x pays taxes."
        ]
    },
    {
        "premises-NL": [
            "All club members play sports.",
            "No student plays sports.",
            "Everyone who plays a sport has free time.",
            "Everyone either studies hard or works part time.",
            "Anyone who has free time does not study hard.",
            "All workers work part time.",
            "Some students are good students.",
            "All good students are members of a club."
        ],
        "premises-FOL": [
            "∀x (ClubMember(x) → PlaysSport(x)) ::: For all x, if x is a club member, then x plays a sport.",
            "∀x (Student(x) → ¬PlaysSport(x)) ::: For all x, if x is a student, then x does not play a sport.",
            "∀x (PlaysSport(x) → HasFreeTime(x)) ::: For all x, if x plays a sport, then x has free time.",
            "∀x (Student(x) ∨ Worker(x)) ::: For all x, x is a student or x is a worker.",
            "∀x (HasFreeTime(x) → ¬StudiesHard(x)) ::: For all x, if x has free time, then x does not study hard.",
            "∀x (Worker(x) → WorksPartTime(x)) ::: For all x, if x is a worker, then x works part time.",
            "∃x (Student(x) ∧ GoodStudent(x)) ::: There exists an x such that x is a student and x is a good student.",
            "∀x (GoodStudent(x) → ClubMember(x)) ::: For all x, if x is a good student, then x is a club member."
        ],
        "predicates": [
            "ClubMember(x) ::: x is a member of a club",
            "Student(x) ::: x is a student",
            "Worker(x) ::: x is a worker",
            "PlaysSport(x) ::: x plays a sport",
            "HasFreeTime(x) ::: x has free time",
            "StudiesHard(x) ::: x studies hard",
            "WorksPartTime(x) ::: x works part time",
            "GoodStudent(x) ::: x is a good student"
        ]
    },
    {
        "premises-NL": [
            "All smart people like science.",
            "No one who reads books likes math.",
            "Everyone who studies hard is smart.",
            "Anyone who enjoys logic likes math.",
            "Everyone who understands math is smart.",
            "All teachers are smart and read books.",
            "No student likes math and likes science.",
            "Someone who passes exams is good at science",
            "Everyone who is good at science likes science.",
            "No student studies hard.",
            "Someone who does not like math is not smart."
        ],
        "premises-FOL": [
            "∀x (Smart(x) → LikesScience(x)) ::: For all x, if x is smart, then x likes science.",
            "∀x (ReadsBooks(x) → ¬LikesMath(x)) ::: For all x, if x reads books, then x does not like math.",
            "∀x (StudiesHard(x) → Smart(x)) ::: For all x, if x studies hard, then x is smart.",
            "∀x (EnjoysLogic(x) → LikesMath(x)) ::: For all x, if x enjoys logic, then x likes math.",
            "∀x (UnderstandsMath(x) → Smart(x)) ::: For all x, if x understands math, then x is smart.",
            "∀x (IsATeacher(x) → (Smart(x) ∧ ReadsBooks(x))) ::: For all x, if x is a teacher, then x is smart and reads books.",
            "∀x (IsStudent(x) → ¬(LikesMath(x) ∧ LikesScience(x))) ::: For all x, if x is a student, then it is not the case that x likes math and likes science.",
            "∃x (PassesExams(x) ∧ GoodAtScience(x)) ::: There exists an x such that x passes exams and x is good at science.",
            "∀x (GoodAtScience(x) → LikesScience(x)) ::: For all x, if x is good at science, then x likes science.",
            "∀x (IsStudent(x) → ¬StudiesHard(x)) ::: For all x, if x is a student, then it is not the case that x studies hard.",
            "∃x (¬LikesMath(x) ∧ ¬Smart(x)) ::: There exists an x such that x does not like math and is not smart."
        ],
        "predicates": [
            "LikesScience(x) ::: x likes science",
            "LikesMath(x) ::: x likes math",
            "Smart(x) ::: x is smart",
            "ReadsBooks(x) ::: x reads books",
            "StudiesHard(x) ::: x studies hard",
            "EnjoysLogic(x) ::: x enjoys logic",
            "UnderstandsMath(x) ::: x understands math",
            "IsATeacher(x) ::: x is a teacher",
            "IsStudent(x) ::: x is a student",
            "PassesExams(x) ::: x passes exams",
            "GoodAtScience(x) ::: x is good at science"
        ]
    },
    {
        "premises-NL": [
            "All doctors study medicine.",
            "Anyone who studies medicine attends university.",
            "Anyone who attends university and has a PhD is a healthcare professional.",
            "Some doctors work at a hospital.",
            "Some doctors are researchers.",
            "Anyone who is a researcher and works at a hospital is a healthcare professional.",
            "All doctors have a PhD.",
            "John is a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → StudiesMedicine(x)) ::: All doctors study medicine.",
            "∀x (StudiesMedicine(x) → AttendsUniversity(x)) ::: Anyone who studies medicine attends university.",
            "∀x (AttendsUniversity(x) ∧ HasPhD(x) → HealthcareProfessional(x)) ::: Anyone who attends university and has a PhD is a healthcare professional.",
            "∃x (Doctor(x) ∧ WorksAtHospital(x)) ::: Some doctors work at a hospital.",
            "∃x (Doctor(x) ∧ Researcher(x)) ::: Some doctors are researchers.",
            "∀x (Researcher(x) ∧ WorksAtHospital(x) → HealthcareProfessional(x)) ::: Anyone who is a researcher and works at a hospital is a healthcare professional.",
            "∀x (Doctor(x) → HasPhD(x)) ::: All doctors have a PhD.",
            "Doctor(john) ::: John is a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "HasPhD(x) ::: x has a PhD",
            "HealthcareProfessional(x) ::: x is a healthcare professional",
            "StudiesMedicine(x) ::: x studies medicine",
            "AttendsUniversity(x) ::: x attends university",
            "WorksAtHospital(x) ::: x works at a hospital",
            "Researcher(x) ::: x is a researcher"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard get a good grade.",
            "If a student studies hard and has time, they succeed.",
            "If a student takes a difficult course and gets a good grade, then they succeed.",
            "Some students fail.",
            "Any student who takes all difficult courses is a student.",
            "A student takes all difficult courses if they take all difficult courses.",
            "If a student studies hard, they have time.",
            "Some courses are difficult.",
            "If a student takes all difficult courses, then they will succeed or fail.",
            "All students either succeed or fail."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) → GoodGrade(x)) ::: All students who study hard get a good grade.",
            "∀x (StudiesHard(x) ∧ HasTime(x) → Succeeds(x)) ::: If a student studies hard and has time, they succeed.",
            "∀x ∀y (Takes(x, y) ∧ Difficult(y) ∧ GoodGrade(x) → Succeeds(x)) ::: If a student takes a difficult course and gets a good grade, then they succeed.",
            "∃x Fails(x) ::: Some students fail.",
            "∀x (TakesAllDifficultCourses(x) → Student(x)) ::: Any student who takes all difficult courses is a student.",
            "∀x (TakesAllDifficultCourses(x) → TakesAllDifficultCourses(x)) ::: A student takes all difficult courses if they take all difficult courses.",
            "∀x (StudiesHard(x) → HasTime(x)) ::: If a student studies hard, they have time.",
            "∃x Difficult(x) ::: Some courses are difficult.",
            "∀x (TakesAllDifficultCourses(x) → (Succeeds(x) ∨ Fails(x))) ::: If a student takes all difficult courses, then they will succeed or fail.",
            "∀x (Student(x) → (Succeeds(x) ∨ Fails(x))) ::: All students either succeed or fail."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Course(x) ::: x is a course",
            "Takes(x, y) ::: x takes y",
            "Difficult(x) ::: x is difficult",
            "TakesAllDifficultCourses(x) ::: x takes all difficult courses",
            "Succeeds(x) ::: x succeeds",
            "Fails(x) ::: x fails",
            "GoodGrade(x) ::: x gets a good grade",
            "StudiesHard(x) ::: x studies hard",
            "HasTime(x) ::: x has time"
        ]
    },
    {
        "premises-NL": [
            "All students who attend class study hard.",
            "If someone likes their teacher, then they are intelligent.",
            "If someone reads books, they will attend class.",
            "John attends class.",
            "John likes his teacher.",
            "All who study hard will pass the exam.",
            "John reads books.",
            "If someone is intelligent, they will pass the exam."
        ],
        "premises-FOL": [
            "∀x (AttendsClass(x) → StudiesHard(x)) ::: All students who attend class study hard.",
            "∀x (LikesTeacher(x) → Intelligent(x)) ::: If someone likes their teacher, then they are intelligent.",
            "∀x (ReadsBook(x) → AttendsClass(x)) ::: If someone reads books, they will attend class.",
            "AttendsClass(John) ::: John attends class.",
            "LikesTeacher(John) ::: John likes his teacher.",
            "∀x (StudiesHard(x) → PassExam(x)) ::: All who study hard will pass the exam.",
            "ReadsBook(John) ::: John reads books.",
            "∀x (Intelligent(x) → PassExam(x)) ::: If someone is intelligent, they will pass the exam."
        ],
        "predicates": [
            "StudiesHard(x) ::: x studies hard",
            "Intelligent(x) ::: x is intelligent",
            "PassExam(x) ::: x passes the exam",
            "AttendsClass(x) ::: x attends class",
            "LikesTeacher(x) ::: x likes their teacher",
            "ReadsBook(x) ::: x reads books"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "If someone treats patients, they are kind.",
            "If someone likes cats, they have a pet.",
            "If someone has a pet, they are friendly.",
            "If someone is friendly, they like cats.",
            "All doctors care for animals.",
            "If someone cares for animals, they are kind.",
            "John is a doctor.",
            "John likes cats."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → TreatsPatients(x)) ::: All doctors treat patients.",
            "∀x (TreatsPatients(x) → KindPerson(x)) ::: If someone treats patients, they are kind.",
            "∀x (LikesCats(x) → HasPet(x)) ::: If someone likes cats, they have a pet.",
            "∀x (HasPet(x) → Friendly(x)) ::: If someone has a pet, they are friendly.",
            "∀x (Friendly(x) → LikesCats(x)) ::: If someone is friendly, they like cats.",
            "∀x (Doctor(x) → CaresForAnimals(x)) ::: All doctors care for animals.",
            "∀x (CaresForAnimals(x) → KindPerson(x)) ::: If someone cares for animals, they are kind.",
            "Doctor(John) ::: John is a doctor.",
            "LikesCats(John) ::: John likes cats."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "LikesCats(x) ::: x likes cats",
            "KindPerson(x) ::: x is a kind person",
            "TreatsPatients(x) ::: x treats patients",
            "HasPet(x) ::: x has a pet",
            "Friendly(x) ::: x is friendly",
            "EnjoysNature(x) ::: x enjoys nature",
            "GoodAtDiagnosis(x) ::: x is good at diagnosis",
            "CaresForAnimals(x) ::: x cares for animals"
        ]
    },
    {
        "premises-NL": [
            "If a product is advertised and is popular, then it has a good review.",
            "If a product is expensive and has a good review, it is bought.",
            "If a product is on sale, then it is advertised.",
            "If a product is advertised and on sale, it sells.",
            "If a product has a good review and is not expensive, it is useful.",
            "If a product is useful, then the customer is satisfied.",
            "Product A is advertised.",
            "Product A has a good review.",
            "Product A is not expensive.",
            "If a product is durable it is advertised.",
            "Product A is popular."
        ],
        "premises-FOL": [
            "∀x (Advertised(x) ∧ Popular(x) → GoodReview(x)) ::: If a product is advertised and is popular, then it has a good review.",
            "∀x (Expensive(x) ∧ GoodReview(x) → Bought(x)) ::: If a product is expensive and has a good review, it is bought.",
            "∀x (OnSale(x) → Advertised(x)) ::: If a product is on sale, then it is advertised.",
            "∀x (Advertised(x) ∧ OnSale(x) → Sells(x)) ::: If a product is advertised and on sale, it sells.",
            "∀x (GoodReview(x) ∧ ¬Expensive(x) → IsUseful(x)) ::: If a product has a good review and is not expensive, it is useful.",
            "∀x (IsUseful(x) → CustomerSatisfied(x)) ::: If a product is useful, then the customer is satisfied.",
            "Advertised(ProductA) ::: Product A is advertised.",
            "GoodReview(ProductA) ::: Product A has a good review.",
            "¬Expensive(ProductA) ::: Product A is not expensive.",
            "∀x (IsDurable(x) → Advertised(x)) ::: If a product is durable it is advertised.",
            "Popular(ProductA) ::: Product A is popular."
        ],
        "predicates": [
            "Advertised(x) ::: x is advertised",
            "GoodReview(x) ::: x has a good review",
            "Sells(x) ::: x sells",
            "Popular(x) ::: x is popular",
            "Expensive(x) ::: x is expensive",
            "HasFeature(x, y) ::: x has feature y",
            "IsDurable(x) ::: x is durable",
            "Bought(x) ::: x is bought",
            "OnSale(x) ::: x is on sale",
            "CustomerSatisfied(x) ::: customer is satisfied",
            "IsUseful(x) ::: x is useful"
        ]
    },
    {
        "premises-NL": [
            "All students are registered.",
            "If someone is registered, they pay fees.",
            "Anyone who attends the university is a student.",
            "Anyone who has a scholarship has good grades.",
            "If someone has good grades, they either study hard or pass the exam.",
            "If someone passes the exam, they take the exam.",
            "If someone is registered, they attend the university.",
            "John is a student.",
            "John is involved in events.",
            "If someone is active member, they attend the university.",
            "If someone participates in events they are active member."
        ],
        "premises-FOL": [
            "∀x (Student(x) → IsRegistered(x)) ::: All students are registered.",
            "∀x (IsRegistered(x) → PayFees(x)) ::: If someone is registered, they pay fees.",
            "∀x (AttendsUniversity(x) → Student(x)) ::: Anyone who attends the university is a student.",
            "∀x (HasScholarship(x) → GoodGrades(x)) ::: Anyone who has a scholarship has good grades.",
            "∀x (GoodGrades(x) → (StudiesHard(x) ∨ PassExam(x))) ::: If someone has good grades, they either study hard or pass the exam.",
            "∀x (PassExam(x) → TakeExam(x)) ::: If someone passes the exam, they take the exam.",
            "∀x (IsRegistered(x) → AttendsUniversity(x)) ::: If someone is registered, they attend the university.",
            "Student(John) ::: John is a student.",
            "IsInvolved(John,Events) ::: John is involved in events.",
            "∀x (ActiveMember(x) → AttendsUniversity(x)) ::: If someone is active member, they attend the university.",
            "∀x (ParticipatesInEvents(x) → ActiveMember(x)) ::: If someone participates in events they are active member."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsUniversity(x) ::: x attends the university",
            "StudiesHard(x) ::: x studies hard",
            "TakeExam(x) ::: x takes the exam",
            "HasScholarship(x) ::: x has a scholarship",
            "GoodGrades(x) ::: x has good grades",
            "IsRegistered(x) ::: x is registered",
            "PayFees(x) ::: x pays fees",
            "PassExam(x) ::: x passes the exam",
            "IsInvolved(x,y) ::: x is involved in y",
            "ActiveMember(x) ::: x is an active member",
            "ParticipatesInEvents(x) ::: x participates in events"
        ]
    },
    {
        "premises-NL": [
            "All students attend lectures.",
            "Some students pass the exam.",
            "Students are individuals."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendLecture(x)) ::: For all x, if x is a student, then x attends lectures.",
            "∃x (Student(x) ∧ PassExam(x)) ::: There exists an x such that x is a student and passes the exam.",
            "∀x (Student(x) → Individual(x)) ::: All students are individuals.",
            "Individual(x) ::: x is an individual.",
            "∃x Student(x) ::: There exists at least one student.",
            "∀x PassExam(x) ∨ ¬PassExam(x) ::: For all x, x either passes the exam or doesn't pass.",
            "∀x (AttendLecture(x) ∨ ¬AttendLecture(x)) ::: For all x, x either attends a lecture or doesn't attend.",
            "∀x (Student(x) → (PassExam(x) ∨ ¬AttendLecture(x))) ::: If x is a student, then x either passes the exam or does not attend the lecture.",
            "¬∀x (Student(x) → ¬AttendLecture(x)) ::: It is not the case that all students don't attend lectures."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendLecture(x) ::: x attends lectures",
            "PassExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "All researchers are in the lab.",
            "Some researchers work on the project.",
            "Some researchers like coffee.",
            "If someone likes coffee, then they are a researcher.",
            "At least one person exists.",
            "If someone works on a project, they are a researcher.",
            "If someone is in the lab, they might work on the project.",
            "It is not the case that all researchers don't work on projects.",
            "Researchers are individuals.",
            "Not all researchers in the lab like coffee."
        ],
        "premises-FOL": [
            "∀x (Researcher(x) → InLab(x)) ::: For all x, if x is a researcher, then x is in the lab.",
            "∃x (Researcher(x) ∧ WorksOnProject(x)) ::: There exists an x such that x is a researcher and works on the project.",
            "∃x (Researcher(x) ∧ LikesCoffee(x)) ::: There exists a researcher who likes coffee.",
            "∀x (LikesCoffee(x) → Researcher(x)) ::: For all x, if x likes coffee, then x is a researcher.",
            "∃x Person(x) ::: There exists a person.",
            "∀x (WorksOnProject(x) → Researcher(x)) ::: If x works on a project, then x is a researcher.",
            "∀x (InLab(x) → (WorksOnProject(x) ∨ ¬WorksOnProject(x))) ::: If x is in the lab, then x either works on the project or doesn't.",
            "¬∀x (Researcher(x) → ¬WorksOnProject(x)) ::: It is not the case that all researchers do not work on projects.",
            "∀x (Researcher(x) → Individual(x)) ::: All researchers are individuals.",
            "¬∀x (InLab(x) → LikesCoffee(x)) ::: Not all researchers in the lab like coffee."
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher",
            "InLab(x) ::: x is in the lab",
            "WorksOnProject(x) ::: x works on the project",
            "LikesCoffee(x) ::: x likes coffee"
        ]
    },
    {
        "premises-NL": [
            "All students who are registered and have paid fees are allowed to attend classes.",
            "Some students are registered.",
            "Some students have paid fees.",
            "Every student has an ID card.",
            "If someone is registered, they are a student.",
            "If someone has paid fees, they are a student.",
            "If someone has an ID card, then they are a student.",
            "Some students do not attend classes.",
            "Students exist.",
            "It is not the case that some students have not paid fees.",
            "Not every student that is registered has paid fees.",
            "If someone is a student, then they attend classes or they do not."
        ],
        "premises-FOL": [
            "∀x ((Student(x) ∧ Registered(x) ∧ PaidFees(x)) → AttendClasses(x)) ::: For all x, if x is a student, registered, and has paid fees, then x attends classes.",
            "∃x (Student(x) ∧ Registered(x)) ::: There exists a student who is registered.",
            "∃x (Student(x) ∧ PaidFees(x)) ::: There exists a student who has paid fees.",
            "∀x (Student(x) → HasIdCard(x)) ::: All students have an ID card.",
            "∀x (Registered(x) → Student(x)) ::: For all x, if x is registered, then x is a student.",
            "∀x (PaidFees(x) → Student(x)) ::: For all x, if x has paid fees, then x is a student.",
            "∀x (HasIdCard(x) → Student(x)) ::: For all x, if x has an ID card, then x is a student.",
            "∃x (Student(x) ∧ ¬AttendClasses(x)) ::: There exists a student who does not attend classes.",
            "∃x Student(x) ::: There exists a student.",
            "¬∃x (Student(x) ∧ ¬PaidFees(x)) ::: It is not the case that some students have not paid fees.",
            "¬∀x (Registered(x) → PaidFees(x)) ::: Not every student that is registered has paid fees.",
            "∀x (Student(x) → (AttendClasses(x) ∨ ¬AttendClasses(x))) ::: If x is a student, then x attends classes or does not attend."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Registered(x) ::: x is registered",
            "PaidFees(x) ::: x has paid fees",
            "AttendClasses(x) ::: x attends classes",
            "HasIdCard(x) ::: x has an ID card"
        ]
    },
    {
        "premises-NL": [
            "All scientists are researchers.",
            "All researchers publish papers.",
            "Some scientists work at a university.",
            "Some researchers are funded by a grant.",
            "If someone is a scientist, then they either publish or don't.",
            "Anyone who publishes a paper is a researcher or is not.",
            "If someone publishes a paper and is funded by a grant, then they are a scientist.",
            "Every scientist that works at a university is a researcher.",
            "It is not the case that some scientists do not publish papers.",
            "Some scientists are funded by a grant.",
            "If someone works at a university and is funded by a grant, they are a scientist.",
            "It is not the case that some scientists do not work at a university.",
            "Some scientists exist."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Researcher(x)) ::: For all x, if x is a scientist, then x is a researcher.",
            "∀x (Researcher(x) → PublishesPaper(x)) ::: For all x, if x is a researcher, then x publishes a paper.",
            "∃x (Scientist(x) ∧ WorksAtUniversity(x)) ::: There exists a scientist who works at a university.",
            "∃x (Researcher(x) ∧ FundedByGrant(x)) ::: There exists a researcher who is funded by a grant.",
            "∀x (Scientist(x) → (PublishesPaper(x) ∨ ¬PublishesPaper(x))) ::: If x is a scientist, then x either publishes a paper or does not.",
            "∀x (PublishesPaper(x) → (Researcher(x) ∨ ¬Researcher(x))) ::: For all x, if x publishes a paper, then they are a researcher or they are not.",
            "∀x ((PublishesPaper(x) ∧ FundedByGrant(x)) → Scientist(x)) ::: For all x, if x publishes a paper and is funded by a grant, then x is a scientist.",
            "∀x ((Scientist(x) ∧ WorksAtUniversity(x)) → Researcher(x)) ::: If x is a scientist and works at a university, then x is a researcher.",
            "¬∃x (Scientist(x) ∧ ¬PublishesPaper(x)) ::: It is not the case that some scientists do not publish papers.",
            "∃x (Scientist(x) ∧ FundedByGrant(x)) ::: There exists a scientist funded by a grant.",
            "∀x ((WorksAtUniversity(x) ∧ FundedByGrant(x)) → Scientist(x)) ::: For all x, if x works at a university and is funded by a grant, then they are a scientist.",
            "¬∃x (Scientist(x) ∧ ¬WorksAtUniversity(x)) ::: It is not the case that some scientists do not work at a university.",
            "∃x Scientist(x) ::: There exists a scientist."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "PublishesPaper(x) ::: x publishes a paper",
            "Researcher(x) ::: x is a researcher",
            "WorksAtUniversity(x) ::: x works at a university",
            "FundedByGrant(x) ::: x is funded by a grant"
        ]
    },
    {
        "premises-NL": [
            "All students are taking a course.",
            "Alice is a student.",
            "Everyone who takes a course has to pass the exam.",
            "Alice has passed the exam.",
            "If someone passed the exam, they are enrolled in some advanced course.",
            "Alice is a student who is taking a course.",
            "Bob is a student.",
            "Bob is taking a course.",
            "Bob has to pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakingCourse(x)) ::: For all x, if x is a student, then x is taking a course.",
            "Student(alice) ::: Alice is a student.",
            "∀x (TakingCourse(x) → PassedExam(x)) ::: For all x, if x is taking a course, then x passed the exam.",
            "PassedExam(alice) ::: Alice passed the exam.",
            "∀x (PassedExam(x) → EnrolledAdvanced(x)) ::: For all x, if x passed the exam, then x is enrolled in the advanced course.",
            "Student(alice) ∧ TakingCourse(alice) ::: Alice is a student who is taking a course.",
            "Student(bob) ::: Bob is a student.",
            "TakingCourse(bob) ::: Bob is taking a course.",
            "PassedExam(bob) ::: Bob has to pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PassedExam(x) ::: x passed the exam",
            "EnrolledAdvanced(x) ::: x is enrolled in the advanced course"
        ]
    },
    {
        "premises-NL": [
            "All researchers work at a university.",
            "Some researchers are not smart.",
            "All smart people are good at mathematics.",
            "Some people who work at a university are researchers.",
            "Anyone who is a researcher is either smart or not good at math.",
            "If someone is not smart then they are not good at math.",
            "Some researchers are smart.",
            "If a researcher is smart they are good at math.",
            "Some people who are not smart do not work at a university.",
            "All who are good at math are smart.",
            "No researcher is not smart."
        ],
        "premises-FOL": [
            "∀x (Researcher(x) → WorksAtUniversity(x)) ::: All researchers work at a university.",
            "∃x (Researcher(x) ∧ ¬Smart(x)) ::: Some researchers are not smart.",
            "∀x (Smart(x) → GoodAtMath(x)) ::: All smart people are good at mathematics.",
            "∃x (WorksAtUniversity(x) ∧ Researcher(x)) ::: Some people who work at a university are researchers.",
            "∀x (Researcher(x) → (Smart(x) ∨ ¬GoodAtMath(x))) ::: Anyone who is a researcher is either smart or not good at math.",
            "∀x (¬Smart(x) → ¬GoodAtMath(x)) ::: If someone is not smart then they are not good at math.",
            "∃x (Researcher(x) ∧ Smart(x)) ::: Some researchers are smart.",
            "∀x (Researcher(x) ∧ Smart(x) → GoodAtMath(x)) ::: If a researcher is smart they are good at math.",
            "∃x (¬Smart(x) ∧ ¬WorksAtUniversity(x)) ::: Some people who are not smart do not work at a university.",
            "∀x (GoodAtMath(x) → Smart(x)) ::: All who are good at math are smart.",
            "¬∃x (Researcher(x) ∧ ¬Smart(x)) ::: No researcher is not smart."
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher",
            "GoodAtMath(x) ::: x is good at mathematics",
            "Smart(x) ::: x is smart",
            "WorksAtUniversity(x) ::: x works at a university"
        ]
    },
    {
        "premises-NL": [
            "All companies that are not sustainable use renewable energy.",
            "Some companies are sustainable.",
            "All companies are either profitable or employ people.",
            "No company both is profitable and uses renewable energy.",
            "All sustainable companies are profitable.",
            "Some companies use renewable energy.",
            "All profitable companies do not use renewable energy.",
            "Some companies are not profitable.",
            "No company is sustainable and does not use renewable energy.",
            "All companies that employ people do not use renewable energy.",
            "Some companies employ people.",
            "All companies either use renewable energy or are sustainable.",
            "All companies that are not sustainable are not profitable."
        ],
        "premises-FOL": [
            "∀x (Company(x) ∧ ¬IsSustainable(x) → UsesRenewableEnergy(x)) ::: All companies that are not sustainable use renewable energy.",
            "∃x (Company(x) ∧ IsSustainable(x)) ::: Some companies are sustainable.",
            "∀x (Company(x) → (Profitable(x) ∨ EmploysPeople(x))) ::: All companies are either profitable or employ people.",
            "¬∃x (Company(x) ∧ Profitable(x) ∧ UsesRenewableEnergy(x)) ::: No company both is profitable and uses renewable energy.",
            "∀x (IsSustainable(x) → Profitable(x)) ::: All sustainable companies are profitable.",
            "∃x (Company(x) ∧ UsesRenewableEnergy(x)) ::: Some companies use renewable energy.",
            "∀x (Profitable(x) → ¬UsesRenewableEnergy(x)) ::: All profitable companies do not use renewable energy.",
            "∃x (Company(x) ∧ ¬Profitable(x)) ::: Some companies are not profitable.",
            "¬∃x (Company(x) ∧ IsSustainable(x) ∧ ¬UsesRenewableEnergy(x)) ::: No company is sustainable and does not use renewable energy.",
            "∀x (Company(x) ∧ EmploysPeople(x) → ¬UsesRenewableEnergy(x)) ::: All companies that employ people do not use renewable energy.",
            "∃x (Company(x) ∧ EmploysPeople(x)) ::: Some companies employ people.",
            "∀x (Company(x) → (UsesRenewableEnergy(x) ∨ IsSustainable(x))) ::: All companies either use renewable energy or are sustainable.",
            "∀x (Company(x) ∧ ¬IsSustainable(x) → ¬Profitable(x)) ::: All companies that are not sustainable are not profitable."
        ],
        "predicates": [
            "Company(x) ::: x is a company",
            "UsesRenewableEnergy(x) ::: x uses renewable energy",
            "IsSustainable(x) ::: x is sustainable",
            "Profitable(x) ::: x is profitable",
            "EmploysPeople(x) ::: x employs people"
        ]
    },
    {
        "premises-NL": [
            "Every student is enrolled in a course.",
            "Bob is enrolled in Calculus.",
            "Calculus is a course.",
            "If someone is enrolled in a course, they are a student.",
            "If someone fails a course, they are not a student.",
            "Bob failed Calculus.",
            "All students pass a course or fail a course.",
            "No professor is a student.",
            "Professor Smith teaches Calculus.",
            "Bob is not a professor.",
            "If Bob is not a professor and Smith teaches calculus, then Bob is not a student.",
            "If someone fails calculus, that does not imply they are a student.",
            "Bob is enrolled in calculus."
        ],
        "premises-FOL": [
            "∀x ∀y (Student(x) ∧ Course(y) → Enrolled(x, y)) ::: Every student is enrolled in a course.",
            "Enrolled(bob, calculus) ::: Bob is enrolled in Calculus.",
            "Course(calculus) ::: Calculus is a course.",
            "∀x ∀y (Enrolled(x, y) → Student(x)) ::: If someone is enrolled in a course, they are a student.",
            "∀x ∀y (Fails(x, y) → ¬Student(x)) ::: If someone fails a course, they are not a student.",
            "Fails(bob, calculus) ::: Bob failed Calculus.",
            "∀x ∀y (Student(x) → (Passes(x, y) ∨ Fails(x, y))) ::: All students pass a course or fail a course.",
            "∀x (Professor(x) → ¬Student(x)) ::: No professor is a student.",
            "Teaches(smith, calculus) ::: Professor Smith teaches Calculus.",
            "¬Professor(bob) ::: Bob is not a professor.",
            "¬Professor(bob) ∧ Teaches(smith, calculus) → ¬Student(bob) ::: If Bob is not a professor and Smith teaches calculus, then Bob is not a student.",
            "¬Fails(x,calculus) → Student(x) ::: If someone fails calculus, that does not imply they are a student.",
            "Enrolled(bob, calculus) ::: Bob is enrolled in calculus."
        ],
        "predicates": [
            "Enrolled(x, y) ::: x is enrolled in course y",
            "Student(x) ::: x is a student",
            "Course(x) ::: x is a course",
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches y",
            "Passes(x, y) ::: x passes y",
            "Fails(x, y) ::: x fails y"
        ]
    },
    {
        "premises-NL": [
            "All mammals are animals.",
            "All birds are animals.",
            "No reptile is a mammal.",
            "Some mammals are warm-blooded.",
            "Some birds have feathers.",
            "All reptiles are cold-blooded.",
            "If something has feathers then it is a bird.",
            "Some animals are not birds.",
            "Some reptiles lay eggs.",
            "If something is a bird, then it can fly.",
            "If something is a mammal, then it is warm-blooded."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → Animal(x)) ::: All mammals are animals.",
            "∀x (Bird(x) → Animal(x)) ::: All birds are animals.",
            "∀x (Reptile(x) → ¬Mammal(x)) ::: No reptile is a mammal.",
            "∃x (Mammal(x) ∧ WarmBlooded(x)) ::: Some mammals are warm-blooded.",
            "∃x (Bird(x) ∧ HasFeathers(x)) ::: Some birds have feathers.",
            "∀x (Reptile(x) → ColdBlooded(x)) ::: All reptiles are cold-blooded.",
            "∀x (HasFeathers(x) → Bird(x)) ::: If something has feathers then it is a bird.",
            "∃x (Animal(x) ∧ ¬Bird(x)) ::: Some animals are not birds.",
            "∃x (Reptile(x) ∧ LaysEggs(x)) ::: Some reptiles lay eggs.",
            "∀x (Bird(x) → CanFly(x)) ::: If something is a bird, then it can fly.",
            "∀x (Mammal(x) → WarmBlooded(x)) ::: If something is a mammal, then it is warm-blooded."
        ],
        "predicates": [
            "Animal(x) ::: x is an animal",
            "Mammal(x) ::: x is a mammal",
            "Bird(x) ::: x is a bird",
            "Reptile(x) ::: x is a reptile",
            "HasFeathers(x) ::: x has feathers",
            "LaysEggs(x) ::: x lays eggs",
            "WarmBlooded(x) ::: x is warm-blooded",
            "LivesOnLand(x) ::: x lives on land",
            "Aquatic(x) ::: x is aquatic",
            "CanFly(x) ::: x can fly",
            "ColdBlooded(x) ::: x is cold-blooded"
        ]
    },
    {
        "premises-NL": [
            "All artists are painters.",
            "Some painters are rich.",
            "Everyone is either a painter or not rich.",
            "If someone is an artist, then they are not a programmer.",
            "Anyone who is a programmer is poor.",
            "If anyone is rich then they are not poor.",
            "All painters are creative.",
            "If anyone is creative then they have a hobby.",
            "There are no programmers who are painters."
        ],
        "premises-FOL": [
            "∀x (Artist(x) → Painter(x)) ::: All artists are painters.",
            "∃x (Painter(x) ∧ Rich(x)) ::: Some painters are rich.",
            "∀x (Painter(x) ∨ ¬Rich(x)) ::: Everyone is either a painter or not rich.",
            "∀x (Artist(x) → ¬Programmer(x)) ::: If someone is an artist, then they are not a programmer.",
            "∀x (Programmer(x) → Poor(x)) ::: Anyone who is a programmer is poor.",
            "∀x (Rich(x) → ¬Poor(x)) ::: If anyone is rich then they are not poor.",
            "∀x (Painter(x) → Creative(x)) ::: All painters are creative.",
            "∀x (Creative(x) → Hobby(x)) ::: If anyone is creative then they have a hobby.",
            "¬∃x (Programmer(x) ∧ Painter(x)) ::: There are no programmers who are painters."
        ],
        "predicates": [
            "Artist(x) ::: x is an artist",
            "Painter(x) ::: x is a painter",
            "Rich(x) ::: x is rich"
        ]
    },
    {
        "premises-NL": [
            "All students either like apples or bananas.",
            "Some students like bananas.",
            "If someone likes bananas, then they eat bananas.",
            "If someone eats something, then they like something.",
            "No one eats both apples and bananas.",
            "Everyone who likes bananas is a student.",
            "Some students do not like oranges.",
            "Anyone who eats an apple likes an apple.",
            "There exists a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Likes(x, \"apples\") ∨ Likes(x, \"bananas\"))) ::: All students either like apples or bananas.",
            "∃x (Student(x) ∧ Likes(x, \"bananas\")) ::: Some students like bananas.",
            "∀x (Likes(x, \"bananas\") → Eats(x, \"bananas\")) ::: If someone likes bananas, then they eat bananas.",
            "∀x ∀y (Eats(x, y) → Likes(x, y)) ::: If someone eats something, then they like something.",
            "¬∃x ∃y (Eats(x, \"apples\") ∧ Eats(x, \"bananas\")) ::: No one eats both apples and bananas.",
            "∀x (Likes(x, \"bananas\") → Student(x)) ::: Everyone who likes bananas is a student.",
            "∃x (Student(x) ∧ ¬Likes(x, \"oranges\")) ::: Some students do not like oranges.",
            "∀x (Eats(x, \"apples\") → Likes(x, \"apples\")) ::: Anyone who eats an apple likes an apple.",
            "∃x (Student(x)) ::: There exists a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Likes(x, y) ::: x likes y",
            "Eats(x, y) ::: x eats y"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All surgeons have degrees.",
            "Anyone who has a degree is educated.",
            "Some specialists are surgeons.",
            "Anyone who is a doctor is a specialist or not a surgeon.",
            "If someone is educated, then they have skills.",
            "Some specialists are not doctors.",
            "If someone is a doctor and a specialist, then they are a surgeon.",
            "Anyone who has skills is educated.",
            "No doctor is a pilot.",
            "Some people are doctors and have degrees."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (Surgeon(x) → HasDegree(x)) ::: All surgeons have degrees.",
            "∀x (HasDegree(x) → Educated(x)) ::: Anyone who has a degree is educated.",
            "∃x (Specialist(x) ∧ Surgeon(x)) ::: Some specialists are surgeons.",
            "∀x (Doctor(x) → (Specialist(x) ∨ ¬Surgeon(x))) ::: Anyone who is a doctor is a specialist or not a surgeon.",
            "∀x (Educated(x) → HasSkills(x)) ::: If someone is educated, then they have skills.",
            "∃x (Specialist(x) ∧ ¬Doctor(x)) ::: Some specialists are not doctors.",
            "∀x (Doctor(x) ∧ Specialist(x) → Surgeon(x)) ::: If someone is a doctor and a specialist, then they are a surgeon.",
            "∀x (HasSkills(x) → Educated(x)) ::: Anyone who has skills is educated.",
            "¬∃x (Doctor(x) ∧ Pilot(x)) ::: No doctor is a pilot.",
            "∃x (Doctor(x) ∧ HasDegree(x)) ::: Some people are doctors and have degrees."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Surgeon(x) ::: x is a surgeon",
            "HasDegree(x) ::: x has a degree",
            "Specialist(x) ::: x is a specialist"
        ]
    },
    {
        "premises-NL": [
            "All employees either have a high salary or not.",
            "If an employee has a high salary, they are satisfied.",
            "If an employee is not satisfied, they don't have a high salary.",
            "Some employees do not have high salaries.",
            "All employees are working.",
            "Every employee has either a high salary or a low salary.",
            "If someone has a low salary, then they are not satisfied.",
            "If someone is an employee and they are not satisfied, then they are not happy.",
            "There is an employee who is not satisfied."
        ],
        "premises-FOL": [
            "∀x (Employee(x) → (HighSalary(x) ∨ ¬HighSalary(x))) ::: All employees either have a high salary or not.",
            "∀x (HighSalary(x) → SalarySatisfaction(x)) ::: If an employee has a high salary, they are satisfied.",
            "∀x (¬SalarySatisfaction(x) → ¬HighSalary(x)) ::: If an employee is not satisfied, they don't have a high salary.",
            "∃x (Employee(x) ∧ ¬HighSalary(x)) ::: Some employees do not have high salaries.",
            "∀x (Employee(x) → Working(x)) ::: All employees are working.",
            "∀x (Employee(x) → (HighSalary(x) ∨ LowSalary(x))) ::: Every employee has either a high salary or a low salary.",
            "∀x (LowSalary(x) → ¬SalarySatisfaction(x)) ::: If someone has a low salary, then they are not satisfied.",
            "∀x (Employee(x) ∧ ¬SalarySatisfaction(x) → ¬Happy(x)) ::: If someone is an employee and they are not satisfied, then they are not happy.",
            "∃x (Employee(x) ∧ ¬SalarySatisfaction(x)) ::: There is an employee who is not satisfied."
        ],
        "predicates": [
            "Employee(x) ::: x is an employee",
            "SalarySatisfaction(x) ::: x is satisfied with their salary",
            "HighSalary(x) ::: x has a high salary"
        ]
    },
    {
        "premises-NL": [
            "All people are either rich or poor.",
            "If a person is rich, they are happy.",
            "If a person is poor, they are not happy.",
            "If a person is happy, they have friends.",
            "If a person is not happy, then they are either poor or do not have friends.",
            "Some people are poor.",
            "Anyone who has friends is happy.",
            "There is a person who is not happy.",
            "Some people don't have friends.",
            "Every person is rich or not rich.",
            "If someone has a friend they are happy.",
            "Someone is a person and poor."
        ],
        "premises-FOL": [
            "∀x (Person(x) → (Rich(x) ∨ Poor(x))) ::: All people are either rich or poor.",
            "∀x (Rich(x) → Happy(x)) ::: If a person is rich, they are happy.",
            "∀x (Poor(x) → ¬Happy(x)) ::: If a person is poor, they are not happy.",
            "∀x (Happy(x) → HasFriend(x)) ::: If a person is happy, they have friends.",
            "∀x (¬Happy(x) → (Poor(x) ∨ ¬HasFriend(x))) ::: If a person is not happy, then they are either poor or do not have friends.",
            "∃x (Person(x) ∧ Poor(x)) ::: Some people are poor.",
            "∀x (HasFriend(x) → Happy(x)) ::: Anyone who has friends is happy.",
            "∃x (Person(x) ∧ ¬Happy(x)) ::: There is a person who is not happy.",
            "∃x (Person(x) ∧ ¬HasFriend(x)) ::: Some people don't have friends.",
            "∀x (Person(x) → (Rich(x) ∨ ¬Rich(x))) ::: Every person is rich or not rich.",
            "∀x (HasFriend(x) → Happy(x)) ::: If someone has a friend they are happy.",
            "∃x (Person(x) ∧ Poor(x)) ::: Someone is a person and poor."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Happy(x) ::: x is happy",
            "HasFriend(x) ::: x has a friend",
            "Rich(x) ::: x is rich",
            "Poor(x) ::: x is poor"
        ]
    },
    {
        "premises-NL": [
            "All doctors earn money.",
            "If someone earns money, then they are busy.",
            "No busy person is happy.",
            "John is a doctor.",
            "Anyone who is a doctor helps people or earns money.",
            "If John does not help people, then John is not happy.",
            "If someone is not happy, then they do not earn money.",
            "All doctors are busy.",
            "Anyone who helps people is happy."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → EarnMoney(x)) ::: All doctors earn money.",
            "∀x (EarnMoney(x) → Busy(x)) ::: If someone earns money, then they are busy.",
            "∀x (Busy(x) → ¬Happy(x)) ::: No busy person is happy.",
            "Doctor(John) ::: John is a doctor.",
            "∀x (Doctor(x) → HelpPeople(x) ∨ EarnMoney(x)) ::: Anyone who is a doctor helps people or earns money.",
            "¬HelpPeople(John) → ¬Happy(John) ::: If John does not help people, then John is not happy.",
            "∀x (¬Happy(x) → ¬EarnMoney(x)) ::: If someone is not happy, then they do not earn money.",
            "∀x (Doctor(x) → Busy(x)) ::: All doctors are busy.",
            "∀x (HelpPeople(x) → Happy(x)) ::: Anyone who helps people is happy."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Happy(x) ::: x is happy.",
            "HelpPeople(x) ::: x helps people.",
            "EarnMoney(x) ::: x earns money.",
            "Busy(x) ::: x is busy."
        ]
    },
    {
        "premises-NL": [
            "All programmers use a computer.",
            "Alex is a programmer.",
            "If someone uses a computer, then they write code.",
            "Anyone who writes code likes coffee or works at night.",
            "If someone is a good programmer, they write code.",
            "Alex does not like coffee.",
            "Alex is a good programmer or Alex works at night.",
            "If someone likes coffee, then they are a programmer.",
            "All programmers work at night.",
            "Alex is a programmer or Alex does not use a computer."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → UseComputer(x)) ::: All programmers use a computer.",
            "Programmer(Alex) ::: Alex is a programmer.",
            "∀x (UseComputer(x) → WriteCode(x)) ::: If someone uses a computer, then they write code.",
            "∀x (WriteCode(x) → LikeCoffee(x) ∨ WorkAtNight(x)) ::: Anyone who writes code likes coffee or works at night.",
            "∀x (GoodProgrammer(x) → WriteCode(x)) ::: If someone is a good programmer, they write code.",
            "¬LikeCoffee(Alex) ::: Alex does not like coffee.",
            "GoodProgrammer(Alex) ∨ WorkAtNight(Alex) ::: Alex is a good programmer or Alex works at night.",
            "∀x (LikeCoffee(x) → Programmer(x)) ::: If someone likes coffee, then they are a programmer.",
            "∀x (Programmer(x) → WorkAtNight(x)) ::: All programmers work at night.",
            "Programmer(Alex) ∨ ¬UseComputer(Alex) ::: Alex is a programmer or Alex does not use a computer."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer.",
            "UseComputer(x) ::: x uses a computer.",
            "WriteCode(x) ::: x writes code.",
            "LikeCoffee(x) ::: x likes coffee.",
            "WorkAtNight(x) ::: x works at night.",
            "GoodProgrammer(x) ::: x is a good programmer."
        ]
    },
    {
        "premises-NL": [
            "All cats like milk or hunt mice.",
            "Some cats do not like milk.",
            "All cats are friendly or playful.",
            "If something is friendly and likes milk, then it is playful.",
            "If something hunts mice, then it is not friendly.",
            "Some cats hunt mice.",
            "Some cats are not friendly."
        ],
        "premises-FOL": [
            "∀x (Cat(x) → LikesMilk(x) ∨ HuntsMice(x)) ::: All cats like milk or hunt mice.",
            "∃x (Cat(x) ∧ ¬LikesMilk(x)) ::: Some cats do not like milk.",
            "∀x (Cat(x) → Friendly(x) ∨ Playful(x)) ::: All cats are friendly or playful.",
            "∀x (Friendly(x) ∧ LikesMilk(x) → Playful(x)) ::: If something is friendly and likes milk, then it is playful.",
            "∀x (HuntsMice(x) → ¬Friendly(x)) ::: If something hunts mice, then it is not friendly.",
            "∃x (Cat(x) ∧ HuntsMice(x)) ::: Some cats hunt mice.",
            "∃x (Cat(x) ∧ ¬Friendly(x)) ::: Some cats are not friendly."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Friendly(x) ::: x is friendly",
            "Playful(x) ::: x is playful",
            "LikesMilk(x) ::: x likes milk",
            "HuntsMice(x) ::: x hunts mice"
        ]
    },
    {
        "premises-NL": [
            "All fruits are either apples or bananas.",
            "Everyone who likes fruit eats it.",
            "Some people eat apples.",
            "Anyone who likes a fruit also likes apples or bananas.",
            "Some people do not like bananas.",
            "No one likes something that is not fruit.",
            "Some people eat bananas.",
            "Some fruits are liked by everyone."
        ],
        "premises-FOL": [
            "∀x (Fruit(x) → Apple(x) ∨ Banana(x)) ::: All fruits are either apples or bananas.",
            "∀x ∀y (Likes(x, y) ∧ Fruit(y) → Eats(x, y)) ::: Everyone who likes fruit eats it.",
            "∃x ∃y (Eats(x, y) ∧ Apple(y)) ::: Some people eat apples.",
            "∀x ∀y (Likes(x, y) ∧ Fruit(y) → Likes(x, apples) ∨ Likes(x, bananas)) ::: Anyone who likes a fruit also likes apples or bananas.",
            "∃x ¬Likes(x, bananas) ::: Some people do not like bananas.",
            "∀x ∀y (¬Fruit(y) → ¬Likes(x, y)) ::: No one likes something that is not fruit.",
            "∃x ∃y (Eats(x, y) ∧ Banana(y)) ::: Some people eat bananas.",
            "∃y ∀x (Fruit(y) → Likes(x, y)) ::: Some fruits are liked by everyone."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Apple(x) ::: x is an apple",
            "Banana(x) ::: x is a banana",
            "Fruit(x) ::: x is a fruit",
            "Eats(x, y) ::: x eats y"
        ]
    },
    {
        "premises-NL": [
            "All artists either paint or write.",
            "Anyone who paints is talented.",
            "All talented people create masterpieces or are famous.",
            "Some artists write.",
            "All famous people appreciate art.",
            "Some people who appreciate art are not artists.",
            "If someone is famous, they do not create masterpieces.",
            "All artists are famous or talented.",
            "No one both writes and paints."
        ],
        "premises-FOL": [
            "∀x (Artist(x) → Paints(x) ∨ Writes(x)) ::: All artists either paint or write.",
            "∀x (Paints(x) → IsTalented(x)) ::: Anyone who paints is talented.",
            "∀x (IsTalented(x) → CreatesMasterpiece(x) ∨ Famous(x)) ::: All talented people create masterpieces or are famous.",
            "∃x (Artist(x) ∧ Writes(x)) ::: Some artists write.",
            "∀x (Famous(x) → AppreciatesArt(x)) ::: All famous people appreciate art.",
            "∃x (AppreciatesArt(x) ∧ ¬Artist(x)) ::: Some people who appreciate art are not artists.",
            "∀x (Famous(x) → ¬CreatesMasterpiece(x)) ::: If someone is famous, they do not create masterpieces.",
            "∀x (Artist(x) → Famous(x) ∨ IsTalented(x)) ::: All artists are famous or talented.",
            "∀x (Writes(x) → ¬Paints(x)) ::: No one both writes and paints."
        ],
        "predicates": [
            "Artist(x) ::: x is an artist",
            "CreatesMasterpiece(x) ::: x creates a masterpiece",
            "Paints(x) ::: x paints",
            "Writes(x) ::: x writes",
            "IsTalented(x) ::: x is talented",
            "AppreciatesArt(x) ::: x appreciates art",
            "Famous(x) ::: x is famous"
        ]
    },
    {
        "premises-NL": [
            "All students who attend lectures study hard.",
            "Sarah attends lectures.",
            "Anyone who studies hard and is smart will pass the exam.",
            "Sarah is smart.",
            "No one helps others if they do not pass exams.",
            "If John helps others, he will pass exam.",
            "John attends lectures.",
            "Students who help others are smart.",
            "Sarah studies hard if John passes exam.",
            "John studies hard."
        ],
        "premises-FOL": [
            "∀x (AttendsLectures(x) → StudiesHard(x)) ::: All students who attend lectures study hard",
            "AttendsLectures(sarah) ::: Sarah attends lectures",
            "∀x (StudiesHard(x) ∧ IsSmart(x) → PassesExam(x)) ::: Anyone who studies hard and is smart will pass the exam",
            "IsSmart(sarah) ::: Sarah is smart",
            "∀x (HelpsOthers(x) → PassesExam(x)) ::: No one helps others if they do not pass exams.",
            "PassesExam(john) → HelpsOthers(john) ::: If John helps others, he will pass exam",
            "AttendsLectures(john) ::: John attends lectures",
            "∀x (HelpsOthers(x) → IsSmart(x)) ::: Students who help others are smart",
            "PassesExam(john) → StudiesHard(sarah) ::: Sarah studies hard if John passes exam",
            "StudiesHard(john) ::: John studies hard",
            "StudiesHard(john) → PassesExam(john) ::: John will pass exam if he studies hard."
        ],
        "predicates": [
            "StudiesHard(x) ::: x studies hard",
            "AttendsLectures(x) ::: x attends lectures",
            "PassesExam(x) ::: x passes the exam",
            "IsSmart(x) ::: x is smart",
            "HelpsOthers(x) ::: x helps others"
        ]
    },
    {
        "premises-NL": [
            "All green things are plants.",
            "The green plant is green.",
            "Healthy plants are green and receive sunlight.",
            "The green plant is a plant.",
            "Anything that is healthy needs water.",
            "All plants need water or get water.",
            "The green plant needs water.",
            "Healthy plants are healthy.",
            "The green plant gets water.",
            "Anything that is healthy and gets water is healthy.",
            "The green plant is not unhealthy.",
            "Any plant which receives sunlight is healthy."
        ],
        "premises-FOL": [
            "∀x (IsGreen(x) → IsPlant(x)) ::: All green things are plants",
            "IsGreen(greenPlant) ::: The green plant is green",
            "∀x (IsHealthy(x) → (IsGreen(x) ∧ ReceivesSunlight(x))) ::: Healthy plants are green and receive sunlight",
            "IsPlant(greenPlant) ::: The green plant is a plant",
            "∀x (IsHealthy(x) → NeedsWater(x)) ::: Anything that is healthy needs water",
            "∀x (IsPlant(x) → NeedsWater(x) ∨ GetsWater(x)) ::: All plants need water or get water",
            "NeedsWater(greenPlant) ::: The green plant needs water",
            "∀x (IsHealthy(x) → IsHealthy(x)) ::: Healthy plants are healthy",
            "GetsWater(greenPlant) ::: The green plant gets water",
            "∀x ((IsHealthy(x) ∧ GetsWater(x)) → IsHealthy(x)) ::: Anything that is healthy and gets water is healthy",
            "¬IsHealthy(greenPlant) → IsHealthy(greenPlant) ::: The green plant is not unhealthy",
            "∀x (IsPlant(x) ∧ ReceivesSunlight(x) → IsHealthy(x)) ::: Any plant which receives sunlight is healthy"
        ],
        "predicates": [
            "IsGreen(x) ::: x is green",
            "IsPlant(x) ::: x is a plant",
            "IsHealthy(x) ::: x is healthy",
            "ReceivesSunlight(x) ::: x receives sunlight",
            "NeedsWater(x) ::: x needs water",
            "GetsWater(x) ::: x gets water"
        ]
    },
    {
        "premises-NL": [
            "If a patient is sick and takes medicine, they will get better.",
            "If a patient gets better, they will be discharged.",
            "If a patient does not take medicine, they require surgery.",
            "The patient is sick.",
            "The patient takes medicine.",
            "Patients who require surgery are hospitalized.",
            "Patients that are hospitalized will not be discharged.",
            "If the patient has surgery, the patient is hospitalized.",
            "If a patient is sick and has surgery then they require surgery.",
            "If patients need to be discharged they must get better.",
            "If a patient does not need surgery they are not hospitalized.",
            "The patient is not hospitalized.",
            "If a patient has surgery then they will get better.",
            "If patient is not taking medicine then he has surgery."
        ],
        "premises-FOL": [
            "∀x (IsSick(x) ∧ TakesMedicine(x, medicine) → GetsBetter(x)) ::: If a patient is sick and takes medicine, they will get better",
            "∀x (GetsBetter(x) → Discharged(x)) ::: If a patient gets better, they will be discharged",
            "∀x (¬TakesMedicine(x, medicine) → RequiresSurgery(x)) ::: If a patient does not take medicine, they require surgery",
            "IsSick(patient) ::: The patient is sick",
            "TakesMedicine(patient, medicine) ::: The patient takes medicine",
            "∀x (RequiresSurgery(x) → IsHospitalized(x)) ::: Patients who require surgery are hospitalized",
            "∀x (IsHospitalized(x) → ¬Discharged(x)) ::: Patients that are hospitalized will not be discharged",
            "HasSurgery(patient) → IsHospitalized(patient) ::: If the patient has surgery, the patient is hospitalized",
            "∀x (IsSick(x) ∧ HasSurgery(x) → RequiresSurgery(x)) ::: If a patient is sick and has surgery then they require surgery",
            "∀x (Discharged(x) → GetsBetter(x)) ::: If patients need to be discharged they must get better",
            "∀x (¬RequiresSurgery(x) → ¬IsHospitalized(x)) ::: If a patient does not need surgery they are not hospitalized",
            "¬IsHospitalized(patient) ::: The patient is not hospitalized",
            "HasSurgery(patient) → GetsBetter(patient) ::: If a patient has surgery then they will get better",
            "¬TakesMedicine(patient, medicine) → HasSurgery(patient) ::: If patient is not taking medicine then he has surgery"
        ],
        "predicates": [
            "TakesMedicine(x, y) ::: x takes medicine y",
            "IsSick(x) ::: x is sick",
            "GetsBetter(x) ::: x gets better",
            "Discharged(x) ::: x is discharged",
            "HasSurgery(x) ::: x has surgery",
            "RequiresSurgery(x) ::: x requires surgery",
            "IsHospitalized(x) ::: x is hospitalized"
        ]
    },
    {
        "premises-NL": [
            "If a company invests in research, it has a good strategy.",
            "If a company invests in development, it employs skilled workers.",
            "If a company has a good strategy and employs skilled workers, it is competitive.",
            "If a company is competitive, it increases its profits.",
            "If a company is competitive, it increases its market share.",
            "If a company invests in research and development, it has a good strategy and employs skilled workers.",
            "If the company increases profits, it has invested in development or employs skilled workers.",
            "If a company is competitive or has a good strategy then it increases market share.",
            "If a company employs skilled workers and invests in development, it increases market share.",
            "If a company has a good strategy, it increases market share.",
            "If a company invests in development then it is competitive and increases its profits.",
            "If the company does not have a good strategy, it does not increase profits.",
            "If a company employs skilled workers or has a good strategy, it increases profits.",
            "If a company invests in research, then it is competitive.",
            "If the company increases market share then it invests in research and development."
        ],
        "premises-FOL": [
            "∀x (InvestsInResearch(x) → HasGoodStrategy(x)) ::: If a company invests in research, it has a good strategy",
            "∀x (InvestsInDevelopment(x) → EmploysSkilledWorkers(x)) ::: If a company invests in development, it employs skilled workers",
            "∀x (HasGoodStrategy(x) ∧ EmploysSkilledWorkers(x) → IsCompetitive(x)) ::: If a company has a good strategy and employs skilled workers, it is competitive",
            "∀x (IsCompetitive(x) → IncreasesProfits(x)) ::: If a company is competitive, it increases its profits",
            "∀x (IsCompetitive(x) → IncreasesMarketShare(x)) ::: If a company is competitive, it increases its market share",
            "∀x ((InvestsInResearch(x) ∧ InvestsInDevelopment(x)) → (HasGoodStrategy(x) ∧ EmploysSkilledWorkers(x))) ::: If a company invests in research and development, it has a good strategy and employs skilled workers",
            "IncreasesProfits(company) → (InvestsInDevelopment(company) ∨ EmploysSkilledWorkers(company)) ::: If the company increases profits, it has invested in development or employs skilled workers",
            "∀x ((IsCompetitive(x) ∨ HasGoodStrategy(x)) → IncreasesMarketShare(x)) ::: If a company is competitive or has a good strategy then it increases market share",
            "∀x ((EmploysSkilledWorkers(x) ∧ InvestsInDevelopment(x)) → IncreasesMarketShare(x)) ::: If a company employs skilled workers and invests in development, it increases market share",
            "∀x (HasGoodStrategy(x) → IncreasesMarketShare(x)) ::: If a company has a good strategy, it increases market share",
            "∀x (InvestsInDevelopment(x) → (IsCompetitive(x) ∧ IncreasesProfits(x))) ::: If a company invests in development then it is competitive and increases its profits",
            "¬HasGoodStrategy(company) → ¬IncreasesProfits(company) ::: If the company does not have a good strategy, it does not increase profits",
            "∀x ((EmploysSkilledWorkers(x) ∨ HasGoodStrategy(x)) → IncreasesProfits(x)) ::: If a company employs skilled workers or has a good strategy, it increases profits",
            "∀x (InvestsInResearch(x) → IsCompetitive(x)) ::: If a company invests in research, then it is competitive",
            "IncreasesMarketShare(company) → (InvestsInResearch(company) ∧ InvestsInDevelopment(company)) ::: If the company increases market share then it invests in research and development"
        ],
        "predicates": [
            "InvestsInResearch(x) ::: x invests in research",
            "InvestsInDevelopment(x) ::: x invests in development",
            "IncreasesProfits(x) ::: x increases profits",
            "IncreasesMarketShare(x) ::: x increases market share",
            "HasGoodStrategy(x) ::: x has a good strategy",
            "EmploysSkilledWorkers(x) ::: x employs skilled workers",
            "IsCompetitive(x) ::: x is competitive"
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "Alex is a student.",
            "If someone is smart and attends class, then they study hard.",
            "Alex attends the class.",
            "If someone studies hard, then they will pass the exam.",
            "If a student is smart then they study hard.",
            "Being smart implies studying hard.",
            "Alex studies hard.",
            "If Alex attends class, then he studies hard.",
            "Anyone who is smart passes the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "Student(alex) ::: Alex is a student.",
            "∀x ((Smart(x) ∧ AttendsClass(x)) → StudiesHard(x)) ::: If someone is smart and attends class, then they study hard.",
            "AttendsClass(alex) ::: Alex attends the class.",
            "∀x (StudiesHard(x) → PassExam(x)) ::: If someone studies hard, then they will pass the exam.",
            "∀x (Student(x) ∧ Smart(x) → StudiesHard(x)) ::: If a student is smart then they study hard.",
            "∀x (Smart(x) → StudiesHard(x)) ::: Being smart implies studying hard.",
            "StudiesHard(alex) ::: Alex studies hard.",
            "AttendsClass(alex) → StudiesHard(alex) ::: If Alex attends class, then he studies hard.",
            "∀x (Smart(x) → PassExam(x)) ::: Anyone who is smart passes the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "AttendsClass(x) ::: x attends the class",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All premium users have a subscription.",
            "If a user has a subscription, they can access all features.",
            "If a user is a premium user, they use the app.",
            "If someone uses the app and likes content, they share content.",
            "If someone shares content, they post a comment.",
            "If someone posts a comment, they purchase an item.",
            "Premium users are online.",
            "Every user who is online is registered.",
            "Alice is a premium user.",
            "Alice likes the content.",
            "Alice is registered.",
            "If a user uses the app and is online, they can access basic features."
        ],
        "premises-FOL": [
            "∀x (PremiumUser(x) → HasSubscription(x)) ::: All premium users have a subscription.",
            "∀x (HasSubscription(x) → AccessAllFeatures(x)) ::: If a user has a subscription, they can access all features.",
            "∀x (PremiumUser(x) → UsesApp(x)) ::: If a user is a premium user, they use the app.",
            "∀x ((UsesApp(x) ∧ LikesContent(x)) → SharesContent(x)) ::: If someone uses the app and likes content, they share content.",
            "∀x (SharesContent(x) → PostsComment(x)) ::: If someone shares content, they post a comment.",
            "∀x (PostsComment(x) → PurchasesItem(x)) ::: If someone posts a comment, they purchase an item.",
            "∀x (PremiumUser(x) → IsOnline(x)) ::: Premium users are online.",
            "∀x (IsOnline(x) → IsRegistered(x)) ::: Every user who is online is registered.",
            "PremiumUser(alice) ::: Alice is a premium user.",
            "LikesContent(alice) ::: Alice likes the content.",
            "IsRegistered(alice) ::: Alice is registered.",
            "∀x ((UsesApp(x) ∧ IsOnline(x)) → AccessBasicFeatures(x)) ::: If a user uses the app and is online, they can access basic features."
        ],
        "predicates": [
            "User(x) ::: x is a user",
            "PremiumUser(x) ::: x is a premium user",
            "UsesApp(x) ::: x uses the app",
            "AccessBasicFeatures(x) ::: x accesses basic features",
            "AccessAllFeatures(x) ::: x accesses all features",
            "HasSubscription(x) ::: x has a subscription",
            "IsOnline(x) ::: x is online",
            "IsRegistered(x) ::: x is registered",
            "LikesContent(x) ::: x likes the content",
            "SharesContent(x) ::: x shares the content",
            "PostsComment(x) ::: x posts a comment",
            "PurchasesItem(x) ::: x purchases an item"
        ]
    },
    {
        "premises-NL": [
            "John is a person.",
            "Mary is a person.",
            "If John is friends with Mary, then John and Mary attend the party together.",
            "If John and Mary attend the party together, John is happy.",
            "If John and Mary attend the party together, Mary is happy.",
            "If someone likes music and is dancing, they are happy.",
            "If someone enjoys food and drinks, they are happy.",
            "If someone is happy, they are at the party.",
            "If someone is at the party, they are invited.",
            "John likes music.",
            "John enjoys food.",
            "Mary is friends with John.",
            "Everyone who is friends with John knows Mary.",
            "John is dancing.",
            "John drinks."
        ],
        "premises-FOL": [
            "Person(john) ::: John is a person.",
            "Person(mary) ::: Mary is a person.",
            "Friend(john, mary) → AttendTogether(john, mary) ::: If John is friends with Mary, then John and Mary attend the party together.",
            "AttendTogether(john, mary) → Happy(john) ::: If John and Mary attend the party together, John is happy.",
            "AttendTogether(john, mary) → Happy(mary) ::: If John and Mary attend the party together, Mary is happy.",
            "∀x ((LikesMusic(x) ∧ Dancing(x)) → Happy(x)) ::: If someone likes music and is dancing, they are happy.",
            "∀x ((EnjoysFood(x) ∧ Drinks(x)) → Happy(x)) ::: If someone enjoys food and drinks, they are happy.",
            "∀x (Happy(x) → IsAtParty(x)) ::: If someone is happy, they are at the party.",
            "∀x (IsAtParty(x) → Invited(x)) ::: If someone is at the party, they are invited.",
            "LikesMusic(john) ::: John likes music.",
            "EnjoysFood(john) ::: John enjoys food.",
            "Friend(mary, john) ::: Mary is friends with John.",
            "∀x (Friend(john, x) → KnowsPeople(john, x)) ::: Everyone who is friends with John knows Mary.",
            "Dancing(john) ::: John is dancing.",
            "Drinks(john) ::: John drinks."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Friend(x, y) ::: x is a friend of y",
            "AttendParty(x) ::: x attends the party",
            "AttendTogether(x, y) ::: x and y attend the party together",
            "Happy(x) ::: x is happy",
            "LikesMusic(x) ::: x likes music",
            "Dancing(x) ::: x is dancing",
            "EnjoysFood(x) ::: x enjoys food",
            "Drinks(x) ::: x drinks",
            "TalksTo(x, y) ::: x talks to y",
            "IsAtParty(x) ::: x is at the party",
            "Invited(x) ::: x is invited",
            "KnowsPeople(x, y) ::: x knows y"
        ]
    },
    {
        "premises-NL": [
            "All patients who have a fever take medicine.",
            "All patients take medicine or they are not ill.",
            "If a patient is not ill, they do not have a fever.",
            "A patient has a fever or they do not have medicine.",
            "Any patient without medicine is not ill."
        ],
        "premises-FOL": [
            "∀x (Patient(x) ∧ Fever(x) → TakesMedicine(x, Medicine)) ::: All patients who have a fever take medicine.",
            "∀x (Patient(x) → (TakesMedicine(x, Medicine) ∨ ¬Ill(x))) ::: All patients take medicine or they are not ill.",
            "∀x (Patient(x) ∧ ¬Ill(x) → ¬Fever(x)) ::: If a patient is not ill, they do not have a fever.",
            "∀x (Patient(x) → (Fever(x) ∨ ¬HasMedicine(x))) ::: A patient has a fever or they do not have medicine.",
            "∀x (Patient(x) ∧ ¬HasMedicine(x) → ¬Ill(x)) ::: Any patient without medicine is not ill."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient",
            "HasMedicine(x) ::: x has medicine",
            "Fever(x) ::: x has a fever",
            "Ill(x) ::: x is ill",
            "TakesMedicine(x, y) ::: x takes medicine y"
        ]
    },
    {
        "premises-NL": [
            "All mammals breathe air.",
            "Some aquatic species live in water.",
            "If a species lives in water, then it is aquatic.",
            "If a species breathes air and lives in water, it's not a mammal.",
            "Dolphins are mammals.",
            "Dolphins breathe air.",
            "Dolphins live in water.",
            "Whales are mammals.",
            "Whales breathe air.",
            "If a species is a mammal, then it breathes air.",
            "Fish are aquatic.",
            "Sharks live in water."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → BreathesAir(x)) ::: All mammals breathe air",
            "∃x (Aquatic(x) ∧ LivesInWater(x)) ::: Some aquatic species live in water",
            "∀x (LivesInWater(x) → Aquatic(x)) ::: If a species lives in water, then it is aquatic",
            "∀x (BreathesAir(x) ∧ LivesInWater(x) → ¬Mammal(x)) ::: If a species breathes air and lives in water, it's not a mammal",
            "Mammal(dolphin) ::: Dolphins are mammals",
            "BreathesAir(dolphin) ::: Dolphins breathe air",
            "LivesInWater(dolphin) ::: Dolphins live in water",
            "Mammal(whale) ::: Whales are mammals",
            "BreathesAir(whale) ::: Whales breathe air",
            "∀x (Mammal(x) → BreathesAir(x)) ::: If a species is a mammal, then it breathes air",
            "Aquatic(fish) ::: Fish are aquatic",
            "LivesInWater(shark) ::: Sharks live in water"
        ],
        "predicates": [
            "Aquatic(x) ::: x is aquatic",
            "Mammal(x) ::: x is a mammal",
            "BreathesAir(x) ::: x breathes air",
            "LivesInWater(x) ::: x lives in water"
        ]
    },
    {
        "premises-NL": [
            "All doctors are qualified.",
            "Dr. Smith is a doctor.",
            "If someone is a doctor then they are a medical professional.",
            "If someone is qualified then they are a medical professional.",
            "Dr. Smith is a human.",
            "All humans require sleep.",
            "If someone requires sleep then they are alive.",
            "If someone is alive then they are a human.",
            "If someone is a doctor they are kind.",
            "Dr. Smith is kind.",
            "Humans are not robots."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Qualified(x)) ::: All doctors are qualified",
            "Doctor(smith) ::: Dr. Smith is a doctor",
            "∀x (Doctor(x) → MedicalProfessional(x)) ::: If someone is a doctor then they are a medical professional",
            "∀x (Qualified(x) → MedicalProfessional(x)) ::: If someone is qualified then they are a medical professional",
            "Human(smith) ::: Dr. Smith is a human",
            "∀x (Human(x) → RequiresSleep(x)) ::: All humans require sleep",
            "∀x (RequiresSleep(x) → Alive(x)) ::: If someone requires sleep then they are alive",
            "∀x (Alive(x) → Human(x)) ::: If someone is alive then they are a human",
            "∀x (Doctor(x) → Kind(x)) ::: If someone is a doctor they are kind",
            "Kind(smith) ::: Dr. Smith is kind",
            "¬Robot(x) ::: Humans are not robots"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Qualified(x) ::: x is qualified"
        ]
    },
    {
        "premises-NL": [
            "All students are diligent.",
            "Alex is a student.",
            "If someone is diligent, then they succeed.",
            "If someone succeeds, then they are happy.",
            "Alex is not happy."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Diligence(x)) ::: All students are diligent",
            "Student(alex) ::: Alex is a student",
            "∀x (Diligence(x) → Succeed(x)) ::: If someone is diligent, then they succeed",
            "∀x (Succeed(x) → Happy(x)) ::: If someone succeeds, then they are happy",
            "¬Happy(alex) ::: Alex is not happy"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Diligence(x) ::: x is diligent"
        ]
    },
    {
        "premises-NL": [
            "All doctors are knowledgeable.",
            "All researchers are passionate.",
            "Anyone who is knowledgeable and passionate is a scientist.",
            "If someone is a doctor, they are observant.",
            "If someone is a researcher, they are also observant.",
            "If someone is observant, then they are a scientist."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Knowledgeable(x)) ::: All doctors are knowledgeable",
            "∀x (Researcher(x) → Passionate(x)) ::: All researchers are passionate",
            "∀x ((Knowledgeable(x) ∧ Passionate(x)) → Scientist(x)) ::: Anyone who is knowledgeable and passionate is a scientist",
            "∀x (Doctor(x) → Observant(x)) ::: If someone is a doctor, they are observant",
            "∀x (Researcher(x) → Observant(x)) ::: If someone is a researcher, they are also observant",
            "∀x (Observant(x) → Scientist(x)) ::: If someone is observant, then they are a scientist"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Researcher(x) ::: x is a researcher",
            "Scientist(x) ::: x is a scientist",
            "Knowledgeable(x) ::: x is knowledgeable",
            "Passionate(x) ::: x is passionate",
            "Observant(x) ::: x is observant"
        ]
    },
    {
        "premises-NL": [
            "All students study.",
            "Some students are successful.",
            "If someone is a student, then they have access to resources.",
            "If someone has access to resources, then they can study.",
            "If someone studies, then they can succeed.",
            "Some people have resources.",
            "A student, Alice, exists.",
            "If Alice studies, she will be successful.",
            "If a person is a student, they are enrolled.",
            "If a person is enrolled, they are studying.",
            "Alice is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Studies(x)) ::: All students study.",
            "∃x (Student(x) ∧ Successful(x)) ::: Some students are successful.",
            "∀x (Student(x) → AccessResources(x)) ::: If someone is a student, then they have access to resources.",
            "∀x (AccessResources(x) → Studies(x)) ::: If someone has access to resources, then they can study.",
            "∀x (Studies(x) → Succeeds(x)) ::: If someone studies, then they can succeed.",
            "∃x AccessResources(x) ::: Some people have resources.",
            "Student(alice) ::: A student, Alice, exists.",
            "Studies(alice) → Successful(alice) ::: If Alice studies, she will be successful.",
            "∀x (Student(x) → Enrolled(x)) ::: If a person is a student, they are enrolled.",
            "∀x (Enrolled(x) → Studies(x)) ::: If a person is enrolled, they are studying.",
            "Student(alice) ::: Alice is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "Successful(x) ::: x is successful"
        ]
    },
    {
        "premises-NL": [
            "All programmers use computers.",
            "Some programmers are creative.",
            "If someone is a programmer, they write code.",
            "If someone writes code, they use a computer.",
            "If someone is creative, they can create art.",
            "Some artists exist.",
            "If an artist is creative, they are respected.",
            "If a programmer is creative, they are helpful.",
            "If someone uses a computer, they work on projects.",
            "If someone works on projects, they use a computer.",
            "A programmer, Carol, exists.",
            "If Carol is creative, she makes art.",
            "If someone is creative, they think outside the box."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → UsesComputer(x)) ::: All programmers use computers.",
            "∃x (Programmer(x) ∧ Creative(x)) ::: Some programmers are creative.",
            "∀x (Programmer(x) → WritesCode(x)) ::: If someone is a programmer, they write code.",
            "∀x (WritesCode(x) → UsesComputer(x)) ::: If someone writes code, they use a computer.",
            "∀x (Creative(x) → CreatesArt(x)) ::: If someone is creative, they can create art.",
            "∃x Artist(x) ::: Some artists exist.",
            "∀x (Artist(x) ∧ Creative(x) → Respected(x)) ::: If an artist is creative, they are respected.",
            "∀x (Programmer(x) ∧ Creative(x) → Helpful(x)) ::: If a programmer is creative, they are helpful.",
            "∀x (UsesComputer(x) → WorksOnProjects(x)) ::: If someone uses a computer, they work on projects.",
            "∀x (WorksOnProjects(x) → UsesComputer(x)) ::: If someone works on projects, they use a computer.",
            "Programmer(carol) ::: A programmer, Carol, exists.",
            "Creative(carol) → MakesArt(carol) ::: If Carol is creative, she makes art.",
            "∀x (Creative(x) → ThinksOutsideTheBox(x)) ::: If someone is creative, they think outside the box."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "UsesComputer(x) ::: x uses a computer",
            "Creative(x) ::: x is creative",
            "Artist(x) ::: x is an artist"
        ]
    },
    {
        "premises-NL": [
            "All scientists study nature.",
            "Some scientists are curious.",
            "If someone is a scientist, they conduct experiments.",
            "If someone conducts experiments, they study nature.",
            "If someone is curious, they ask questions.",
            "Some explorers exist.",
            "If an explorer is curious, they travel.",
            "If a scientist is curious, they discover new things.",
            "If someone studies nature, they read books.",
            "If someone reads books, they study nature.",
            "A scientist, David, exists.",
            "If David is curious, he makes discoveries.",
            "If someone is curious, they seek knowledge.",
            "If someone studies nature, they understand the world."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → StudiesNature(x)) ::: All scientists study nature.",
            "∃x (Scientist(x) ∧ Curious(x)) ::: Some scientists are curious.",
            "∀x (Scientist(x) → ConductsExperiments(x)) ::: If someone is a scientist, they conduct experiments.",
            "∀x (ConductsExperiments(x) → StudiesNature(x)) ::: If someone conducts experiments, they study nature.",
            "∀x (Curious(x) → AsksQuestions(x)) ::: If someone is curious, they ask questions.",
            "∃x Explorer(x) ::: Some explorers exist.",
            "∀x (Explorer(x) ∧ Curious(x) → Travels(x)) ::: If an explorer is curious, they travel.",
            "∀x (Scientist(x) ∧ Curious(x) → DiscoversNewThings(x)) ::: If a scientist is curious, they discover new things.",
            "∀x (StudiesNature(x) → ReadsBooks(x)) ::: If someone studies nature, they read books.",
            "∀x (ReadsBooks(x) → StudiesNature(x)) ::: If someone reads books, they study nature.",
            "Scientist(david) ::: A scientist, David, exists.",
            "Curious(david) → MakesDiscoveries(david) ::: If David is curious, he makes discoveries.",
            "∀x (Curious(x) → SeeksKnowledge(x)) ::: If someone is curious, they seek knowledge.",
            "∀x (StudiesNature(x) → UnderstandsWorld(x)) ::: If someone studies nature, they understand the world."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "StudiesNature(x) ::: x studies nature",
            "Curious(x) ::: x is curious",
            "Explorer(x) ::: x is an explorer"
        ]
    },
    {
        "premises-NL": [
            "All engineers build bridges.",
            "Some engineers are innovative.",
            "If someone is an engineer, they solve problems.",
            "If someone solves problems, they build bridges.",
            "If someone is innovative, they design things.",
            "Some architects exist.",
            "If an architect is innovative, they win awards.",
            "If an engineer is innovative, they improve designs.",
            "If someone builds bridges, they use materials.",
            "If someone uses materials, they build bridges.",
            "An engineer, Emily, exists.",
            "If Emily is innovative, she gets recognition.",
            "If someone is innovative, they create new solutions.",
            "If someone builds bridges, they work with structures.",
            "If someone designs things, they create blueprints."
        ],
        "premises-FOL": [
            "∀x (Engineer(x) → BuildsBridge(x)) ::: All engineers build bridges.",
            "∃x (Engineer(x) ∧ Innovative(x)) ::: Some engineers are innovative.",
            "∀x (Engineer(x) → SolvesProblems(x)) ::: If someone is an engineer, they solve problems.",
            "∀x (SolvesProblems(x) → BuildsBridge(x)) ::: If someone solves problems, they build bridges.",
            "∀x (Innovative(x) → DesignsThings(x)) ::: If someone is innovative, they design things.",
            "∃x Architect(x) ::: Some architects exist.",
            "∀x (Architect(x) ∧ Innovative(x) → WinsAwards(x)) ::: If an architect is innovative, they win awards.",
            "∀x (Engineer(x) ∧ Innovative(x) → ImprovesDesigns(x)) ::: If an engineer is innovative, they improve designs.",
            "∀x (BuildsBridge(x) → UsesMaterials(x)) ::: If someone builds bridges, they use materials.",
            "∀x (UsesMaterials(x) → BuildsBridge(x)) ::: If someone uses materials, they build bridges.",
            "Engineer(emily) ::: An engineer, Emily, exists.",
            "Innovative(emily) → GetsRecognition(emily) ::: If Emily is innovative, she gets recognition.",
            "∀x (Innovative(x) → CreatesNewSolutions(x)) ::: If someone is innovative, they create new solutions.",
            "∀x (BuildsBridge(x) → WorksWithStructures(x)) ::: If someone builds bridges, they work with structures.",
            "∀x (DesignsThings(x) → CreatesBlueprints(x)) ::: If someone designs things, they create blueprints."
        ],
        "predicates": [
            "Engineer(x) ::: x is an engineer",
            "BuildsBridge(x) ::: x builds bridges",
            "Innovative(x) ::: x is innovative",
            "Architect(x) ::: x is an architect"
        ]
    },
    {
        "premises-NL": [
            "Every scientist publishes papers.",
            "If someone publishes papers, they are respected.",
            "If someone knows facts, then they are respected.",
            "Some people are scientists.",
            "All scientists know facts.",
            "Dr. Smith is a scientist.",
            "If Dr. Smith is a scientist, then Dr. Smith publishes papers.",
            "If Dr. Smith publishes papers and Dr. Smith knows facts, then Dr. Smith is respected."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → PublishesPapers(x)) ::: Every scientist publishes papers.",
            "∀x (PublishesPapers(x) → Respected(x)) ::: If someone publishes papers, they are respected.",
            "∀x (KnowsFacts(x) → Respected(x)) ::: If someone knows facts, then they are respected.",
            "∃x (Scientist(x)) ::: Some people are scientists.",
            "∀x (Scientist(x) → KnowsFacts(x)) ::: All scientists know facts.",
            "Scientist(smith) ::: Dr. Smith is a scientist.",
            "Scientist(smith) → PublishesPapers(smith) ::: If Dr. Smith is a scientist, then Dr. Smith publishes papers.",
            "(PublishesPapers(smith) ∧ KnowsFacts(smith)) → Respected(smith) ::: If Dr. Smith publishes papers and Dr. Smith knows facts, then Dr. Smith is respected."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "PublishesPapers(x) ::: x publishes papers",
            "Respected(x) ::: x is respected",
            "KnowsFacts(x) ::: x knows facts"
        ]
    },
    {
        "premises-NL": [
            "Every student who attends lectures prepares notes.",
            "If a student prepares notes and studies hard, they pass the exam.",
            "Some students attend lectures.",
            "If someone studies hard, they take an exam.",
            "All students take an exam.",
            "Alice is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ AttendLecture(x) → PrepareNotes(x)) ::: Every student who attends lectures prepares notes.",
            "∀x (PrepareNotes(x) ∧ StudyHard(x) → PassExam(x)) ::: If a student prepares notes and studies hard, they pass the exam.",
            "∃x (Student(x) ∧ AttendLecture(x)) ::: Some students attend lectures.",
            "∀x (StudyHard(x) → Exam(x)) ::: If someone studies hard, they take an exam.",
            "∀x (Student(x) → Exam(x)) ::: All students take an exam.",
            "Student(alice) ::: Alice is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudyHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "AttendLecture(x) ::: x attends lectures",
            "PrepareNotes(x) ::: x prepares notes",
            "Exam(x) ::: x is an exam"
        ]
    },
    {
        "premises-NL": [
            "All researchers are scientists.",
            "If someone is smart, they are a researcher.",
            "If someone studies science and is curious, they are smart.",
            "If someone works in a lab, they are curious.",
            "Anyone who is a scientist likes cats or studies science.",
            "Bob is a scientist.",
            "Bob works in a lab."
        ],
        "premises-FOL": [
            "∀x (Researcher(x) → Scientist(x)) ::: All researchers are scientists.",
            "∀x (Smart(x) → Researcher(x)) ::: If someone is smart, they are a researcher.",
            "∀x (StudiesScience(x) ∧ Curious(x) → Smart(x)) ::: If someone studies science and is curious, they are smart.",
            "∀x (WorksInLab(x) → Curious(x)) ::: If someone works in a lab, they are curious.",
            "∀x (Scientist(x) → LikesCats(x) ∨ StudiesScience(x)) ::: Anyone who is a scientist likes cats or studies science.",
            "Scientist(bob) ::: Bob is a scientist.",
            "WorksInLab(bob) ::: Bob works in a lab."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Researcher(x) ::: x is a researcher",
            "LikesCats(x) ::: x likes cats",
            "Smart(x) ::: x is smart",
            "StudiesScience(x) ::: x studies science",
            "Curious(x) ::: x is curious",
            "WorksInLab(x) ::: x works in a lab"
        ]
    },
    {
        "premises-NL": [
            "If someone eats healthy and exercises, they are healthy.",
            "If someone is healthy, they are not sick.",
            "Anyone who avoids junk food eats healthy.",
            "If someone sleeps well, they are not sick.",
            "If someone has a disease, they are sick.",
            "Everyone who exercises takes medicine or avoids junk food.",
            "Alice exercises.",
            "Alice avoids junk food."
        ],
        "premises-FOL": [
            "∀x (EatsHealthy(x) ∧ Exercises(x) → Healthy(x)) ::: If someone eats healthy and exercises, they are healthy.",
            "∀x (Healthy(x) → ¬Sick(x)) ::: If someone is healthy, they are not sick.",
            "∀x (AvoidsJunkFood(x) → EatsHealthy(x)) ::: Anyone who avoids junk food eats healthy.",
            "∀x (SleepsWell(x) → ¬Sick(x)) ::: If someone sleeps well, they are not sick.",
            "∀x (HasDisease(x) → Sick(x)) ::: If someone has a disease, they are sick.",
            "∀x (Exercises(x) → TakesMedicine(x) ∨ AvoidsJunkFood(x)) ::: Everyone who exercises takes medicine or avoids junk food.",
            "Exercises(alice) ::: Alice exercises.",
            "AvoidsJunkFood(alice) ::: Alice avoids junk food."
        ],
        "predicates": [
            "EatsHealthy(x) ::: x eats healthy",
            "Exercises(x) ::: x exercises",
            "Sick(x) ::: x is sick",
            "HasDisease(x) ::: x has a disease",
            "TakesMedicine(x) ::: x takes medicine",
            "Healthy(x) ::: x is healthy",
            "AvoidsJunkFood(x) ::: x avoids junk food",
            "SleepsWell(x) ::: x sleeps well"
        ]
    },
    {
        "premises-NL": [
            "All programmers write code.",
            "If someone writes code and uses a computer, they are a programmer.",
            "If someone reads books, they learn.",
            "Anyone who understands logic reads books.",
            "If someone has internet access and writes documentation, they understand logic.",
            "If someone writes code, they use a computer.",
            "Bob is a programmer.",
            "Bob writes documentation.",
            "Bob has internet access."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → WritesCode(x)) ::: All programmers write code.",
            "∀x (WritesCode(x) ∧ UsesComputer(x) → Programmer(x)) ::: If someone writes code and uses a computer, they are a programmer.",
            "∀x (ReadsBooks(x) → Learns(x)) ::: If someone reads books, they learn.",
            "∀x (UnderstandsLogic(x) → ReadsBooks(x)) ::: Anyone who understands logic reads books.",
            "∀x (HasInternet(x) ∧ WritesDocumentation(x) → UnderstandsLogic(x)) ::: If someone has internet access and writes documentation, they understand logic.",
            "∀x (WritesCode(x) → UsesComputer(x)) ::: If someone writes code, they use a computer.",
            "Programmer(bob) ::: Bob is a programmer.",
            "WritesDocumentation(bob) ::: Bob writes documentation.",
            "HasInternet(bob) ::: Bob has internet access."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "WritesCode(x) ::: x writes code",
            "ReadsBooks(x) ::: x reads books",
            "Learns(x) ::: x learns",
            "UnderstandsLogic(x) ::: x understands logic",
            "UsesComputer(x) ::: x uses a computer",
            "HasInternet(x) ::: x has internet access",
            "WritesDocumentation(x) ::: x writes documentation",
            "Expert(x) ::: x is an expert"
        ]
    },
    {
        "premises-NL": [
            "All students attend lectures.",
            "Sarah is a student.",
            "All those who attend lectures must study.",
            "Anyone who studies will pass.",
            "Anyone who passes the course gets a certificate.",
            "John is a professor.",
            "John teaches logic.",
            "Logic is a course.",
            "All who take a course study it.",
            "Students are either in the course or not.",
            "Sarah attends the lecture",
            "Anyone who studies will be intelligent."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendLecture(x)) ::: All students attend lectures.",
            "Student(Sarah) ::: Sarah is a student.",
            "∀x (AttendLecture(x) → MustStudy(x)) ::: All those who attend lectures must study.",
            "∀x (MustStudy(x) → Pass(x)) ::: Anyone who studies will pass.",
            "∀x (Pass(x) → GetCertificate(x)) ::: Anyone who passes the course gets a certificate.",
            "Professor(John) ::: John is a professor.",
            "Teaches(John, Logic) ::: John teaches logic.",
            "Course(Logic) ::: Logic is a course.",
            "∀x (Course(y) ∧ Takes(x, y) → MustStudy(x)) ::: All who take a course study it.",
            "∀x (Student(x) → Takes(x, Logic) ∨ ¬ Takes(x, Logic)) ::: Students are either in the course or not.",
            "AttendLecture(Sarah) ::: Sarah attends the lecture",
            "∀x (MustStudy(x) → Intelligent(x)) ::: Anyone who studies will be intelligent."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Intelligent(x) ::: x is intelligent",
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches y",
            "Course(x) ::: x is a course"
        ]
    },
    {
        "premises-NL": [
            "All doctors are knowledgeable.",
            "Alex is a doctor.",
            "All knowledgeable people are helpful.",
            "Helpful people are good.",
            "All doctors treat patients.",
            "Every patient is sick.",
            "Some patients have the flu.",
            "If someone treats a patient, they are a doctor.",
            "Alex treats patients",
            "All good people are helpful",
            "All those who are helpful are knowledgeable.",
            "All doctors are good persons",
            "If someone has the flu, they are sick."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Knowledgeable(x)) ::: All doctors are knowledgeable.",
            "Doctor(Alex) ::: Alex is a doctor.",
            "∀x (Knowledgeable(x) → Helpful(x)) ::: All knowledgeable people are helpful.",
            "∀x (Helpful(x) → GoodPerson(x)) ::: Helpful people are good.",
            "∀x (Doctor(x) → Treats(x, y)) ::: All doctors treat patients.",
            "∀x (Patient(x) → Sick(x)) ::: Every patient is sick.",
            "∃x (Patient(x) ∧ HasDisease(x, Flu)) ::: Some patients have the flu.",
            "∀x ∀y (Treats(x, y) → Doctor(x)) ::: If someone treats a patient, they are a doctor.",
            "Treats(Alex, y) ::: Alex treats patients",
            "∀x (GoodPerson(x) → Helpful(x)) ::: All good people are helpful",
            "∀x (Helpful(x) → Knowledgeable(x)) ::: All those who are helpful are knowledgeable.",
            "∀x (Doctor(x) → GoodPerson(x)) ::: All doctors are good persons",
            "∀x (HasDisease(x, Flu) → Sick(x)) ::: If someone has the flu, they are sick."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "GoodPerson(x) ::: x is a good person",
            "Patient(x) ::: x is a patient",
            "Treats(x, y) ::: x treats y",
            "Sick(x) ::: x is sick",
            "HasDisease(x, y) ::: x has disease y"
        ]
    },
    {
        "premises-NL": [
            "Every student is motivated.",
            "Alice is a student.",
            "Alice is enrolled in the Data Science course.",
            "Every student enrolled in Data Science will take exams.",
            "Anyone taking an exam will pass it.",
            "If someone passes all exams, they graduate.",
            "Data Science is a course.",
            "All motivated students study.",
            "Those who study pass their exams.",
            "If someone is enrolled in a course, they are a student.",
            "Alice is motivated.",
            "Anyone who passes the exam graduates.",
            "All exams are mandatory.",
            "Students in data science are motivated."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Motivated(x)) ::: Every student is motivated.",
            "Student(Alice) ::: Alice is a student.",
            "Enrolled(Alice, DataScience) ::: Alice is enrolled in the Data Science course.",
            "∀x (Enrolled(x, DataScience) → TakesExam(x)) ::: Every student enrolled in Data Science will take exams.",
            "∀x (TakesExam(x) → PassExam(x)) ::: Anyone taking an exam will pass it.",
            "∀x (PassExam(x) → Graduate(x)) ::: If someone passes all exams, they graduate.",
            "Course(DataScience) ::: Data Science is a course.",
            "∀x (Motivated(x) → Studies(x)) ::: All motivated students study.",
            "∀x (Studies(x) → PassExam(x)) ::: Those who study pass their exams.",
            "∀x ∀y (Enrolled(x, y) → Student(x)) ::: If someone is enrolled in a course, they are a student.",
            "Motivated(Alice) ::: Alice is motivated.",
            "∀x (PassExam(x) → Graduate(x)) ::: Anyone who passes the exam graduates.",
            "∀x (Exam(x) → Mandatory(x)) ::: All exams are mandatory.",
            "∀x (Enrolled(x, DataScience) ∧ Student(x) → Motivated(x)) ::: Students in data science are motivated."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "Graduate(x) ::: x will graduate",
            "TakesExam(x, y) ::: x takes exam y",
            "PassExam(x, y) ::: x passes exam y",
            "Course(x) ::: x is a course"
        ]
    },
    {
        "premises-NL": [
            "All doctors can diagnose illnesses.",
            "Some doctors are specialists.",
            "All specialists have the authority to prescribe medication.",
            "If a person can diagnose an illness, they can recommend treatment.",
            "If a person is a doctor and can recommend treatment, then they can prescribe medicine to their patients.",
            "There is a doctor called Alice.",
            "Alice is a specialist.",
            "Bob is a patient.",
            "Every doctor is a healthcare professional.",
            "Only healthcare professionals can prescribe medicine."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → CanDiagnose(x)) ::: For all x, if x is a doctor, then x can diagnose",
            "∃x (Doctor(x) ∧ Specialist(x)) ::: There exists an x such that x is a doctor and a specialist",
            "∀x (Specialist(x) → AuthorityToPrescribe(x)) ::: For all x, if x is a specialist, then x has authority to prescribe",
            "∀x (CanDiagnose(x) → CanRecommendTreatment(x)) ::: For all x, if x can diagnose, then x can recommend treatment",
            "∀x ∀y (Doctor(x) ∧ CanRecommendTreatment(x) ∧ Patient(y) → CanPrescribe(x, y)) ::: For all x and y, if x is a doctor and x can recommend treatment and y is a patient, then x can prescribe to y",
            "Doctor(alice) ::: Alice is a doctor",
            "Specialist(alice) ::: Alice is a specialist",
            "Patient(bob) ::: Bob is a patient",
            "∀x (Doctor(x) → HealthcareProfessional(x)) ::: For all x, if x is a doctor, then x is a healthcare professional",
            "∀x ∀y (CanPrescribe(x, y) → HealthcareProfessional(x)) ::: For all x and y, if x can prescribe to y, then x is a healthcare professional"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "AuthorityToPrescribe(x) ::: x has the authority to prescribe medication",
            "Patient(y) ::: y is a patient",
            "CanPrescribe(x, y) ::: x can prescribe medicine to y"
        ]
    },
    {
        "premises-NL": [
            "All employees are assigned to a department.",
            "If an employee is assigned to a department, then they work in that department.",
            "Every department either has a budget or does not have a budget.",
            "If a department has a budget, then it can fund projects.",
            "If a project is funded, then it uses resources.",
            "John is an employee.",
            "John is assigned to the IT department.",
            "The IT department has a budget.",
            "John has a project called 'Project Alpha'.",
            "All projects either have resources or don't have resources.",
            "If a project uses resources, then it requires funding."
        ],
        "premises-FOL": [
            "∀x ∃y AssignedTo(x, y) ::: For all x, there exists a y such that x is assigned to y",
            "∀x ∀y (AssignedTo(x, y) → WorksIn(x, y)) ::: For all x and y, if x is assigned to y, then x works in y",
            "∀y (DepartmentHasBudget(y) ∨ ¬DepartmentHasBudget(y)) ::: For all y, department y has a budget or does not have a budget",
            "∀y (DepartmentHasBudget(y) → CanFundProjects(y)) ::: For all y, if y has a budget, then y can fund projects",
            "∀z (Funded(z) → UsesResources(z)) ::: For all z, if z is funded, then z uses resources",
            "Employee(john) ::: John is an employee",
            "AssignedTo(john, it) ::: John is assigned to IT department",
            "DepartmentHasBudget(it) ::: IT department has a budget",
            "HasProject(john, projectAlpha) ::: John has a project called Project Alpha",
            "∀z (UsesResources(z) ∨ ¬UsesResources(z)) ::: For all z, project z uses resources or does not use resources",
            "∀z (UsesResources(z) → RequiresFunding(z)) ::: For all z, if z uses resources, then z requires funding"
        ],
        "predicates": [
            "Employee(x) ::: x is an employee",
            "WorksIn(x, y) ::: x works in department y",
            "DepartmentHasBudget(y) ::: Department y has a budget",
            "HasProject(x, z) ::: x has project z",
            "UsesResources(z) ::: Project z uses resources"
        ]
    },
    {
        "premises-NL": [
            "All endangered species face environmental threats.",
            "If a species faces environmental threats, it can be affected by pollution.",
            "Every species lives in a habitat.",
            "If a pollutant is introduced into a habitat, then the habitat is polluted.",
            "Pollution can negatively affect species that live in the polluted habitat.",
            "The 'Snow Leopard' is an endangered species.",
            "Snow Leopards live in the 'Himalayan Mountains'.",
            "The 'Himalayan Mountains' are a habitat.",
            "A chemical pollutant called 'Xylene' is introduced into the 'Himalayan Mountains'.",
            "If a species is affected by pollution, then its population will decline.",
            "All species are either endangered or not endangered.",
            "If a habitat is polluted, and a species lives in that habitat, the species is affected by pollution."
        ],
        "premises-FOL": [
            "∀s (Endangered(s) → FacesThreats(s)) ::: For all s, if s is endangered, then s faces threats",
            "∀s (FacesThreats(s) → CanBeAffectedByPollution(s)) ::: For all s, if s faces threats, then s can be affected by pollution",
            "∀s ∃h LivesIn(s, h) ::: For all s, there exists an h such that s lives in h",
            "∀h ∀p (IntroducedIn(p, h) → Polluted(h)) ::: For all h and p, if p is introduced in h, then h is polluted",
            "∀s ∀h (LivesIn(s, h) ∧ Polluted(h) → CanBeAffectedByPollution(s)) ::: For all s and h, if s lives in h and h is polluted, then s can be affected by pollution",
            "Endangered(snowLeopard) ::: Snow Leopard is endangered",
            "LivesIn(snowLeopard, himalayanMountains) ::: Snow Leopard lives in Himalayan Mountains",
            "Habitat(himalayanMountains) ::: Himalayan Mountains are a habitat",
            "IntroducedIn(xylene, himalayanMountains) ::: Xylene is introduced in Himalayan Mountains",
            "∀s (CanBeAffectedByPollution(s) → PopulationDecline(s)) ::: For all s, if s can be affected by pollution, then s's population will decline",
            "∀s (Endangered(s) ∨ ¬Endangered(s)) ::: For all s, s is endangered or not endangered",
            "∀s ∀h (LivesIn(s, h) ∧ Polluted(h) → CanBeAffectedByPollution(s)) ::: For all s and h, if s lives in h and h is polluted, then s is affected by pollution."
        ],
        "predicates": [
            "Endangered(s) ::: Species s is endangered",
            "LivesIn(s, h) ::: Species s lives in habitat h",
            "IntroducedIn(p, h) ::: Pollutant p is introduced in habitat h",
            "PopulationDecline(s) ::: Population of species s declines"
        ]
    },
    {
        "premises-NL": [
            "If someone takes medicine, they will recover.",
            "If someone recovers, they are not sick.",
            "Anyone who doesn't have a fever takes medicine or is sick.",
            "John doesn't recover.",
            "If someone does not take medicine, they are sick or have a fever.",
            "If someone has a fever and is not sick, they take medicine."
        ],
        "premises-FOL": [
            "∀x (TakesMedicine(x) → Recovers(x)) ::: For all x, if x takes medicine, then x recovers.",
            "∀x (Recovers(x) → ¬Sick(x)) ::: For all x, if x recovers, then x is not sick.",
            "∀x (¬HasFever(x) → (TakesMedicine(x) ∨ Sick(x))) ::: For all x, if x does not have a fever, then x takes medicine or is sick.",
            "¬Recovers(John) ::: John doesn't recover.",
            "∀x (¬TakesMedicine(x) → (Sick(x) ∨ HasFever(x))) ::: For all x, if x does not take medicine, then x is sick or has a fever.",
            "∀x ((HasFever(x) ∧ ¬Sick(x)) → TakesMedicine(x)) ::: For all x, if x has a fever and is not sick, then x takes medicine."
        ],
        "predicates": [
            "TakesMedicine(x) ::: x takes medicine",
            "Sick(x) ::: x is sick",
            "HasFever(x) ::: x has a fever",
            "Recovers(x) ::: x recovers"
        ]
    },
    {
        "premises-NL": [
            "All doctors study medicine.",
            "If someone studies medicine, they are not a lawyer.",
            "John is a doctor.",
            "If someone is a doctor, they studies medicine.",
            "No one studies both law and medicine."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → StudiesMedicine(x)) ::: For all x, if x is a doctor, then x studies medicine.",
            "∀x (StudiesMedicine(x) → ¬Lawyer(x)) ::: For all x, if x studies medicine, then x is not a lawyer.",
            "Doctor(john) ::: John is a doctor.",
            "∀x (Doctor(x) → StudiesMedicine(x)) ::: For all x, if x is a doctor, then x studies medicine.",
            "∀x ¬(StudiesLaw(x) ∧ StudiesMedicine(x)) ::: For all x, it is not the case that x studies law and medicine."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Lawyer(x) ::: x is a lawyer",
            "StudiesLaw(x) ::: x studies law",
            "StudiesMedicine(x) ::: x studies medicine"
        ]
    },
    {
        "premises-NL": [
            "All registered users have a password.",
            "If someone is registered and active, they can access the system.",
            "If someone has a password, they are registered.",
            "Every active user has logged in.",
            "If someone has logged in and is verified, they are active.",
            "Every registered user is verified.",
            "If someone is registered, they are active.",
            "If someone is active, then they can log in.",
            "Anyone who can log in can access the system.",
            "If someone is verified, they have a password.",
            "Every user is registered if they have a password.",
            "If someone is verified, then they can access the system.",
            "If someone is a registered user and has logged in, then they are active.",
            "If someone is registered and verified, they can log in.",
            "If a user has a password, they can log in.",
            "A user with an active account can log in.",
            "If a user has a password and is verified, they can log in.",
            "If someone logs in they have a password."
        ],
        "premises-FOL": [
            "∀x (RegisteredUser(x) → HasPassword(x)) ::: All registered users have a password.",
            "∀x (RegisteredUser(x) ∧ IsActive(x) → CanAccess(x)) ::: If someone is registered and active, they can access the system.",
            "∀x (HasPassword(x) → RegisteredUser(x)) ::: If someone has a password, they are registered.",
            "∀x (IsActive(x) → LogsIn(x)) ::: Every active user has logged in.",
            "∀x (LogsIn(x) ∧ Verified(x) → IsActive(x)) ::: If someone has logged in and is verified, they are active.",
            "∀x (RegisteredUser(x) → Verified(x)) ::: Every registered user is verified.",
            "∀x (RegisteredUser(x) → IsActive(x)) ::: If someone is registered, they are active.",
            "∀x (IsActive(x) → LogsIn(x)) ::: If someone is active, then they can log in.",
            "∀x (LogsIn(x) → CanAccess(x)) ::: Anyone who can log in can access the system.",
            "∀x (Verified(x) → HasPassword(x)) ::: If someone is verified, they have a password.",
            "∀x (HasPassword(x) → RegisteredUser(x)) ::: Every user is registered if they have a password.",
            "∀x (Verified(x) → CanAccess(x)) ::: If someone is verified, then they can access the system.",
            "∀x (RegisteredUser(x) ∧ LogsIn(x) → IsActive(x)) ::: If someone is a registered user and has logged in, then they are active.",
            "∀x (RegisteredUser(x) ∧ Verified(x) → LogsIn(x)) ::: If someone is registered and verified, they can log in.",
            "∀x (HasPassword(x) → LogsIn(x)) ::: If a user has a password, they can log in.",
            "∀x (IsActive(x) → LogsIn(x)) ::: A user with an active account can log in.",
            "∀x (HasPassword(x) ∧ Verified(x) → LogsIn(x)) ::: If a user has a password and is verified, they can log in.",
            "∀x (LogsIn(x) → HasPassword(x)) ::: If someone logs in they have a password."
        ],
        "predicates": [
            "RegisteredUser(x) ::: x is a registered user",
            "CanAccess(x) ::: x can access the system",
            "HasPassword(x) ::: x has a password",
            "IsActive(x) ::: x is active",
            "Verified(x) ::: x is verified",
            "LogsIn(x) ::: x logs in"
        ]
    },
    {
        "premises-NL": [
            "All patients need medicine.",
            "If a patient has a prescription and is insured, they get medicine.",
            "If a patient gets medicine, they have a prescription.",
            "If a medicine is available and someone needs it, then they get it.",
            "Every patient has a prescription.",
            "If a medicine is available, then someone approves it.",
            "If a patient is insured, then they are approved.",
            "If someone is insured and a patient, then they need the medicine.",
            "If someone needs medicine and gets a prescription, then they get the medicine.",
            "Not every medicine is available.",
            "If a patient is not insured, then they do not get the medicine.",
            "Not all patients get medicine.",
            "Some medicines are not available.",
            "If a patient is approved and needs medicine, then they get it.",
            "If a patient needs medicine and is not insured, then they do not get the medicine.",
            "If a patient has a prescription and is not insured, then they do not get the medicine.",
            "If someone approves the medicine, then it is available.",
            "If a patient is not approved, then they do not get the medicine.",
            "Every patient needs medicine."
        ],
        "premises-FOL": [
            "∀x (Patient(x) → NeedsMedicine(x)) ::: All patients need medicine.",
            "∀x (Patient(x) ∧ HasPrescription(x) ∧ IsInsured(x) → GetsMedicine(x)) ::: If a patient has a prescription and is insured, they get medicine.",
            "∀x (GetsMedicine(x) → HasPrescription(x)) ::: If a patient gets medicine, they have a prescription.",
            "∀x ∀y (Available(y, x) ∧ NeedsMedicine(x) → GetsMedicine(x)) ::: If a medicine is available and someone needs it, then they get it.",
            "∀x (Patient(x) → HasPrescription(x)) ::: Every patient has a prescription.",
            "∀x (Available(x, y) → Approved(y, x)) ::: If a medicine is available, then someone approves it.",
            "∀x (IsInsured(x) → Approved(x, y)) ::: If a patient is insured, then they are approved.",
            "∀x (IsInsured(x) ∧ Patient(x) → NeedsMedicine(x)) ::: If someone is insured and a patient, then they need the medicine.",
            "∀x (NeedsMedicine(x) ∧ HasPrescription(x) → GetsMedicine(x)) ::: If someone needs medicine and gets a prescription, then they get the medicine.",
            "¬∀x Available(x, y) ::: Not every medicine is available.",
            "∀x (Patient(x) ∧ ¬IsInsured(x) → ¬GetsMedicine(x)) ::: If a patient is not insured, then they do not get the medicine.",
            "¬∀x (Patient(x) → GetsMedicine(x)) ::: Not all patients get medicine.",
            "∃x ¬Available(x, y) ::: Some medicines are not available.",
            "∀x (Patient(x) ∧ Approved(x, y) ∧ NeedsMedicine(x) → GetsMedicine(x)) ::: If a patient is approved and needs medicine, then they get it.",
            "∀x (Patient(x) ∧ NeedsMedicine(x) ∧ ¬IsInsured(x) → ¬GetsMedicine(x)) ::: If a patient needs medicine and is not insured, then they do not get the medicine.",
            "∀x (Patient(x) ∧ HasPrescription(x) ∧ ¬IsInsured(x) → ¬GetsMedicine(x)) ::: If a patient has a prescription and is not insured, then they do not get the medicine.",
            "∀x (Approved(y, x) → Available(x, y)) ::: If someone approves the medicine, then it is available.",
            "∀x (Patient(x) ∧ ¬Approved(x, y) → ¬GetsMedicine(x)) ::: If a patient is not approved, then they do not get the medicine.",
            "∀x (Patient(x) → NeedsMedicine(x)) ::: Every patient needs medicine."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient",
            "NeedsMedicine(x) ::: x needs medicine",
            "GetsMedicine(x) ::: x gets medicine",
            "HasPrescription(x) ::: x has a prescription",
            "IsInsured(x) ::: x is insured",
            "Approved(x, y) ::: x approves y",
            "Available(x, y) ::: x is available for y"
        ]
    },
    {
        "premises-NL": [
            "All professors teach at least one course.",
            "Alex teaches Logic.",
            "Logic is a course.",
            "If someone teaches a course, they are a professor.",
            "No student teaches any course.",
            "If someone is a student, they don't teach any course.",
            "Alex is not a student.",
            "If Alex is a professor then Alex is not a student.",
            "Some courses are taught by Alex.",
            "Alex teaches some courses.",
            "Alex is a teacher or is a student.",
            "Alex is a student or a professor."
        ],
        "premises-FOL": [
            "∀x ∃y (Professor(x) → Teaches(x, y)) ::: All professors teach at least one course.",
            "Teaches(alex, logic) ::: Alex teaches Logic.",
            "Course(logic) ::: Logic is a course.",
            "∀x ∃y (Teaches(x, y) → Professor(x)) ::: If someone teaches a course, they are a professor.",
            "¬∃x ∃y (Student(x) ∧ Teaches(x, y)) ::: No student teaches any course.",
            "∀x ∃y (Student(x) → ¬Teaches(x, y)) ::: If someone is a student, they don't teach any course.",
            "¬Student(alex) ::: Alex is not a student.",
            "Professor(alex) → ¬Student(alex) ::: If Alex is a professor then Alex is not a student.",
            "∃y Teaches(alex, y) ::: Some courses are taught by Alex.",
            "∃y Teaches(alex, y) ::: Alex teaches some courses.",
            "Professor(alex) ∨ Student(alex) ::: Alex is a teacher or is a student.",
            "Student(alex) ∨ Professor(alex) ::: Alex is a student or a professor."
        ],
        "predicates": [
            "Teaches(x, y) ::: x teaches course y",
            "Course(x) ::: x is a course",
            "Professor(x) ::: x is a professor",
            "Student(x) ::: x is a student"
        ]
    },
    {
        "premises-NL": [
            "All managers are employed.",
            "Some managers have a high income.",
            "If someone is employed and has a high income, then they are successful.",
            "All those who are employed and have a high income are successful.",
            "If a person is a manager, they are employed.",
            "Every manager is employed.",
            "A manager is employed.",
            "Some people are managers.",
            "If a person is a manager, they must have a high income.",
            "Some managers report to someone.",
            "If a person is a manager, they are successful or unsuccessful.",
            "Some people are successful.",
            "If a person is a manager, then they have a high income or they are not successful.",
            "If someone has a high income, then they are a manager."
        ],
        "premises-FOL": [
            "∀x (Manager(x) → Employed(x)) ::: All managers are employed.",
            "∃x (Manager(x) ∧ HighIncome(x)) ::: Some managers have a high income.",
            "∀x (Employed(x) ∧ HighIncome(x) → Successful(x)) ::: If someone is employed and has a high income, then they are successful.",
            "∀x ((Employed(x) ∧ HighIncome(x)) → Successful(x)) ::: All those who are employed and have a high income are successful.",
            "∀x (Manager(x) → Employed(x)) ::: If a person is a manager, they are employed.",
            "∀x (Manager(x) → Employed(x)) ::: Every manager is employed.",
            "∃x Manager(x) ::: A manager is employed.",
            "∃x Manager(x) ::: Some people are managers.",
            "∀x (Manager(x) → HighIncome(x)) ::: If a person is a manager, they must have a high income.",
            "∃x ∃y ReportsTo(x, y) ::: Some managers report to someone.",
            "∀x (Manager(x) → (Successful(x) ∨ ¬Successful(x))) ::: If a person is a manager, they are successful or unsuccessful.",
            "∃x Successful(x) ::: Some people are successful.",
            "∀x (Manager(x) → (HighIncome(x) ∨ ¬Successful(x))) ::: If a person is a manager, then they have a high income or they are not successful.",
            "∀x (HighIncome(x) → Manager(x)) ::: If someone has a high income, then they are a manager."
        ],
        "predicates": [
            "Manager(x) ::: x is a manager",
            "HighIncome(x) ::: x has a high income",
            "Successful(x) ::: x is successful",
            "Employed(x) ::: x is employed",
            "ReportsTo(x, y) ::: x reports to y"
        ]
    },
    {
        "premises-NL": [
            "All doctors should care for patients.",
            "If someone cares for patients, they are a doctor.",
            "Not all doctors are friendly.",
            "Someone is a doctor and is not friendly.",
            "If a doctor cares for patients, they should be a doctor.",
            "It is not the case that all doctors are friendly.",
            "Some doctors are not friendly.",
            "If someone is a doctor and is not friendly, then they do not care for patients.",
            "Every doctor should care for patients.",
            "If a person is a doctor, they are friendly or not friendly.",
            "If a person is smart and friendly, they are a doctor.",
            "If someone is a doctor, they should be a doctor.",
            "Not all doctors are smart.",
            "If someone is a doctor and is not friendly, they should not be a doctor.",
            "If a doctor is not friendly, they should not be a doctor."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → CaresForPatients(x)) ::: All doctors should care for patients.",
            "∀x (CaresForPatients(x) → Doctor(x)) ::: If someone cares for patients, they are a doctor.",
            "¬∀x (Doctor(x) → Friendly(x)) ::: Not all doctors are friendly.",
            "∃x (Doctor(x) ∧ ¬Friendly(x)) ::: Someone is a doctor and is not friendly.",
            "∀x (Doctor(x) ∧ CaresForPatients(x) → ShouldBeDoctor(x)) ::: If a doctor cares for patients, they should be a doctor.",
            "¬∀x (Doctor(x) → Friendly(x)) ::: It is not the case that all doctors are friendly.",
            "∃x (Doctor(x) ∧ ¬Friendly(x)) ::: Some doctors are not friendly.",
            "∀x (Doctor(x) ∧ ¬Friendly(x) → ¬CaresForPatients(x)) ::: If someone is a doctor and is not friendly, then they do not care for patients.",
            "∀x (Doctor(x) → CaresForPatients(x)) ::: Every doctor should care for patients.",
            "∀x (Doctor(x) → (Friendly(x) ∨ ¬Friendly(x))) ::: If a person is a doctor, they are friendly or not friendly.",
            "∀x (Smart(x) ∧ Friendly(x) → Doctor(x)) ::: If a person is smart and friendly, they are a doctor.",
            "∀x (Doctor(x) → ShouldBeDoctor(x)) ::: If someone is a doctor, they should be a doctor.",
            "¬∀x (Doctor(x) → Smart(x)) ::: Not all doctors are smart.",
            "∀x (Doctor(x) ∧ ¬Friendly(x) → ¬ShouldBeDoctor(x)) ::: If someone is a doctor and is not friendly, they should not be a doctor.",
            "∀x (Doctor(x) ∧ ¬Friendly(x) → ¬ShouldBeDoctor(x)) ::: If a doctor is not friendly, they should not be a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Friendly(x) ::: x is friendly",
            "ShouldBeDoctor(x) ::: x should be a doctor",
            "CaresForPatients(x) ::: x cares for patients",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard pass the exam.",
            "If a student likes to study, they study hard.",
            "If a student fails the exam, they did not study hard.",
            "If a student attends all classes, they study hard.",
            "Some students study hard and attend classes.",
            "If a student is a student, they are happy or unhappy.",
            "A student passes the exam if they study hard and attend classes.",
            "If someone fails the exam, they are not a student.",
            "If a student likes to study, they attend classes or fail the exam.",
            "If a student attends classes and does not study hard, they fail the exam.",
            "If someone is a student and studies hard, they will pass the exam.",
            "If a student likes to study, they study hard and attend classes.",
            "A student passes the exam or fails the exam.",
            "If a student does not attend classes, they do not study hard.",
            "If a student attends all classes, then they study hard or they fail the exam.",
            "If a student studies hard and attends all classes, then they will pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: All students who study hard pass the exam.",
            "∀x (Student(x) ∧ LikesStudy(x) → StudiesHard(x)) ::: If a student likes to study, they study hard.",
            "∀x (Student(x) ∧ FailsExam(x) → ¬StudiesHard(x)) ::: If a student fails the exam, they did not study hard.",
            "∀x (Student(x) ∧ AttendsClasses(x) → StudiesHard(x)) ::: If a student attends all classes, they study hard.",
            "∃x (Student(x) ∧ StudiesHard(x) ∧ AttendsClasses(x)) ::: Some students study hard and attend classes.",
            "∀x (Student(x) → (Happy(x) ∨ ¬Happy(x))) ::: If a student is a student, they are happy or unhappy.",
            "∀x (Student(x) ∧ StudiesHard(x) ∧ AttendsClasses(x) → PassExam(x)) ::: A student passes the exam if they study hard and attend classes.",
            "∀x (FailsExam(x) → ¬Student(x)) ::: If someone fails the exam, they are not a student.",
            "∀x (Student(x) ∧ LikesStudy(x) → (AttendsClasses(x) ∨ FailsExam(x))) ::: If a student likes to study, they attend classes or fail the exam.",
            "∀x (Student(x) ∧ AttendsClasses(x) ∧ ¬StudiesHard(x) → FailsExam(x)) ::: If a student attends classes and does not study hard, they fail the exam.",
            "∀x (Student(x) ∧ StudiesHard(x) → PassExam(x)) ::: If someone is a student and studies hard, they will pass the exam.",
            "∀x (Student(x) ∧ LikesStudy(x) → (StudiesHard(x) ∧ AttendsClasses(x))) ::: If a student likes to study, they study hard and attend classes.",
            "∀x (Student(x) → (PassExam(x) ∨ FailsExam(x))) ::: A student passes the exam or fails the exam.",
            "∀x (Student(x) ∧ ¬AttendsClasses(x) → ¬StudiesHard(x)) ::: If a student does not attend classes, they do not study hard.",
            "∀x (Student(x) ∧ AttendsClasses(x) → (StudiesHard(x) ∨ FailsExam(x))) ::: If a student attends all classes, then they study hard or they fail the exam.",
            "∀x (Student(x) ∧ StudiesHard(x) ∧ AttendsClasses(x) → PassExam(x)) ::: If a student studies hard and attends all classes, then they will pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "AttendsClasses(x) ::: x attends classes",
            "PassExam(x) ::: x passes the exam",
            "FailsExam(x) ::: x fails the exam",
            "LikesStudy(x) ::: x likes to study"
        ]
    },
    {
        "premises-NL": [
            "All students who attend class, study hard.",
            "Some students are smart.",
            "All smart students get good grades.",
            "Some students attend class.",
            "All students who get good grades succeed.",
            "Some students like learning.",
            "Everyone who likes learning studies hard.",
            "All who participate in class attend class.",
            "Some students ask questions.",
            "Everyone who asks questions participates in class.",
            "Every student is enrolled in some course.",
            "Every student takes an exam.",
            "If a student takes an exam and passes it, they get good grades.",
            "Some students have homework."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ AttendsClass(x) → StudiesHard(x)) ::: All students who attend class study hard.",
            "∃x (Student(x) ∧ Smart(x)) ::: Some students are smart.",
            "∀x (Smart(x) → GetsGoodGrades(x)) ::: All smart students get good grades.",
            "∃x (Student(x) ∧ AttendsClass(x)) ::: Some students attend class.",
            "∀x (Student(x) ∧ GetsGoodGrades(x) → Succeeds(x)) ::: All students who get good grades succeed.",
            "∃x (Student(x) ∧ LikesLearning(x)) ::: Some students like learning.",
            "∀x (LikesLearning(x) → StudiesHard(x)) ::: Everyone who likes learning studies hard.",
            "∀x (ParticipatesInClass(x) → AttendsClass(x)) ::: All who participate in class attend class.",
            "∃x (Student(x) ∧ AsksQuestions(x)) ::: Some students ask questions.",
            "∀x (AsksQuestions(x) → ParticipatesInClass(x)) ::: Everyone who asks questions participates in class.",
            "∀x ∃y EnrolledInCourse(x, y) ::: Every student is enrolled in some course.",
            "∀x ∃y TakesExam(x, y) ::: Every student takes an exam.",
            "∀x ∀y (TakesExam(x, y) ∧ PassesExam(x, y) → GetsGoodGrades(x)) ::: If a student takes an exam and passes it, they get good grades.",
            "∃x (Student(x) ∧ HasHomework(x)) ::: Some students have homework."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "Succeeds(x) ::: x succeeds",
            "AttendsClass(x) ::: x attends class",
            "Smart(x) ::: x is smart",
            "GetsGoodGrades(x) ::: x gets good grades",
            "EnrolledInCourse(x, y) ::: x is enrolled in course y",
            "PassesExam(x, y) ::: x passes exam y",
            "TakesExam(x, y) ::: x takes exam y",
            "HasHomework(x) ::: x has homework",
            "CompletesHomework(x) ::: x completes homework",
            "LikesLearning(x) ::: x likes learning",
            "ParticipatesInClass(x) ::: x participates in class",
            "AsksQuestions(x) ::: x asks questions"
        ]
    },
    {
        "premises-NL": [
            "Every city is either polluted or not polluted.",
            "All cities with traffic are polluted.",
            "All cities with industry have traffic.",
            "Some cities are near the coast.",
            "All cities located in a country develop that country.",
            "All capitals are cities.",
            "Every city either has a high population or has low resources.",
            "All cities with industry produce pollution.",
            "Every city that is near the coast is a coastal city.",
            "Some cities have high population.",
            "Some cities are overcrowded.",
            "All cities with traffic are overcrowded.",
            "Some cities export goods.",
            "All cities that produce pollution are polluted.",
            "Some cities are capitals.",
            "Every coastal city is a city."
        ],
        "premises-FOL": [
            "∀x (City(x) → (Polluted(x) ∨ ¬Polluted(x))) ::: Every city is either polluted or not polluted.",
            "∀x (City(x) ∧ HasTraffic(x) → Polluted(x)) ::: All cities with traffic are polluted.",
            "∀x (City(x) ∧ HasIndustry(x) → HasTraffic(x)) ::: All cities with industry have traffic.",
            "∃x ∃y (City(x) ∧ IsNear(x, y)) ::: Some cities are near the coast.",
            "∀x ∀y (City(x) ∧ LocatedIn(x, y) → Develops(x, y)) ::: All cities located in a country develop that country.",
            "∀x (IsCapital(x) → City(x)) ::: All capitals are cities.",
            "∀x (City(x) → (HasHighPopulation(x) ∨ HasLowResources(x))) ::: Every city either has a high population or has low resources.",
            "∀x (City(x) ∧ HasIndustry(x) → ProducesPollution(x)) ::: All cities with industry produce pollution.",
            "∀x (City(x) ∧ IsNear(x, coast) → IsCoastal(x)) ::: Every city that is near the coast is a coastal city.",
            "∃x (City(x) ∧ HasHighPopulation(x)) ::: Some cities have high population.",
            "∃x (City(x) ∧ Overcrowded(x)) ::: Some cities are overcrowded.",
            "∀x (City(x) ∧ HasTraffic(x) → Overcrowded(x)) ::: All cities with traffic are overcrowded.",
            "∃x ∃y Exports(x, y) ::: Some cities export goods.",
            "∀x (City(x) ∧ ProducesPollution(x) → Polluted(x)) ::: All cities that produce pollution are polluted.",
            "∃x IsCapital(x) ::: Some cities are capitals.",
            "∀x IsCoastal(x) → City(x) ::: Every coastal city is a city."
        ],
        "predicates": [
            "City(x) ::: x is a city",
            "Polluted(x) ::: x is polluted",
            "Overcrowded(x) ::: x is overcrowded",
            "HasTraffic(x) ::: x has traffic",
            "HasIndustry(x) ::: x has industry",
            "LocatedIn(x, y) ::: x is located in y",
            "IsCapital(x) ::: x is a capital",
            "Country(x) ::: x is a country",
            "Develops(x, y) ::: x develops y",
            "Exports(x, y) ::: x exports y",
            "IsNear(x, y) ::: x is near y",
            "IsCoastal(x) ::: x is coastal",
            "Imports(x, y) ::: x imports y",
            "HasHighPopulation(x) ::: x has a high population",
            "HasLowResources(x) ::: x has low resources",
            "ProducesPollution(x) ::: x produces pollution"
        ]
    },
    {
        "premises-NL": [
            "Anyone who is sick takes medicine or has a fever.",
            "If someone takes medicine, they either get better or remain sick.",
            "If someone has a fever and doesn't get better, then they remain sick.",
            "John is sick.",
            "John doesn't get better.",
            "If someone is sick and doesn't get better, they take medicine."
        ],
        "premises-FOL": [
            "∀x (Sick(x) → TakesMedicine(x) ∨ Fever(x)) ::: Anyone who is sick takes medicine or has a fever.",
            "∀x (TakesMedicine(x) → GetsBetter(x) ∨ Sick(x)) ::: If someone takes medicine, they either get better or remain sick.",
            "∀x ((Fever(x) ∧ ¬GetsBetter(x)) → Sick(x)) ::: If someone has a fever and doesn't get better, then they remain sick.",
            "Sick(john) ::: John is sick.",
            "¬GetsBetter(john) ::: John doesn't get better.",
            "∀x ((Sick(x) ∧ ¬GetsBetter(x)) → TakesMedicine(x)) ::: If someone is sick and doesn't get better, they take medicine."
        ],
        "predicates": [
            "TakesMedicine(x) ::: x takes medicine.",
            "Fever(x) ::: x has a fever.",
            "GetsBetter(x) ::: x gets better.",
            "Sick(x) ::: x is sick."
        ]
    },
    {
        "premises-NL": [
            "All employees undergo a security check.",
            "If someone has a valid ID, they are authorized.",
            "Anyone authorized is not denied access.",
            "If someone undergoes a security check and does not have a valid ID, they are not authorized.",
            "John is an employee.",
            "If someone is authorized, then they are not denied access.",
            "John does not have a valid ID."
        ],
        "premises-FOL": [
            "∀x (Employee(x) → SecurityCheck(x)) ::: All employees undergo a security check.",
            "∀x (HasValidID(x) → Authorized(x)) ::: If someone has a valid ID, they are authorized.",
            "∀x (Authorized(x) → ¬DeniedAccess(x)) ::: Anyone authorized is not denied access.",
            "∀x (SecurityCheck(x) ∧ ¬HasValidID(x) → ¬Authorized(x)) ::: If someone undergoes a security check and does not have a valid ID, they are not authorized.",
            "Employee(john) ::: John is an employee.",
            "∀x (Authorized(x) → ¬DeniedAccess(x)) ::: If someone is authorized, then they are not denied access.",
            "¬HasValidID(john) ::: John does not have a valid ID."
        ],
        "predicates": [
            "Employee(x) ::: x is an employee.",
            "HasValidID(x) ::: x has a valid ID.",
            "DeniedAccess(x) ::: x is denied access.",
            "SecurityCheck(x) ::: x undergoes a security check.",
            "Authorized(x) ::: x is authorized."
        ]
    },
    {
        "premises-NL": [
            "All plants are living things.",
            "All living things need sunlight or water.",
            "If something is a plant, then it needs sunlight.",
            "If something is a plant, then it needs water.",
            "If something is a plant and it has sunlight and water, then it photosynthesizes.",
            "If something photosynthesizes, then it grows.",
            "This is a plant.",
            "This plant is exposed to sunlight."
        ],
        "premises-FOL": [
            "∀x (Plant(x) → LivingThing(x)) ::: All plants are living things.",
            "∀x (LivingThing(x) → NeedsSunlight(x) ∨ NeedsWater(x)) ::: All living things need sunlight or water.",
            "∀x (Plant(x) → NeedsSunlight(x)) ::: If something is a plant, then it needs sunlight.",
            "∀x (Plant(x) → NeedsWater(x)) ::: If something is a plant, then it needs water.",
            "∀x (Plant(x) ∧ ExposedToSunlight(x) ∧ HasWater(x) → Photosynthesizes(x)) ::: If something is a plant and it has sunlight and water, then it photosynthesizes.",
            "∀x (Photosynthesizes(x) → Grows(x)) ::: If something photosynthesizes, then it grows.",
            "Plant(this) ::: This is a plant.",
            "ExposedToSunlight(this) ::: This plant is exposed to sunlight."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant.",
            "ExposedToSunlight(x) ::: x is exposed to sunlight.",
            "HasWater(x) ::: x has water.",
            "Grows(x) ::: x grows.",
            "LivingThing(x) ::: x is a living thing.",
            "NeedsSunlight(x) ::: x needs sunlight.",
            "NeedsWater(x) ::: x needs water.",
            "Photosynthesizes(x) ::: x photosynthesizes."
        ]
    },
    {
        "premises-NL": [
            "All engineers are employees.",
            "All managers are employees.",
            "All employees work hard or are lazy.",
            "If someone is an engineer, then they are smart.",
            "If someone works hard, then they are not lazy.",
            "Some engineers are managers.",
            "Bob is an engineer.",
            "Bob is smart.",
            "If someone is a manager, then they work hard.",
            "All smart people work hard.",
            "Bob is an employee."
        ],
        "premises-FOL": [
            "∀x (Engineer(x) → Employee(x)) ::: All engineers are employees.",
            "∀x (Manager(x) → Employee(x)) ::: All managers are employees.",
            "∀x (Employee(x) → (WorksHard(x) ∨ Lazy(x))) ::: All employees work hard or are lazy.",
            "∀x (Engineer(x) → Smart(x)) ::: If someone is an engineer, then they are smart.",
            "∀x (WorksHard(x) → ¬Lazy(x)) ::: If someone works hard, then they are not lazy.",
            "∃x (Engineer(x) ∧ Manager(x)) ::: Some engineers are managers.",
            "Engineer(bob) ::: Bob is an engineer.",
            "Smart(bob) ::: Bob is smart.",
            "∀x (Manager(x) → WorksHard(x)) ::: If someone is a manager, then they work hard.",
            "∀x (Smart(x) → WorksHard(x)) ::: All smart people work hard.",
            "Employee(bob) ::: Bob is an employee."
        ],
        "predicates": [
            "Engineer(x) ::: x is an engineer",
            "Lazy(x) ::: x is lazy",
            "WorksHard(x) ::: x works hard",
            "Smart(x) ::: x is smart",
            "Employee(x) ::: x is an employee",
            "Manager(x) ::: x is a manager"
        ]
    },
    {
        "premises-NL": [
            "If someone has a car and a driver's license, they can drive.",
            "Bob has a car.",
            "If someone drives a car, they can travel.",
            "If someone is a driver, they can operate a car.",
            "If someone has a driver's license, they are a driver.",
            "If someone can operate a car, they can travel.",
            "Bob has a driver's license.",
            "If someone has a car, they drive the car.",
            "Bob drives a car.",
            "If someone drives a car, they can operate the car.",
            "If someone can drive, they can operate the car.",
            "If someone can drive, they can travel.",
            "If someone can travel, they are able to travel.",
            "If someone drives a car, they are able to travel."
        ],
        "premises-FOL": [
            "∀x (HasCar(x) ∧ HasLicense(x) → Drives(x, y)) ::: If someone has a car and a driver's license, they can drive.",
            "HasCar(Bob) ::: Bob has a car.",
            "∀x (Drives(x, y) → AbleToTravel(x)) ::: If someone drives a car, they can travel.",
            "∀x (IsDriver(x) → CanOperate(x, y)) ::: If someone is a driver, they can operate a car.",
            "∀x (HasLicense(x) → IsDriver(x)) ::: If someone has a driver's license, they are a driver.",
            "∀x (CanOperate(x, y) → AbleToTravel(x)) ::: If someone can operate a car, they can travel.",
            "HasLicense(Bob) ::: Bob has a driver's license.",
            "∀x (HasCar(x) → Drives(x, y)) ::: If someone has a car, they drive the car.",
            "Drives(Bob, y) ::: Bob drives a car.",
            "∀x (Drives(x, y) → CanOperate(x, y)) ::: If someone drives a car, they can operate the car.",
            "∀x (Drives(x, y) → CanOperate(x, y)) ::: If someone can drive, they can operate the car.",
            "∀x (IsDriver(x) → AbleToTravel(x)) ::: If someone can drive, they can travel.",
            "∀x (AbleToTravel(x) → AbleToTravel(x)) ::: If someone can travel, they are able to travel.",
            "∀x (Drives(x, y) → AbleToTravel(x)) ::: If someone drives a car, they are able to travel."
        ],
        "predicates": [
            "HasCar(x) ::: x has a car.",
            "AbleToTravel(x) ::: x is able to travel.",
            "HasLicense(x) ::: x has a driver's license.",
            "Drives(x, y) ::: x drives y.",
            "IsDriver(x) ::: x is a driver.",
            "CanOperate(x, y) ::: x can operate y."
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "David is a student.",
            "If someone is a student and studies, then they pass the exam.",
            "If someone is smart, they study.",
            "David is smart."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "Student(david) ::: David is a student.",
            "∀x (Student(x) ∧ Studies(x) → PassesExam(x)) ::: If someone is a student and studies, then they pass the exam.",
            "∀x (Smart(x) → Studies(x)) ::: If someone is smart, they study.",
            "Smart(david) ::: David is smart."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "Smart(x) ::: x is smart",
            "PassesExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "If Alex studies hard and attends class, then Alex will succeed.",
            "Alex studies hard.",
            "Alex attends class.",
            "If someone studies hard and attends class, then he/she is smart.",
            "Alex is smart."
        ],
        "premises-FOL": [
            "(StudiesHard(x) ∧ AttendsClass(x)) → Succeeds(x) ::: If x studies hard and attends class, then x will succeed.",
            "StudiesHard(alex) ::: Alex studies hard.",
            "AttendsClass(alex) ::: Alex attends class.",
            "(StudiesHard(x) ∧ AttendsClass(x)) → Smart(x) ::: If x studies hard and attends class, then he/she is smart.",
            "Smart(alex) ::: Alex is smart."
        ],
        "predicates": [
            "StudiesHard(x) ::: x studies hard",
            "AttendsClass(x) ::: x attends class",
            "Succeeds(x) ::: x succeeds",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "If someone is a doctor, then they work at a hospital.",
            "If someone works at a hospital, then they are either a doctor or a scientist.",
            "David is a doctor.",
            "If David is a doctor, then David is a researcher.",
            "If David is a researcher then David is a scientist or David is a doctor.",
            "David is a doctor or a scientist."
        ],
        "premises-FOL": [
            "Doctor(x) → WorksAtHospital(x) ::: If x is a doctor, then x works at a hospital.",
            "WorksAtHospital(x) → (Doctor(x) ∨ Scientist(x)) ::: If x works at a hospital, then they are either a doctor or a scientist.",
            "Doctor(david) ::: David is a doctor.",
            "Doctor(david) → Researcher(david) ::: If David is a doctor, then David is a researcher.",
            "Researcher(david) → (Scientist(david) ∨ Doctor(david)) ::: If David is a researcher then David is a scientist or David is a doctor.",
            "Doctor(david) ∨ Scientist(david) ::: David is a doctor or a scientist."
        ],
        "predicates": [
            "IsDoctor(x) ::: x is a doctor",
            "WorksAtHospital(x) ::: x works at a hospital",
            "IsScientist(x) ::: x is a scientist",
            "Researcher(x) ::: x is a researcher",
            "Doctor(x) ::: x is a doctor",
            "Scientist(x) ::: x is a scientist"
        ]
    },
    {
        "premises-NL": [
            "All artists are eccentric.",
            "Some painters are artists.",
            "Every artist appreciates beauty.",
            "If someone appreciates beauty, they possess a creative mind.",
            "Every painter is an artist or a sculptor.",
            "If someone is an artist and a sculptor, then they are successful.",
            "Someone who is not successful is unhappy.",
            "If someone is unhappy, then they don't create good art.",
            "All painters appreciate beauty or are unhappy.",
            "If someone is a sculptor, they are not an artist.",
            "Every sculptor appreciates beauty or is unsuccessful.",
            "Everyone who is an artist is also beautiful.",
            "If someone is unhappy, they are not an artist."
        ],
        "premises-FOL": [
            "∀x (Artist(x) → Eccentric(x)) ::: All artists are eccentric.",
            "∃x (Painter(x) ∧ Artist(x)) ::: Some painters are artists.",
            "∀x (Artist(x) → AppreciatesBeauty(x)) ::: Every artist appreciates beauty.",
            "∀x (AppreciatesBeauty(x) → CreativeMind(x)) ::: If someone appreciates beauty, they possess a creative mind.",
            "∀x (Painter(x) → (Artist(x) ∨ Sculptor(x))) ::: Every painter is an artist or a sculptor.",
            "∀x ((Artist(x) ∧ Sculptor(x)) → Successful(x)) ::: If someone is an artist and a sculptor, then they are successful.",
            "∀x (¬Successful(x) → Unhappy(x)) ::: Someone who is not successful is unhappy.",
            "∀x (Unhappy(x) → ¬CreatesGoodArt(x)) ::: If someone is unhappy, then they don't create good art.",
            "∀x (Painter(x) → (AppreciatesBeauty(x) ∨ Unhappy(x))) ::: All painters appreciate beauty or are unhappy.",
            "∀x (Sculptor(x) → ¬Artist(x)) ::: If someone is a sculptor, they are not an artist.",
            "∀x (Sculptor(x) → (AppreciatesBeauty(x) ∨ ¬Successful(x))) ::: Every sculptor appreciates beauty or is unsuccessful.",
            "∀x (Artist(x) → Beautiful(x)) ::: Everyone who is an artist is also beautiful.",
            "∀x (Unhappy(x) → ¬Artist(x)) ::: If someone is unhappy, they are not an artist."
        ],
        "predicates": [
            "Artist(x) ::: x is an artist",
            "Eccentric(x) ::: x is eccentric",
            "Painter(x) ::: x is a painter"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "All doctors work in hospitals.",
            "If someone treats a patient, then that person is a healer.",
            "Some doctors are surgeons.",
            "All surgeons are doctors.",
            "If someone is a healer, then they work in a hospital.",
            "All patients are injured.",
            "If someone works in a hospital, then they treat patients.",
            "If a person is injured, the person is a patient.",
            "If someone treats someone, then that person is a doctor.",
            "If someone is a doctor, they heal people.",
            "If someone is a surgeon, then they treat patients.",
            "Some injured people go to the hospital.",
            "If someone treats someone injured, then that person is a healer.",
            "If a person works in a hospital, they are a doctor or a nurse.",
            "If a doctor is a healer, they work in a hospital.",
            "If someone is a doctor and works in a hospital, then that person is a healer.",
            "If someone is a doctor and a patient is injured, then they are treated."
        ],
        "premises-FOL": [
            "∀x ∀y (Doctor(x) ∧ Patient(y) → Treats(x, y)) ::: For all x and y, if x is a doctor and y is a patient, then x treats y.",
            "∀x (Doctor(x) → WorksIn(x, hospital)) ::: For all x, if x is a doctor, then x works in a hospital.",
            "∀x ∀y (Treats(x, y) → Healer(x)) ::: For all x and y, if x treats y, then x is a healer.",
            "∃x (Doctor(x) ∧ Surgeon(x)) ::: There exists an x, such that x is a doctor and a surgeon.",
            "∀x (Surgeon(x) → Doctor(x)) ::: For all x, if x is a surgeon, then x is a doctor.",
            "∀x (Healer(x) → WorksIn(x, hospital)) ::: For all x, if x is a healer, then x works in a hospital.",
            "∀x (Patient(x) → Injured(x)) ::: For all x, if x is a patient, then x is injured.",
            "∀x ∀y (WorksIn(x, hospital) ∧ Patient(y) → Treats(x, y)) ::: For all x and y, if x works in a hospital and y is a patient, then x treats y.",
            "∀x (Injured(x) → Patient(x)) ::: For all x, if x is injured, then x is a patient.",
            "∀x ∀y (Treats(x, y) → Doctor(x)) ::: For all x and y, if x treats y, then x is a doctor.",
            "∀x (Doctor(x) → Healer(x)) ::: For all x, if x is a doctor, then x heals people.",
            "∀x ∀y (Surgeon(x) ∧ Patient(y) → Treats(x, y)) ::: For all x and y, if x is a surgeon and y is a patient, then x treats y.",
            "∃x (Injured(x) ∧ WorksIn(x, hospital)) ::: There exists an x such that x is injured and works in a hospital.",
            "∀x ∀y (Treats(x, y) ∧ Injured(y) → Healer(x)) ::: For all x and y, if x treats y and y is injured, then x is a healer.",
            "∀x (WorksIn(x, hospital) → Doctor(x) ∨ Nurse(x)) ::: For all x, if x works in a hospital, then x is a doctor or a nurse.",
            "∀x (Doctor(x) ∧ Healer(x) → WorksIn(x, hospital)) ::: For all x, if x is a doctor and a healer, then x works in a hospital.",
            "∀x (Doctor(x) ∧ WorksIn(x, hospital) → Healer(x)) ::: For all x, if x is a doctor and works in a hospital, then x is a healer.",
            "∀x ∀y (Doctor(x) ∧ Injured(y) → Treats(x, y)) ::: For all x and y, if x is a doctor and y is injured, then x treats y."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "WorksIn(x, y) ::: x works in y",
            "Hospital(x) ::: x is a hospital",
            "Healer(x) ::: x is a healer",
            "Treats(x, y) ::: x treats y",
            "Patient(x) ::: x is a patient",
            "Injured(x) ::: x is injured"
        ]
    },
    {
        "premises-NL": [
            "If someone studies computer science, that person studies programming.",
            "If someone studies programming, they know programming.",
            "If someone studies programming and is skilled, then they write code.",
            "If someone writes code, then they know programming.",
            "If someone studies computer science, that person studies math.",
            "If someone is good at math, they are skilled.",
            "If someone studies programming and likes math, then they get a good grade.",
            "If someone reads a book, they like to study.",
            "If someone gets a good grade, then they are skilled.",
            "Some people study computer science.",
            "Some people write code.",
            "If someone is skilled, then they know how to write code.",
            "If someone studies computer science and they get a good grade, then they are skilled.",
            "If someone is skilled and studies computer science, then they know programming.",
            "Anyone who reads a book related to programming, knows programming.",
            "If someone likes to study, then they study computer science.",
            "If someone knows programming, then they read about programming.",
            "If someone studies math, they like math.",
            "If someone is skilled and studies computer science, then they are good at math."
        ],
        "premises-FOL": [
            "∀x (Studies(x, computer_science) → Studies(x, programming)) ::: For all x, if x studies computer science, then x studies programming.",
            "∀x (Studies(x, programming) → Knows(x, programming)) ::: For all x, if x studies programming, then x knows programming.",
            "∀x (Studies(x, programming) ∧ Skilled(x) → WritesCode(x)) ::: For all x, if x studies programming and is skilled, then x writes code.",
            "∀x (WritesCode(x) → Knows(x, programming)) ::: For all x, if x writes code, then x knows programming.",
            "∀x (Studies(x, computer_science) → Studies(x, math)) ::: For all x, if x studies computer science, then x studies math.",
            "∀x (GoodAt(x, math) → Skilled(x)) ::: For all x, if x is good at math, then x is skilled.",
            "∀x (Studies(x, programming) ∧ Likes(x, math) → GoodGrade(x)) ::: For all x, if x studies programming and likes math, then x gets a good grade.",
            "∀x ∀y (Reads(x, y) ∧ Book(y) → LikesToStudy(x)) ::: For all x and y, if x reads y and y is a book, then x likes to study.",
            "∀x (GoodGrade(x) → Skilled(x)) ::: For all x, if x gets a good grade, then x is skilled.",
            "∃x Studies(x, computer_science) ::: There exists someone who studies computer science.",
            "∃x WritesCode(x) ::: There exists someone who writes code.",
            "∀x (Skilled(x) → WritesCode(x)) ::: For all x, if x is skilled, then x knows how to write code.",
            "∀x (Studies(x, computer_science) ∧ GoodGrade(x) → Skilled(x)) ::: For all x, if x studies computer science and gets a good grade, then x is skilled.",
            "∀x (Skilled(x) ∧ Studies(x, computer_science) → Knows(x, programming)) ::: For all x, if x is skilled and studies computer science, then x knows programming.",
            "∀x ∀y (Reads(x, y) ∧ ProgrammingBook(y) → Knows(x, programming)) ::: For all x and y, if x reads a programming book y, then x knows programming.",
            "∀x (LikesToStudy(x) → Studies(x, computer_science)) ::: For all x, if x likes to study, then x studies computer science.",
            "∀x (Knows(x, programming) → Reads(x, programming_book)) ::: For all x, if x knows programming, then x reads about programming.",
            "∀x (Studies(x, math) → Likes(x, math)) ::: For all x, if x studies math, then x likes math.",
            "∀x (Skilled(x) ∧ Studies(x, computer_science) → GoodAt(x, math)) ::: For all x, if x is skilled and studies computer science, then x is good at math."
        ],
        "predicates": [
            "Studies(x, y) ::: x studies y",
            "ComputerScience(x) ::: x is Computer Science",
            "Skilled(x) ::: x is skilled",
            "Knows(x, y) ::: x knows y",
            "Programming(x) ::: x is Programming",
            "Reads(x, y) ::: x reads y",
            "Book(x) ::: x is a book",
            "WritesCode(x) ::: x writes code",
            "Likes(x, y) ::: x likes y",
            "Math(x) ::: x is math",
            "GoodGrade(x) ::: x has a good grade"
        ]
    },
    {
        "premises-NL": [
            "All squares are shapes.",
            "All circles are shapes.",
            "Nothing is both a circle and a square.",
            "Some objects are red and shapes.",
            "x is a shape if it is a square or a circle.",
            "There is a red object.",
            "If something is not a shape, then it is not red.",
            "Every red object is a shape.",
            "There is a square.",
            "Some shapes are red."
        ],
        "premises-FOL": [
            "∀x (Square(x) → Shape(x)) ::: All squares are shapes.",
            "∀x (Circle(x) → Shape(x)) ::: All circles are shapes.",
            "¬∃x (Circle(x) ∧ Square(x)) ::: Nothing is both a circle and a square.",
            "∃x (Red(x) ∧ Shape(x)) ::: Some objects are red and shapes.",
            "∀x (Shape(x) ↔ (Square(x) ∨ Circle(x))) ::: x is a shape if and only if it is a square or a circle.",
            "∃x Red(x) ::: There is a red object.",
            "∀x (¬Shape(x) → ¬Red(x)) ::: If something is not a shape, then it is not red.",
            "∀x (Red(x) → Shape(x)) ::: Every red object is a shape.",
            "∃x Square(x) ::: There is a square.",
            "∃x (Shape(x) ∧ Red(x)) ::: Some shapes are red."
        ],
        "predicates": [
            "Red(x) ::: x is red",
            "Square(x) ::: x is a square",
            "Circle(x) ::: x is a circle",
            "Is(x, y) ::: x is y"
        ]
    },
    {
        "premises-NL": [
            "Everyone who likes apples eats apples.",
            "Everyone who likes bananas eats bananas.",
            "John likes apples.",
            "Mary likes bananas.",
            "John and Mary are people.",
            "If someone likes something, then someone eats it.",
            "Apples are eaten.",
            "Bananas are eaten.",
            "Some people like apples.",
            "Some people like bananas.",
            "John likes apples and Mary likes bananas."
        ],
        "premises-FOL": [
            "∀x ∀y (Likes(x, Apples) → Eats(x, Apples)) ::: Everyone who likes apples eats apples.",
            "∀x ∀y (Likes(x, Bananas) → Eats(x, Bananas)) ::: Everyone who likes bananas eats bananas.",
            "Likes(John, Apples) ::: John likes apples.",
            "Likes(Mary, Bananas) ::: Mary likes bananas.",
            "Person(John) ∧ Person(Mary) ::: John and Mary are people.",
            "∀x ∀y (Likes(x, y) → Eats(x, y)) ::: If someone likes something, then someone eats it.",
            "Eats(x, Apples) ::: Apples are eaten.",
            "Eats(x, Bananas) ::: Bananas are eaten.",
            "∃x Likes(x, Apples) ::: Some people like apples.",
            "∃x Likes(x, Bananas) ::: Some people like bananas.",
            "Likes(John, Apples) ∧ Likes(Mary, Bananas) ::: John likes apples and Mary likes bananas."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Likes(x, y) ::: x likes y",
            "Eats(x, y) ::: x eats y"
        ]
    },
    {
        "premises-NL": [
            "All students who take Calculus are in the advanced class.",
            "All students who are in the advanced class have a high GPA.",
            "If a student takes both Calculus and Physics then they are smart.",
            "If a student is smart then they are eligible for a scholarship.",
            "John is a student.",
            "John takes Calculus.",
            "John takes Physics.",
            "All smart students have a high GPA."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ TakesCourse(x, Calculus) → AdvancedClass(x)) ::: All students who take Calculus are in the advanced class.",
            "∀x (AdvancedClass(x) → HighGPA(x)) ::: All students in the advanced class have a high GPA.",
            "∀x (Student(x) ∧ TakesCourse(x, Calculus) ∧ TakesCourse(x, Physics) → SmartStudent(x)) ::: If a student takes Calculus and Physics, they are smart.",
            "∀x (SmartStudent(x) → EligibleForScholarship(x)) ::: If a student is smart, they are eligible for a scholarship.",
            "Student(John) ::: John is a student.",
            "TakesCourse(John, Calculus) ::: John takes Calculus.",
            "TakesCourse(John, Physics) ::: John takes Physics.",
            "∀x (SmartStudent(x) → HighGPA(x)) ::: All smart students have a high GPA."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "AdvancedClass(x) ::: x is in the advanced class.",
            "HighGPA(x) ::: x has a high GPA.",
            "EligibleForScholarship(x) ::: x is eligible for a scholarship.",
            "TakesCourse(x, y) ::: x takes course y.",
            "Calculus(x) ::: x studies Calculus.",
            "Physics(x) ::: x studies Physics.",
            "SmartStudent(x) ::: x is a smart student"
        ]
    },
    {
        "premises-NL": [
            "Alex likes all animals.",
            "All cats are animals.",
            "Alex is a person."
        ],
        "premises-FOL": [
            "∀x (Animal(x) → Likes(Alex, x)) ::: Alex likes all animals",
            "∀x (Cat(x) → Animal(x)) ::: All cats are animals",
            "Person(Alex) ::: Alex is a person"
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "Animal(x) ::: x is an animal",
            "Cat(x) ::: x is a cat"
        ]
    },
    {
        "premises-NL": [
            "All doctors treat patients.",
            "If someone treats a patient, they are a doctor.",
            "Charles is a doctor or Bill is a lawyer.",
            "Patients are ill.",
            "If Charles treats a patient, then Bill is a lawyer."
        ],
        "premises-FOL": [
            "∀x ∀y (Doctor(x) ∧ Patient(y) → Treats(x, y)) ::: All doctors treat patients.",
            "∀x ∀y (Treats(x, y) → Doctor(x)) ::: If someone treats a patient, they are a doctor.",
            "Doctor(Charles) ∨ Lawyer(Bill) ::: Charles is a doctor or Bill is a lawyer.",
            "∀x (Patient(x) → Ill(x)) ::: Patients are ill.",
            "∀x ∀y (Treats(Charles, y) → Lawyer(Bill)) ::: If Charles treats a patient, then Bill is a lawyer."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Lawyer(x) ::: x is a lawyer",
            "Patient(x) ::: x is a patient",
            "Treats(x, y) ::: x treats y",
            "Ill(x) ::: x is ill"
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "John is a student.",
            "All smart people attend lectures.",
            "If someone attends lectures, they pass the exam.",
            "John passes the exam.",
            "John is smart."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "Student(john) ::: John is a student.",
            "∀x (Smart(x) → AttendsLectures(x)) ::: All smart people attend lectures.",
            "∀x (AttendsLectures(x) → PassesExam(x)) ::: If someone attends lectures, they pass the exam.",
            "PassesExam(john) ::: John passes the exam.",
            "Smart(john) ::: John is smart."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Smart(x) ::: x is smart",
            "AttendsLectures(x) ::: x attends lectures",
            "PassesExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "All golden retrievers are dogs.",
            "Every dog that likes treats is friendly.",
            "All golden retrievers like treats.",
            "If a dog barks, then it is a dog.",
            "Every dog is a pet.",
            "All pets eats meat.",
            "Every dog has a tail.",
            "Some dogs are golden retrievers.",
            "If x is a dog, and eats meat, then x likes treats.",
            "There are no dogs that are friendly."
        ],
        "premises-FOL": [
            "∀x (GoldenRetriever(x) → Dog(x)) ::: All golden retrievers are dogs.",
            "∀x ((Dog(x) ∧ LikesTreats(x)) → Friendly(x)) ::: Every dog that likes treats is friendly.",
            "∀x (GoldenRetriever(x) → LikesTreats(x)) ::: All golden retrievers like treats.",
            "∀x (Barks(x) → Dog(x)) ::: If a dog barks, then it is a dog.",
            "∀x (Dog(x) → IsAPet(x)) ::: Every dog is a pet.",
            "∀x (IsAPet(x) → EatsMeat(x)) ::: All pets eats meat.",
            "∀x (Dog(x) → HasTail(x)) ::: Every dog has a tail.",
            "∃x GoldenRetriever(x) ::: Some dogs are golden retrievers.",
            "∀x ((Dog(x) ∧ EatsMeat(x)) → LikesTreats(x)) ::: If x is a dog, and eats meat, then x likes treats.",
            "¬∃x (Dog(x) ∧ Friendly(x)) ::: There are no dogs that are friendly."
        ],
        "predicates": [
            "Dog(x) ::: x is a dog",
            "GoldenRetriever(x) ::: x is a golden retriever",
            "LikesTreats(x) ::: x likes treats",
            "Friendly(x) ::: x is friendly",
            "Barks(x) ::: x barks",
            "IsAPet(x) ::: x is a pet",
            "EatsMeat(x) ::: x eats meat",
            "HasTail(x) ::: x has a tail"
        ]
    },
    {
        "premises-NL": [
            "All doctors are people.",
            "No smoker has healthy lungs.",
            "Some doctors prescribe medicine.",
            "All patients take medicine.",
            "If a person has a disease, they are a patient.",
            "If a person has a good diet and exercises regularly, they have healthy lungs.",
            "All doctors have healthy lungs.",
            "If a person is a smoker, then they do not have healthy lungs.",
            "All doctors are not smokers.",
            "If someone has insurance, they consult a doctor.",
            "Doctors prescribe medicine."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Person(x)) ::: All doctors are people.",
            "∀x (Smoker(x) → ¬HealthyLungs(x)) ::: No smoker has healthy lungs.",
            "∃x ∃y PrescribesMedicine(x, y) ::: Some doctors prescribe medicine.",
            "∀x ∀y (Patient(x) → TakesMedicine(x, y)) ::: All patients take medicine.",
            "∀x (HasDisease(x) → Patient(x)) ::: If a person has a disease, they are a patient.",
            "∀x ((HasGoodDiet(x) ∧ ExercisesRegularly(x)) → HealthyLungs(x)) ::: If a person has a good diet and exercises regularly, they have healthy lungs.",
            "∀x (Doctor(x) → HealthyLungs(x)) ::: All doctors have healthy lungs.",
            "∀x (Smoker(x) → ¬HealthyLungs(x)) ::: If a person is a smoker, then they do not have healthy lungs.",
            "∀x (Doctor(x) → ¬Smoker(x)) ::: All doctors are not smokers.",
            "∀x (HasInsurance(x) → ConsultsDoctor(x)) ::: If someone has insurance, they consult a doctor.",
            "∀x PrescribesMedicine(x, y) ::: Doctors prescribe medicine."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Smoker(x) ::: x is a smoker",
            "HasHealthyLungs(x) ::: x has healthy lungs",
            "Patient(x) ::: x is a patient",
            "PrescribesMedicine(x, y) ::: x prescribes medicine y",
            "TakesMedicine(x, y) ::: x takes medicine y",
            "HasDisease(x) ::: x has a disease",
            "HasGoodDiet(x) ::: x has a good diet",
            "ExercisesRegularly(x) ::: x exercises regularly",
            "HasInsurance(x) ::: x has insurance",
            "ConsultsDoctor(x) ::: x consults doctor"
        ]
    },
    {
        "premises-NL": [
            "Everyone in the marketing team has experience in advertising.",
            "Anyone with experience in advertising is skilled in communication.",
            "All members of the marketing team work for the company.",
            "If someone is promoted, then they are skilled in communication.",
            "If someone works for the company and has a degree in marketing, they will be promoted.",
            "Someone who is skilled in communication, writes a blog.",
            "Anyone who is skilled in communication, uses marketing software.",
            "If someone writes blog, then he/she also attends a meeting.",
            "People with experience in advertising, has portfolio.",
            "Someone from the marketing team also speaks english.",
            "The marketing team manages the sales team.",
            "Everyone in the marketing team is skilled in communication."
        ],
        "premises-FOL": [
            "∀x (MemberOf(x, \"Marketing Team\") → ExperienceIn(x, \"Advertising\")) ::: Everyone in the marketing team has experience in advertising.",
            "∀x (ExperienceIn(x, \"Advertising\") → SkilledIn(x, \"Communication\")) ::: Anyone with experience in advertising is skilled in communication.",
            "∀x (MemberOf(x, \"Marketing Team\") → WorksFor(x, \"Company\")) ::: All members of the marketing team work for the company.",
            "∀x (IsPromoted(x) → SkilledIn(x, \"Communication\")) ::: If someone is promoted, then they are skilled in communication.",
            "∀x ((WorksFor(x, \"Company\") ∧ HasDegreeIn(x, \"Marketing\")) → IsPromoted(x)) ::: If someone works for the company and has a degree in marketing, they will be promoted.",
            "∀x (SkilledIn(x, \"Communication\") → WritesBlog(x)) ::: Someone who is skilled in communication, writes a blog.",
            "∀x (SkilledIn(x, \"Communication\") → UsesSoftware(x, \"Marketing Software\")) ::: Anyone who is skilled in communication, uses marketing software.",
            "∀x (WritesBlog(x) → AttendsMeeting(x, \"Marketing Meeting\")) ::: If someone writes blog, then he/she also attends a meeting.",
            "∀x (ExperienceIn(x, \"Advertising\") → HasPortfolio(x)) ::: People with experience in advertising, has portfolio.",
            "∃x (MemberOf(x, \"Marketing Team\") ∧ KnowsLanguage(x, \"English\")) ::: Someone from the marketing team also speaks english.",
            "∀x ∀y (MemberOf(x, \"Marketing Team\") → ManagesTeam(x, y)) ::: The marketing team manages the sales team.",
            "∀x (MemberOf(x, \"Marketing Team\") → SkilledIn(x, \"Communication\")) ::: Everyone in the marketing team is skilled in communication."
        ],
        "predicates": [
            "MemberOf(x, y) ::: x is a member of team y",
            "ExperienceIn(x, y) ::: x has experience in field y",
            "SkilledIn(x, y) ::: x is skilled in field y",
            "WorksFor(x, y) ::: x works for company y",
            "AttendsMeeting(x, y) ::: x attends meeting y",
            "IsPromoted(x) ::: x is promoted",
            "HasDegreeIn(x, y) ::: x has a degree in y",
            "ManagesTeam(x, y) ::: x manages team y",
            "KnowsLanguage(x, y) ::: x knows language y",
            "UsesSoftware(x, y) ::: x uses software y",
            "HasPortfolio(x) ::: x has portfolio",
            "WritesBlog(x) ::: x writes blog"
        ]
    },
    {
        "premises-NL": [
            "All investors own assets.",
            "Anyone risk-averse does not invest in stocks.",
            "If someone has savings, they are not risk-averse.",
            "Everyone who is employed has income.",
            "If someone studies economics, they understand the market.",
            "Anyone who invests in stocks follows market trends.",
            "If someone has a credit card, then they are not risk-averse.",
            "Someone who buys property, is not risk-averse.",
            "Anyone who invests in stocks has income.",
            "If someone sells stock, they do not have savings.",
            "People who are not risk-averse, follow market trends.",
            "If someone is risk-averse, then they have debt.",
            "If someone understands the market, then they invest in stocks."
        ],
        "premises-FOL": [
            "∀x (InvestsIn(x, y) → OwnsAsset(x, y)) ::: All investors own assets.",
            "∀x (RiskAverse(x) → ¬InvestsIn(x, \"Stocks\")) ::: Anyone risk-averse does not invest in stocks.",
            "∀x (HasSavings(x) → ¬RiskAverse(x)) ::: If someone has savings, they are not risk-averse.",
            "∀x (IsEmployed(x) → HasIncome(x)) ::: Everyone who is employed has income.",
            "∀x (StudiesEconomics(x) → UnderstandsMarket(x)) ::: If someone studies economics, they understand the market.",
            "∀x (InvestsIn(x, \"Stocks\") → FollowsMarketTrends(x)) ::: Anyone who invests in stocks follows market trends.",
            "∀x (HasCreditCard(x) → ¬RiskAverse(x)) ::: If someone has a credit card, then they are not risk-averse.",
            "∀x (BuysProperty(x, y) → ¬RiskAverse(x)) ::: Someone who buys property, is not risk-averse.",
            "∀x (InvestsIn(x, \"Stocks\") → HasIncome(x)) ::: Anyone who invests in stocks has income.",
            "∀x (SellsStock(x) → ¬HasSavings(x)) ::: If someone sells stock, they do not have savings.",
            "∀x (¬RiskAverse(x) → FollowsMarketTrends(x)) ::: People who are not risk-averse, follow market trends.",
            "∀x (RiskAverse(x) → HasDebt(x)) ::: If someone is risk-averse, then they have debt.",
            "∀x (UnderstandsMarket(x) → InvestsIn(x, \"Stocks\")) ::: If someone understands the market, then they invest in stocks."
        ],
        "predicates": [
            "InvestsIn(x, y) ::: x invests in y",
            "RiskAverse(x) ::: x is risk-averse",
            "OwnsAsset(x, y) ::: x owns asset y",
            "HasSavings(x) ::: x has savings",
            "IsEmployed(x) ::: x is employed",
            "StudiesEconomics(x) ::: x studies economics",
            "UnderstandsMarket(x) ::: x understands the market",
            "HasCreditCard(x) ::: x has a credit card",
            "BuysProperty(x, y) ::: x buys property y",
            "FollowsMarketTrends(x) ::: x follows market trends",
            "HasDebt(x) ::: x has debt",
            "SellsStock(x) ::: x sells stock",
            "HasIncome(x) ::: x has income"
        ]
    },
    {
        "premises-NL": [
            "Every student is either enrolled in a course or taking a break.",
            "John is a student.",
            "If someone is taking a break, then they are not studying.",
            "Anyone enrolled in a course must pay tuition.",
            "If someone does not pay tuition, they will be dropped from the course.",
            "All people can be enrolled in a course.",
            "If anyone is taking a break, then they are not enrolled in a course.",
            "If John is enrolled in a course then he is paying tuition.",
            "John is either a student or a professor.",
            "If someone is a professor, then they do not pay tuition.",
            "There is someone who is not enrolled in a course.",
            "If someone is not paying tuition, they are not enrolled.",
            "If someone is taking a break, they are relaxing.",
            "Not everyone is taking a break.",
            "Anyone who pays tuition is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (EnrolledInCourse(x) ∨ TakingBreak(x))) ::: Every student is either enrolled in a course or taking a break.",
            "Student(john) ::: John is a student.",
            "∀x (TakingBreak(x) → ¬Studying(x)) ::: If someone is taking a break, then they are not studying.",
            "∀x (EnrolledInCourse(x) → PaysTuition(x)) ::: Anyone enrolled in a course must pay tuition.",
            "∀x (¬PaysTuition(x) → ¬EnrolledInCourse(x)) ::: If someone does not pay tuition, they will be dropped from the course.",
            "∀x (CanBeEnrolled(x)) ::: All people can be enrolled in a course.",
            "∀x (TakingBreak(x) → ¬EnrolledInCourse(x)) ::: If anyone is taking a break, then they are not enrolled in a course.",
            "EnrolledInCourse(john) → PaysTuition(john) ::: If John is enrolled in a course then he is paying tuition.",
            "Student(john) ∨ Professor(john) ::: John is either a student or a professor.",
            "∀x (Professor(x) → ¬PaysTuition(x)) ::: If someone is a professor, then they do not pay tuition.",
            "∃x ¬EnrolledInCourse(x) ::: There is someone who is not enrolled in a course.",
            "∀x (¬PaysTuition(x) → ¬EnrolledInCourse(x)) ::: If someone is not paying tuition, they are not enrolled.",
            "∀x (TakingBreak(x) → Relaxing(x)) ::: If someone is taking a break, they are relaxing.",
            "¬∀x TakingBreak(x) ::: Not everyone is taking a break.",
            "∀x (PaysTuition(x) → Student(x)) ::: Anyone who pays tuition is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledInCourse(x) ::: x is enrolled in a course",
            "TakingBreak(x) ::: x is taking a break"
        ]
    },
    {
        "premises-NL": [
            "All programmers write code.",
            "Every programmer reads documentation.",
            "Anyone who reads documentation understands logic.",
            "John is a programmer.",
            "If someone understands logic, they are smart.",
            "If someone is smart and writes code, then they create software.",
            "Not everyone writes code.",
            "If someone creates software, they use computers.",
            "If someone uses computers, they have internet access.",
            "Not everyone uses computers.",
            "If someone is smart, then they can understand complex problems.",
            "If someone understands complex problems and is a programmer, they can debug code.",
            "If someone can debug code, they read documentation.",
            "If someone is not a programmer, they may not write code.",
            "If someone is a programmer, they are employed.",
            "If someone is employed, they earn money.",
            "Every programmer uses a computer."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → WritesCode(x)) ::: All programmers write code.",
            "∀x (Programmer(x) → ReadsDocumentation(x)) ::: Every programmer reads documentation.",
            "∀x (ReadsDocumentation(x) → UnderstandsLogic(x)) ::: Anyone who reads documentation understands logic.",
            "Programmer(john) ::: John is a programmer.",
            "∀x (UnderstandsLogic(x) → Smart(x)) ::: If someone understands logic, they are smart.",
            "∀x (Smart(x) ∧ WritesCode(x) → CreatesSoftware(x)) ::: If someone is smart and writes code, then they create software.",
            "¬∀x WritesCode(x) ::: Not everyone writes code.",
            "∀x (CreatesSoftware(x) → UsesComputers(x)) ::: If someone creates software, they use computers.",
            "∀x (UsesComputers(x) → HasInternetAccess(x)) ::: If someone uses computers, they have internet access.",
            "¬∀x UsesComputers(x) ::: Not everyone uses computers.",
            "∀x (Smart(x) → CanUnderstandComplexProblems(x)) ::: If someone is smart, then they can understand complex problems.",
            "∀x (CanUnderstandComplexProblems(x) ∧ Programmer(x) → CanDebugCode(x)) ::: If someone understands complex problems and is a programmer, they can debug code.",
            "∀x (CanDebugCode(x) → ReadsDocumentation(x)) ::: If someone can debug code, they read documentation.",
            "∀x (¬Programmer(x) → ¬WritesCode(x)) ::: If someone is not a programmer, they may not write code.",
            "∀x (Programmer(x) → Employed(x)) ::: If someone is a programmer, they are employed.",
            "∀x (Employed(x) → EarnsMoney(x)) ::: If someone is employed, they earn money.",
            "∀x (Programmer(x) → UsesComputers(x)) ::: Every programmer uses a computer."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer",
            "WritesCode(x) ::: x writes code",
            "ReadsDocumentation(x) ::: x reads documentation",
            "UnderstandsLogic(x) ::: x understands logic"
        ]
    },
    {
        "premises-NL": [
            "All doctors prescribe medicine.",
            "Dr. Smith is a doctor.",
            "Every doctor treats patients.",
            "If someone treats patients, they have a medical degree.",
            "If someone has a medical degree and prescribes medicine, they are qualified.",
            "If someone is qualified, then they can perform surgeries.",
            "Not all doctors are surgeons.",
            "If someone is a surgeon, they are specialized.",
            "If someone is specialized, they have advanced training.",
            "Dr. Jones is a surgeon.",
            "If someone treats patients and is a doctor, they are employed.",
            "If someone is employed, they earn money.",
            "If someone has a medical degree and does not perform surgeries, they are general practitioners.",
            "Not everyone earns money.",
            "If someone is a doctor and not a surgeon, then they treat common illnesses.",
            "If someone treats common illnesses and is not specialized, they prescribe standard medication.",
            "If someone prescribes standard medication, they are using proven methods.",
            "Dr. Smith treats patients."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → PrescribesMedicine(x)) ::: All doctors prescribe medicine.",
            "Doctor(drSmith) ::: Dr. Smith is a doctor.",
            "∀x (Doctor(x) → TreatsPatients(x)) ::: Every doctor treats patients.",
            "∀x (TreatsPatients(x) → HasMedicalDegree(x)) ::: If someone treats patients, they have a medical degree.",
            "∀x (HasMedicalDegree(x) ∧ PrescribesMedicine(x) → Qualified(x)) ::: If someone has a medical degree and prescribes medicine, they are qualified.",
            "∀x (Qualified(x) → CanPerformSurgeries(x)) ::: If someone is qualified, then they can perform surgeries.",
            "¬∀x (Doctor(x) → Surgeon(x)) ::: Not all doctors are surgeons.",
            "∀x (Surgeon(x) → Specialized(x)) ::: If someone is a surgeon, they are specialized.",
            "∀x (Specialized(x) → HasAdvancedTraining(x)) ::: If someone is specialized, they have advanced training.",
            "Surgeon(drJones) ::: Dr. Jones is a surgeon.",
            "∀x (TreatsPatients(x) ∧ Doctor(x) → Employed(x)) ::: If someone treats patients and is a doctor, they are employed.",
            "∀x (Employed(x) → EarnsMoney(x)) ::: If someone is employed, they earn money.",
            "∀x (HasMedicalDegree(x) ∧ ¬CanPerformSurgeries(x) → GeneralPractitioner(x)) ::: If someone has a medical degree and does not perform surgeries, they are general practitioners.",
            "¬∀x EarnsMoney(x) ::: Not everyone earns money.",
            "∀x (Doctor(x) ∧ ¬Surgeon(x) → TreatsCommonIllnesses(x)) ::: If someone is a doctor and not a surgeon, then they treat common illnesses.",
            "∀x (TreatsCommonIllnesses(x) ∧ ¬Specialized(x) → PrescribesStandardMedication(x)) ::: If someone treats common illnesses and is not specialized, they prescribe standard medication.",
            "∀x (PrescribesStandardMedication(x) → UsesProvenMethods(x)) ::: If someone prescribes standard medication, they are using proven methods.",
            "TreatsPatients(drSmith) ::: Dr. Smith treats patients."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "PrescribesMedicine(x) ::: x prescribes medicine",
            "TreatsPatients(x) ::: x treats patients",
            "HasMedicalDegree(x) ::: x has a medical degree"
        ]
    },
    {
        "premises-NL": [
            "All humans need oxygen.",
            "John is human.",
            "All humans are mortal.",
            "If someone is mortal, they are alive.",
            "If someone is alive, they breathe air.",
            "If someone breathes air and eats food, they are complex organisms.",
            "All animals are alive.",
            "If someone is human and is mortal, they are not immortal.",
            "Not all humans eat food.",
            "If someone is not human, they might be an animal.",
            "If someone is an animal, they need food.",
            "If someone needs food and oxygen, they have energy needs.",
            "John needs oxygen.",
            "If someone is complex, they are made of cells.",
            "If someone is made of cells and needs oxygen, they are living.",
            "If someone is living, they reproduce.",
            "If someone is human, they eat food.",
            "If someone is mortal, they are not immortal.",
            "If someone needs oxygen, they are not immortal."
        ],
        "premises-FOL": [
            "∀x (Human(x) → NeedsOxygen(x)) ::: All humans need oxygen.",
            "Human(john) ::: John is human.",
            "∀x (Human(x) → Mortal(x)) ::: All humans are mortal.",
            "∀x (Mortal(x) → Alive(x)) ::: If someone is mortal, they are alive.",
            "∀x (Alive(x) → BreathesAir(x)) ::: If someone is alive, they breathe air.",
            "∀x (BreathesAir(x) ∧ EatsFood(x) → ComplexOrganism(x)) ::: If someone breathes air and eats food, they are complex organisms.",
            "∀x (Animal(x) → Alive(x)) ::: All animals are alive.",
            "∀x (Human(x) ∧ Mortal(x) → ¬Immortal(x)) ::: If someone is human and is mortal, they are not immortal.",
            "¬∀x (Human(x) → EatsFood(x)) ::: Not all humans eat food.",
            "∀x (¬Human(x) → Animal(x)) ::: If someone is not human, they might be an animal.",
            "∀x (Animal(x) → NeedsFood(x)) ::: If someone is an animal, they need food.",
            "∀x (NeedsFood(x) ∧ NeedsOxygen(x) → HasEnergyNeeds(x)) ::: If someone needs food and oxygen, they have energy needs.",
            "NeedsOxygen(john) ::: John needs oxygen.",
            "∀x (ComplexOrganism(x) → MadeOfCells(x)) ::: If someone is complex, they are made of cells.",
            "∀x (MadeOfCells(x) ∧ NeedsOxygen(x) → Living(x)) ::: If someone is made of cells and needs oxygen, they are living.",
            "∀x (Living(x) → Reproduces(x)) ::: If someone is living, they reproduce.",
            "∀x (Human(x) → EatsFood(x)) ::: If someone is human, they eat food.",
            "∀x (Mortal(x) → ¬Immortal(x)) ::: If someone is mortal, they are not immortal.",
            "∀x (NeedsOxygen(x) → ¬Immortal(x)) ::: If someone needs oxygen, they are not immortal."
        ],
        "predicates": [
            "Human(x) ::: x is human",
            "NeedsOxygen(x) ::: x needs oxygen",
            "Mortal(x) ::: x is mortal",
            "BreathsAir(x) ::: x breathes air",
            "EatsFood(x) ::: x eats food"
        ]
    },
    {
        "premises-NL": [
            "All engineers solve problems.",
            "Engineers use computers.",
            "People who solve problems either know calculus or are programmers.",
            "Anyone who uses computers designs systems.",
            "Those who design systems understand physics.",
            "If someone understands physics, they read books.",
            "If someone reads books, they write code.",
            "If someone writes code, they are creative.",
            "People who are creative build things.",
            "Engineers study engineering.",
            "If someone studies engineering, they solve problems.",
            "A person that is an engineer solves problems, and uses computers."
        ],
        "premises-FOL": [
            "∀x (Engineer(x) → SolvesProblems(x)) ::: All engineers solve problems.",
            "∀x (Engineer(x) → UsesComputers(x)) ::: Engineers use computers.",
            "∀x (SolvesProblems(x) → (KnowsCalculus(x) ∨ Programmer(x))) ::: People who solve problems either know calculus or are programmers.",
            "∀x (UsesComputers(x) → DesignsSystems(x)) ::: Anyone who uses computers designs systems.",
            "∀x (DesignsSystems(x) → UnderstandsPhysics(x)) ::: Those who design systems understand physics.",
            "∀x (UnderstandsPhysics(x) → ReadsBooks(x)) ::: If someone understands physics, they read books.",
            "∀x (ReadsBooks(x) → WritesCode(x)) ::: If someone reads books, they write code.",
            "∀x (WritesCode(x) → IsCreative(x)) ::: If someone writes code, they are creative.",
            "∀x (IsCreative(x) → BuildsThings(x)) ::: People who are creative build things.",
            "∀x (Engineer(x) → StudiesEngineering(x)) ::: Engineers study engineering.",
            "∀x (StudiesEngineering(x) → SolvesProblems(x)) ::: If someone studies engineering, they solve problems.",
            "∀x (Engineer(x) → (SolvesProblems(x) ∧ UsesComputers(x))) ::: A person that is an engineer solves problems, and uses computers."
        ],
        "predicates": [
            "Engineer(x) ::: x is an engineer",
            "KnowsCalculus(x) ::: x knows calculus",
            "Programmer(x) ::: x is a programmer",
            "SolvesProblems(x) ::: x solves problems",
            "UsesComputers(x) ::: x uses computers",
            "DesignsSystems(x) ::: x designs systems",
            "UnderstandsPhysics(x) ::: x understands physics",
            "ReadsBooks(x) ::: x reads books",
            "WritesCode(x) ::: x writes code",
            "IsCreative(x) ::: x is creative",
            "BuildsThings(x) ::: x builds things",
            "StudiesEngineering(x) ::: x studies engineering"
        ]
    },
    {
        "premises-NL": [
            "All scientists conduct experiments.",
            "Scientists who work with chemicals must wear protective gear.",
            "If someone conducts experiments and analyzes data, they are detail-oriented.",
            "If someone is detail-oriented, they follow safety protocols.",
            "If someone follows safety protocols, they must wear protective gear.",
            "Anyone who uses a microscope studies biology.",
            "People who study biology work in a lab.",
            "Those who work in a lab read scientific journals.",
            "If someone reads scientific journals, they are knowledgeable.",
            "Scientists who conduct experiments, analyze data, and follow safety protocols are detail oriented.",
            "Anyone who works with chemicals is organized.",
            "Scientists must conduct experiments.",
            "Scientists analyze data."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → ConductsExperiments(x)) ::: All scientists conduct experiments.",
            "∀x (Scientist(x) ∧ WorksWithChemicals(x) → MustWearProtectiveGear(x)) ::: Scientists who work with chemicals must wear protective gear.",
            "∀x ((ConductsExperiments(x) ∧ AnalyzesData(x)) → DetailOriented(x)) ::: If someone conducts experiments and analyzes data, they are detail-oriented.",
            "∀x (DetailOriented(x) → FollowsSafetyProtocols(x)) ::: If someone is detail-oriented, they follow safety protocols.",
            "∀x (FollowsSafetyProtocols(x) → MustWearProtectiveGear(x)) ::: If someone follows safety protocols, they must wear protective gear.",
            "∀x (UsesMicroscope(x) → StudiesBiology(x)) ::: Anyone who uses a microscope studies biology.",
            "∀x (StudiesBiology(x) → WorksInLab(x)) ::: People who study biology work in a lab.",
            "∀x (WorksInLab(x) → ReadsScientificJournals(x)) ::: Those who work in a lab read scientific journals.",
            "∀x (ReadsScientificJournals(x) → IsKnowledgeable(x)) ::: If someone reads scientific journals, they are knowledgeable.",
            "∀x (Scientist(x) ∧ ConductsExperiments(x) ∧ AnalyzesData(x) ∧ FollowsSafetyProtocols(x) → DetailOriented(x)) ::: Scientists who conduct experiments, analyze data, and follow safety protocols are detail oriented.",
            "∀x (WorksWithChemicals(x) → IsOrganized(x)) ::: Anyone who works with chemicals is organized.",
            "∀x (Scientist(x) → ConductsExperiments(x)) ::: Scientists must conduct experiments.",
            "∀x (Scientist(x) → AnalyzesData(x)) ::: Scientists analyze data."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "WorksWithChemicals(x) ::: x works with chemicals",
            "UsesMicroscope(x) ::: x uses a microscope",
            "DetailOriented(x) ::: x is detail-oriented",
            "MustWearProtectiveGear(x) ::: x must wear protective gear",
            "ConductsExperiments(x) ::: x conducts experiments",
            "AnalyzesData(x) ::: x analyzes data",
            "IsOrganized(x) ::: x is organized",
            "FollowsSafetyProtocols(x) ::: x follows safety protocols",
            "IsKnowledgeable(x) ::: x is knowledgeable",
            "StudiesBiology(x) ::: x studies biology",
            "WorksInLab(x) ::: x works in a lab",
            "ReadsScientificJournals(x) ::: x reads scientific journals"
        ]
    },
    {
        "premises-NL": [
            "All doctors have a medical degree.",
            "Some doctors are specialists.",
            "Specialists often treat patients.",
            "No one who smokes is healthy.",
            "Healthy people can treat the sick.",
            "Some patients have diseases.",
            "All specialists are doctors.",
            "Doctors are healthy or smoke.",
            "Not all doctors treat sick people.",
            "Anyone who is not a doctor can not treat the sick",
            "A doctor that does not smoke is healthy."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HasMedicalDegree(x)) ::: All doctors have a medical degree.",
            "∃x (Doctor(x) ∧ Specialist(x)) ::: Some doctors are specialists.",
            "∀x (Specialist(x) → TreatsPatients(x)) ::: Specialists often treat patients.",
            "∀x (Smokes(x) → ¬Healthy(x)) ::: No one who smokes is healthy.",
            "∀x (Healthy(x) → TreatsSick(x)) ::: Healthy people can treat the sick.",
            "∃x (Patient(x) ∧ HasDisease(x)) ::: Some patients have diseases.",
            "∀x (Specialist(x) → Doctor(x)) ::: All specialists are doctors.",
            "∀x (Doctor(x) → (Healthy(x) ∨ Smokes(x))) ::: Doctors are healthy or smoke.",
            "∃x (Doctor(x) ∧ ¬TreatsSick(x)) ::: Not all doctors treat sick people.",
            "∀x (¬Doctor(x) → ¬TreatsSick(x)) ::: Anyone who is not a doctor can not treat the sick",
            "∀x ((Doctor(x) ∧ ¬Smokes(x)) → Healthy(x)) ::: A doctor that does not smoke is healthy."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Smokes(x) ::: x smokes",
            "Patient(x) ::: x is a patient",
            "TreatsSick(x) ::: x treats the sick",
            "HasDisease(x) ::: x has a disease"
        ]
    },
    {
        "premises-NL": [
            "Anyone who graduates is employed.",
            "Some students study and take an exam.",
            "Anyone who studies attends lectures.",
            "Anyone who takes an exam, either passes or fails.",
            "If someone fails a course, they don't graduate.",
            "If someone studies and attends lectures, they either pass or fail.",
            "Some people who attend lectures, pass exams.",
            "Those who pass the exam, are employed.",
            "Anyone who is employed studies or graduates.",
            "If someone studies, they attend lectures or takes exams.",
            "Anyone who takes an exam studies.",
            "If someone doesn't fail a course, they pass an exam or study.",
            "Students take exams.",
            "If someone doesn't take an exam, they don't study or graduate.",
            "If someone is employed, they don't fail a course.",
            "Some people study and don't fail any courses."
        ],
        "premises-FOL": [
            "∀x (Graduates(x) → Employed(x)) ::: Anyone who graduates is employed.",
            "∃x (Studies(x) ∧ TakesExam(x)) ::: Some students study and take an exam.",
            "∀x (Studies(x) → AttendsLecture(x)) ::: Anyone who studies attends lectures.",
            "∀x (TakesExam(x) → (PassesExam(x) ∨ FailsCourse(x))) ::: Anyone who takes an exam, either passes or fails.",
            "∀x (FailsCourse(x) → ¬Graduates(x)) ::: If someone fails a course, they don't graduate.",
            "∀x ((Studies(x) ∧ AttendsLecture(x)) → (PassesExam(x) ∨ FailsCourse(x))) ::: If someone studies and attends lectures, they either pass or fail.",
            "∃x (AttendsLecture(x) ∧ PassesExam(x)) ::: Some people who attend lectures, pass exams.",
            "∀x (PassesExam(x) → Employed(x)) ::: Those who pass the exam, are employed.",
            "∀x (Employed(x) → (Studies(x) ∨ Graduates(x))) ::: Anyone who is employed studies or graduates.",
            "∀x (Studies(x) → (AttendsLecture(x) ∨ TakesExam(x))) ::: If someone studies, they attend lectures or takes exams.",
            "∀x (TakesExam(x) → Studies(x)) ::: Anyone who takes an exam studies.",
            "∀x (¬FailsCourse(x) → (PassesExam(x) ∨ Studies(x))) ::: If someone doesn't fail a course, they pass an exam or study.",
            "∀x (TakesExam(x) → Student(x)) ::: Students take exams.",
            "∀x (¬TakesExam(x) → (¬Studies(x) ∧ ¬Graduates(x))) ::: If someone doesn't take an exam, they don't study or graduate.",
            "∀x (Employed(x) → ¬FailsCourse(x)) ::: If someone is employed, they don't fail a course.",
            "∃x (Studies(x) ∧ ¬FailsCourse(x)) ::: Some people study and don't fail any courses."
        ],
        "predicates": [
            "Graduates(x) ::: x graduates",
            "Studies(x) ::: x studies",
            "FailsCourse(x) ::: x fails a course",
            "Employed(x) ::: x is employed",
            "TakesExam(x) ::: x takes an exam",
            "PassesExam(x) ::: x passes the exam",
            "AttendsLecture(x) ::: x attends a lecture"
        ]
    },
    {
        "premises-NL": [
            "All scientists conduct research.",
            "Engineers apply theory.",
            "Anyone who conducts research has knowledge.",
            "Anyone who applies theory solves problems.",
            "Anyone who solves problems creates inventions.",
            "All engineers design systems or build prototypes.",
            "Someone who creates inventions either solves problems or applies theory.",
            "Anyone who designs systems is an engineer.",
            "If someone conducts research they apply theory.",
            "If someone builds a prototype, they solve problems.",
            "Anyone that designs systems has knowledge.",
            "Anyone that builds prototype is an engineer.",
            "Those that build prototype has knowledge or creates invention.",
            "If someone has knowledge or solves problem, they create inventions.",
            "Anyone that conducts research or apply theory, is a scientist or an engineer.",
            "If someone has knowledge, they do not design a system, nor build a prototype, nor apply theory, nor solve problems."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → ConductsResearch(x)) ::: All scientists conduct research.",
            "∀x (Engineer(x) → AppliesTheory(x)) ::: Engineers apply theory.",
            "∀x (ConductsResearch(x) → HasKnowledge(x)) ::: Anyone who conducts research has knowledge.",
            "∀x (AppliesTheory(x) → SolvesProblems(x)) ::: Anyone who applies theory solves problems.",
            "∀x (SolvesProblems(x) → CreatesInventions(x)) ::: Anyone who solves problems creates inventions.",
            "∀x (Engineer(x) → (DesignsSystem(x) ∨ BuildsPrototype(x))) ::: All engineers design systems or build prototypes.",
            "∀x (CreatesInventions(x) → (SolvesProblems(x) ∨ AppliesTheory(x))) ::: Someone who creates inventions either solves problems or applies theory.",
            "∀x (DesignsSystem(x) → Engineer(x)) ::: Anyone who designs systems is an engineer.",
            "∀x (ConductsResearch(x) → AppliesTheory(x)) ::: If someone conducts research they apply theory.",
            "∀x (BuildsPrototype(x) → SolvesProblems(x)) ::: If someone builds a prototype, they solve problems.",
            "∀x (DesignsSystem(x) → HasKnowledge(x)) ::: Anyone that designs systems has knowledge.",
            "∀x (BuildsPrototype(x) → Engineer(x)) ::: Anyone that builds prototype is an engineer.",
            "∀x (BuildsPrototype(x) → (HasKnowledge(x) ∨ CreatesInventions(x))) ::: Those that build prototype has knowledge or creates invention.",
            "∀x ((HasKnowledge(x) ∨ SolvesProblems(x)) → CreatesInventions(x)) ::: If someone has knowledge or solves problem, they create inventions.",
            "∀x ((ConductsResearch(x) ∨ AppliesTheory(x)) → (Scientist(x) ∨ Engineer(x))) ::: Anyone that conducts research or apply theory, is a scientist or an engineer.",
            "∀x (HasKnowledge(x) → (¬DesignsSystem(x) ∧ ¬BuildsPrototype(x) ∧ ¬AppliesTheory(x) ∧ ¬SolvesProblems(x))) ::: If someone has knowledge, they do not design a system, nor build a prototype, nor apply theory, nor solve problems."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Engineer(x) ::: x is an engineer",
            "HasKnowledge(x) ::: x has knowledge",
            "CreatesInventions(x) ::: x creates inventions",
            "ConductsResearch(x) ::: x conducts research",
            "AppliesTheory(x) ::: x applies theory",
            "SolvesProblems(x) ::: x solves problems",
            "DesignsSystem(x) ::: x designs systems",
            "BuildsPrototype(x) ::: x builds a prototype"
        ]
    },
    {
        "premises-NL": [
            "Every programmer is a student.",
            "Some students are programmers.",
            "Anyone who is a student and takes a class is skilled.",
            "All experts are skilled.",
            "Everyone enrolled in a course takes that course.",
            "If x is enrolled in a class, then x takes that class.",
            "Some students are enrolled in a programming course.",
            "Being a programmer implies being skilled.",
            "x is a programmer if they take programming classes.",
            "Programming classes are taught to students only.",
            "If someone is enrolled, they are taking a class."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → Student(x)) ::: Every programmer is a student.",
            "∃x (Student(x) ∧ Programmer(x)) ::: Some students are programmers.",
            "∀x ∀y ((Student(x) ∧ TakesClass(x, y)) → Skilled(x)) ::: Anyone who is a student and takes a class is skilled.",
            "∀x (Expert(x) → Skilled(x)) ::: All experts are skilled.",
            "∀x ∀y (Enrolled(x, y) → TakesClass(x, y)) ::: Everyone enrolled in a course takes that course.",
            "∀x ∀y (Enrolled(x,y) → TakesClass(x, y)) ::: If x is enrolled in a class, then x takes that class.",
            "∃x ∃y (Student(x) ∧ Enrolled(x, y) ∧ ClassType(y, 'Programming')) ::: Some students are enrolled in a programming course.",
            "∀x (Programmer(x) → Skilled(x)) ::: Being a programmer implies being skilled.",
            "∀x ∀y (TakesClass(x, y) ∧ ClassType(y, 'Programming') → Programmer(x)) ::: x is a programmer if they take programming classes.",
            "∀x ∀y (ClassType(y, 'Programming') → Student(x)) ::: Programming classes are taught to students only.",
            "∀x ∀y (Enrolled(x,y) → TakesClass(x,y)) ::: If someone is enrolled, they are taking a class."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Programmer(x) ::: x is a programmer",
            "Enrolled(x,y) ::: x is enrolled in y",
            "TakesClass(x,y) ::: x takes class y",
            "Skilled(x) ::: x is skilled",
            "Expert(x) ::: x is an expert"
        ]
    },
    {
        "premises-NL": [
            "Every company that needs capital is profitable.",
            "Any company that raises capital attracts investors.",
            "If a company raises capital, it needs capital.",
            "If a company generates profit, it has revenue.",
            "If a company attracts investors, it expands.",
            "Any company that expands grows.",
            "Some companies raise capital.",
            "If a company is profitable and attracts investors, it grows.",
            "If x needs capital, then x is profitable.",
            "Every company is either profitable or not sustainable.",
            "If a company expands, it employs people.",
            "A company that generates profit needs capital."
        ],
        "premises-FOL": [
            "∀x (NeedsCapital(x) → Profitable(x)) ::: Every company that needs capital is profitable.",
            "∀x (RaisesCapital(x, y) → AttractsInvestors(x)) ::: Any company that raises capital attracts investors.",
            "∀x (RaisesCapital(x, y) → NeedsCapital(x)) ::: If a company raises capital, it needs capital.",
            "∀x ∀y (GeneratesProfit(x, y) → HasRevenue(x, y)) ::: If a company generates profit, it has revenue.",
            "∀x (AttractsInvestors(x) → Expands(x)) ::: If a company attracts investors, it expands.",
            "∀x (Expands(x) → Grows(x)) ::: Any company that expands grows.",
            "∃x ∃y (Company(x) ∧ RaisesCapital(x, y)) ::: Some companies raise capital.",
            "∀x ((Profitable(x) ∧ AttractsInvestors(x)) → Grows(x)) ::: If a company is profitable and attracts investors, it grows.",
            "∀x (NeedsCapital(x) → Profitable(x)) ::: If x needs capital, then x is profitable.",
            "∀x (Company(x) → (Profitable(x) ∨ ¬IsSustainable(x))) ::: Every company is either profitable or not sustainable.",
            "∀x ∀y (Expands(x) → Employs(x, y)) ::: If a company expands, it employs people.",
            "∀x ∀y (GeneratesProfit(x, y) → NeedsCapital(x)) ::: A company that generates profit needs capital."
        ],
        "predicates": [
            "Company(x) ::: x is a company",
            "Profitable(x) ::: x is profitable",
            "Invests(x,y) ::: x invests in y",
            "Grows(x) ::: x grows",
            "NeedsCapital(x) ::: x needs capital",
            "RaisesCapital(x,y) ::: x raises capital from y",
            "HasRevenue(x,y) ::: x has revenue y",
            "GeneratesProfit(x,y) ::: x generates profit y",
            "AttractsInvestors(x) ::: x attracts investors",
            "IsSustainable(x) ::: x is sustainable",
            "Employs(x,y) ::: x employs y",
            "Expands(x) ::: x expands"
        ]
    },
    {
        "premises-NL": [
            "All creatures have life.",
            "All creatures are animals.",
            "If something has life, it needs food.",
            "All mammals eat food.",
            "If something has life, it needs water.",
            "Every herbivore eats plants.",
            "Every animal is either a herbivore or a carnivore.",
            "Every carnivore eats meat.",
            "If something is an animal, then it needs water.",
            "Animals live in habitats.",
            "If something lives in an aquatic habitat, then it can swim.",
            "If something breathes air, then it has life.",
            "All reptiles need water to survive.",
            "Every mammal breathes air."
        ],
        "premises-FOL": [
            "∀x (Creature(x) → HasLife(x)) ::: All creatures have life.",
            "∀x (Creature(x) → Animal(x)) ::: All creatures are animals.",
            "∀x (HasLife(x) → EatsFood(x)) ::: If something has life, it needs food.",
            "∀x (IsMammal(x) → EatsFood(x)) ::: All mammals eat food.",
            "∀x (HasLife(x) → NeedsWater(x)) ::: If something has life, it needs water.",
            "∀x (IsHerbivore(x) → EatsPlants(x)) ::: Every herbivore eats plants.",
            "∀x (Animal(x) → (IsHerbivore(x) ∨ IsCarnivore(x))) ::: Every animal is either a herbivore or a carnivore.",
            "∀x (IsCarnivore(x) → EatsMeat(x)) ::: Every carnivore eats meat.",
            "∀x (Animal(x) → NeedsWater(x)) ::: If something is an animal, then it needs water.",
            "∀x ∃y LivesInHabitat(x, y) ::: Animals live in habitats.",
            "∀x (LivesInHabitat(x, 'Aquatic') → CanSwim(x)) ::: If something lives in an aquatic habitat, then it can swim.",
            "∀x (BreathesAir(x) → HasLife(x)) ::: If something breathes air, then it has life.",
            "∀x (IsReptile(x) → NeedsWater(x)) ::: All reptiles need water to survive.",
            "∀x (IsMammal(x) → BreathesAir(x)) ::: Every mammal breathes air."
        ],
        "predicates": [
            "Creature(x) ::: x is a creature",
            "HasLife(x) ::: x has life",
            "Animal(x) ::: x is an animal",
            "EatsFood(x) ::: x eats food",
            "IsMammal(x) ::: x is a mammal",
            "NeedsWater(x) ::: x needs water",
            "IsHerbivore(x) ::: x is a herbivore",
            "EatsPlants(x) ::: x eats plants",
            "IsCarnivore(x) ::: x is a carnivore",
            "EatsMeat(x) ::: x eats meat",
            "LivesInHabitat(x,y) ::: x lives in habitat y",
            "IsAquatic(x) ::: x is aquatic",
            "CanSwim(x) ::: x can swim",
            "BreathesAir(x) ::: x breathes air",
            "IsReptile(x) ::: x is a reptile"
        ]
    },
    {
        "premises-NL": [
            "All students take exams.",
            "Anyone who studies hard takes exams.",
            "If someone takes the exam, they either pass or fail.",
            "Anyone who passes the exam is successful.",
            "John is a student.",
            "John studies hard.",
            "Anyone who studies hard takes an exam.",
            "If John studies hard, then he passes the exam.",
            "John is successful.",
            "If John is a student and studies hard, then John is successful.",
            "Every student takes an exam and passes it.",
            "Everyone either passes or fails.",
            "If someone is a student, then they study hard.",
            "If someone is successful, then they are a student.",
            "Some students study hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakesExam(x)) ::: All students take exams",
            "∀x (StudyHard(x) → TakesExam(x)) ::: Anyone who studies hard takes exams",
            "∀x (TakesExam(x) → (PassExam(x) ∨ ¬PassExam(x))) ::: If someone takes the exam, they either pass or fail",
            "∀x (PassExam(x) → Successful(x)) ::: Anyone who passes the exam is successful",
            "Student(john) ::: John is a student",
            "StudyHard(john) ::: John studies hard",
            "∀x (StudyHard(x) → TakesExam(x)) ::: Anyone who studies hard takes an exam",
            "StudyHard(john) → PassExam(john) ::: If John studies hard, then he passes the exam",
            "Successful(john) ::: John is successful",
            "(Student(john) ∧ StudyHard(john)) → Successful(john) ::: If John is a student and studies hard, then John is successful",
            "∀x (Student(x) → (TakesExam(x) ∧ PassExam(x))) ::: Every student takes an exam and passes it",
            "∀x (PassExam(x) ∨ ¬PassExam(x)) ::: Everyone either passes or fails",
            "∀x (Student(x) → StudyHard(x)) ::: If someone is a student, then they study hard",
            "∀x (Successful(x) → Student(x)) ::: If someone is successful, then they are a student",
            "∃x (Student(x) ∧ StudyHard(x)) ::: Some students study hard"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudyHard(x) ::: x studies hard",
            "TakesExam(x) ::: x takes an exam",
            "PassExam(x) ::: x passes the exam",
            "Successful(x) ::: x is successful"
        ]
    },
    {
        "premises-NL": [
            "All people who enjoy reading read books.",
            "Anyone who reads books either goes to the library or does not.",
            "Some people who go to the library like animals.",
            "If someone likes animals, then they may own a pet.",
            "John enjoys reading.",
            "John reads books.",
            "John goes to the library.",
            "John likes animals.",
            "John owns a pet.",
            "Everyone who has a dog likes animals.",
            "Anyone who has a cat likes animals.",
            "John is a student.",
            "If John reads books, then he enjoys reading.",
            "If someone visits the library and likes animals, then they own a pet.",
            "If someone enjoys reading and owns a pet, then that person is not a student.",
            "If someone is a student, they do not own a pet.",
            "If someone likes animals, then they read books.",
            "If someone owns a pet, then that person does not enjoy reading."
        ],
        "premises-FOL": [
            "∀x (EnjoysReading(x) → ReadsBooks(x)) ::: All people who enjoy reading read books",
            "∀x (ReadsBooks(x) → (VisitsLibrary(x) ∨ ¬VisitsLibrary(x))) ::: Anyone who reads books either goes to the library or does not",
            "∃x (VisitsLibrary(x) ∧ LikesAnimals(x)) ::: Some people who go to the library like animals",
            "∀x (LikesAnimals(x) → (OwnsPet(x) ∨ ¬OwnsPet(x))) ::: If someone likes animals, then they may own a pet",
            "EnjoysReading(john) ::: John enjoys reading",
            "ReadsBooks(john) ::: John reads books",
            "VisitsLibrary(john) ::: John goes to the library",
            "LikesAnimals(john) ::: John likes animals",
            "OwnsPet(john) ::: John owns a pet",
            "∀x (HasDog(x) → LikesAnimals(x)) ::: Everyone who has a dog likes animals",
            "∀x (HasCat(x) → LikesAnimals(x)) ::: Anyone who has a cat likes animals",
            "IsStudent(john) ::: John is a student",
            "ReadsBooks(john) → EnjoysReading(john) ::: If John reads books, then he enjoys reading",
            "(VisitsLibrary(x) ∧ LikesAnimals(x)) → OwnsPet(x) ::: If someone visits the library and likes animals, then they own a pet",
            "(EnjoysReading(x) ∧ OwnsPet(x)) → ¬IsStudent(x) ::: If someone enjoys reading and owns a pet, then that person is not a student",
            "∀x (IsStudent(x) → ¬OwnsPet(x)) ::: If someone is a student, they do not own a pet",
            "∀x (LikesAnimals(x) → ReadsBooks(x)) ::: If someone likes animals, then they read books",
            "∀x (OwnsPet(x) → ¬EnjoysReading(x)) ::: If someone owns a pet, then that person does not enjoy reading"
        ],
        "predicates": [
            "EnjoysReading(x) ::: x enjoys reading",
            "OwnsPet(x) ::: x owns a pet",
            "LikesAnimals(x) ::: x likes animals",
            "ReadsBooks(x) ::: x reads books",
            "VisitsLibrary(x) ::: x visits the library",
            "HasDog(x) ::: x has a dog",
            "HasCat(x) ::: x has a cat",
            "IsStudent(x) ::: x is a student"
        ]
    },
    {
        "premises-NL": [
            "All students study either math or physics.",
            "Alice is a student.",
            "Bob is a student.",
            "Alice likes math.",
            "If someone studies math, they like math.",
            "If someone studies physics, they like physics.",
            "Bob studies physics.",
            "Alice and Bob are related.",
            "Anyone who is related to someone studying math also likes physics."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Studies(x, math) ∨ Studies(x, physics))) ::: For all x, if x is a student, then x studies math or physics.",
            "Student(alice) ::: Alice is a student.",
            "Student(bob) ::: Bob is a student.",
            "LikesMath(alice) ::: Alice likes math.",
            "∀x (Studies(x, math) → LikesMath(x)) ::: For all x, if x studies math, then x likes math.",
            "∀x (Studies(x, physics) → LikesPhysics(x)) ::: For all x, if x studies physics, then x likes physics.",
            "Studies(bob, physics) ::: Bob studies physics.",
            "IsRelatedTo(alice, bob) ::: Alice and Bob are related.",
            "∀x ∀y (IsRelatedTo(x, y) ∧ Studies(y, math) → LikesPhysics(x)) ::: For all x and y, if x is related to y and y studies math, then x likes physics."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "LikesMath(x) ::: x likes math",
            "LikesPhysics(x) ::: x likes physics",
            "Studies(x, y) ::: x studies y",
            "IsRelatedTo(x, y) ::: x is related to y"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "Some surgeons work at City Hospital.",
            "All surgeons are specialists.",
            "No specialist treats all patients.",
            "Some doctors don't work at City Hospital.",
            "If someone is a doctor and doesn't work at City Hospital, they don't treat patients.",
            "If a doctor works at a hospital, they treat patients.",
            "David is a surgeon.",
            "All doctors are either specialists or non-specialists.",
            "There is no doctor who is neither a specialist nor does not treat patients."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: For all x, if x is a surgeon, then x is a doctor.",
            "∃x (Surgeon(x) ∧ WorksAtHospital(x, cityHospital)) ::: There exists a surgeon who works at City Hospital.",
            "∀x (Surgeon(x) → Specialist(x)) ::: For all x, if x is a surgeon, then x is a specialist.",
            "∀x (Specialist(x) → ¬TreatsAllPatients(x)) ::: For all x, if x is a specialist, then x doesn't treat all patients.",
            "∃x (Doctor(x) ∧ ¬WorksAtHospital(x, cityHospital)) ::: There exists a doctor who doesn't work at City Hospital.",
            "∀x (Doctor(x) ∧ ¬WorksAtHospital(x, cityHospital) → ¬TreatsPatients(x)) ::: For all x, if x is a doctor and doesn't work at City Hospital, then x doesn't treat patients.",
            "∀x ∀y (Doctor(x) ∧ WorksAtHospital(x, y) → TreatsPatients(x)) ::: For all x and y, if x is a doctor and works at hospital y, then x treats patients.",
            "Surgeon(david) ::: David is a surgeon.",
            "∀x (Doctor(x) → (Specialist(x) ∨ ¬Specialist(x))) ::: For all x, a doctor is either a specialist or not.",
            "¬∃x (Doctor(x) ∧ ¬Specialist(x) ∧ TreatsPatients(x)) ::: There does not exist a doctor who is not a specialist and treats patients."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Specialist(x) ::: x is a specialist",
            "TreatsPatients(x) ::: x treats patients",
            "Surgeon(x) ::: x is a surgeon",
            "WorksAtHospital(x, y) ::: x works at hospital y"
        ]
    },
    {
        "premises-NL": [
            "All patients who are infected have a fever.",
            "Some patients are coughing.",
            "Every patient who has a fever is sick.",
            "All sick patients have a disease.",
            "Every patient who has a disease is infected.",
            "Some patients are exposed to the virus.",
            "Every patient who is exposed to the virus feels sick.",
            "If a patient feels sick and is coughing, then they have a fever.",
            "If a patient takes medication, they are not infected.",
            "There is a patient who feels sick and is coughing.",
            "Every patient who has a disease does not take medication.",
            "There is a patient."
        ],
        "premises-FOL": [
            "∀x (Infected(x) → HasFever(x)) ::: All patients who are infected have a fever.",
            "∃x Coughing(x) ::: Some patients are coughing.",
            "∀x (HasFever(x) → FeelsSick(x)) ::: Every patient who has a fever is sick.",
            "∀x (FeelsSick(x) → HasDisease(x)) ::: All sick patients have a disease.",
            "∀x (HasDisease(x) → Infected(x)) ::: Every patient who has a disease is infected.",
            "∃x ExposedToVirus(x) ::: Some patients are exposed to the virus.",
            "∀x (ExposedToVirus(x) → FeelsSick(x)) ::: Every patient who is exposed to the virus feels sick.",
            "∀x ((FeelsSick(x) ∧ Coughing(x)) → HasFever(x)) ::: If a patient feels sick and is coughing, then they have a fever.",
            "∀x (TakesMedication(x) → ¬Infected(x)) ::: If a patient takes medication, they are not infected.",
            "∃x (FeelsSick(x) ∧ Coughing(x)) ::: There is a patient who feels sick and is coughing.",
            "∀x (HasDisease(x) → ¬TakesMedication(x)) ::: Every patient who has a disease does not take medication.",
            "∃x Patient(x) ::: There is a patient."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient",
            "HasFever(x) ::: x has a fever",
            "Coughing(x) ::: x is coughing",
            "Infected(x) ::: x is infected",
            "TakesMedication(x) ::: x takes medication",
            "FeelsSick(x) ::: x feels sick",
            "HasDisease(x) ::: x has a disease",
            "ExposedToVirus(x) ::: x is exposed to the virus"
        ]
    },
    {
        "premises-NL": [
            "All employees who receive a bonus are satisfied.",
            "Some employees work hard.",
            "Every employee who works hard gets a promotion.",
            "Every employee who gets a promotion is rewarded.",
            "All rewarded employees are satisfied.",
            "Some employees do not meet expectations.",
            "If an employee does not meet expectations, then they do not get promoted.",
            "If an employee is rewarded, they meet expectations.",
            "If an employee gets a promotion, then they receives a bonus.",
            "All employees are employees.",
            "If an employee works hard, the employee is an employee.",
            "If an employee does not meet expectations, they are not satisfied.",
            "An employee that receives a bonus, works hard."
        ],
        "premises-FOL": [
            "∀x (ReceivesBonus(x) → Satisfied(x)) ::: All employees who receive a bonus are satisfied.",
            "∃x WorksHard(x) ::: Some employees work hard.",
            "∀x (WorksHard(x) → GetsPromotion(x)) ::: Every employee who works hard gets a promotion.",
            "∀x (GetsPromotion(x) → IsRewarded(x)) ::: Every employee who gets a promotion is rewarded.",
            "∀x (IsRewarded(x) → Satisfied(x)) ::: All rewarded employees are satisfied.",
            "∃x ¬MeetsExpectations(x) ::: Some employees do not meet expectations.",
            "∀x (¬MeetsExpectations(x) → ¬GetsPromotion(x)) ::: If an employee does not meet expectations, then they do not get promoted.",
            "∀x (IsRewarded(x) → MeetsExpectations(x)) ::: If an employee is rewarded, they meet expectations.",
            "∀x (GetsPromotion(x) → ReceivesBonus(x)) ::: If an employee gets a promotion, then they receives a bonus.",
            "∀x Employee(x) ::: All employees are employees.",
            "∀x (WorksHard(x) → Employee(x)) ::: If an employee works hard, the employee is an employee.",
            "∀x (¬MeetsExpectations(x) → ¬Satisfied(x)) ::: If an employee does not meet expectations, they are not satisfied.",
            "∀x (ReceivesBonus(x) → WorksHard(x)) ::: An employee that receives a bonus, works hard."
        ],
        "predicates": [
            "Employee(x) ::: x is an employee",
            "Satisfied(x) ::: x is satisfied",
            "ReceivesBonus(x) ::: x receives a bonus",
            "WorksHard(x) ::: x works hard",
            "GetsPromotion(x) ::: x gets a promotion",
            "IsRewarded(x) ::: x is rewarded",
            "MeetsExpectations(x) ::: x meets expectations"
        ]
    },
    {
        "premises-NL": [
            "All scientists who are studying genetics read papers.",
            "Some scientists publish results.",
            "Every scientist who publishes results is interested in the results.",
            "All scientists working at a university attend conferences.",
            "Some scientists are studying genetics.",
            "Every scientist who reads papers is studying genetics.",
            "Every scientist who attends conferences presents results.",
            "Every scientist who presents results is interested in the results.",
            "Some scientists read papers.",
            "Every scientist that presents results, is a scientist.",
            "Every scientist studies genetics or they do not attend conferences.",
            "A scientist who publishes results reads papers.",
            "Every scientist works at a university and is a scientist.",
            "There is a scientist who publishes results and studies genetics.",
            "If a scientist is studying genetics, then the scientist reads papers and is a scientist."
        ],
        "premises-FOL": [
            "∀x (StudyingGenetics(x) → ReadsPapers(x)) ::: All scientists who are studying genetics read papers.",
            "∃x PublishesResults(x) ::: Some scientists publish results.",
            "∀x (PublishesResults(x) → InterestedInResults(x)) ::: Every scientist who publishes results is interested in the results.",
            "∀x (WorksAtUniversity(x) → AttendsConference(x)) ::: All scientists working at a university attend conferences.",
            "∃x StudyingGenetics(x) ::: Some scientists are studying genetics.",
            "∀x (ReadsPapers(x) → StudyingGenetics(x)) ::: Every scientist who reads papers is studying genetics.",
            "∀x (AttendsConference(x) → PresentsResults(x)) ::: Every scientist who attends conferences presents results.",
            "∀x (PresentsResults(x) → InterestedInResults(x)) ::: Every scientist who presents results is interested in the results.",
            "∃x ReadsPapers(x) ::: Some scientists read papers.",
            "∀x (PresentsResults(x) → Scientist(x)) ::: Every scientist that presents results, is a scientist.",
            "∀x (Scientist(x) → (StudyingGenetics(x) ∨ ¬AttendsConference(x))) ::: Every scientist studies genetics or they do not attend conferences.",
            "∀x (PublishesResults(x) → ReadsPapers(x)) ::: A scientist who publishes results reads papers.",
            "∀x (WorksAtUniversity(x) ∧ Scientist(x)) ::: Every scientist works at a university and is a scientist.",
            "∃x (PublishesResults(x) ∧ StudyingGenetics(x)) ::: There is a scientist who publishes results and studies genetics.",
            "∀x (StudyingGenetics(x) → (ReadsPapers(x) ∧ Scientist(x))) ::: If a scientist is studying genetics, then the scientist reads papers and is a scientist."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "StudyingGenetics(x) ::: x is studying genetics",
            "InterestedInResults(x) ::: x is interested in the results",
            "ReadsPapers(x) ::: x reads papers",
            "PublishesResults(x) ::: x publishes results",
            "WorksAtUniversity(x) ::: x works at a university",
            "AttendsConference(x) ::: x attends a conference",
            "PresentsResults(x) ::: x presents results"
        ]
    },
    {
        "premises-NL": [
            "All students take either Math or Physics.",
            "Some students do not take Math.",
            "x is a student, y is a student. If x takes Math and y takes Physics, then x and y are colleagues.",
            "If someone takes Math, they study hard.",
            "If someone studies hard and they are a student, then they graduate."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (TakesMath(x) ∨ TakesPhysics(x))) ::: For all x, if x is a student, then x takes Math or Physics.",
            "∃x (Student(x) ∧ ¬TakesMath(x)) ::: There exists a student who does not take Math.",
            "∀x ∀y ((Student(x) ∧ Student(y) ∧ TakesMath(x) ∧ TakesPhysics(y)) → Colleagues(x, y)) ::: For all x and y, if x is a student, y is a student, x takes Math, and y takes Physics, then x and y are colleagues.",
            "∀x (TakesMath(x) → StudiesHard(x)) ::: For all x, if x takes Math, then x studies hard.",
            "∀x ((StudiesHard(x) ∧ Student(x)) → Graduates(x)) ::: For all x, if x studies hard and is a student, then x graduates.",
            "∀x (Graduates(x) → HasJob(x)) ::: If x graduates, then x has a job.",
            "∃x (HasJob(x)) ::: Someone has a job."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "TakesMath(x) ::: x takes Math",
            "TakesPhysics(x) ::: x takes Physics"
        ]
    },
    {
        "premises-NL": [
            "All doctors are either specialists or general practitioners.",
            "Some doctors are not specialists.",
            "If x is a specialist, x has specific skills.",
            "If x is a doctor and x has specific skills, x is an expert.",
            "If x is an expert, x is respected.",
            "If someone is not respected, they are alone.",
            "Anyone who's alone is sad.",
            "If x is happy, x is sociable."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → (Specialist(x) ∨ GeneralPractitioner(x))) ::: For all x, if x is a doctor, then x is a specialist or a general practitioner.",
            "∃x (Doctor(x) ∧ ¬Specialist(x)) ::: There exists a doctor who is not a specialist.",
            "∀x (Specialist(x) → HasSpecificSkills(x)) ::: For all x, if x is a specialist, then x has specific skills.",
            "∀x ((Doctor(x) ∧ HasSpecificSkills(x)) → Expert(x)) ::: For all x, if x is a doctor and has specific skills, then x is an expert.",
            "∀x (Expert(x) → Respected(x)) ::: For all x, if x is an expert, then x is respected.",
            "∀x (¬Respected(x) → Alone(x)) ::: For all x, if x is not respected, then x is alone.",
            "∀x (Alone(x) → Sad(x)) ::: For all x, if x is alone, then x is sad.",
            "∀x (Happy(x) → Sociable(x)) ::: For all x, if x is happy, then x is sociable."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Specialist(x) ::: x is a specialist",
            "GeneralPractitioner(x) ::: x is a general practitioner"
        ]
    },
    {
        "premises-NL": [
            "Everyone who likes apples also likes bananas.",
            "Someone likes apples.",
            "Anyone who likes bananas and apples also likes carrots.",
            "If x likes bananas and x likes apples, then x is happy.",
            "If x is happy, x is cheerful.",
            "If x is cheerful, x is a friend.",
            "If x is a friend and y is a friend, then they are companions.",
            "Some companions share secrets.",
            "If x likes carrots and x shares a secret, then x is trustworthy."
        ],
        "premises-FOL": [
            "∀x (LikesApples(x) → LikesBananas(x)) ::: For all x, if x likes apples, then x likes bananas.",
            "∃x LikesApples(x) ::: There exists someone who likes apples.",
            "∀x ((LikesBananas(x) ∧ LikesApples(x)) → LikesCarrots(x)) ::: For all x, if x likes bananas and apples, then x likes carrots.",
            "∀x ((LikesBananas(x) ∧ LikesApples(x)) → Happy(x)) ::: For all x, if x likes bananas and apples, then x is happy.",
            "∀x (Happy(x) → Cheerful(x)) ::: For all x, if x is happy, then x is cheerful.",
            "∀x (Cheerful(x) → Friend(x)) ::: For all x, if x is cheerful, then x is a friend.",
            "∀x ∀y ((Friend(x) ∧ Friend(y)) → Companions(x, y)) ::: For all x and y, if x and y are friends, then they are companions.",
            "∃x ∃y (Companions(x, y) ∧ SharesSecrets(x, y)) ::: There exist x and y who are companions and share secrets.",
            "∀x (LikesCarrots(x) ∧ SharesSecrets(x, y) → Trustworthy(x)) ::: For all x, if x likes carrots and shares secrets with y, then x is trustworthy."
        ],
        "predicates": [
            "LikesApples(x) ::: x likes apples",
            "LikesBananas(x) ::: x likes bananas",
            "LikesCarrots(x) ::: x likes carrots"
        ]
    },
    {
        "premises-NL": [
            "All mammals are warm-blooded.",
            "Some animals are mammals.",
            "If x is a mammal, x has fur.",
            "If x has fur, then x is alive.",
            "If x is alive, then x needs oxygen.",
            "If x is warm-blooded, then x is alive.",
            "If x needs oxygen and y is alive, then they are related.",
            "If x is warm-blooded and has fur, then x is friendly.",
            "If x is friendly, then x is social.",
            "If x is social, then x is communicative.",
            "If x is an animal and social, then x is interesting."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → WarmBlooded(x)) ::: For all x, if x is a mammal, then x is warm-blooded.",
            "∃x (Animal(x) ∧ Mammal(x)) ::: There exists an animal which is a mammal.",
            "∀x (Mammal(x) → HasFur(x)) ::: For all x, if x is a mammal, then x has fur.",
            "∀x (HasFur(x) → Alive(x)) ::: For all x, if x has fur, then x is alive.",
            "∀x (Alive(x) → NeedsOxygen(x)) ::: For all x, if x is alive, then x needs oxygen.",
            "∀x (WarmBlooded(x) → Alive(x)) ::: For all x, if x is warm-blooded, then x is alive.",
            "∀x ∀y ((NeedsOxygen(x) ∧ Alive(y)) → Related(x, y)) ::: For all x and y, if x needs oxygen and y is alive, then x and y are related.",
            "∀x (WarmBlooded(x) ∧ HasFur(x) → Friendly(x)) ::: For all x, if x is warm-blooded and has fur, then x is friendly.",
            "∀x (Friendly(x) → Social(x)) ::: For all x, if x is friendly, then x is social.",
            "∀x (Social(x) → Communicative(x)) ::: For all x, if x is social, then x is communicative.",
            "∀x ((Animal(x) ∧ Social(x)) → Interesting(x)) ::: For all x, if x is an animal and is social, then x is interesting."
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal",
            "WarmBlooded(x) ::: x is warm-blooded",
            "Animal(x) ::: x is an animal",
            "HasFur(x) ::: x has fur"
        ]
    },
    {
        "premises-NL": [
            "All doctors have a medical degree.",
            "Anyone with a medical degree must have studied medicine and graduated.",
            "Some doctors are successful.",
            "All successful doctors passed the exam.",
            "All successful doctors are licensed.",
            "The licensed doctors must practice medicine.",
            "Dr. Smith is a doctor.",
            "Dr. Smith completed medical degree",
            "Anyone who is a doctor is a medical professional.",
            "All medical professional attended a university.",
            "Dr. Smith is a teacher at the hospital."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → CompletedMedicalDegree(x)) ::: For all x, if x is a doctor, then x completed a medical degree.",
            "∀x (CompletedMedicalDegree(x) → (StudiedMedicine(x) ∧ Graduated(x))) ::: For all x, if x completed a medical degree, then x studied medicine and graduated.",
            "∃x (Doctor(x) ∧ SuccessfulDoctor(x)) ::: There exists an x such that x is a doctor and successful doctor.",
            "∀x (SuccessfulDoctor(x) → PassedExam(x)) ::: For all x, if x is a successful doctor, then x passed the exam.",
            "∀x (SuccessfulDoctor(x) → Licensed(x)) ::: For all x, if x is a successful doctor, then x is licensed.",
            "∀x (Licensed(x) → PracticesMedicine(x)) ::: For all x, if x is licensed, then x practices medicine.",
            "Doctor(smith) ::: Smith is a doctor.",
            "CompletedMedicalDegree(smith) ::: Smith completed medical degree",
            "∀x (Doctor(x) →  PracticesMedicine(x)) ::: If anyone is a doctor they practice medicine.",
            "∀x (PracticesMedicine(x) → AttendedUniversity(x, y)) ::: All medical professional attended a university.",
            "IsATeacher(smith, hospital) ::: Smith is a teacher at the hospital"
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "StudiedMedicine(x) ::: x studied medicine.",
            "Graduated(x) ::: x has graduated.",
            "AttendedUniversity(x, y) ::: x attended university y.",
            "MedicalSchool(y) ::: y is a medical school.",
            "PassedExam(x) ::: x passed the exam.",
            "Licensed(x) ::: x is licensed",
            "PracticesMedicine(x) ::: x practices medicine",
            "SuccessfulDoctor(x) ::: x is a successful doctor",
            "CompletedMedicalDegree(x) ::: x completed medical degree",
            "IsATeacher(x, y) ::: x is a teacher at y"
        ]
    },
    {
        "premises-NL": [
            "Everyone who works and receives a salary has a high income.",
            "If someone has a high income and has a savings account, they save money.",
            "No students have a high income.",
            "John works and receives a salary.",
            "If someone does not have a savings account, they spend money.",
            "John does not have a savings account.",
            "If a person has a high income, they have a savings account.",
            "All people who save money have a high income.",
            "Students do not save money",
            "John is not a student.",
            "Everyone has a high income or is a student.",
            "If someone has a high income, they save money"
        ],
        "premises-FOL": [
            "∀x Works(x) ∧ ReceivesSalary(x) → HighIncome(x) ::: Everyone who works and receives a salary has a high income.",
            "∀x HighIncome(x) ∧ HasSavingsAccount(x) → SavesMoney(x) ::: If someone has a high income and has a savings account, they save money.",
            "∀x Student(x) → ¬HighIncome(x) ::: No students have a high income.",
            "Works(john) ∧ ReceivesSalary(john) ::: John works and receives a salary.",
            "∀x ¬HasSavingsAccount(x) → SpendsMoney(x) ::: If someone does not have a savings account, they spend money.",
            "¬HasSavingsAccount(john) ::: John does not have a savings account.",
            "∀x HighIncome(x) → HasSavingsAccount(x) ::: If a person has a high income, they have a savings account.",
            "∀x SavesMoney(x) → HighIncome(x) ::: All people who save money have a high income.",
            "∀x Student(x) → ¬SavesMoney(x) ::: Students do not save money",
            "¬Student(john) ::: John is not a student.",
            "∀x HighIncome(x) ∨ Student(x) ::: Everyone has a high income or is a student.",
            "∀x HighIncome(x) → SavesMoney(x) ::: If someone has a high income, they save money"
        ],
        "predicates": [
            "HighIncome(x) ::: x has a high income",
            "Student(x) ::: x is a student",
            "SavesMoney(x) ::: x saves money",
            "Works(x) ::: x works",
            "HasSavingsAccount(x) ::: x has a savings account",
            "ReceivesSalary(x) ::: x receives a salary",
            "SpendsMoney(x) ::: x spends money"
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled in a course.",
            "Alex is a student.",
            "If someone is a student and studies hard, then they will pass the exam.",
            "Alex studies hard.",
            "If Alex is a student, then Alex studies hard.",
            "If someone is a student then he is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → EnrolledInCourse(x)) ::: All students are enrolled in a course.",
            "Student(Alex) ::: Alex is a student.",
            "∀x ((Student(x) ∧ StudiesHard(x)) → PassExam(x)) ::: If someone is a student and studies hard, then they will pass the exam.",
            "StudiesHard(Alex) ::: Alex studies hard.",
            "Student(Alex) → StudiesHard(Alex) ::: If Alex is a student, then Alex studies hard.",
            "∀x (Student(x) → Student(x)) ::: If someone is a student then he is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "All doctors have medical knowledge.",
            "Dr. Smith is a doctor.",
            "Dr. Smith specializes in surgery.",
            "Anyone who specializes in surgery is a doctor.",
            "If someone is a doctor and specializes in surgery, they provide treatment.",
            "If someone provides treatment, then they have medical knowledge.",
            "All doctors provide treatment."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HasMedicalKnowledge(x)) ::: All doctors have medical knowledge.",
            "Doctor(Smith) ::: Dr. Smith is a doctor.",
            "SpecializesInSurgery(Smith) ::: Dr. Smith specializes in surgery.",
            "∀x (SpecializesInSurgery(x) → Doctor(x)) ::: Anyone who specializes in surgery is a doctor.",
            "∀x (Doctor(x) ∧ SpecializesInSurgery(x) → ProvidesTreatment(x, y)) ::: If someone is a doctor and specializes in surgery, they provide treatment.",
            "∀x (ProvidesTreatment(x, y) → HasMedicalKnowledge(x)) ::: If someone provides treatment, then they have medical knowledge.",
            "∀x (Doctor(x) → ProvidesTreatment(x, y)) ::: All doctors provide treatment."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "SpecializesInSurgery(x) ::: x specializes in surgery",
            "HasMedicalKnowledge(x) ::: x has medical knowledge",
            "ProvidesTreatment(x, y) ::: x provides treatment to y"
        ]
    },
    {
        "premises-NL": [
            "All plants photosynthesize.",
            "If something photosynthesizes, it needs sunlight.",
            "If something photosynthesizes, it needs water.",
            "All growing things are plants.",
            "Something grows.",
            "Something is a plant if it grows.",
            "Plants have leaves.",
            "If something is a plant, then it photosynthesizes.",
            "Something needs sunlight."
        ],
        "premises-FOL": [
            "∀x (Plant(x) → Photosynthesizes(x)) ::: All plants photosynthesize.",
            "∀x (Photosynthesizes(x) → NeedsSunlight(x)) ::: If something photosynthesizes, it needs sunlight.",
            "∀x (Photosynthesizes(x) → NeedsWater(x)) ::: If something photosynthesizes, it needs water.",
            "∀x (Grows(x) → Plant(x)) ::: All growing things are plants.",
            "∃x Grows(x) ::: Something grows.",
            "∀x (Grows(x) → Plant(x)) ::: Something is a plant if it grows.",
            "∀x (Plant(x) → HasLeaves(x)) ::: Plants have leaves.",
            "∀x (Plant(x) → Photosynthesizes(x)) ::: If something is a plant, then it photosynthesizes.",
            "∃x NeedsSunlight(x) ::: Something needs sunlight."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "NeedsSunlight(x) ::: x needs sunlight",
            "NeedsWater(x) ::: x needs water",
            "Grows(x) ::: x grows",
            "Photosynthesizes(x) ::: x photosynthesizes"
        ]
    },
    {
        "premises-NL": [
            "All birds are animals.",
            "All birds have feathers.",
            "If something is a bird, then it can fly.",
            "If something is a bird, then it lives in trees.",
            "All animals have feathers.",
            "Something is a bird if it can fly and has feathers.",
            "If something has feathers, it is a bird.",
            "A specific entity can fly and has feathers.",
            "All birds are either animals or insects.",
            "If something is a bird and an animal, then it lives in trees.",
            "There is an animal."
        ],
        "premises-FOL": [
            "∀x (Bird(x) → IsAnimal(x)) ::: All birds are animals.",
            "∀x (Bird(x) → HasFeathers(x)) ::: All birds have feathers.",
            "∀x (Bird(x) → CanFly(x)) ::: If something is a bird, then it can fly.",
            "∀x (Bird(x) → LivesInTrees(x)) ::: If something is a bird, then it lives in trees.",
            "∀x (IsAnimal(x) → HasFeathers(x)) ::: All animals have feathers.",
            "∀x ((CanFly(x) ∧ HasFeathers(x)) → Bird(x)) ::: Something is a bird if it can fly and has feathers.",
            "∀x (HasFeathers(x) → Bird(x)) ::: If something has feathers, it is a bird.",
            "∃x (CanFly(x) ∧ HasFeathers(x)) ::: A specific entity can fly and has feathers.",
            "∀x (Bird(x) → (IsAnimal(x) ∨ IsInsect(x))) ::: All birds are either animals or insects.",
            "∀x ((Bird(x) ∧ IsAnimal(x)) → LivesInTrees(x)) ::: If something is a bird and an animal, then it lives in trees.",
            "∃x IsAnimal(x) ::: There is an animal."
        ],
        "predicates": [
            "Bird(x) ::: x is a bird",
            "CanFly(x) ::: x can fly",
            "HasFeathers(x) ::: x has feathers",
            "IsAnimal(x) ::: x is an animal",
            "LivesInTrees(x) ::: x lives in trees"
        ]
    },
    {
        "premises-NL": [
            "Every student likes homework.",
            "Anyone who likes homework has homework.",
            "If a person is a student, then they attend the lecture.",
            "If a person has homework, then they will study.",
            "John is a student.",
            "Everyone who studies will attend the lecture.",
            "Mark attends a lecture.",
            "Mark likes homework.",
            "Mark is a person."
        ],
        "premises-FOL": [
            "∀x (Student(x) → LikesHomework(x)) ::: Every student likes homework.",
            "∀x (LikesHomework(x) → HasHomework(x)) ::: Anyone who likes homework has homework.",
            "∀x (Student(x) → AttendsLecture(x)) ::: If a person is a student, then they attend the lecture.",
            "∀x (HasHomework(x) → WillStudy(x)) ::: If a person has homework, then they will study.",
            "Student(John) ::: John is a student.",
            "∀x (WillStudy(x) → AttendsLecture(x)) ::: Everyone who studies will attend the lecture.",
            "AttendsLecture(Mark) ::: Mark attends a lecture.",
            "LikesHomework(Mark) ::: Mark likes homework.",
            "Person(Mark) ::: Mark is a person."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "AttendsLecture(x) ::: x attends a lecture",
            "WillStudy(x) ::: x will study",
            "Student(x) ::: x is a student",
            "LikesHomework(x) ::: x likes homework",
            "HasHomework(x) ::: x has homework"
        ]
    },
    {
        "premises-NL": [
            "Every person either has a degree or doesn't.",
            "If someone doesn't have a degree, they are unqualified.",
            "If someone is qualified, then they get employed.",
            "If someone applies for a job and has a degree, then they get an interview.",
            "If someone gets an interview, they will pass the exam.",
            "If someone passes the exam and is employed, then they are experienced.",
            "If someone studied the material, then they know the material.",
            "If someone is experienced, then they are qualified.",
            "Mark applies for a job and has a degree.",
            "Mark studied the material.",
            "Mark is a person.",
            "If someone passes the exam then they get employed.",
            "Mark is employed."
        ],
        "premises-FOL": [
            "∀x (Person(x) → (HasDegree(x) ∨ ¬HasDegree(x))) ::: Every person either has a degree or doesn't.",
            "∀x (¬HasDegree(x) → ¬Qualified(x)) ::: If someone doesn't have a degree, they are unqualified.",
            "∀x (Qualified(x) → Employed(x)) ::: If someone is qualified, then they get employed.",
            "∀x (AppliesForJob(x) ∧ HasDegree(x) → GetsInterview(x)) ::: If someone applies for a job and has a degree, then they get an interview.",
            "∀x (GetsInterview(x) → PassesExam(x)) ::: If someone gets an interview, they will pass the exam.",
            "∀x (PassesExam(x) ∧ Employed(x) → Experienced(x)) ::: If someone passes the exam and is employed, then they are experienced.",
            "∀x ∀y (Studied(x, y) → Knows(x, y)) ::: If someone studied the material, then they know the material.",
            "∀x (Experienced(x) → Qualified(x)) ::: If someone is experienced, then they are qualified.",
            "(AppliesForJob(Mark) ∧ HasDegree(Mark)) ::: Mark applies for a job and has a degree.",
            "Studied(Mark, Material) ::: Mark studied the material.",
            "Person(Mark) ::: Mark is a person.",
            "∀x (PassesExam(x) → Employed(x)) ::: If someone passes the exam then they get employed.",
            "Employed(Mark) ::: Mark is employed."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "HasDegree(x) ::: x has a degree",
            "Employed(x) ::: x is employed",
            "Qualified(x) ::: x is qualified",
            "AppliesForJob(x) ::: x applies for a job",
            "GetsInterview(x) ::: x gets an interview",
            "PassesExam(x) ::: x passes an exam",
            "Experienced(x) ::: x is experienced",
            "Knows(x, y) ::: x knows y",
            "Studied(x, y) ::: x studied y"
        ]
    },
    {
        "premises-NL": [
            "If someone knows someone else, the other one knows the former.",
            "If someone likes someone, they are not friends.",
            "Everyone either likes or hates another person.",
            "If someone hates someone, they are not friends.",
            "If two people are related, they cannot be friends.",
            "If two people are not friends, then they can't play together.",
            "If two people share a secret, then they are friends.",
            "Anyone who likes someone, also shares a secret with that person.",
            "If someone plays with someone, they are friends."
        ],
        "premises-FOL": [
            "∀x ∀y (Knows(x, y) → Knows(y, x)) ::: If someone knows someone else, the other one knows the former.",
            "∀x ∀y (Likes(x, y) → ¬Friends(x, y)) ::: If someone likes someone, they are not friends.",
            "∀x ∃y (Likes(x, y) ∨ Hates(x, y)) ::: Everyone either likes or hates another person.",
            "∀x ∀y (Hates(x, y) → ¬Friends(x, y)) ::: If someone hates someone, they are not friends.",
            "∀x ∀y (Related(x, y) → ¬Friends(x, y)) ::: If two people are related, they cannot be friends.",
            "∀x ∀y (¬Friends(x, y) → ¬PlaysWith(x, y)) ::: If two people are not friends, then they can't play together.",
            "∀x ∀y (SharesSecret(x, y) → Friends(x, y)) ::: If two people share a secret, then they are friends.",
            "∀x ∀y (Likes(x, y) → SharesSecret(x, y)) ::: Anyone who likes someone, also shares a secret with that person.",
            "∀x ∀y (PlaysWith(x, y) → Friends(x, y)) ::: If someone plays with someone, they are friends."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Friends(x, y) ::: x and y are friends",
            "Knows(x, y) ::: x knows y",
            "Likes(x, y) ::: x likes y",
            "Hates(x, y) ::: x hates y",
            "Related(x, y) ::: x and y are related",
            "PlaysWith(x, y) ::: x plays with y",
            "SharesSecret(x, y) ::: x shares a secret with y"
        ]
    },
    {
        "premises-NL": [
            "All students study.",
            "Anyone who studies, passes the exam.",
            "John is a student.",
            "Sarah is a student.",
            "John studies.",
            "Sarah takes a course.",
            "If Sarah takes a course and the course is difficult, Sarah fails."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Studies(x)) ::: All students study.",
            "∀x (Studies(x) → PassExam(x)) ::: Anyone who studies, passes the exam.",
            "Student(john) ::: John is a student.",
            "Student(sarah) ::: Sarah is a student.",
            "Studies(john) ::: John studies.",
            "TakesCourse(sarah, course1) ::: Sarah takes a course.",
            "TakesCourse(sarah, course1) ∧ IsDifficult(course1) → ¬PassExam(sarah) ::: If Sarah takes a course and the course is difficult, Sarah fails."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "PassExam(x) ::: x passes the exam",
            "TakesCourse(x, y) ::: x takes the course y",
            "IsDifficult(y) ::: y is a difficult course",
            "Enrolls(x, y) ::: x enrolls in course y"
        ]
    },
    {
        "premises-NL": [
            "All doctors have medical licenses.",
            "All doctors treat patients.",
            "Anyone who treats patients helps people.",
            "If someone is a doctor and prescribes medication, they help people.",
            "Dr. Smith is a doctor.",
            "All doctors prescribe medication.",
            "Dr. Smith helps people.",
            "Dr. Smith has a license."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → HasLicense(x)) ::: All doctors have medical licenses.",
            "∀x (Doctor(x) → TreatsPatients(x, y)) ::: All doctors treat patients.",
            "∀x ∀y (TreatsPatients(x, y) → HelpsPeople(x)) ::: Anyone who treats patients helps people.",
            "∀x (Doctor(x) ∧ PrescribesMedication(x) → HelpsPeople(x)) ::: If someone is a doctor and prescribes medication, they help people.",
            "Doctor(smith) ::: Dr. Smith is a doctor.",
            "∀x (Doctor(x) → PrescribesMedication(x)) ::: All doctors prescribe medication.",
            "HelpsPeople(smith) ::: Dr. Smith helps people.",
            "HasLicense(smith) ::: Dr. Smith has a license."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "HelpsPeople(x) ::: x helps people",
            "PrescribesMedication(x) ::: x prescribes medication",
            "TreatsPatients(x, y) ::: x treats patient y",
            "Patient(y) ::: y is a patient",
            "NeedsHelp(y) ::: y needs help",
            "HelpfulPerson(x) ::: x is a helpful person",
            "HasLicense(x) ::: x has a medical license"
        ]
    },
    {
        "premises-NL": [
            "All scientists are researchers.",
            "All researchers who attend a conference present research.",
            "Anyone who presents research publishes papers.",
            "Scientists who attend a conference are researchers.",
            "Dr. Jones is a scientist.",
            "Dr. Jones attends a conference.",
            "Dr. Jones presents research.",
            "All who publish papers obtain funding.",
            "If someone is a scientist and a researcher, they are qualified."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Researcher(x)) ::: All scientists are researchers.",
            "∀x (Researcher(x) ∧ AttendsConference(x) → PresentsResearch(x)) ::: All researchers who attend a conference present research.",
            "∀x (PresentsResearch(x) → PublishesPapers(x)) ::: Anyone who presents research publishes papers.",
            "∀x (Scientist(x) ∧ AttendsConference(x) → Researcher(x)) ::: Scientists who attend a conference are researchers.",
            "Scientist(jones) ::: Dr. Jones is a scientist.",
            "AttendsConference(jones) ::: Dr. Jones attends a conference.",
            "PresentsResearch(jones) ::: Dr. Jones presents research.",
            "∀x (PublishesPapers(x) → ObtainsFunding(x)) ::: All who publish papers obtain funding.",
            "∀x (Scientist(x) ∧ Researcher(x) → IsQualified(x)) ::: If someone is a scientist and a researcher, they are qualified."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Researcher(x) ::: x is a researcher",
            "PublishesPapers(x) ::: x publishes papers",
            "AttendsConference(x) ::: x attends a conference",
            "PresentsResearch(x) ::: x presents research",
            "ObtainsFunding(x) ::: x obtains funding",
            "HasDegree(x, y) ::: x has degree y",
            "IsQualified(x) ::: x is qualified",
            "WorksAtUniversity(x, y) ::: x works at university y"
        ]
    },
    {
        "premises-NL": [
            "All professors teach.",
            "All professors do research.",
            "Anyone who teaches and does research publishes papers.",
            "Anyone who publishes papers receives a grant.",
            "Professor Smith is a professor.",
            "If someone teaches and does research, the university appreciates them.",
            "Professor Smith teaches.",
            "Professor Smith does research.",
            "Professor Smith is an excellent teacher.",
            "Professor Smith mentors students."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Teaches(x)) ::: All professors teach.",
            "∀x (Professor(x) → DoesResearch(x)) ::: All professors do research.",
            "∀x (Teaches(x) ∧ DoesResearch(x) → PublishesPapers(x)) ::: Anyone who teaches and does research publishes papers.",
            "∀x (PublishesPapers(x) → ReceivesGrant(x)) ::: Anyone who publishes papers receives a grant.",
            "Professor(smith) ::: Professor Smith is a professor.",
            "∀x (Teaches(x) ∧ DoesResearch(x) → AppreciatedByUniversity(x)) ::: If someone teaches and does research, the university appreciates them.",
            "Teaches(smith) ::: Professor Smith teaches.",
            "DoesResearch(smith) ::: Professor Smith does research.",
            "IsExcellentTeacher(smith) ::: Professor Smith is an excellent teacher.",
            "MentorsStudents(smith) ::: Professor Smith mentors students."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "Teaches(x) ::: x teaches",
            "DoesResearch(x) ::: x does research",
            "PublishesPapers(x) ::: x publishes papers",
            "AppreciatedByUniversity(x) ::: The university appreciates x",
            "ReceivesGrant(x) ::: x receives a grant",
            "MentorsStudents(x) ::: x mentors students",
            "WorksAt(x, y) ::: x works at y",
            "University(y) ::: y is a university",
            "IsExcellentTeacher(x) ::: x is an excellent teacher"
        ]
    },
    {
        "premises-NL": [
            "All students attend class.",
            "Everyone who attends class studies.",
            "Anyone who studies and understands the material is diligent.",
            "If someone is diligent, they will succeed.",
            "John is a student.",
            "John attends class.",
            "Anyone who attends class, studies.",
            "If someone studies, they understand the material.",
            "If someone understands material, then they are diligent.",
            "Mary is a student.",
            "Mary attends class.",
            "Mary studies.",
            "Mary understands material."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClass(x)) ::: All students attend class.",
            "∀x (AttendsClass(x) → Studies(x)) ::: Everyone who attends class studies.",
            "∀x (Studies(x) ∧ UnderstandsMaterial(x) → Diligence(x)) ::: Anyone who studies and understands the material is diligent.",
            "∀x (Diligence(x) → Succeed(x)) ::: If someone is diligent, they will succeed.",
            "Student(john) ::: John is a student.",
            "AttendsClass(john) ::: John attends class.",
            "∀x (AttendsClass(x) → Studies(x)) ::: Anyone who attends class, studies.",
            "∀x (Studies(x) → UnderstandsMaterial(x)) ::: If someone studies, they understand the material.",
            "∀x (UnderstandsMaterial(x) → Diligence(x)) ::: If someone understands material, then they are diligent.",
            "Student(mary) ::: Mary is a student.",
            "AttendsClass(mary) ::: Mary attends class.",
            "Studies(mary) ::: Mary studies.",
            "UnderstandsMaterial(mary) ::: Mary understands material."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Diligence(x) ::: x is diligent",
            "AttendsClass(x) ::: x attends class",
            "Studies(x) ::: x studies",
            "Succeed(x) ::: x succeeds",
            "UnderstandsMaterial(x) ::: x understands material"
        ]
    },
    {
        "premises-NL": [
            "All plants need water and sunlight.",
            "If a plant gets sunlight, it is green.",
            "If a plant is green and needs nutrients, then it grows.",
            "All plants have roots.",
            "If a plant has roots, then it needs water.",
            "Rose is a plant.",
            "Rose receives sunlight.",
            "Rose needs nutrients.",
            "Rose has roots.",
            "Daisy is a plant.",
            "Daisy receives sunlight.",
            "Daisy is green.",
            "Tulip is a plant.",
            "Tulip has roots.",
            "Tulip is green."
        ],
        "premises-FOL": [
            "∀x (Plant(x) → (ReceivesSunlight(x) ∧ ReceivesWater(x))) ::: All plants need water and sunlight.",
            "∀x (ReceivesSunlight(x) → IsGreen(x)) ::: If a plant gets sunlight, it is green.",
            "∀x (IsGreen(x) ∧ NeedsNutrients(x) → Grows(x)) ::: If a plant is green and needs nutrients, then it grows.",
            "∀x (Plant(x) → HasRoots(x)) ::: All plants have roots.",
            "∀x (HasRoots(x) → ReceivesWater(x)) ::: If a plant has roots, then it needs water.",
            "Plant(rose) ::: Rose is a plant.",
            "ReceivesSunlight(rose) ::: Rose receives sunlight.",
            "NeedsNutrients(rose) ::: Rose needs nutrients.",
            "HasRoots(rose) ::: Rose has roots.",
            "Plant(daisy) ::: Daisy is a plant.",
            "ReceivesSunlight(daisy) ::: Daisy receives sunlight.",
            "IsGreen(daisy) ::: Daisy is green.",
            "Plant(tulip) ::: Tulip is a plant.",
            "HasRoots(tulip) ::: Tulip has roots.",
            "IsGreen(tulip) ::: Tulip is green."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "ReceivesSunlight(x) ::: x receives sunlight",
            "ReceivesWater(x) ::: x receives water",
            "Grows(x) ::: x grows",
            "IsGreen(x) ::: x is green",
            "NeedsNutrients(x) ::: x needs nutrients",
            "HasRoots(x) ::: x has roots"
        ]
    },
    {
        "premises-NL": [
            "All people either have a fever or they don't have a cough.",
            "Some people have a cough and are not vaccinated.",
            "If someone is vaccinated, they are not infected.",
            "If someone has a fever, they are tired.",
            "John is a person.",
            "John has a fever.",
            "John is not vaccinated.",
            "Mary is a person.",
            "Mary has a cough.",
            "Mary is not vaccinated.",
            "If someone has a fever and a cough, they are tired.",
            "If someone is tired, they have a headache.",
            "If someone has a headache they might have the flu.",
            "All people with a fever or cough are infected."
        ],
        "premises-FOL": [
            "∀x (Person(x) → (HasFever(x) ∨ ¬HasCough(x))) ::: All people either have a fever or they don't have a cough.",
            "∃x (HasCough(x) ∧ ¬Vaccinated(x)) ::: Some people have a cough and are not vaccinated.",
            "∀x (Vaccinated(x) → ¬IsInfected(x)) ::: If someone is vaccinated, they are not infected.",
            "∀x (HasFever(x) → IsTired(x)) ::: If someone has a fever, they are tired.",
            "Person(john) ::: John is a person.",
            "HasFever(john) ::: John has a fever.",
            "¬Vaccinated(john) ::: John is not vaccinated.",
            "Person(mary) ::: Mary is a person.",
            "HasCough(mary) ::: Mary has a cough.",
            "¬Vaccinated(mary) ::: Mary is not vaccinated.",
            "∀x (HasFever(x) ∧ HasCough(x) → IsTired(x)) ::: If someone has a fever and a cough, they are tired.",
            "∀x (IsTired(x) → HasHeadache(x)) ::: If someone is tired, they have a headache.",
            "∀x (HasHeadache(x) → HasFlu(x)) ::: If someone has a headache they might have the flu.",
            "∀x ((HasFever(x) ∨ HasCough(x)) → IsInfected(x)) ::: All people with a fever or cough are infected."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "HasFever(x) ::: x has a fever",
            "HasCough(x) ::: x has a cough",
            "Vaccinated(x) ::: x is vaccinated",
            "HasFlu(x) ::: x has the flu",
            "IsInfected(x) ::: x is infected",
            "IsTired(x) ::: x is tired",
            "HasHeadache(x) ::: x has a headache"
        ]
    },
    {
        "premises-NL": [
            "If a country's economy grows, employment increases.",
            "If employment increases, then investments increase.",
            "If investments increase and inflation is controlled, poverty is reduced.",
            "If the economy grows and poverty is reduced, the standard of living improves.",
            "The USA is a country.",
            "The economy of the USA grows.",
            "The USA controls inflation.",
            "Canada is a country.",
            "Canada's economy grows.",
            "If a country has resources and its economy grows, inflation is controlled.",
            "If inflation is controlled and employment increases, the standard of living improves.",
            "If a country has resources, then investments increase.",
            "If a country has resources, and its economy grows, then the standard of living will improve.",
            "Japan has resources."
        ],
        "premises-FOL": [
            "∀x (EconomyGrows(x) → IncreasesEmployment(x)) ::: If a country's economy grows, employment increases.",
            "∀x (IncreasesEmployment(x) → InvestmentsIncrease(x)) ::: If employment increases, then investments increase.",
            "∀x (InvestmentsIncrease(x) ∧ ControlledInflation(x) → ReducesPoverty(x)) ::: If investments increase and inflation is controlled, poverty is reduced.",
            "∀x (EconomyGrows(x) ∧ ReducesPoverty(x) → ImproveStandardOfLiving(x)) ::: If the economy grows and poverty is reduced, the standard of living improves.",
            "Country(usa) ::: The USA is a country.",
            "EconomyGrows(usa) ::: The economy of the USA grows.",
            "ControlledInflation(usa) ::: The USA controls inflation.",
            "Country(canada) ::: Canada is a country.",
            "EconomyGrows(canada) ::: Canada's economy grows.",
            "∀x (HasResources(x) ∧ EconomyGrows(x) → ControlledInflation(x)) ::: If a country has resources and its economy grows, inflation is controlled.",
            "∀x (ControlledInflation(x) ∧ IncreasesEmployment(x) → ImproveStandardOfLiving(x)) ::: If inflation is controlled and employment increases, the standard of living improves.",
            "∀x (HasResources(x) → InvestmentsIncrease(x)) ::: If a country has resources, then investments increase.",
            "∀x (HasResources(x) ∧ EconomyGrows(x) → ImproveStandardOfLiving(x)) ::: If a country has resources, and its economy grows, then the standard of living will improve.",
            "HasResources(japan) ::: Japan has resources."
        ],
        "predicates": [
            "Country(x) ::: x is a country",
            "EconomyGrows(x) ::: The economy of x grows",
            "ControlledInflation(x) ::: Inflation is controlled in x",
            "ImproveStandardOfLiving(x) ::: The standard of living improves in x",
            "IncreasesEmployment(x) ::: Employment increases in x",
            "InvestmentsIncrease(x) ::: Investments increase in x",
            "ReducesPoverty(x) ::: Poverty reduces in x",
            "HasResources(x) ::: x has resources"
        ]
    },
    {
        "premises-NL": [
            "All doctors are people.",
            "All doctors work at a hospital.",
            "Some patients have diseases.",
            "If someone is a patient, they are not healthy.",
            "Every doctor treats every patient.",
            "Some doctors are friendly.",
            "If someone is a doctor, they help patients.",
            "If a patient has a disease, then they are at the hospital.",
            "If a doctor treats a patient then they help them.",
            "No person studies medicine or is not friendly.",
            "Some people are not friendly.",
            "If someone helps a patient then the patient is not healthy."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Person(x)) ::: All doctors are people.",
            "∀x ∃y (Doctor(x) → WorksAt(x, y)) ::: All doctors work at a hospital.",
            "∃z (Patient(z) ∧ HasDisease(z)) ::: Some patients have diseases.",
            "∀z (Patient(z) → ¬IsHealthy(z)) ::: If someone is a patient, they are not healthy.",
            "∀x ∀z (Doctor(x) ∧ Patient(z) → Treats(x, z)) ::: Every doctor treats every patient.",
            "∃x (Doctor(x) ∧ Friendly(x)) ::: Some doctors are friendly.",
            "∀x ∀z (Doctor(x) ∧ Patient(z) → HelpsPatient(x, z)) ::: If someone is a doctor, they help patients.",
            "∀z ∀y (Patient(z) ∧ HasDisease(z) → AtHospital(z, y)) ::: If a patient has a disease, then they are at the hospital.",
            "∀x ∀z (Treats(x, z) → HelpsPatient(x, z)) ::: If a doctor treats a patient then they help them.",
            "∀x (¬StudiesMedicine(x) ∨ Friendly(x)) ::: No person studies medicine or is not friendly.",
            "∃x ¬Friendly(x) ::: Some people are not friendly.",
            "∀x ∀z (HelpsPatient(x,z) → ¬IsHealthy(z)) ::: If someone helps a patient then the patient is not healthy."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "Doctor(x) ::: x is a doctor.",
            "Hospital(y) ::: y is a hospital.",
            "WorksAt(x, y) ::: x works at y.",
            "Patient(z) ::: z is a patient.",
            "HelpsPatient(x, z) ::: x helps z.",
            "HasDisease(z) ::: z has a disease.",
            "IsHealthy(z) ::: z is healthy.",
            "Treats(x, z) ::: x treats z.",
            "Friendly(x) ::: x is friendly.",
            "AtHospital(z, y) ::: z is at y.",
            "StudiesMedicine(x) ::: x studies medicine."
        ]
    },
    {
        "premises-NL": [
            "All students attend classes.",
            "Anyone who attends classes and studies hard is successful.",
            "Some students like studying.",
            "If someone studies hard, then they attend classes.",
            "All students study hard or like studying.",
            "If someone attends classes and likes studying, they are successful.",
            "There exists someone who studies hard.",
            "Every student is either successful or doesn't attend classes."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsClasses(x)) ::: All students attend classes.",
            "∀x ((AttendsClasses(x) ∧ StudiesHard(x)) → Successful(x)) ::: Anyone who attends classes and studies hard is successful.",
            "∃x (Student(x) ∧ LikesStudying(x)) ::: Some students like studying.",
            "∀x (StudiesHard(x) → AttendsClasses(x)) ::: If someone studies hard, then they attend classes.",
            "∀x (Student(x) → (StudiesHard(x) ∨ LikesStudying(x))) ::: All students study hard or like studying.",
            "∀x ((AttendsClasses(x) ∧ LikesStudying(x)) → Successful(x)) ::: If someone attends classes and likes studying, they are successful.",
            "∃x StudiesHard(x) ::: There exists someone who studies hard.",
            "∀x (Student(x) → (Successful(x) ∨ ¬AttendsClasses(x))) ::: Every student is either successful or doesn't attend classes."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "Successful(x) ::: x is successful",
            "AttendsClasses(x) ::: x attends classes",
            "LikesStudying(x) ::: x likes studying"
        ]
    },
    {
        "premises-NL": [
            "All scientists read papers.",
            "Anyone who reads papers and conducts experiments is knowledgeable.",
            "Some scientists publish results.",
            "If someone conducts experiments, then they read papers.",
            "All scientists conduct experiments or publish results.",
            "If someone reads papers and publishes results, they are knowledgeable.",
            "There exists a scientist who conducts experiments.",
            "Every scientist is either knowledgeable or doesn't read papers.",
            "Anyone using a microscope is a scientist."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → ReadsPapers(x)) ::: All scientists read papers.",
            "∀x ((ReadsPapers(x) ∧ ConductsExperiment(x)) → Knowledgeable(x)) ::: Anyone who reads papers and conducts experiments is knowledgeable.",
            "∃x (Scientist(x) ∧ PublishesResults(x)) ::: Some scientists publish results.",
            "∀x (ConductsExperiment(x) → ReadsPapers(x)) ::: If someone conducts experiments, then they read papers.",
            "∀x (Scientist(x) → (ConductsExperiment(x) ∨ PublishesResults(x))) ::: All scientists conduct experiments or publish results.",
            "∀x ((ReadsPapers(x) ∧ PublishesResults(x)) → Knowledgeable(x)) ::: If someone reads papers and publishes results, they are knowledgeable.",
            "∃x (Scientist(x) ∧ ConductsExperiment(x)) ::: There exists a scientist who conducts experiments.",
            "∀x (Scientist(x) → (Knowledgeable(x) ∨ ¬ReadsPapers(x))) ::: Every scientist is either knowledgeable or doesn't read papers.",
            "∀x (UsesMicroscope(x) → Scientist(x)) ::: Anyone using a microscope is a scientist."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "ConductsExperiment(x) ::: x conducts experiments",
            "Knowledgeable(x) ::: x is knowledgeable",
            "ReadsPapers(x) ::: x reads papers",
            "PublishesResults(x) ::: x publishes results",
            "UsesMicroscope(x) ::: x uses a microscope"
        ]
    },
    {
        "premises-NL": [
            "All doctors are experts.",
            "All experts are knowledgeable.",
            "Some researchers are doctors.",
            "Anyone who studies medicine is either a researcher or a doctor.",
            "Anyone who has a degree studies medicine.",
            "Anyone who studies medicine publishes research.",
            "Some researchers publish research.",
            "Doctors publish research.",
            "Anyone who is knowledgeable has a degree.",
            "Not all researchers are doctors.",
            "Some experts are doctors.",
            "All doctors have a degree.",
            "No one who publishes research is a doctor.",
            "Some people are doctors and researchers.",
            "Doctors are knowledgeable."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Expert(x)) ::: All doctors are experts.",
            "∀x (Expert(x) → Knowledgeable(x)) ::: All experts are knowledgeable.",
            "∃x (Researcher(x) ∧ Doctor(x)) ::: Some researchers are doctors.",
            "∀x (StudiesMedicine(x) → Researcher(x) ∨ Doctor(x)) ::: Anyone who studies medicine is either a researcher or a doctor.",
            "∀x (HasDegree(x) → StudiesMedicine(x)) ::: Anyone who has a degree studies medicine.",
            "∀x (StudiesMedicine(x) → PublishesResearch(x)) ::: Anyone who studies medicine publishes research.",
            "∃x (Researcher(x) ∧ PublishesResearch(x)) ::: Some researchers publish research.",
            "∀x (Doctor(x) → PublishesResearch(x)) ::: Doctors publish research.",
            "∀x (Knowledgeable(x) → HasDegree(x)) ::: Anyone who is knowledgeable has a degree.",
            "¬∀x (Researcher(x) → Doctor(x)) ::: Not all researchers are doctors.",
            "∃x (Expert(x) ∧ Doctor(x)) ::: Some experts are doctors.",
            "∀x (Doctor(x) → HasDegree(x)) ::: All doctors have a degree.",
            "¬∃x (PublishesResearch(x) ∧ Doctor(x)) ::: No one who publishes research is a doctor.",
            "∃x (Doctor(x) ∧ Researcher(x)) ::: Some people are doctors and researchers.",
            "∀x (Doctor(x) → Knowledgeable(x)) ::: Doctors are knowledgeable."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "Researcher(x) ::: x is a researcher",
            "Expert(x) ::: x is an expert",
            "Knowledgeable(x) ::: x is knowledgeable",
            "StudiesMedicine(x) ::: x studies medicine",
            "PublishesResearch(x) ::: x publishes research",
            "HasDegree(x) ::: x has a degree"
        ]
    },
    {
        "premises-NL": [
            "All flowering plants are alive.",
            "Some plants need sunlight and water.",
            "All plants that need water are green.",
            "Some plants are green and absorb CO2.",
            "All green plants are alive.",
            "Some plants are flowering and need sunlight.",
            "All plants are either green or flowering.",
            "Plants need water if and only if they are green.",
            "All plants that absorb CO2 are green.",
            "Any plant that needs sunlight is alive.",
            "All alive plants absorb CO2.",
            "No plant is both flowering and needs sunlight.",
            "All green plants need sunlight.",
            "Some plants do not need sunlight.",
            "All plants that are flowering absorb CO2.",
            "All plants are either flowering or not alive.",
            "Some plants are not green."
        ],
        "premises-FOL": [
            "∀x (Flowering(x) → Alive(x)) ::: All flowering plants are alive.",
            "∃x (Plant(x) ∧ NeedsSunlight(x) ∧ NeedsWater(x)) ::: Some plants need sunlight and water.",
            "∀x (Plant(x) ∧ NeedsWater(x) → IsGreen(x)) ::: All plants that need water are green.",
            "∃x (Plant(x) ∧ IsGreen(x) ∧ AbsorbsCO2(x)) ::: Some plants are green and absorb CO2.",
            "∀x (IsGreen(x) → Alive(x)) ::: All green plants are alive.",
            "∃x (Plant(x) ∧ Flowering(x) ∧ NeedsSunlight(x)) ::: Some plants are flowering and need sunlight.",
            "∀x (Plant(x) → IsGreen(x) ∨ Flowering(x)) ::: All plants are either green or flowering.",
            "∀x (Plant(x) → (NeedsWater(x) ↔ IsGreen(x))) ::: Plants need water if and only if they are green.",
            "∀x (Plant(x) ∧ AbsorbsCO2(x) → IsGreen(x)) ::: All plants that absorb CO2 are green.",
            "∀x (Plant(x) ∧ NeedsSunlight(x) → Alive(x)) ::: Any plant that needs sunlight is alive.",
            "∀x (Alive(x) → AbsorbsCO2(x)) ::: All alive plants absorb CO2.",
            "¬∃x (Flowering(x) ∧ NeedsSunlight(x)) ::: No plant is both flowering and needs sunlight.",
            "∀x (IsGreen(x) → NeedsSunlight(x)) ::: All green plants need sunlight.",
            "∃x ¬NeedsSunlight(x) ::: Some plants do not need sunlight.",
            "∀x (Plant(x) ∧ Flowering(x) → AbsorbsCO2(x)) ::: All plants that are flowering absorb CO2.",
            "∀x (Plant(x) → Flowering(x) ∨ ¬Alive(x)) ::: All plants are either flowering or not alive.",
            "∃x (Plant(x) ∧ ¬IsGreen(x)) ::: Some plants are not green."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "Flowering(x) ::: x is flowering",
            "Alive(x) ::: x is alive",
            "NeedsSunlight(x) ::: x needs sunlight",
            "NeedsWater(x) ::: x needs water",
            "IsGreen(x) ::: x is green",
            "AbsorbsCO2(x) ::: x absorbs CO2"
        ]
    },
    {
        "premises-NL": [
            "All mammals are warm-blooded.",
            "All mammals have fur.",
            "All mammals give birth.",
            "Some animals live on land and have fur.",
            "All animals that give birth are mammals.",
            "Some animals are warm-blooded and eat meat.",
            "All animals with fur are mammals.",
            "Any animal that eats meat is warm-blooded.",
            "All mammals live on land.",
            "All animals that are warm-blooded have fur.",
            "No animal is a mammal and lives on land.",
            "Some animals are warm-blooded and mammals.",
            "All mammals are mammals and warm-blooded.",
            "All animals that eat meat are warm-blooded and eat meat.",
            "All animals with fur and eating meat are mammals and eating meat.",
            "Animals are either mammals or live on land.",
            "All animals are warm-blooded or have fur."
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → WarmBlooded(x)) ::: All mammals are warm-blooded.",
            "∀x (Mammal(x) → HasFur(x)) ::: All mammals have fur.",
            "∀x (Mammal(x) → GivesBirth(x)) ::: All mammals give birth.",
            "∃x (Animal(x) ∧ LivesOnLand(x) ∧ HasFur(x)) ::: Some animals live on land and have fur.",
            "∀x (Animal(x) ∧ GivesBirth(x) → Mammal(x)) ::: All animals that give birth are mammals.",
            "∃x (Animal(x) ∧ WarmBlooded(x) ∧ EatsMeat(x)) ::: Some animals are warm-blooded and eat meat.",
            "∀x (Animal(x) ∧ HasFur(x) → Mammal(x)) ::: All animals with fur are mammals.",
            "∀x (Animal(x) ∧ EatsMeat(x) → WarmBlooded(x)) ::: Any animal that eats meat is warm-blooded.",
            "∀x (Mammal(x) → LivesOnLand(x)) ::: All mammals live on land.",
            "∀x (WarmBlooded(x) → HasFur(x)) ::: All animals that are warm-blooded have fur.",
            "¬∃x (Mammal(x) ∧ LivesOnLand(x)) ::: No animal is a mammal and lives on land.",
            "∃x (Animal(x) ∧ WarmBlooded(x) ∧ Mammal(x)) ::: Some animals are warm-blooded and mammals.",
            "∀x (Mammal(x) → Mammal(x) ∧ WarmBlooded(x)) ::: All mammals are mammals and warm-blooded.",
            "∀x (Animal(x) ∧ EatsMeat(x) → WarmBlooded(x) ∧ EatsMeat(x)) ::: All animals that eat meat are warm-blooded and eat meat.",
            "∀x (Animal(x) ∧ HasFur(x) ∧ EatsMeat(x) → Mammal(x) ∧ EatsMeat(x)) ::: All animals with fur and eating meat are mammals and eating meat.",
            "∀x (Animal(x) → Mammal(x) ∨ LivesOnLand(x)) ::: Animals are either mammals or live on land.",
            "∀x (Animal(x) → WarmBlooded(x) ∨ HasFur(x)) ::: All animals are warm-blooded or have fur."
        ],
        "predicates": [
            "Animal(x) ::: x is an animal",
            "Mammal(x) ::: x is a mammal",
            "WarmBlooded(x) ::: x is warm-blooded",
            "HasFur(x) ::: x has fur",
            "LivesOnLand(x) ::: x lives on land",
            "GivesBirth(x) ::: x gives birth",
            "EatsMeat(x) ::: x eats meat"
        ]
    },
    {
        "premises-NL": [
            "Alex is smart.",
            "If Alex is smart, then he studies.",
            "If Alex studies, then he will pass the exam.",
            "Alex is hard working.",
            "If Alex is hard working, then he studies.",
            "If Alex studies, he will succeed"
        ],
        "premises-FOL": [
            "Smart(Alex) ::: Alex is smart.",
            "Smart(x) → Studies(x) ::: If x is smart, then x studies.",
            "Studies(x) → PassExam(x) ::: If x studies, then x will pass the exam.",
            "HardWorking(Alex) ::: Alex is hard working.",
            "HardWorking(x) → Studies(x) ::: If x is hard working, then x studies.",
            "Studies(x) → Succeed(x) ::: If x studies, he will succeed"
        ],
        "predicates": [
            "Studies(x) ::: x studies",
            "PassExam(x) ::: x passes the exam",
            "Smart(x) ::: x is smart",
            "HardWorking(x) ::: x is hard working"
        ]
    },
    {
        "premises-NL": [
            "Every student that is enrolled in a class attends that class.",
            "If a student attends a class, and takes the class, then they are enrolled in that class.",
            "If a student takes a class they get a grade.",
            "If a student is a student and is attending the class, they are taking the class.",
            "If a student gets a grade in the class and passes the exam, then they studies",
            "John is a student",
            "John is enrolled in Math101.",
            "Everyone who studies passes the exam."
        ],
        "premises-FOL": [
            "∀x ∀y (Enrolled(x, y) → Attends(x, y)) ::: Every student that is enrolled in a class attends that class.",
            "∀x ∀y ((Attends(x, y) ∧ TakesClass(x, y)) → Enrolled(x, y)) ::: If a student attends a class, and takes the class, then they are enrolled in that class.",
            "∀x ∀y (TakesClass(x, y) → GetsGrade(x, y)) ::: If a student takes a class they get a grade.",
            "∀x ∀y ((Student(x) ∧ Attends(x, y)) → TakesClass(x, y)) ::: If a student is a student and is attending the class, they are taking the class.",
            "∀x ∀y ((GetsGrade(x, y) ∧ PassesExam(x, y)) → Studies(x)) ::: If a student gets a grade in the class and passes the exam, then they studies",
            "Student(John) ::: John is a student.",
            "Enrolled(John, Math101) ::: John is enrolled in Math101.",
            "∀x (Studies(x) → PassesExam(x, Math101)) ::: Everyone who studies passes the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Class(y) ::: y is a class",
            "Enrolled(x, y) ::: x is enrolled in y",
            "Attends(x, y) ::: x attends y",
            "GetsGrade(x, y) ::: x gets a grade in y",
            "PassesExam(x, y) ::: x passes the exam in y",
            "Studies(x) ::: x studies",
            "TakesClass(x, y) ::: x takes class y"
        ]
    },
    {
        "premises-NL": [
            "All cats are felines.",
            "Every feline is a mammal.",
            "Every mammal that eats meat is a carnivore.",
            "Every cat eats meat.",
            "If an animal eats meat, then it can hunt.",
            "Cats have claws.",
            "Felines are animals.",
            "Cats are domesticated"
        ],
        "premises-FOL": [
            "∀x (Cat(x) → Feline(x)) ::: All cats are felines.",
            "∀x (Feline(x) → Mammal(x)) ::: Every feline is a mammal.",
            "∀x (Mammal(x) ∧ EatsMeat(x) → Carnivore(x)) ::: Every mammal that eats meat is a carnivore.",
            "∀x (Cat(x) → EatsMeat(x)) ::: Every cat eats meat.",
            "∀x (EatsMeat(x) → CanHunt(x)) ::: If an animal eats meat, then it can hunt.",
            "∀x (Cat(x) → HasClaws(x)) ::: Cats have claws.",
            "∀x (Feline(x) → Animal(x)) ::: Felines are animals.",
            "∀x (Cat(x) → Domesticated(x)) ::: Cats are domesticated"
        ],
        "predicates": [
            "Animal(x) ::: x is an animal",
            "Cat(x) ::: x is a cat",
            "Mammal(x) ::: x is a mammal",
            "Carnivore(x) ::: x is a carnivore",
            "CanHunt(x) ::: x can hunt",
            "EatsMeat(x) ::: x eats meat",
            "Feline(x) ::: x is a feline",
            "HasClaws(x) ::: x has claws",
            "Domesticated(x) ::: x is domesticated"
        ]
    },
    {
        "premises-NL": [
            "All students who attend lectures understand concepts.",
            "All students who read books understand concepts.",
            "Anyone who understands a concept will pass the exam.",
            "If a student attends lectures or reads a book, they study hard.",
            "John is a student.",
            "John attends lectures.",
            "John reads books.",
            "Maria is a student.",
            "Maria studies hard.",
            "Anyone who studies hard will pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ AttendsLecture(x) → UnderstandsConcept(x)) ::: All students who attend lectures understand concepts.",
            "∀x (Student(x) ∧ ReadsBook(x) → UnderstandsConcept(x)) ::: All students who read books understand concepts.",
            "∀x (UnderstandsConcept(x) → PassExam(x)) ::: Anyone who understands a concept will pass the exam.",
            "∀x ((AttendsLecture(x) ∨ ReadsBook(x)) → StudiesHard(x)) ::: If a student attends lectures or reads a book, they study hard.",
            "Student(john) ::: John is a student.",
            "AttendsLecture(john) ::: John attends lectures.",
            "ReadsBook(john) ::: John reads books.",
            "Student(maria) ::: Maria is a student.",
            "StudiesHard(maria) ::: Maria studies hard.",
            "∀x (StudiesHard(x) → PassExam(x)) ::: Anyone who studies hard will pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "StudiesHard(x) ::: x studies hard.",
            "PassExam(x) ::: x passes the exam.",
            "AttendsLecture(x) ::: x attends lectures.",
            "UnderstandsConcept(x) ::: x understands the concept.",
            "ReadsBook(x) ::: x reads a book."
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "Every doctor who has a patient, treats the patient.",
            "A surgeon is a doctor.",
            "Some doctors are specialists.",
            "All specialists are doctors.",
            "Some specialists diagnose illnesses.",
            "All general practitioners are doctors.",
            "A specialist can prescribe medication.",
            "John is a doctor and has a patient.",
            "John is not a surgeon.",
            "John is a human."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x ∀y (Doctor(x) ∧ HasPatient(x) → TreatsDisease(x, y)) ::: Every doctor who has a patient, treats the patient.",
            "Surgeon(x) → Doctor(x) ::: A surgeon is a doctor.",
            "∃x (Doctor(x) ∧ Specialist(x)) ::: Some doctors are specialists.",
            "∀x (Specialist(x) → Doctor(x)) ::: All specialists are doctors.",
            "∃x ∃y (Specialist(x) ∧ DiagnosesIllness(x, y)) ::: Some specialists diagnose illnesses.",
            "∀x (GeneralPractitioner(x) → Doctor(x)) ::: All general practitioners are doctors.",
            "∃x ∃y (Specialist(x) ∧ PrescribesMedication(x, y)) ::: A specialist can prescribe medication.",
            "Doctor(john) ∧ HasPatient(john) ::: John is a doctor and has a patient.",
            "¬Surgeon(john) ::: John is not a surgeon.",
            "IsHuman(john) ::: John is a human."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "HasPatient(x) ::: x has a patient.",
            "Surgeon(x) ::: x is a surgeon.",
            "GeneralPractitioner(x) ::: x is a general practitioner.",
            "Specialist(x) ::: x is a specialist.",
            "TreatsDisease(x, y) ::: x treats disease y.",
            "PatientOf(x, y) ::: x is a patient of y.",
            "HasDegree(x, y) ::: x has a degree in y.",
            "DiagnosesIllness(x, y) ::: x diagnoses illness y.",
            "PrescribesMedication(x, y) ::: x prescribes medication y.",
            "IsHuman(x) ::: x is human."
        ]
    },
    {
        "premises-NL": [
            "All students attend the university.",
            "John is a student.",
            "A student is either a graduate student or an undergraduate student.",
            "John is not a graduate student.",
            "If a student attends the university and is not a graduate student, then they are an undergraduate student.",
            "Any undergraduate student needs to take at least three modules.",
            "John takes at least three modules.",
            "If John takes at least three modules and is an undergraduate student, then he is taking the required number of modules.",
            "If someone takes at least three modules, then they are enrolled in the required number of modules.",
            "John is enrolled in the required number of modules."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsUniversity(x)) ::: All students attend the university",
            "Student(john) ::: John is a student",
            "∀x (Student(x) → (GraduateStudent(x) ∨ UndergraduateStudent(x))) ::: A student is either a graduate student or an undergraduate student",
            "¬GraduateStudent(john) ::: John is not a graduate student",
            "∀x ((Student(x) ∧ AttendsUniversity(x) ∧ ¬GraduateStudent(x)) → UndergraduateStudent(x)) ::: If a student attends the university and is not a graduate student, then they are an undergraduate student",
            "∀x (UndergraduateStudent(x) → TakesModules(x, 3)) ::: Any undergraduate student needs to take at least three modules",
            "TakesModules(john, 3) ::: John takes at least three modules",
            "∀x ((TakesModules(x, 3) ∧ UndergraduateStudent(x)) → RequiredModules(x)) ::: If John takes at least three modules and is an undergraduate student, then he is taking the required number of modules",
            "∀x (TakesModules(x, 3) → RequiredModules(x)) ::: If someone takes at least three modules, then they are enrolled in the required number of modules",
            "RequiredModules(john) ::: John is enrolled in the required number of modules"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsUniversity(x) ::: x attends the university"
        ]
    },
    {
        "premises-NL": [
            "John invests in bonds.",
            "Bonds yield a good return.",
            "If something yields a good return, then it's a safe investment.",
            "John and Mary are partners.",
            "If John invests in something, then Mary receives a return.",
            "If John invests in bonds, then John will receive a good return.",
            "If John receives a good return and he is a partner with Mary, then Mary receives a good return.",
            "John invests in bonds and if John is a partner with Mary, then Mary receives a return.",
            "Bonds are safe investments.",
            "John receives a good return.",
            "If Mary receives a return and it is a good one, then Mary will get a good return.",
            "If someone gets a good return, they are happy."
        ],
        "premises-FOL": [
            "InvestsIn(john, bonds) ::: John invests in bonds",
            "Yield(bonds, good) ::: Bonds yield a good return",
            "∀x (Yield(x, good) → SafeInvestment(x)) ::: If something yields a good return, then it's a safe investment",
            "Partners(john, mary) ::: John and Mary are partners",
            "∀x ∀y (InvestsIn(x, y) → ReceivesReturn(mary, x)) ::: If John invests in something, then Mary receives a return",
            "InvestsIn(john, bonds) → ReceivesReturn(john, good) ::: If John invests in bonds, then John will receive a good return",
            "ReceivesReturn(john, good) ∧ Partners(john, mary) → ReceivesReturn(mary, good) ::: If John receives a good return and he is a partner with Mary, then Mary receives a good return",
            "(InvestsIn(john, bonds) ∧ Partners(john, mary)) → ReceivesReturn(mary, good) ::: John invests in bonds and if John is a partner with Mary, then Mary receives a return",
            "SafeInvestment(bonds) ::: Bonds are safe investments",
            "ReceivesReturn(john, good) ::: John receives a good return",
            "∀x (ReceivesReturn(mary, x) ∧ GoodReturn(x) → ReceivesReturn(mary, good)) ::: If Mary receives a return and it is a good one, then Mary will get a good return",
            "∀x (ReceivesReturn(x, good) → Happy(x)) ::: If someone gets a good return, they are happy"
        ],
        "predicates": [
            "InvestsIn(x, y) ::: x invests in y",
            "Partners(x, y) ::: x and y are partners",
            "Yield(x, y) ::: x yields y",
            "GoodReturn(x) ::: x is a good return",
            "ReceivesReturn(x, y) ::: x receives y"
        ]
    },
    {
        "premises-NL": [
            "Emily studies hard.",
            "If Emily studies hard and attends class, she will pass the exam.",
            "Emily attends class.",
            "If someone is smart, they will not fail.",
            "Emily is smart."
        ],
        "premises-FOL": [
            "StudiesHard(emily) ::: Emily studies hard",
            "StudiesHard(x) ∧ AttendsClass(x) → PassExam(x) ::: If x studies hard and attends class, then x passes the exam",
            "AttendsClass(emily) ::: Emily attends class.",
            "Smart(x) → ¬Failure(x) ::: If x is smart, then x will not fail.",
            "Smart(emily) ::: Emily is smart."
        ],
        "predicates": [
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x passes the exam",
            "AttendsClass(x) ::: x attends class",
            "Smart(x) ::: x is smart",
            "Failure(x) ::: x fails"
        ]
    },
    {
        "premises-NL": [
            "All scientists are researchers.",
            "All researchers work at a lab.",
            "Anyone who works at a lab publishes papers.",
            "Anyone who publishes papers is driven.",
            "If someone is driven, they are diligent.",
            "Some scientists are driven."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → Researcher(x)) ::: All scientists are researchers.",
            "∀x (Researcher(x) → WorksAtLab(x)) ::: All researchers work at a lab.",
            "∀x (WorksAtLab(x) → PublishesPapers(x)) ::: Anyone who works at a lab publishes papers.",
            "∀x (PublishesPapers(x) → Driven(x)) ::: Anyone who publishes papers is driven.",
            "∀x (Driven(x) → Diligent(x)) ::: If someone is driven, they are diligent.",
            "∃x (Scientist(x) ∧ Driven(x)) ::: Some scientists are driven."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Diligent(x) ::: x is diligent",
            "Researcher(x) ::: x is a researcher",
            "WorksAtLab(x) ::: x works at a lab",
            "PublishesPapers(x) ::: x publishes papers",
            "Driven(x) ::: x is driven"
        ]
    },
    {
        "premises-NL": [
            "If someone lives in an apartment, they are not allowed pets.",
            "If someone is a student and is employed, then they pay rent.",
            "If someone does not pay rent, they are allowed pets.",
            "If someone studies and takes an exam, they are a student.",
            "If someone lives in an apartment and needs money, they are not employed.",
            "Someone takes the exam.",
            "Anyone who takes the exam studies.",
            "Everyone lives in an apartment.",
            "Some people need money."
        ],
        "premises-FOL": [
            "∀x (LivesInApartment(x) → ¬AllowedPets(x)) ::: If someone lives in an apartment, they are not allowed pets.",
            "∀x (Student(x) ∧ IsEmployed(x) → PaysRent(x)) ::: If someone is a student and is employed, then they pay rent.",
            "∀x (¬PaysRent(x) → AllowedPets(x)) ::: If someone does not pay rent, they are allowed pets.",
            "∀x (Studies(x, y) ∧ TakesExam(x) → Student(x)) ::: If someone studies and takes an exam, they are a student.",
            "∀x (LivesInApartment(x) ∧ NeedsMoney(x) → ¬IsEmployed(x)) ::: If someone lives in an apartment and needs money, they are not employed.",
            "∃x TakesExam(x) ::: Someone takes the exam.",
            "∀x ∀y (TakesExam(x) ∧ Studies(x, y) ) ::: Anyone who takes the exam studies.",
            "∀x LivesInApartment(x) ::: Everyone lives in an apartment.",
            "∃x NeedsMoney(x) ::: Some people need money."
        ],
        "predicates": [
            "HasPet(x) ::: x has a pet",
            "Student(x) ::: x is a student",
            "LivesInApartment(x) ::: x lives in an apartment",
            "AllowedPets(x) ::: x is allowed pets",
            "PaysRent(x) ::: x pays rent",
            "IsEmployed(x) ::: x is employed",
            "Studies(x, y) ::: x studies y",
            "TakesExam(x) ::: x takes exam",
            "NeedsMoney(x) ::: x needs money"
        ]
    },
    {
        "premises-NL": [
            "The patient has the disease.",
            "If a patient has the disease and is given medication, they will recover.",
            "If a patient recovers, then they will be healthy.",
            "If someone is healthy they will not be sick.",
            "The patient is given medication.",
            "A healthy person will recover.",
            "If someone has a disease they are sick.",
            "If someone is sick and given medicine they will recover.",
            "The patient is given medicine.",
            "If someone is sick and recovers then they become healthy.",
            "If the patient is given medicine then the patient will recover.",
            "If the patient recovers they are not sick.",
            "If the patient does not recover then they are sick."
        ],
        "premises-FOL": [
            "HasDisease(patient) ::: The patient has the disease",
            "∀x (HasDisease(x) ∧ GivenMedication(x) → Recovers(x)) ::: If a patient has the disease and is given medication, they will recover",
            "∀x (Recovers(x) → IsHealthy(x)) ::: If a patient recovers, then they will be healthy",
            "∀x (IsHealthy(x) → ¬IsSick(x)) ::: If someone is healthy they will not be sick",
            "GivenMedication(patient) ::: The patient is given medication",
            "∀x (IsHealthy(x) → Recovers(x)) ::: A healthy person will recover",
            "∀x (HasDisease(x) → IsSick(x)) ::: If someone has a disease they are sick",
            "∀x (IsSick(x) ∧ GivenMedicine(x) → Recovers(x)) ::: If someone is sick and given medicine they will recover",
            "GivenMedicine(patient) ::: The patient is given medicine",
            "∀x (IsSick(x) ∧ Recovers(x) → IsHealthy(x)) ::: If someone is sick and recovers then they become healthy",
            "GivenMedicine(patient) → Recovers(patient) ::: If the patient is given medicine then the patient will recover",
            "Recovers(patient) → ¬IsSick(patient) ::: If the patient recovers they are not sick",
            "¬Recovers(patient) → IsSick(patient) ::: If the patient does not recover then they are sick"
        ],
        "predicates": [
            "HasDisease(x) ::: x has the disease",
            "GivenMedication(x) ::: Medication is given to x",
            "Recovers(x) ::: x recovers",
            "IsHealthy(x) ::: x is healthy"
        ]
    },
    {
        "premises-NL": [
            "All students are required to take the exam.",
            "Some students are smart.",
            "If a student is smart, they will pass the exam.",
            "Every student either is smart or will fail the exam.",
            "No student both smart and fail the exam.",
            "John is a student.",
            "If John is smart, John will pass the exam.",
            "If John does not pass the exam, John is not smart.",
            "Every smart student will pass the exam.",
            "Every student is smart or will fail the exam.",
            "John is not failing the exam.",
            "If John is a student, then John will take the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakeExam(x)) ::: All students are required to take the exam.",
            "∃x (Student(x) ∧ Smart(x)) ::: Some students are smart.",
            "∀x (Smart(x) → PassExam(x)) ::: If a student is smart, they will pass the exam.",
            "∀x (Student(x) → (Smart(x) ∨ FailExam(x))) ::: Every student either is smart or will fail the exam.",
            "¬∃x (Smart(x) ∧ FailExam(x)) ::: No student both smart and fail the exam.",
            "Student(john) ::: John is a student.",
            "Smart(john) → PassExam(john) ::: If John is smart, John will pass the exam.",
            "¬PassExam(john) → ¬Smart(john) ::: If John does not pass the exam, John is not smart.",
            "∀x (Smart(x) → PassExam(x)) ::: Every smart student will pass the exam.",
            "∀x (Student(x) → (Smart(x) ∨ FailExam(x))) ::: Every student is smart or will fail the exam.",
            "¬FailExam(john) ::: John is not failing the exam.",
            "Student(john) → TakeExam(john) ::: If John is a student, then John will take the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Smart(x) ::: x is smart.",
            "PassExam(x) ::: x will pass the exam."
        ]
    },
    {
        "premises-NL": [
            "All people are healthy if they eat fruits.",
            "All people are healthy if they eat vegetables.",
            "If someone likes vegetables, they eat vegetables.",
            "If someone likes fruits, they eat fruits.",
            "Anyone who is healthy either likes vegetables or likes fruits.",
            "John is a person.",
            "Mary is a person.",
            "John doesn't like vegetables.",
            "Mary likes fruits.",
            "All people eat fruits.",
            "All people eat vegetables.",
            "Anyone that likes vegetables also eats them.",
            "Anyone that likes fruits also eats them.",
            "If someone is healthy, then they like vegetables or fruits."
        ],
        "premises-FOL": [
            "∀x (Person(x) ∧ EatsFruits(x) → IsHealthy(x)) ::: For all x, if x is a person and eats fruits, then x is healthy.",
            "∀x (Person(x) ∧ EatsVegetables(x) → IsHealthy(x)) ::: For all x, if x is a person and eats vegetables, then x is healthy.",
            "∀x (LikesVegetables(x) → EatsVegetables(x)) ::: For all x, if x likes vegetables, then x eats vegetables.",
            "∀x (LikesFruits(x) → EatsFruits(x)) ::: For all x, if x likes fruits, then x eats fruits.",
            "∀x (IsHealthy(x) → (LikesVegetables(x) ∨ LikesFruits(x))) ::: For all x, if x is healthy, then x likes vegetables or fruits.",
            "Person(John) ::: John is a person.",
            "Person(Mary) ::: Mary is a person.",
            "¬LikesVegetables(John) ::: John doesn't like vegetables.",
            "LikesFruits(Mary) ::: Mary likes fruits.",
            "∀x (Person(x) → EatsFruits(x)) ::: For all x, if x is a person, then x eats fruits.",
            "∀x (Person(x) → EatsVegetables(x)) ::: For all x, if x is a person, then x eats vegetables.",
            "∀x (LikesVegetables(x) → EatsVegetables(x)) ::: For all x, if x likes vegetables, then x eats them.",
            "∀x (LikesFruits(x) → EatsFruits(x)) ::: For all x, if x likes fruits, then x eats them.",
            "∀x (IsHealthy(x) → (LikesVegetables(x) ∨ LikesFruits(x))) ::: If someone is healthy, then they like vegetables or fruits."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "LikesVegetables(x) ::: x likes vegetables",
            "LikesFruits(x) ::: x likes fruits",
            "IsHealthy(x) ::: x is healthy",
            "EatsVegetables(x) ::: x eats vegetables",
            "EatsFruits(x) ::: x eats fruits"
        ]
    },
    {
        "premises-NL": [
            "All athletes train hard.",
            "If an athlete trains hard and gets enough rest, then they are healthy.",
            "If an athlete is healthy, then they win competitions.",
            "If an athlete eats healthy food and follows a training regimen, then they train hard.",
            "If an athlete participates in a sport and has a good coach, then they follow a training regimen.",
            "If an athlete is dedicated and doesn't get enough rest, then the athlete is injured.",
            "All athletes get enough rest.",
            "Some athletes eat healthy food.",
            "Some athletes have a good coach.",
            "Athlete D is an athlete.",
            "Athlete D does not get injured."
        ],
        "premises-FOL": [
            "∀x (Athlete(x) → TrainsHard(x)) ::: All athletes train hard.",
            "∀x ((TrainsHard(x) ∧ GetsEnoughRest(x)) → Healthy(x)) ::: If an athlete trains hard and gets enough rest, then they are healthy.",
            "∀x (Healthy(x) → WinsCompetition(x)) ::: If an athlete is healthy, then they win competitions.",
            "∀x ((EatsHealthyFood(x) ∧ FollowsTrainingRegimen(x)) → TrainsHard(x)) ::: If an athlete eats healthy food and follows a training regimen, then they train hard.",
            "∀x ∀y ((ParticipatesInSport(x, y) ∧ HasAGoodCoach(x)) → FollowsTrainingRegimen(x)) ::: If an athlete participates in a sport and has a good coach, then they follow a training regimen.",
            "∀x ((IsDedicated(x) ∧ ¬GetsEnoughRest(x)) → IsInjured(x)) ::: If an athlete is dedicated and doesn't get enough rest, then the athlete is injured.",
            "∀x (Athlete(x) → GetsEnoughRest(x)) ::: All athletes get enough rest.",
            "∃x EatsHealthyFood(x) ::: Some athletes eat healthy food.",
            "∃x HasAGoodCoach(x) ::: Some athletes have a good coach.",
            "Athlete(D) ::: Athlete D is an athlete.",
            "¬IsInjured(D) ::: Athlete D does not get injured."
        ],
        "predicates": [
            "Athlete(x) ::: x is an athlete",
            "TrainsHard(x) ::: x trains hard",
            "Healthy(x) ::: x is healthy",
            "WinsCompetition(x) ::: x wins competition",
            "EatsHealthyFood(x) ::: x eats healthy food",
            "FollowsTrainingRegimen(x) ::: x follows training regimen",
            "GetsEnoughRest(x) ::: x gets enough rest",
            "ParticipatesInSport(x, y) ::: x participates in sport y",
            "HasAGoodCoach(x) ::: x has a good coach",
            "IsDedicated(x) ::: x is dedicated",
            "IsInjured(x) ::: x is injured"
        ]
    },
    {
        "premises-NL": [
            "All entrepreneurs take risks.",
            "If an entrepreneur takes risks and secures funding, they are successful.",
            "If an entrepreneur is successful and attracts investors, then they create jobs.",
            "If an entrepreneur develops innovation and manages a team, then they take risks.",
            "If an entrepreneur works long hours and has a good idea, then they develop innovation.",
            "If an entrepreneur understands the market and deals with regulations, then they secure funding.",
            "All entrepreneurs attract investors.",
            "Some entrepreneurs develop innovation.",
            "Some entrepreneurs deal with regulations.",
            "Entrepreneur E is an entrepreneur.",
            "Entrepreneur E understands the market.",
            "Entrepreneur E works long hours."
        ],
        "premises-FOL": [
            "∀x (Entrepreneur(x) → TakesRisks(x)) ::: All entrepreneurs take risks.",
            "∀x ((TakesRisks(x) ∧ SecuresFunding(x)) → Successful(x)) ::: If an entrepreneur takes risks and secures funding, they are successful.",
            "∀x ((Successful(x) ∧ AttractsInvestors(x)) → CreatesJobs(x)) ::: If an entrepreneur is successful and attracts investors, then they create jobs.",
            "∀x ((DevelopsInnovation(x) ∧ ManagesTeam(x)) → TakesRisks(x)) ::: If an entrepreneur develops innovation and manages a team, then they take risks.",
            "∀x ((WorksLongHours(x) ∧ HasGoodIdea(x)) → DevelopsInnovation(x)) ::: If an entrepreneur works long hours and has a good idea, then they develop innovation.",
            "∀x ((UnderstandsMarket(x) ∧ DealsWithRegulations(x)) → SecuresFunding(x)) ::: If an entrepreneur understands the market and deals with regulations, then they secure funding.",
            "∀x (Entrepreneur(x) → AttractsInvestors(x)) ::: All entrepreneurs attract investors.",
            "∃x DevelopsInnovation(x) ::: Some entrepreneurs develop innovation.",
            "∃x DealsWithRegulations(x) ::: Some entrepreneurs deal with regulations.",
            "Entrepreneur(E) ::: Entrepreneur E is an entrepreneur.",
            "UnderstandsMarket(E) ::: Entrepreneur E understands the market.",
            "WorksLongHours(E) ::: Entrepreneur E works long hours."
        ],
        "predicates": [
            "Entrepreneur(x) ::: x is an entrepreneur",
            "TakesRisks(x) ::: x takes risks",
            "Successful(x) ::: x is successful",
            "CreatesJobs(x) ::: x creates jobs",
            "SecuresFunding(x) ::: x secures funding",
            "DevelopsInnovation(x) ::: x develops innovation",
            "ManagesTeam(x) ::: x manages a team",
            "WorksLongHours(x) ::: x works long hours",
            "HasGoodIdea(x) ::: x has a good idea",
            "AttractsInvestors(x) ::: x attracts investors",
            "UnderstandsMarket(x) ::: x understands the market",
            "DealsWithRegulations(x) ::: x deals with regulations"
        ]
    },
    {
        "premises-NL": [
            "All doctors are highly educated or have exceptional skills.",
            "If someone attends medical school, they will become a doctor.",
            "If someone passes the board exam, they will become a doctor.",
            "Some people attend medical school.",
            "All those who attend medical school pass the board exam."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → (HighlyEducated(x) ∨ ExceptionalSkills(x))) ::: All doctors are highly educated or have exceptional skills.",
            "∀x (AttendsMedicalSchool(x) → Doctor(x)) ::: If someone attends medical school, they will become a doctor.",
            "∀x (PassesBoardExam(x) → Doctor(x)) ::: If someone passes the board exam, they will become a doctor.",
            "∃x AttendsMedicalSchool(x) ::: Some people attend medical school.",
            "∀x (AttendsMedicalSchool(x) → PassesBoardExam(x)) ::: All those who attend medical school pass the board exam."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "HighlyEducated(x) ::: x is highly educated",
            "ExceptionalSkills(x) ::: x possesses exceptional skills",
            "AttendsMedicalSchool(x) ::: x attends medical school",
            "PassesBoardExam(x) ::: x passes the board exam"
        ]
    },
    {
        "premises-NL": [
            "If a patient is treated with a medicine, then the patient is administered the medicine.",
            "If a patient has a disease and is treated with a specific medicine, then the medicine is administered.",
            "If a patient recovers from the disease, the patient is treated with a medicine.",
            "There is a patient.",
            "A patient has a disease.",
            "The patient is treated with the medicine.",
            "The patient recovers."
        ],
        "premises-FOL": [
            "∀x ∀y (TreatedWith(x, y) → Administered(x, y)) ::: If a patient is treated with a medicine, then the patient is administered the medicine.",
            "∀x ∀y ∀z (Patient(x) ∧ HasDisease(x, y) ∧ TreatedWith(x, z) → Administered(x, z)) ::: If a patient has a disease and is treated with a specific medicine, then the medicine is administered.",
            "∀x ∃y (Recovers(x) → TreatedWith(x, y)) ::: If a patient recovers from the disease, the patient is treated with a medicine.",
            "∃x Patient(x) ::: There is a patient.",
            "∃x ∃y HasDisease(x, y) ::: A patient has a disease.",
            "∃x ∃y TreatedWith(x, y) ::: The patient is treated with the medicine.",
            "∃x Recovers(x) ::: The patient recovers."
        ],
        "predicates": [
            "TreatedWith(x, y) ::: x is treated with medicine y",
            "Recovers(x) ::: x recovers",
            "EffectiveMedicine(x) ::: medicine x is effective",
            "HasDisease(x, y) ::: x has disease y",
            "Administered(x, y) ::: x administers medicine y",
            "DiseaseSeverity(x, y) ::: x's disease y severity",
            "Patient(x) ::: x is a patient"
        ]
    },
    {
        "premises-NL": [
            "A company is profitable if it has high revenue and low expenses.",
            "A company has high revenue if it offers discounts or has a good product.",
            "If a company offers a discount, it has competitive pricing.",
            "If a company has low expenses and high customer satisfaction, then its product is good.",
            "Company A is profitable.",
            "Company A offers discounts.",
            "Company A produces a product."
        ],
        "premises-FOL": [
            "∀x (Profitable(x) → (HighRevenue(x) ∧ LowExpenses(x))) ::: A company is profitable if it has high revenue and low expenses.",
            "∀x (HighRevenue(x) → (OffersDiscount(x) ∨ GoodProduct(x))) ::: A company has high revenue if it offers discounts or has a good product.",
            "∀x (OffersDiscount(x) → CompetitivePricing(x)) ::: If a company offers a discount, it has competitive pricing.",
            "∀x (LowExpenses(x) ∧ CustomerSatisfaction(x) → GoodProduct(x)) ::: If a company has low expenses and high customer satisfaction, then its product is good.",
            "Profitable(a) ::: Company A is profitable.",
            "OffersDiscount(a) ::: Company A offers discounts.",
            "∃y Produces(a, y) ::: Company A produces a product."
        ],
        "predicates": [
            "Profitable(x) ::: x is a profitable company",
            "GoodProduct(x) ::: x has a good product",
            "CompetitivePricing(x) ::: x offers competitive pricing",
            "HighRevenue(x) ::: x has high revenue",
            "LowExpenses(x) ::: x has low expenses",
            "OffersDiscount(x) ::: x offers discounts",
            "CustomerSatisfaction(x) ::: x has high customer satisfaction",
            "Produces(x, y) ::: x produces y"
        ]
    },
    {
        "premises-NL": [
            "Every doctor treats a patient.",
            "Some doctors are skilled.",
            "Anyone who treats a patient is a doctor.",
            "If someone is a doctor then he treats a patient.",
            "Every skilled person is a doctor."
        ],
        "premises-FOL": [
            "∀x ∃y (Doctor(x) → Treats(x, y)) ::: Every doctor treats a patient.",
            "∃x (Doctor(x) ∧ Skilled(x)) ::: Some doctors are skilled.",
            "∀x ∃y (Treats(x, y) → Doctor(x)) ::: Anyone who treats a patient is a doctor.",
            "∀x ∀y (Doctor(x) → Treats(x, y)) ::: If someone is a doctor then he treats a patient.",
            "∀x (Skilled(x) → Doctor(x)) ::: Every skilled person is a doctor."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Patient(x) ::: x is a patient.",
            "Treats(x, y) ::: x treats y.",
            "Skilled(x) ::: x is skilled."
        ]
    },
    {
        "premises-NL": [
            "Every scientist publishes a paper.",
            "All those who publish papers are researchers.",
            "Someone is a scientist if they publishes paper.",
            "Every researcher works at a university.",
            "If someone is a scientist and a researcher then that person publishes a paper.",
            "Every paper is published by someone."
        ],
        "premises-FOL": [
            "∀x ∃y (Scientist(x) → Publishes(x, y)) ::: Every scientist publishes a paper.",
            "∀x ∃y (Publishes(x, y) → Researcher(x)) ::: All those who publish papers are researchers.",
            "∀x ∃y (Publishes(x, y) → Scientist(x)) ::: Someone is a scientist if they publishes paper.",
            "∀x ∃y (Researcher(x) → WorksAt(x, y)) ::: Every researcher works at a university.",
            "∀x ∀y ((Scientist(x) ∧ Researcher(x)) → Publishes(x, y)) ::: If someone is a scientist and a researcher then that person publishes a paper.",
            "∀x ∃y (Paper(x) → Publishes(y, x)) ::: Every paper is published by someone."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist.",
            "Researcher(x) ::: x is a researcher.",
            "Publishes(x, y) ::: x publishes y.",
            "Paper(x) ::: x is a paper.",
            "WorksAt(x, y) ::: x works at y."
        ]
    },
    {
        "premises-NL": [
            "Every doctor treats a patient.",
            "Every doctor is skilled.",
            "Every skilled person is kind.",
            "Every kind person helps a human.",
            "Anyone who treats a patient helps them.",
            "All doctors are friendly.",
            "Every friendly person is kind.",
            "If someone is a doctor, then he treats a patient."
        ],
        "premises-FOL": [
            "∀x ∃y (Doctor(x) → Treats(x, y)) ::: Every doctor treats a patient.",
            "∀x (Doctor(x) → Skilled(x)) ::: Every doctor is skilled.",
            "∀x (Skilled(x) → Kind(x)) ::: Every skilled person is kind.",
            "∀x ∃y (Kind(x) → Helps(x, y)) ::: Every kind person helps a human.",
            "∀x ∀y (Treats(x, y) → Helps(x, y)) ::: Anyone who treats a patient helps them.",
            "∀x (Doctor(x) → Friendly(x)) ::: All doctors are friendly.",
            "∀x (Friendly(x) → Kind(x)) ::: Every friendly person is kind.",
            "∀x ∀y (Doctor(x) → Treats(x, y)) ::: If someone is a doctor, then he treats a patient."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor.",
            "Patient(x) ::: x is a patient.",
            "Treats(x, y) ::: x treats y.",
            "Helps(x, y) ::: x helps y.",
            "Skilled(x) ::: x is skilled.",
            "Human(x) ::: x is a human.",
            "Friendly(x) ::: x is friendly.",
            "Kind(x) ::: x is kind."
        ]
    },
    {
        "premises-NL": [
            "All programmers are smart.",
            "Everyone who is smart solves problems.",
            "Everyone who solves problems likes to code.",
            "All programmers code.",
            "Anyone who codes uses a computer.",
            "Every programmer eats.",
            "If someone uses a computer then that person is happy.",
            "If someone is a programmer and eats, then that person likes to code.",
            "If someone likes to code then that person is happy."
        ],
        "premises-FOL": [
            "∀x (Programmer(x) → Smart(x)) ::: All programmers are smart.",
            "∀x ∃y (Smart(x) → SolvesProblems(x, y)) ::: Everyone who is smart solves problems.",
            "∀x ∀y (SolvesProblems(x, y) → LikesToCode(x)) ::: Everyone who solves problems likes to code.",
            "∀x ∃y (Programmer(x) → Codes(x, y)) ::: All programmers code.",
            "∀x ∀y (Codes(x, y) → UsesComputer(x)) ::: Anyone who codes uses a computer.",
            "∀x ∃y (Programmer(x) → Eats(x, y)) ::: Every programmer eats.",
            "∀x (UsesComputer(x) → Happy(x)) ::: If someone uses a computer then that person is happy.",
            "∀x ∀y ((Programmer(x) ∧ Eats(x, y)) → LikesToCode(x)) ::: If someone is a programmer and eats, then that person likes to code.",
            "∀x (LikesToCode(x) → Happy(x)) ::: If someone likes to code then that person is happy."
        ],
        "predicates": [
            "Programmer(x) ::: x is a programmer.",
            "LikesToCode(x) ::: x likes to code.",
            "Happy(x) ::: x is happy.",
            "Smart(x) ::: x is smart.",
            "SolvesProblems(x, y) ::: x solves y.",
            "Problem(x) ::: x is a problem.",
            "Codes(x, y) ::: x codes y.",
            "UsesComputer(x) ::: x uses a computer.",
            "Eats(x, y) ::: x eats y."
        ]
    },
    {
        "premises-NL": [
            "All students either pass or fail Physics.",
            "All students either pass or fail Chemistry.",
            "Anyone who fails a course is a student.",
            "If a student takes Physics, they either pass or fail Physics.",
            "If a student takes Chemistry, they either pass or fail Chemistry.",
            "If a student takes both Physics and Chemistry and passes both, they are not failing both.",
            "If a student passes a subject, they do not fail the subject.",
            "Students who take both Physics and Chemistry are students."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (PassesPhysics(x) ∨ FailsPhysics(x))) ::: All students either pass or fail Physics.",
            "∀x (Student(x) → (PassesChemistry(x) ∨ FailsChemistry(x))) ::: All students either pass or fail Chemistry.",
            "∀x (FailsPhysics(x) ∨ FailsChemistry(x) → Student(x)) ::: Anyone who fails a course is a student.",
            "∀x (Student(x) ∧ TakesPhysics(x) → (PassesPhysics(x) ∨ FailsPhysics(x))) ::: If a student takes Physics, they either pass or fail Physics.",
            "∀x (Student(x) ∧ TakesChemistry(x) → (PassesChemistry(x) ∨ FailsChemistry(x))) ::: If a student takes Chemistry, they either pass or fail Chemistry.",
            "∀x ((Student(x) ∧ TakesPhysics(x) ∧ TakesChemistry(x) ∧ PassesPhysics(x) ∧ PassesChemistry(x)) → ¬(FailsPhysics(x) ∧ FailsChemistry(x))) ::: If a student takes both Physics and Chemistry and passes both, they are not failing both.",
            "∀x (PassesPhysics(x) → ¬FailsPhysics(x)) ::: If a student passes Physics, they do not fail Physics.",
            "∀x (Student(x) ∧ TakesPhysics(x) ∧ TakesChemistry(x) → Student(x)) ::: Students who take both Physics and Chemistry are students."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "TakesPhysics(x) ::: x takes Physics",
            "TakesChemistry(x) ::: x takes Chemistry",
            "FailsPhysics(x) ::: x fails Physics",
            "FailsChemistry(x) ::: x fails Chemistry",
            "PassesPhysics(x) ::: x passes Physics",
            "PassesChemistry(x) ::: x passes Chemistry"
        ]
    },
    {
        "premises-NL": [
            "All patients with flu symptoms have a virus.",
            "All patients with cold symptoms have a virus or a bacterial infection.",
            "If a patient is treated and has a virus, they receive antiviral drugs.",
            "If a patient is treated and has a bacterial infection, they receive antibiotics.",
            "Patients who have flu symptoms and cold symptoms are patients.",
            "If a patient receives both antiviral drugs and antibiotics, they are treated.",
            "A treated patient must have some type of treatment.",
            "If a patient has both flu and cold symptoms, they must be treated and either receive antiviral drugs or antibiotics.",
            "Patients with bacterial infections have a cold."
        ],
        "premises-FOL": [
            "∀x (HasFluSymptoms(x) → HasVirus(x)) ::: All patients with flu symptoms have a virus.",
            "∀x (HasColdSymptoms(x) → (HasVirus(x) ∨ HasBacterialInfection(x))) ::: All patients with cold symptoms have a virus or a bacterial infection.",
            "∀x ((Treated(x) ∧ HasVirus(x)) → ReceivesAntivirals(x)) ::: If a patient is treated and has a virus, they receive antiviral drugs.",
            "∀x ((Treated(x) ∧ HasBacterialInfection(x)) → ReceivesAntibiotics(x)) ::: If a patient is treated and has a bacterial infection, they receive antibiotics.",
            "∀x ((HasFluSymptoms(x) ∧ HasColdSymptoms(x)) → Patient(x)) ::: Patients who have flu symptoms and cold symptoms are patients.",
            "∀x ((ReceivesAntivirals(x) ∧ ReceivesAntibiotics(x)) → Treated(x)) ::: If a patient receives both antiviral drugs and antibiotics, they are treated.",
            "∀x (Treated(x) → (ReceivesAntivirals(x) ∨ ReceivesAntibiotics(x))) ::: A treated patient must have some type of treatment.",
            "∀x ((Patient(x) ∧ HasFluSymptoms(x) ∧ HasColdSymptoms(x)) → (Treated(x) ∧ (ReceivesAntivirals(x) ∨ ReceivesAntibiotics(x)))) ::: If a patient has both flu and cold symptoms, they must be treated and either receive antiviral drugs or antibiotics.",
            "∀x (HasBacterialInfection(x) → HasColdSymptoms(x)) ::: Patients with bacterial infections have a cold."
        ],
        "predicates": [
            "Patient(x) ::: x is a patient",
            "HasFluSymptoms(x) ::: x has flu symptoms",
            "HasColdSymptoms(x) ::: x has cold symptoms",
            "Treated(x) ::: x is treated",
            "ReceivesAntivirals(x) ::: x receives antiviral drugs",
            "ReceivesAntibiotics(x) ::: x receives antibiotics",
            "HasVirus(x) ::: x has a virus",
            "HasBacterialInfection(x) ::: x has a bacterial infection"
        ]
    },
    {
        "premises-NL": [
            "All managers are employees.",
            "All interns are employees.",
            "Some employees are managers.",
            "If an employee is a manager, they are experienced.",
            "Experienced employees have 10 or more years of experience.",
            "If a manager manages an intern, then the intern is an employee.",
            "An employee is not an intern if they are a manager.",
            "If an employee is a manager, and the intern has less than 2 years of experience, then the manager cannot manage them.",
            "If an employee is an intern, then the employee has less than 2 years of experience.",
            "A manager with more than 10 years experience is experienced."
        ],
        "premises-FOL": [
            "∀x (Manager(x) → Employee(x)) ::: All managers are employees.",
            "∀x (Intern(x) → Employee(x)) ::: All interns are employees.",
            "∃x (Employee(x) ∧ Manager(x)) ::: Some employees are managers.",
            "∀x (Manager(x) → IsExperienced(x)) ::: If an employee is a manager, they are experienced.",
            "∀x (IsExperienced(x) → HasTenYears(x)) ::: Experienced employees have 10 or more years of experience.",
            "∀x ∀y (Manages(x, y) → (Intern(y) ∧ Employee(x))) ::: If a manager manages an intern, then the intern is an employee.",
            "∀x ∀y (Manager(x) → ¬Intern(x)) ::: An employee is not an intern if they are a manager.",
            "∀x ∀y ((Manager(x) ∧ YearsOfExperience(x, 10) ∧ Intern(y)) → ¬Manages(x, y)) ::: If an employee is a manager, and the intern has less than 2 years of experience, then the manager cannot manage them.",
            "∀x (Intern(x) → ¬YearsOfExperience(x,2)) ::: If an employee is an intern, then the employee has less than 2 years of experience.",
            "∀x (Manager(x) ∧ YearsOfExperience(x, 10) → IsExperienced(x)) ::: A manager with more than 10 years experience is experienced."
        ],
        "predicates": [
            "Employee(x) ::: x is an employee",
            "Manager(x) ::: x is a manager",
            "YearsOfExperience(x, y) ::: x has y years of experience",
            "Intern(x) ::: x is an intern",
            "Manages(x, y) ::: x manages y",
            "IsExperienced(x) ::: x is an experienced employee",
            "HasTenYears(x) ::: x has 10 or more years of experience"
        ]
    },
    {
        "premises-NL": [
            "All doctors are people.",
            "Doctors who do not smoke and have a healthy lifestyle are not prone to heart disease.",
            "Doctors who do not smoke and have a healthy lifestyle have a long life expectancy.",
            "People with a healthy lifestyle tend to follow medical advice.",
            "Doctors who are patients get regular checkups.",
            "People who smoke are not healthy.",
            "People who are not healthy are prone to heart disease and do not have a long life expectancy.",
            "People under stress are prone to heart disease.",
            "If a doctor does not smoke and has a healthy lifestyle, then they are not under stress.",
            "People with a healthy lifestyle are not prone to heart disease."
        ],
        "premises-FOL": [
            "∀x (Doctor(x) → Person(x)) ::: All doctors are people.",
            "∀x ((Doctor(x) ∧ ¬Smokes(x) ∧ HealthyLifestyle(x)) → ¬ProneToHeartDisease(x)) ::: Doctors who do not smoke and have a healthy lifestyle are not prone to heart disease.",
            "∀x ((Doctor(x) ∧ ¬Smokes(x) ∧ HealthyLifestyle(x)) → LongLifeExpectancy(x)) ::: Doctors who do not smoke and have a healthy lifestyle have a long life expectancy.",
            "∀x (HealthyLifestyle(x) → FollowsMedicalAdvice(x)) ::: People with a healthy lifestyle tend to follow medical advice.",
            "∀x ((Doctor(x) ∧ IsPatient(x)) → HasRegularCheckups(x)) ::: Doctors who are patients get regular checkups.",
            "∀x (Smokes(x) → ¬IsHealthy(x)) ::: People who smoke are not healthy.",
            "∀x (¬IsHealthy(x) → (ProneToHeartDisease(x) ∧ ¬LongLifeExpectancy(x))) ::: People who are not healthy are prone to heart disease and do not have a long life expectancy.",
            "∀x (UnderStress(x) → ProneToHeartDisease(x)) ::: People under stress are prone to heart disease.",
            "∀x ((Doctor(x) ∧ ¬Smokes(x) ∧ HealthyLifestyle(x)) → ¬UnderStress(x)) ::: If a doctor does not smoke and has a healthy lifestyle, then they are not under stress.",
            "∀x (HealthyLifestyle(x) → ¬ProneToHeartDisease(x)) ::: People with a healthy lifestyle are not prone to heart disease.",
            "∀x (Doctor(x) → Person(x)) ::: All doctors are people."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Doctor(x) ::: x is a doctor",
            "Smokes(x) ::: x smokes",
            "HealthyLifestyle(x) ::: x has a healthy lifestyle",
            "ProneToHeartDisease(x) ::: x is prone to heart disease",
            "LongLifeExpectancy(x) ::: x has a long life expectancy",
            "HasRegularCheckups(x) ::: x has regular checkups",
            "FollowsMedicalAdvice(x) ::: x follows medical advice",
            "IsPatient(x) ::: x is a patient",
            "UnderStress(x) ::: x is under stress",
            "IsHealthy(x) ::: x is healthy"
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled in a course.",
            "If a student is enrolled in a course, then they either pass all exams or fail the course.",
            "If a student does not fail a course, then they pass all exams.",
            "Students who pass exams also have good grades.",
            "Students with good grades tend to complete assignments.",
            "If a student completes all assignments, they do all homework.",
            "Students who attend lectures and read the textbook have good grades.",
            "Students enrolled in the course are taking it.",
            "Students with bad grades will fail the course.",
            "If a student passes the exam then they don't fail the course.",
            "If a student attends lectures and participates in discussions, they complete all homework.",
            "Students who do not complete all assignments are failing the course."
        ],
        "premises-FOL": [
            "∀x ∃y (Student(x) → EnrolledIn(x, y)) ::: All students are enrolled in a course.",
            "∀x ∀y (EnrolledIn(x, y) → (PassesExams(x, y) ∨ FailsCourse(x, y))) ::: If a student is enrolled in a course, then they either pass all exams or fail the course.",
            "∀x ∀y (¬FailsCourse(x, y) → PassesExams(x, y)) ::: If a student does not fail a course, then they pass all exams.",
            "∀x ∀y (PassesExams(x, y) → HasGoodGrades(x, y)) ::: Students who pass exams also have good grades.",
            "∀x ∀y (HasGoodGrades(x, y) → CompletesAssignments(x, y)) ::: Students with good grades tend to complete assignments.",
            "∀x ∀y (CompletesAssignments(x, y) → DoesHomework(x, y)) ::: If a student completes all assignments, they do all homework.",
            "∀x ∀y ((AttendsLectures(x, y) ∧ ReadsTextbook(x, y)) → HasGoodGrades(x, y)) ::: Students who attend lectures and read the textbook have good grades.",
            "∀x ∃y (EnrolledIn(x, y) → Course(y)) ::: Students enrolled in the course are taking it.",
            "∀x ∀y (HasBadGrades(x, y) → FailsCourse(x, y)) ::: Students with bad grades will fail the course.",
            "∀x ∀y (PassesExams(x, y) → ¬FailsCourse(x, y)) ::: If a student passes the exam then they don't fail the course.",
            "∀x ∀y ((AttendsLectures(x, y) ∧ ParticipatesInDiscussions(x, y)) → CompletesAssignments(x, y)) ::: If a student attends lectures and participates in discussions, they complete all homework.",
            "∀x ∀y (¬CompletesAssignments(x, y) → FailsCourse(x, y)) ::: Students who do not complete all assignments are failing the course."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Course(y) ::: y is a course",
            "EnrolledIn(x, y) ::: x is enrolled in y",
            "PassesExams(x, y) ::: x passes all exams in y",
            "DoesHomework(x, y) ::: x does all homework in y",
            "FailsCourse(x, y) ::: x fails y",
            "HasGoodGrades(x, y) ::: x has good grades in y",
            "AttendsLectures(x, y) ::: x attends lectures in y",
            "ReadsTextbook(x, y) ::: x reads the textbook for y",
            "ParticipatesInDiscussions(x, y) ::: x participates in discussions in y",
            "CompletesAssignments(x, y) ::: x completes assignments in y",
            "HasBadGrades(x, y) ::: x has bad grades in y"
        ]
    },
    {
        "premises-NL": [
            "All species that are extinct can no longer reproduce.",
            "Some species live in forests.",
            "If a species lives in a forest, it is endangered.",
            "Every endangered species is protected.",
            "There is habitat loss for the species that live in the forest.",
            "If a species is protected, then it can reproduce.",
            "No endangered species can reproduce.",
            "Some species are extinct.",
            "Every species is either extinct or reproducing.",
            "If there is habitat loss, the species is endangered.",
            "Habitat loss is only in the forest.",
            "Species is protected by the government.",
            "Species in the forest may not survive.",
            "If the species does not survive, then it is extinct.",
            "A species lives in the forest.",
            "The forest has a habitat loss for a species.",
            "The species is under threat."
        ],
        "premises-FOL": [
            "∀x (Extinct(x) → ¬Reproduces(x)) ::: All species that are extinct can no longer reproduce.",
            "∃x ∃y (Species(x) ∧ LivesIn(x, y) ∧ Forests(y)) ::: Some species live in forests.",
            "∀x ∀y (Species(x) ∧ LivesIn(x, y) ∧ Forests(y) → Endangered(x)) ::: If a species lives in a forest, it is endangered.",
            "∀x (Endangered(x) → Protected(x)) ::: Every endangered species is protected.",
            "∃x ∃y (HabitatLoss(x, y) ∧ Species(x) ∧ LivesIn(x, y)) ::: There is habitat loss for the species that live in the forest.",
            "∀x (Protected(x) → Reproduces(x)) ::: If a species is protected, then it can reproduce.",
            "∀x (Endangered(x) → ¬Reproduces(x)) ::: No endangered species can reproduce.",
            "∃x Extinct(x) ::: Some species are extinct.",
            "∀x (Species(x) → Extinct(x) ∨ Reproduces(x)) ::: Every species is either extinct or reproducing.",
            "∀x ∀y (HabitatLoss(x, y) → Endangered(x)) ::: If there is habitat loss, the species is endangered.",
            "∀x ∀y (HabitatLoss(x, y) → Forests(y)) ::: Habitat loss is only in the forest.",
            "∀x (Protected(x) → GovermentProtection(x)) ::: Species is protected by the government.",
            "∀x ∀y (Species(x) ∧ LivesIn(x, y) ∧ Forests(y) → ¬Survive(x)) ::: Species in the forest may not survive.",
            "∀x (¬Survive(x) → Extinct(x)) ::: If the species does not survive, then it is extinct.",
            "∃x ∃y (Species(x) ∧ LivesIn(x, y) ∧ Forests(y)) ::: A species lives in the forest.",
            "∃x ∃y (HabitatLoss(x, y) ∧ Species(x) ∧ LivesIn(x, y) ∧ Forests(y)) ::: The forest has a habitat loss for a species.",
            "∀x (Threat(x) → Endangered(x)) ::: The species is under threat."
        ],
        "predicates": [
            "Species(x) ::: x is a species",
            "Extinct(x) ::: x is extinct",
            "Reproduces(x) ::: x reproduces",
            "LivesIn(x, y) ::: x lives in y",
            "Endangered(x) ::: x is endangered",
            "Protected(x) ::: x is protected",
            "HabitatLoss(x, y) ::: Habitat loss threatens x in y."
        ]
    },
    {
        "premises-NL": [
            "John is a member of the club.",
            "John attends every meeting.",
            "If someone is a member of the club and attends a meeting, they have the right to vote.",
            "If someone has the right to vote, then they will vote.",
            "All members of the club attend meetings.",
            "If someone is at a meeting, they are a member of the club.",
            "John is present at a meeting.",
            "If John speaks at the meeting then he will vote.",
            "John is present at the club meeting.",
            "Every person who is a member of the club follows the rules.",
            "John follows the rules of the club.",
            "If someone follows the rule of the club, then they have the right to vote.",
            "Everyone is a member of the club.",
            "The club has a meeting.",
            "If a person is at a meeting, they must attend.",
            "If someone is at the meeting then the person speaks.",
            "If someone speaks at the meeting, they will vote.",
            "If someone attends the meeting, then the person is present.",
            "John is present at the meeting."
        ],
        "premises-FOL": [
            "MemberOf(john, club1) ::: John is a member of the club.",
            "∀x (Meeting(x) → Attends(john, x)) ::: John attends every meeting.",
            "∀x ∀y (MemberOf(x, y) ∧ Attends(x, z) → HasRightToVote(x)) ::: If someone is a member of the club and attends a meeting, they have the right to vote.",
            "∀x (HasRightToVote(x) → Votes(x)) ::: If someone has the right to vote, then they will vote.",
            "∀x ∀y (MemberOf(x, y) → Attends(x, z)) ::: All members of the club attend meetings.",
            "∀x ∀y (IsPresent(x, y) → MemberOf(x, z)) ::: If someone is at a meeting, they are a member of the club.",
            "IsPresent(john, meeting1) ::: John is present at a meeting.",
            "∀x (Speaks(john, x) → Votes(john)) ::: If John speaks at the meeting then he will vote.",
            "IsPresent(john, meeting1) ::: John is present at the club meeting.",
            "∀x ∀y (MemberOf(x, y) → Follows(x, rules)) ::: Every person who is a member of the club follows the rules.",
            "Follows(john, rules) ::: John follows the rules of the club.",
            "∀x (Follows(x, rules) → HasRightToVote(x)) ::: If someone follows the rule of the club, then they have the right to vote.",
            "∀x (MemberOf(x, club1)) ::: Everyone is a member of the club.",
            "Meeting(meeting1) ::: The club has a meeting.",
            "∀x (IsPresent(x, meeting1) → Attends(x, meeting1)) ::: If a person is at a meeting, they must attend.",
            "∀x (IsPresent(x, meeting1) → Speaks(x, meeting1)) ::: If someone is at the meeting then the person speaks.",
            "∀x (Speaks(x, meeting1) → Votes(x)) ::: If someone speaks at the meeting, they will vote.",
            "∀x (Attends(x, meeting1) → IsPresent(x, meeting1)) ::: If someone attends the meeting, then the person is present.",
            "IsPresent(john, meeting1) ::: John is present at the meeting."
        ],
        "predicates": [
            "MemberOf(x, y) ::: x is a member of y",
            "Attends(x, y) ::: x attends y",
            "Votes(x) ::: x votes",
            "Club(x) ::: x is a club",
            "Meeting(x) ::: x is a meeting",
            "IsPresent(x, y) ::: x is present at y",
            "Speaks(x, y) ::: x speaks at y",
            "HasRightToVote(x) ::: x has right to vote",
            "Follows(x, y) ::: x follows y"
        ]
    },
    {
        "premises-NL": [
            "CS101 is a course.",
            "CS202 is a course.",
            "CS202 requires CS101 as a prerequisite.",
            "If a student completed a prerequisite, they are eligible to attempt the next course.",
            "Alice has completed CS101."
        ],
        "premises-FOL": [
            "Course(CS101) ::: CS101 is a course.",
            "Course(CS202) ::: CS202 is a course.",
            "RequiresPrerequisite(CS202, CS101) ::: CS202 requires CS101 as a prerequisite.",
            "∀s ∀c1 ∀c2 (RequiresPrerequisite(c1, c2) ∧ CompletedCourse(s, c2)) → EligibleToAttempt(s, c1) ::: If a student completed a prerequisite, they are eligible to attempt the next course.",
            "CompletedCourse(Alice, CS101) ::: Alice has completed CS101."
        ],
        "predicates": [
            "Course(x) ::: x is a course",
            "RequiresPrerequisite(x, y) ::: x requires y as a prerequisite",
            "CompletedCourse(x, y) ::: x has completed course y",
            "EligibleToAttempt(x, y) ::: x is eligible to attempt course y"
        ]
    },
    {
        "premises-NL": [
            "Grace is a student.",
            "CS301 is a course.",
            "PHYS201 is a course.",
            "Grace wants to enroll in section CS301_S01.",
            "Grace wants to enroll in section PHYS201_S02.",
            "Section CS301_S01 conflicts with section PHYS201_S02.",
            "CS301_S01 is a section of CS301.",
            "PHYS201_S02 is a section of PHYS201."
        ],
        "premises-FOL": [
            "Student(Grace) ::: Grace is a student.",
            "Course(CS301) ::: CS301 is a course.",
            "Course(PHYS201) ::: PHYS201 is a course.",
            "WantsToEnrollInSection(Grace, CS301_S01) ::: Grace wants to enroll in section CS301_S01.",
            "WantsToEnrollInSection(Grace, PHYS201_S02) ::: Grace wants to enroll in section PHYS201_S02.",
            "Conflicts(CS301_S01, PHYS201_S02) ::: Section CS301_S01 conflicts with section PHYS201_S02.",
            "IsSectionOf(CS301_S01, CS301) ::: CS301_S01 is a section of CS301.",
            "IsSectionOf(PHYS201_S02, PHYS201) ::: PHYS201_S02 is a section of PHYS201."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Course(x) ::: x is a course",
            "WantsToEnrollInSection(s, s) ::: student s wants to enroll in section s",
            "Conflicts(s1, s2) ::: section s1 conflicts with section s2",
            "IsSectionOf(s, c) ::: section s is a section of course c",
            "CannotEnrollBothSections(s, s1, s2) ::: student s cannot enroll in both section s1 and section s2"
        ]
    },
    {
        "premises-NL": [
            "If a course must be taken in a specific semester and is offered in that semester, then it can be taken in that semester.",
            "Logic I (L101) is a mandatory course for the Philosophy degree.",
            "Logic I (L101) must be taken in the Fall semester.",
            "Logic I (L101) is offered in the Fall semester.",
            "L101 is a course.",
            "Fall is a semester."
        ],
        "premises-FOL": [
            "∀x ∀s ((MustBeTakenInSemester(x, s) ∧ OfferedInSemester(x, s)) → CanTakeInSemester(x, s)) ::: If a course x must be taken in semester s and is offered in semester s, then it can be taken in s.",
            "IsMandatoryForDegree(L101, Philosophy) ::: Logic I is a mandatory course for the Philosophy degree.",
            "MustBeTakenInSemester(L101, Fall) ::: Logic I must be taken in the Fall semester.",
            "OfferedInSemester(L101, Fall) ::: Logic I is offered in the Fall semester.",
            "Course(L101) ::: L101 is a course.",
            "Semester(Fall) ::: Fall is a semester."
        ],
        "predicates": [
            "Course(x) ::: x is a course.",
            "Semester(s) ::: s is a semester.",
            "Degree(d) ::: d is a degree.",
            "IsMandatoryForDegree(x, d) ::: Course x is mandatory for degree d.",
            "MustBeTakenInSemester(x, s) ::: Course x must be taken in semester s.",
            "OfferedInSemester(x, s) ::: Course x is offered in semester s.",
            "CanTakeInSemester(x, s) ::: Course x can be taken in semester s."
        ]
    },
    {
        "premises-NL": [
            "Alice is a student.",
            "Alice is majoring in Computer Science.",
            "CS101 is a course for the CS major.",
            "CS201 is a course for the CS major.",
            "CS101 is a required course.",
            "CS201 is a required course.",
            "CS201 has CS101 as a prerequisite.",
            "Alice is enrolled in CS101.",
            "Alice has not completed CS101 yet.",
            "If a student hasn't completed a required course, they need to enroll in it.",
            "If a student is enrolled in a course, and it has a prerequisite they haven't completed, they cannot complete the course this semester.",
            "If a student needs to enroll in a major course they haven't enrolled in, they should plan enrollment."
        ],
        "premises-FOL": [
            "Student(Alice) ::: Alice is a student.",
            "Major(Alice, \"CS\") ::: Alice is majoring in Computer Science.",
            "CourseForMajor(\"CS101\", \"CS\") ::: CS101 is a course for the CS major.",
            "CourseForMajor(\"CS201\", \"CS\") ::: CS201 is a course for the CS major.",
            "RequiredCourse(\"CS101\") ::: CS101 is a required course.",
            "RequiredCourse(\"CS201\") ::: CS201 is a required course.",
            "HasPrerequisite(\"CS201\", \"CS101\") ::: CS201 has CS101 as a prerequisite.",
            "Enrolled(Alice, \"CS101\") ::: Alice is enrolled in CS101.",
            "¬Completed(Alice, \"CS101\") ::: Alice has not completed CS101 yet.",
            "∀x ∀y (Student(x) ∧ RequiredCourse(y) ∧ ¬Completed(x, y) → NeedsToEnroll(x, y)) ::: If a student hasn't completed a required course, they need to enroll in it.",
            "∀x ∀y ∀z (Student(x) ∧ Enrolled(x, y) ∧ HasPrerequisite(y, z) ∧ ¬Completed(x, z) → ¬CanComplete(x, y, \"this semester\")) ::: If a student is enrolled in a course, and it has a prerequisite they haven't completed, they cannot complete the course this semester.",
            "∀x ∀y ∀w (NeedsToEnroll(x, y) ∧ CourseForMajor(y, w) ∧ Major(x, w) ∧ ¬Enrolled(x, y) → ShouldPlanEnrollment(x, y)) ::: If a student needs to enroll in a major course they haven't enrolled in, they should plan enrollment."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Major(x, w) ::: x is majoring in w.",
            "CourseForMajor(y, w) ::: y is a course for major w.",
            "RequiredCourse(y) ::: y is a required course.",
            "HasPrerequisite(y1, y2) ::: y1 has y2 as a prerequisite.",
            "Enrolled(x, y) ::: x is enrolled in course y.",
            "Completed(x, y) ::: x has completed course y.",
            "NeedsToEnroll(x, y) ::: x needs to enroll in course y.",
            "CanComplete(x, y, z) ::: x can complete course y in semester z.",
            "ShouldPlanEnrollment(x, y) ::: x should plan enrollment in course y."
        ]
    },
    {
        "premises-NL": [
            "Eve is a student.",
            "Eve has paid tuition for Spring 2024.",
            "Eve has outstanding fees.",
            "Eve has an academic hold for Spring 2024.",
            "If a student has outstanding fees, they have a financial hold for that semester.",
            "If a student has an academic hold, they have an admin hold for that semester.",
            "If a student has a financial hold, they have an admin hold for that semester.",
            "If a student has an admin hold, their enrollment for that semester is blocked.",
            "A student has all holds cleared if and only if they do not have an admin hold.",
            "Frank is a student.",
            "Frank does not have outstanding fees.",
            "Frank does not have an academic hold.",
            "Frank has a financial hold for Spring 2024.",
            "Grace has an academic hold for Spring 2024.",
            "Grace has a financial hold for Spring 2024."
        ],
        "premises-FOL": [
            "Student(Eve) ::: Eve is a student.",
            "TuitionPaid(Eve, \"Spring2024\") ::: Eve has paid tuition for Spring 2024.",
            "HasOutstandingFees(Eve) ::: Eve has outstanding fees.",
            "AcademicHold(Eve, \"Spring2024\") ::: Eve has an academic hold for Spring 2024.",
            "∀x ∀z (Student(x) ∧ HasOutstandingFees(x) → FinancialHold(x, z)) ::: If a student has outstanding fees, they have a financial hold for that semester.",
            "∀x ∀z (Student(x) ∧ AcademicHold(x, z) → AdminHold(x, z)) ::: If a student has an academic hold, they have an admin hold for that semester.",
            "∀x ∀z (Student(x) ∧ FinancialHold(x, z) → AdminHold(x, z)) ::: If a student has a financial hold, they have an admin hold for that semester.",
            "∀x ∀z (Student(x) ∧ AdminHold(x, z) → EnrollmentBlocked(x, z)) ::: If a student has an admin hold, their enrollment for that semester is blocked.",
            "∀x ∀z (Student(x) ∧ AllHoldsCleared(x, z) ↔ ¬AdminHold(x, z)) ::: A student has all holds cleared if and only if they do not have an admin hold.",
            "Student(Frank) ::: Frank is a student.",
            "¬HasOutstandingFees(Frank) ::: Frank does not have outstanding fees.",
            "¬AcademicHold(Frank, \"Spring2024\") ::: Frank does not have an academic hold.",
            "FinancialHold(Frank, \"Spring2024\") ::: Frank has a financial hold for Spring 2024.",
            "AcademicHold(Grace, \"Spring2024\") ::: Grace has an academic hold for Spring 2024.",
            "FinancialHold(Grace, \"Spring2024\") ::: Grace has a financial hold for Spring 2024."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "TuitionPaid(x, z) ::: x has paid tuition for semester z.",
            "HasOutstandingFees(x) ::: x has outstanding fees.",
            "EnrollmentBlocked(x, z) ::: x's enrollment is blocked for semester z.",
            "AdminHold(x, z) ::: x has an administrative hold for semester z.",
            "FinancialHold(x, z) ::: x has a financial hold for semester z.",
            "AcademicHold(x, z) ::: x has an academic hold for semester z.",
            "AllHoldsCleared(x, z) ::: x has all holds cleared for semester z."
        ]
    },
    {
        "premises-NL": [
            "Getting an F in a course means failing that course.",
            "If a student failed a course, they are placed on academic probation.",
            "Being on academic probation means not being in good academic standing.",
            "Alice received an 'F' grade in the Art101 course.",
            "Alice is a student.",
            "Alice took the Art101 course.",
            "Art101 has no prerequisites."
        ],
        "premises-FOL": [
            "∀x ∀y (Grade(x, y, 'F') → FailedCourse(x, y)) ::: Getting an F means failing a course.",
            "∀x ∀y (FailedCourse(x, y) → OnProbation(x)) ::: If a student failed a course, they are placed on academic probation.",
            "∀x (OnProbation(x) → ¬GoodAcademicStanding(x)) ::: Being on probation means not being in good academic standing.",
            "Grade(Alice, Art101, 'F') ::: Alice got an 'F' in Art101.",
            "Student(Alice) ::: Alice is a student.",
            "TookCourse(Alice, Art101) ::: Alice took Art101.",
            "RequiresPrerequisite(Art101, None) ::: Art101 has no prerequisites."
        ],
        "predicates": [
            "Grade(x, y, gr) ::: Student x received grade gr in course y.",
            "FailedCourse(x, y) ::: Student x failed course y.",
            "OnProbation(x) ::: Student x is on academic probation.",
            "GoodAcademicStanding(x) ::: Student x is in good academic standing.",
            "Student(x) ::: x is a student.",
            "TookCourse(x, y) ::: Student x took course y.",
            "IsUndergraduate(x) ::: x is an undergraduate student.",
            "RequiresPrerequisite(y, z) ::: Course y requires course z as a prerequisite."
        ]
    },
    {
        "premises-NL": [
            "A student is eligible for graduation with a degree program if they are pursuing that degree, have completed the required credits, achieved the minimum GPA, completed the capstone project, and have no administrative holds.",
            "All students pursuing the 'Computer Science' degree must complete 120 credit hours.",
            "All students pursuing the 'Computer Science' degree must achieve a minimum GPA of 2.5.",
            "All students pursuing the 'Computer Science' degree must complete a capstone project.",
            "All students pursuing the 'Computer Science' degree must have no administrative holds.",
            "There is at least one student pursuing the 'Computer Science' degree.",
            "The student pursuing 'Computer Science' has completed 125 credit hours, achieved a GPA of 3.0, completed their capstone project, and has no holds."
        ],
        "premises-FOL": [
            "∀x ∀z ( (PursuingDegree(x, z) ∧ CompletedRequiredCredits(x, z) ∧ AchievedMinimumGPA(x, z) ∧ CompletedCapstoneProject(x, z) ∧ HasNoHolds(x)) → EligibleForGraduation(x, z) ) ::: A student is eligible for graduation with a degree program if they meet all requirements",
            "∀x (PursuingDegree(x, 'ComputerScience') → CompletedRequiredCredits(x, 'ComputerScience')) ::: All students pursuing 'Computer Science' must complete required credits",
            "∀x (PursuingDegree(x, 'ComputerScience') → AchievedMinimumGPA(x, 'ComputerScience')) ::: All students pursuing 'Computer Science' must achieve minimum GPA",
            "∀x (PursuingDegree(x, 'ComputerScience') → CompletedCapstoneProject(x, 'ComputerScience')) ::: All students pursuing 'Computer Science' must complete capstone project",
            "∀x (PursuingDegree(x, 'ComputerScience') → HasNoHolds(x)) ::: All students pursuing 'Computer Science' must have no administrative holds",
            "∃x (Student(x) ∧ PursuingDegree(x, 'ComputerScience')) ::: There is at least one student pursuing 'Computer Science'",
            "∃x (Student(x) ∧ PursuingDegree(x, 'ComputerScience') ∧ CompletedRequiredCredits(x, 'ComputerScience') ∧ AchievedMinimumGPA(x, 'ComputerScience') ∧ CompletedCapstoneProject(x, 'ComputerScience') ∧ HasNoHolds(x)) ::: The student pursuing 'Computer Science' meets all criteria"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "DegreeProgram(z) ::: z is a degree program",
            "PursuingDegree(x, z) ::: Student x is pursuing degree program z",
            "CompletedRequiredCredits(x, z) ::: Student x has completed the required credit hours for degree program z",
            "AchievedMinimumGPA(x, z) ::: Student x has achieved the minimum required GPA for degree program z",
            "CompletedCapstoneProject(x, z) ::: Student x has completed the capstone project for degree program z",
            "HasNoHolds(x) ::: Student x has no administrative holds",
            "EligibleForGraduation(x, z) ::: Student x is eligible for graduation with degree program z"
        ]
    },
    {
        "premises-NL": [
            "Every student is enrolled.",
            "A student can enroll in a course if the course is offered, is not full, they meet the prerequisite, they do not have holds, and they are enrolled.",
            "Chemistry 101 is a prerequisite for Advanced Chemistry.",
            "A student meets the prerequisite for Advanced Chemistry if they have completed Chemistry 101.",
            "Advanced Chemistry is offered in Fall 2023.",
            "Advanced Chemistry is not full.",
            "No student has holds on their account this semester.",
            "Chemistry 101 satisfies a science degree requirement."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x)) ::: Every student is enrolled.",
            "∀x ∀y ( (Offered(y, currentSemester) ∧ ¬IsFull(y) ∧ MeetsPrerequisite(x, y) ∧ ¬HasHolds(x) ∧ Enrolled(x)) → CanEnroll(x, y) ) ::: A student can enroll in a course if the course is offered, is not full, they meet the prerequisite, they do not have holds, and they are enrolled.",
            "Prerequisite(chemistry101, advancedChemistry) ::: Chemistry 101 is a prerequisite for Advanced Chemistry.",
            "∀x (Prerequisite(chemistry101, advancedChemistry) ∧ HasCompleted(x, chemistry101) → MeetsPrerequisite(x, advancedChemistry)) ::: A student meets the prerequisite for Advanced Chemistry if they have completed Chemistry 101.",
            "Offered(advancedChemistry, fall2023) ::: Advanced Chemistry is offered in Fall 2023.",
            "¬IsFull(advancedChemistry) ::: Advanced Chemistry is not full.",
            "∀x ¬HasHolds(x) ::: No student has holds on their account this semester.",
            "SatisfiesDegreeRequirement(chemistry101, scienceRequirement) ::: Chemistry 101 satisfies a science degree requirement."
        ],
        "predicates": [
            "Enrolled(x) ::: x is currently enrolled as a student",
            "MeetsPrerequisite(x, y) ::: student x meets the prerequisite for course y",
            "IsMajor(x, y) ::: student x is majoring in subject y",
            "RequiredForMajor(x, y) ::: course x is required for major y",
            "Offered(x, y) ::: course x is offered in semester y",
            "HasCompleted(x, y) ::: student x has completed course y",
            "CanEnroll(x, y) ::: student x is eligible to enroll in course y",
            "SatisfiesDegreeRequirement(x, y) ::: course x satisfies degree requirement y",
            "IsFull(x) ::: course x is full",
            "HasHolds(x) ::: student x has holds on their account"
        ]
    },
    {
        "premises-NL": [
            "Any course that is Science or Engineering requires a lab.",
            "Any advanced course that requires a lab must be scheduled after 2 PM in any Room.",
            "Any graduate-level course is considered an advanced course.",
            "CHEM301 is a course.",
            "CHEM301 is a Science course.",
            "CHEM301 is a graduate-level course.",
            "Room 101 is a room.",
            "The schedule requires CHEM301 to be held in Room 101."
        ],
        "premises-FOL": [
            "∀c (Course(c) ∧ (IsScience(c) ∨ IsEngineering(c)) → RequiresLab(c)) ::: Any course that is Science or Engineering requires a lab.",
            "∀c ∀r (Course(c) ∧ IsAdvanced(c) ∧ RequiresLab(c) ∧ Room(r) → ScheduledAfter2PMInRoom(c, r)) ::: Any advanced course that requires a lab must be scheduled after 2 PM in any Room.",
            "∀c (Course(c) ∧ IsGradLevel(c) → IsAdvanced(c)) ::: Any graduate-level course is considered an advanced course.",
            "Course(chem301) ::: CHEM301 is a course.",
            "IsScience(chem301) ::: CHEM301 is a Science course.",
            "IsGradLevel(chem301) ::: CHEM301 is a graduate-level course.",
            "Room(room101) ::: Room 101 is a room.",
            "RequiredRoom(chem301, room101) ::: The schedule requires CHEM301 to be held in Room 101."
        ],
        "predicates": [
            "Course(c) ::: c is a course.",
            "RequiresLab(c) ::: Course c requires a lab section.",
            "IsScience(c) ::: Course c is a science course.",
            "IsEngineering(c) ::: Course c is an engineering course.",
            "IsAdvanced(c) ::: Course c is considered an advanced course.",
            "IsGradLevel(c) ::: Course c is a graduate-level course.",
            "ScheduledAfter2PMInRoom(c, r) ::: Course c is scheduled after 2 PM in room r.",
            "Room(r) ::: r is a room.",
            "RequiredRoom(c, r) ::: Course c is required to be held in room r."
        ]
    },
    {
        "premises-NL": [
            "A student can register for a course if they satisfy the prerequisites for the course, the course is available, and they have no holds on their account.",
            "A student satisfies the prerequisites for Course C1 if (they satisfied Prerequisite P1 OR P1 was waived OR (they are concurrently enrolled in P1 AND concurrent enrollment counts for P1 for C1)) AND (they satisfied Prerequisite P2 OR P2 was waived OR (they are concurrently enrolled in P2 AND concurrent enrollment counts for P2 for C1)).",
            "A student has no hold on their account if they do not have a financial hold AND do not have an academic hold.",
            "Course C1 is available for registration.",
            "John has satisfied Prerequisite P1.",
            "John is concurrently enrolled in Prerequisite P2.",
            "Concurrent enrollment in Prerequisite P2 counts towards satisfying the prerequisite for Course C1.",
            "John does not have a financial hold.",
            "John does not have an academic hold."
        ],
        "premises-FOL": [
            "∀x ∀c (SatisfiesPrerequisites(x, c) ∧ CourseIsAvailable(c) ∧ HasNoHold(x) → CanRegister(x, c)) ::: A student can register for a course if they satisfy the prerequisites for the course, the course is available, and they have no holds on their account.",
            "∀x (SatisfiesPrerequisites(x, courseC1) ↔ ((SatisfiedPrerequisite(x, prereqP1) ∨ WaivedPrerequisite(x, prereqP1) ∨ (IsConcurrentlyEnrolled(x, prereqP1) ∧ ConcurrentEnrollmentCounts(prereqP1, courseC1))) ∧ (SatisfiedPrerequisite(x, prereqP2) ∨ WaivedPrerequisite(x, prereqP2) ∨ (IsConcurrentlyEnrolled(x, prereqP2) ∧ ConcurrentEnrollmentCounts(prereqP2, courseC1))))) ::: A student satisfies the prerequisites for Course C1 if (they satisfied Prerequisite P1 OR P1 was waived OR (they are concurrently enrolled in P1 AND concurrent enrollment counts for P1 for C1)) AND (they satisfied Prerequisite P2 OR P2 was waived OR (they are concurrently enrolled in P2 AND concurrent enrollment counts for P2 for C1)).",
            "∀x (HasNoHold(x) ↔ (¬HasFinancialHold(x) ∧ ¬HasAcademicHold(x))) ::: A student has no hold on their account if they do not have a financial hold AND do not have an academic hold.",
            "CourseIsAvailable(courseC1) ::: Course C1 is available for registration.",
            "SatisfiedPrerequisite(john, prereqP1) ::: John has satisfied Prerequisite P1.",
            "IsConcurrentlyEnrolled(john, prereqP2) ::: John is concurrently enrolled in Prerequisite P2.",
            "ConcurrentEnrollmentCounts(prereqP2, courseC1) ::: Concurrent enrollment in Prerequisite P2 counts towards satisfying the prerequisite for Course C1.",
            "¬HasFinancialHold(john) ::: John does not have a financial hold.",
            "¬HasAcademicHold(john) ::: John does not have an academic hold."
        ],
        "predicates": [
            "SatisfiesPrerequisites(x, c) ::: Student x satisfies the prerequisites for course c.",
            "CourseIsAvailable(c) ::: Course c is available for registration.",
            "HasNoHold(x) ::: Student x has no holds on their account.",
            "CanRegister(x, c) ::: Student x can register for course c.",
            "PrerequisiteFor(p, c) ::: Prerequisite p is required for course c.",
            "SatisfiedPrerequisite(x, p) ::: Student x has satisfied prerequisite p.",
            "WaivedPrerequisite(x, p) ::: Prerequisite p has been waived for student x.",
            "IsConcurrentlyEnrolled(x, p) ::: Student x is concurrently enrolled in prerequisite p.",
            "ConcurrentEnrollmentCounts(p, c) ::: Concurrent enrollment in prerequisite p counts towards satisfying the prerequisite for course c.",
            "HasFinancialHold(x) ::: Student x has a financial hold.",
            "HasAcademicHold(x) ::: Student x has an academic hold."
        ]
    },
    {
        "premises-NL": [
            "A student fails a course if they receive a grade below the minimum passing grade for that course.",
            "If a student failed a course that is required for their major, they need to retake it.",
            "Passing a course is the opposite of failing a course for any given student and course.",
            "John is a student in the Electrical Engineering major.",
            "Circuits I is a course.",
            "Circuits I is required for the Electrical Engineering major.",
            "John took Circuits I in Fall 2023.",
            "The minimum passing grade for Circuits I is C-.",
            "John received a grade of D in Circuits I.",
            "Any grade D is below the minimum passing grade C-.",
            "John paid tuition for Fall 2023.",
            "The current semester is Fall 2024."
        ],
        "premises-FOL": [
            "∀x ∀y ((Student(x) ∧ Course(y) ∧ ReceivedGrade(x, y, g) ∧ MinimumGrade(y, min_g) ∧ GradeBelow(g, min_g)) → FailedCourse(x, y)) ::: Student fails if grade is below minimum.",
            "∀x ∀y ∀m ((Student(x) ∧ Course(y) ∧ FailedCourse(x, y) ∧ Major(x, m) ∧ RequiredForMajor(y, m)) → NeedsRetake(x, y)) ::: If failed a required course, need to retake.",
            "∀x ∀y (PassedCourse(x, y) ↔ ¬FailedCourse(x, y)) ::: Passing is opposite of failing.",
            "Student(John) ∧ Major(John, ElectricalEngineering) ::: John is an EE student.",
            "Course(CircuitsI) ::: Circuits I is a course.",
            "RequiredForMajor(CircuitsI, ElectricalEngineering) ::: Circuits I is required for EE.",
            "SemesterTaken(John, CircuitsI, Fall2023) ::: John took Circuits I in Fall 2023.",
            "MinimumGrade(CircuitsI, C_Minus) ::: Minimum grade for Circuits I is C-.",
            "ReceivedGrade(John, CircuitsI, D) ::: John received a D in Circuits I.",
            "GradeBelow(D, C_Minus) ::: Grade D is below C-.",
            "TuitionPaid(John, Fall2023) ::: John paid tuition for Fall 2023.",
            "CurrentSemester(Fall2024) ::: Current semester is Fall 2024."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Course(y) ::: y is a course",
            "Major(x, m) ::: student x has major m",
            "RequiredForMajor(y, m) ::: course y is required for major m",
            "PassedCourse(x, y) ::: student x passed course y",
            "FailedCourse(x, y) ::: student x failed course y",
            "NeedsRetake(x, y) ::: student x needs to retake course y",
            "SemesterTaken(x, y, s) ::: student x took course y in semester s",
            "CurrentSemester(s) ::: s is the current semester",
            "MinimumGrade(y, g) ::: minimum passing grade for course y is g",
            "ReceivedGrade(x, y, g) ::: student x received grade g in course y",
            "TuitionPaid(x, s) ::: student x paid tuition for semester s"
        ]
    },
    {
        "premises-NL": [
            "Uma is a student.",
            "GRAD_SEMINAR is a course.",
            "GRAD_SEMINAR is offered in Fall 2030.",
            "GRAD_SEMINAR requires an undergraduate degree as a prerequisite.",
            "Uma has completed the undergraduate degree prerequisite.",
            "GRAD_SEMINAR requires advisor approval.",
            "Uma does not have advisor approval for GRAD_SEMINAR.",
            "Uma has an advisor hold.",
            "If a student has an advisor hold, they cannot get advisor approval for any course.",
            "If a student is a student, the course is a course, and it's offered in the semester, the student can enroll if and only if (the prerequisite is not required OR it has been completed) AND (advisor approval is not required OR it has been obtained).",
            "Uma is a student, GRAD_SEMINAR is a course, and it's offered in Fall 2030."
        ],
        "premises-FOL": [
            "Student(Uma) ::: Uma is a student.",
            "Course(GRAD_SEMINAR) ::: GRAD_SEMINAR is a course.",
            "Offered(GRAD_SEMINAR, 'Fall2030') ::: GRAD_SEMINAR is offered in Fall 2030.",
            "RequiresPrerequisite(GRAD_SEMINAR, 'UG_DEGREE') ::: GRAD_SEMINAR requires an undergraduate degree as a prerequisite.",
            "HasCompletedPrerequisite(Uma, 'UG_DEGREE') ::: Uma has completed the undergraduate degree prerequisite.",
            "RequiresAdvisorApproval(GRAD_SEMINAR) ::: GRAD_SEMINAR requires advisor approval.",
            "¬HasAdvisorApproval(Uma, GRAD_SEMINAR) ::: Uma does not have advisor approval for GRAD_SEMINAR.",
            "HasAdvisorHold(Uma) ::: Uma has an advisor hold.",
            "∀x (Student(x) ∧ HasAdvisorHold(x) → ¬HasAdvisorApproval(x, y)) ::: If a student has an advisor hold, they cannot get advisor approval for any course.",
            "∀x ∀y ∀s (Student(x) ∧ Course(y) ∧ Offered(y, s) → (CanEnroll(x, y, s) ↔ (¬RequiresPrerequisite(y, z) ∨ HasCompletedPrerequisite(x, z)) ∧ (¬RequiresAdvisorApproval(y) ∨ HasAdvisorApproval(x, y)))) ::: If a student is a student, the course is a course, and it's offered in the semester, the student can enroll if and only if (the prerequisite is not required OR it has been completed) AND (advisor approval is not required OR it has been obtained).",
            "Student(Uma) ∧ Course(GRAD_SEMINAR) ∧ Offered(GRAD_SEMINAR, 'Fall2030') ::: Uma is a student, GRAD_SEMINAR is a course, and it's offered in Fall 2030."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Course(y) ::: y is a course",
            "Offered(y, s) ::: Course y is offered in semester s",
            "HasAdvisorHold(x) ::: x has an advisor hold",
            "RequiresAdvisorApproval(y) ::: y requires advisor approval",
            "HasAdvisorApproval(x, y) ::: x has advisor approval for y",
            "RequiresPrerequisite(y, z) ::: y requires z as a prerequisite",
            "HasCompletedPrerequisite(x, z) ::: x has completed prerequisite z",
            "CanEnroll(x, y, s) ::: Student x can enroll in course y for semester s"
        ]
    },
    {
        "premises-NL": [
            "All students who have completed CourseA meet the enrollment criteria for CourseB.",
            "CourseB requires department approval.",
            "John is a student.",
            "John has completed CourseA.",
            "If a student meets the enrollment criteria for an approval-required course, they can enroll if and only if they receive approval.",
            "CourseA is a course."
        ],
        "premises-FOL": [
            "∀x (IsStudent(x) ∧ HasCompleted(x, CourseA) → MeetsEnrollmentCriteria(x, CourseB)) ::: All students who have completed CourseA meet the enrollment criteria for CourseB.",
            "RequiresApproval(CourseB) ::: CourseB requires department approval.",
            "IsStudent(John) ::: John is a student.",
            "HasCompleted(John, CourseA) ::: John has completed CourseA.",
            "∀x ∀y (MeetsEnrollmentCriteria(x, y) ∧ RequiresApproval(y) → (CanEnroll(x, y) ↔ ReceivedApproval(x, y))) ::: If a student meets the enrollment criteria for an approval-required course, they can enroll if and only if they receive approval.",
            "IsCourse(CourseA) ::: CourseA is a course."
        ],
        "predicates": [
            "IsStudent(x) ::: x is a student",
            "HasCompleted(x, y) ::: x has completed course y",
            "CanEnroll(x, y) ::: x can enroll in course y",
            "MeetsEnrollmentCriteria(x, y) ::: x meets the general enrollment criteria for course y",
            "IsCourse(y) ::: y is a course",
            "RequiresApproval(y) ::: Course y requires department approval",
            "ReceivedApproval(x, y) ::: x has received approval to enroll in course y"
        ]
    },
    {
        "premises-NL": [
            "If course y is a prerequisite for course z for student x, and x has not completed y, then x cannot enroll in z.",
            "If course y requires department approval, and x does not have approval for y, then x cannot enroll in y.",
            "All advanced courses require department approval.",
            "CS401 is an advanced course.",
            "CS301 is a prerequisite for CS401 for Alice.",
            "Alice has not completed CS301.",
            "Alice is enrolled in CS201.",
            "There exists at least one advanced course.",
            "If x can enroll in y, it's not the case that y requires department approval and x doesn't have it."
        ],
        "premises-FOL": [
            "∀x ∀y ∀z (IsPrerequisite(x, y, z) ∧ ¬Completed(x, y) → ¬CanEnroll(x, z)) ::: If course y is a prerequisite for course z for student x, and x has not completed y, then x cannot enroll in z.",
            "∀x ∀y (RequiresDepartmentApproval(y) ∧ ¬HasDepartmentApproval(x, y) → ¬CanEnroll(x, y)) ::: If course y requires department approval, and x does not have approval for y, then x cannot enroll in y.",
            "∀y (IsAdvancedCourse(y) → RequiresDepartmentApproval(y)) ::: All advanced courses require department approval.",
            "IsAdvancedCourse(CS401) ::: CS401 is an advanced course.",
            "IsPrerequisite(Alice, CS301, CS401) ::: CS301 is a prerequisite for CS401 for Alice.",
            "¬Completed(Alice, CS301) ::: Alice has not completed CS301.",
            "Enrolled(Alice, CS201) ::: Alice is enrolled in CS201.",
            "∃y (IsAdvancedCourse(y)) ::: There exists at least one advanced course.",
            "∀x ∀y (CanEnroll(x, y) → ¬(RequiresDepartmentApproval(y) ∧ ¬HasDepartmentApproval(x, y))) ::: If x can enroll in y, it's not the case that y requires department approval and x doesn't have it."
        ],
        "predicates": [
            "Enrolled(x, y) ::: x is enrolled in course y",
            "Completed(x, y) ::: x has completed course y",
            "IsPrerequisite(x, y, z) ::: course y is a prerequisite for course z for student x",
            "IsAdvancedCourse(y) ::: y is an advanced course",
            "RequiresDepartmentApproval(y) ::: course y requires department approval",
            "HasDepartmentApproval(x, y) ::: x has department approval for course y",
            "CanEnroll(x, y) ::: x can enroll in course y"
        ]
    },
    {
        "premises-NL": [
            "Alice is a student.",
            "Advanced Logic is a course.",
            "Intro to Logic is a course.",
            "Advanced Logic requires a prerequisite.",
            "Intro to Logic is a prerequisite for Advanced Logic.",
            "Alice has completed Intro to Logic.",
            "The Advanced Logic course is available."
        ],
        "premises-FOL": [
            "Student(Alice) ::: Alice is a student.",
            "Course(AdvancedLogic) ::: Advanced Logic is a course.",
            "Course(IntroToLogic) ::: Intro to Logic is a course.",
            "RequiresPrerequisite(AdvancedLogic) ::: Advanced Logic requires a prerequisite.",
            "IsPrerequisiteFor(IntroToLogic, AdvancedLogic) ::: Intro to Logic is a prerequisite for Advanced Logic.",
            "HasCompleted(Alice, IntroToLogic) ::: Alice has completed Intro to Logic.",
            "CourseAvailable(AdvancedLogic) ::: The Advanced Logic course is available."
        ],
        "predicates": [
            "AffectsGPACalculation(y)",
            "AnotherPotentialAcademicIssue(x, s)",
            "CanEnroll(x, y)",
            "CanRegister(x, c, s)",
            "CompletedCourse(x, y)",
            "CompletedCourse(x, c)",
            "CompletedProject(x)",
            "CompletedThesis(x)",
            "Course(y)",
            "Course(c)",
            "CourseAvailable(y)",
            "CourseSatisfiesRequirement(c, r)",
            "EligibleToGraduate(x, m)",
            "EligibleForDegree(x, m)",
            "EnrollmentLoadBelowFullTime(x, s)",
            "FailedCourse(x, y, s)",
            "GPABelowThreshold(x, s)",
            "HasCompleted(x, z)",
            "InSemester(x, s)",
            "IsPrerequisiteFor(z, y)",
            "IsRegisteredAtTime(x, t)",
            "MajorRequirement(r, m)",
            "MajoringIn(x, m)",
            "MetCreditRequirement(x, m)",
            "MetElectiveRequirement(x, m)",
            "PlacedOnProbation(x, s)",
            "PotentialAcademicIssue(x, s)",
            "RequiredCourseForMajor(y, m)",
            "RequiresElectives(m)",
            "RequiresPrerequisite(y)",
            "RequiresThesisOrProject(m)",
            "RegistrationBlocked(x, s, r)",
            "ScheduledTime(s, t)",
            "SectionFull(s)",
            "SectionOfCourse(s, c)",
            "Student(x)",
            "WantsToRegister(x, y)",
            "WantsToRegister(x, c, s)"
        ]
    },
    {
        "premises-NL": [
            "Charlie is a student.",
            "Charlie is in the Spring 2024 semester.",
            "Charlie failed Thermodynamics in Spring 2024.",
            "Thermodynamics is a course that affects GPA calculation.",
            "Charlie's GPA is below the threshold in Spring 2024.",
            "Charlie's enrollment load is below full-time in Spring 2024.",
            "If Charlie failed a GPA-affecting course in Spring 2024, it indicates a potential academic issue.",
            "If a student's enrollment load is below full-time in a semester, it indicates another potential academic issue.",
            "If a student has any potential academic issue in a semester and their GPA is below the threshold, they are placed on probation."
        ],
        "premises-FOL": [
            "Student(Charlie) ::: Charlie is a student.",
            "InSemester(Charlie, Spring2024) ::: Charlie is in the Spring 2024 semester.",
            "FailedCourse(Charlie, Thermodynamics, Spring2024) ::: Charlie failed Thermodynamics in Spring 2024.",
            "AffectsGPACalculation(Thermodynamics) ::: Thermodynamics is a course that affects GPA calculation.",
            "GPABelowThreshold(Charlie, Spring2024) ::: Charlie's GPA is below the threshold in Spring 2024.",
            "EnrollmentLoadBelowFullTime(Charlie, Spring2024) ::: Charlie's enrollment load is below full-time in Spring 2024.",
            "∀y (FailedCourse(Charlie, y, Spring2024) ∧ AffectsGPACalculation(y)) → PotentialAcademicIssue(Charlie, Spring2024) ::: If Charlie failed a GPA-affecting course in Spring 2024, it indicates a potential academic issue.",
            "∀x ∀s (Student(x) ∧ InSemester(x, s) ∧ EnrollmentLoadBelowFullTime(x, s)) → AnotherPotentialAcademicIssue(x, s) ::: If a student's enrollment load is below full-time in a semester, it indicates another potential academic issue.",
            "∀x ∀s (Student(x) ∧ InSemester(x, s) ∧ (PotentialAcademicIssue(x, s) ∨ AnotherPotentialAcademicIssue(x, s)) ∧ GPABelowThreshold(x, s) → PlacedOnProbation(x, s)) ::: If a student has any potential academic issue in a semester and their GPA is below the threshold, they are placed on probation."
        ],
        "predicates": [
            "AffectsGPACalculation(y)",
            "AnotherPotentialAcademicIssue(x, s)",
            "CanEnroll(x, y)",
            "CanRegister(x, c, s)",
            "CompletedCourse(x, y)",
            "CompletedCourse(x, c)",
            "CompletedProject(x)",
            "CompletedThesis(x)",
            "Course(y)",
            "Course(c)",
            "CourseAvailable(y)",
            "CourseSatisfiesRequirement(c, r)",
            "EligibleToGraduate(x, m)",
            "EligibleForDegree(x, m)",
            "EnrollmentLoadBelowFullTime(x, s)",
            "FailedCourse(x, y, s)",
            "GPABelowThreshold(x, s)",
            "HasCompleted(x, z)",
            "InSemester(x, s)",
            "IsPrerequisiteFor(z, y)",
            "IsRegisteredAtTime(x, t)",
            "MajorRequirement(r, m)",
            "MajoringIn(x, m)",
            "MetCreditRequirement(x, m)",
            "MetElectiveRequirement(x, m)",
            "PlacedOnProbation(x, s)",
            "PotentialAcademicIssue(x, s)",
            "RequiredCourseForMajor(y, m)",
            "RequiresElectives(m)",
            "RequiresPrerequisite(y)",
            "RequiresThesisOrProject(m)",
            "RegistrationBlocked(x, s, r)",
            "ScheduledTime(s, t)",
            "SectionFull(s)",
            "SectionOfCourse(s, c)",
            "Student(x)",
            "WantsToRegister(x, y)",
            "WantsToRegister(x, c, s)"
        ]
    },
    {
        "premises-NL": [
            "Every student has a GPA status.",
            "Every student has a status regarding sufficient credits completed.",
            "If a student has a GPA status, they either meet or don't meet the minimum GPA.",
            "If a student has completed credits status, they either meet or don't meet the minimum credits.",
            "A student is in good standing if and only if they meet the minimum GPA and meet the minimum credits.",
            "If a student is not in good standing, they require an advisor meeting."
        ],
        "premises-FOL": [
            "∀x (Student(x) → HasGPA(x)) ::: Every student has a GPA status.",
            "∀x (Student(x) → HasCompletedSufficientCredits(x)) ::: Every student has a status regarding sufficient credits completed.",
            "∀x ((Student(x) ∧ HasGPA(x)) → (MeetsMinimumGPA(x) ∨ ¬MeetsMinimumGPA(x))) ::: If a student has a GPA status, they either meet or don't meet the minimum GPA.",
            "∀x ((Student(x) ∧ HasCompletedSufficientCredits(x)) → (MeetsMinimumCredits(x) ∨ ¬MeetsMinimumCredits(x))) ::: If a student has completed credits status, they either meet or don't meet the minimum credits.",
            "∀x (Student(x) → (GoodStanding(x) ↔ (MeetsMinimumGPA(x) ∧ MeetsMinimumCredits(x)))) ::: A student is in good standing if and only if they meet the minimum GPA and meet the minimum credits.",
            "∀x ((Student(x) ∧ ¬GoodStanding(x)) → RequiresAdvisorMeeting(x)) ::: If a student is not in good standing, they require an advisor meeting."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "HasGPA(x) ::: Student x has a GPA status.",
            "HasCompletedSufficientCredits(x) ::: Student x has a status regarding sufficient credits completed.",
            "MeetsMinimumGPA(x) ::: Student x meets the minimum GPA requirement.",
            "MeetsMinimumCredits(x) ::: Student x meets the minimum credit requirement.",
            "GoodStanding(x) ::: Student x is in good academic standing.",
            "RequiresAdvisorMeeting(x) ::: Student x requires a meeting with an advisor."
        ]
    },
    {
        "premises-NL": [
            "All professors who teach advanced courses have high expectations.",
            "If a student is not intelligent and doesn't study, they will struggle.",
            "If a student is enrolled in an advanced course and struggles, they will get a bad grade.",
            "If a student is not dedicated, they will not study",
            "Professor X is a professor",
            "Professor X teaches advanced courses",
            "Student Y is a student",
            "Student Y is enrolled in professor x's advanced course",
            "All students are intelligent",
            "Student Y is not dedicated"
        ],
        "premises-FOL": [
            "∀x (Professor(x) ∧ TeachesAdvancedCourse(x) → HighExpectations(x)) ::: All professors who teach advanced courses have high expectations.",
            "∀x (Student(x) ∧ ¬Intelligent(x) ∧ ¬Studies(x) → Struggles(x)) ::: If a student is not intelligent and doesn't study, they will struggle.",
            "∀x ∀y (Student(x) ∧ EnrolledIn(x, y) ∧ AdvancedCourse(y) ∧ Struggles(x) → BadGrade(x)) ::: If a student is enrolled in an advanced course and struggles, they will get a bad grade.",
            "∀x (Student(x) ∧ ¬Dedicated(x) → ¬Studies(x)) ::: If a student is not dedicated, they will not study",
            "Professor(professorX) ::: Professor X is a professor",
            "TeachesAdvancedCourse(professorX) ::: Professor X teaches advanced courses",
            "Student(studentY) ::: Student Y is a student",
            "EnrolledIn(studentY, professorX) ::: Student Y is enrolled in professor x's advanced course",
            "∀x (Student(x) → Intelligent(x)) ::: All students are intelligent",
            "¬Dedicated(studentY) ::: Student Y is not dedicated"
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "TeachesAdvancedCourse(x) ::: x teaches an advanced course",
            "HighExpectations(x) ::: x has high expectations",
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "Struggles(x) ::: x struggles",
            "BadGrade(x) ::: x gets a bad grade",
            "EnrolledIn(x, y) ::: x is enrolled in y",
            "Intelligent(x) ::: x is intelligent",
            "Dedicated(x) ::: x is dedicated"
        ]
    },
    {
        "premises-NL": [
            "∀x (Student(x) ∧ PaysTuition(x) → Enrolled(x)) ::: All students who pay tuition are enrolled.",
            "∀x (Enrolled(x) → AttendsClasses(x)) ::: All enrolled students attend classes.",
            "∀x (AttendsClasses(x) ∧ StudiesHard(x) → HighGPA(x)) ::: Students who attend classes and study hard have a high GPA.",
            "∀x (HighGPA(x) → Recognized(x)) ::: Students with a high GPA are recognized.",
            "∀x (Recognized(x) ∧ Enrolled(x) → EligibleForScholarship(x)) ::: Recognized and enrolled students are eligible for a scholarship.",
            "∀x (Enrolled(x) ∧ HighGPA(x) → Recognized(x) ∧ Enrolled(x)) ::: Enrolled students with HighGPA are both recognized and enrolled."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ PaysTuition(x) → Enrolled(x)) ::: All students who pay tuition are enrolled.",
            "∀x (Enrolled(x) → AttendsClasses(x)) ::: All enrolled students attend classes.",
            "∀x (AttendsClasses(x) ∧ StudiesHard(x) → HighGPA(x)) ::: Students who attend classes and study hard have a high GPA.",
            "∀x (HighGPA(x) → Recognized(x)) ::: Students with a high GPA are recognized.",
            "∀x (Recognized(x) ∧ Enrolled(x) → EligibleForScholarship(x)) ::: Recognized and enrolled students are eligible for a scholarship.",
            "∀x (Enrolled(x) ∧ HighGPA(x) → Recognized(x) ∧ Enrolled(x)) ::: Enrolled students with HighGPA are both recognized and enrolled."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x) ::: x is enrolled",
            "HighGPA(x) ::: x has a high GPA",
            "EligibleForScholarship(x) ::: x is eligible for a scholarship",
            "PaysTuition(x) ::: x pays tuition",
            "AttendsClasses(x) ::: x attends classes"
        ]
    },
    {
        "premises-NL": [
            "∀x (Student(x) ∧ Takes(x, Calculus) → Evaluated(x, Calculus)) ::: All students taking calculus are evaluated.",
            "∀x (Evaluated(x, Calculus) ∧ PoorPerformance(x) → FailedExam(x)) ::: If a student is evaluated and has poor performance then failed the exam.",
            "∀x (FailedExam(x) → NeedsHelp(x) ∨ RepeatCourse(x)) ::: If a student failed an exam, they need help or repeat the course.",
            "∀x (NeedsHelp(x) ∧ AsksForHelp(x) → GetsBetter(x)) ::: If a student needs help and asks for it, they get better.",
            "∀x (RepeatCourse(x) ∧ WorksHarder(x) → PassesEventually(x)) ::: If a student repeats the course and works harder, they pass eventually.",
            "∀x (Student(x) ∧ FailedExam(x) ∧ AsksForHelp(x) → GetsBetter(x)) ::: A student who failed, and asks for help gets better",
            "∀x (Student(x) ∧ FailedExam(x) ∧ WorksHarder(x) → PassesEventually(x)) ::: A student who failed, and works harder passes eventually",
            "∀x (Takes(x, Calculus) → Student(x)) ::: All the students taking Calculus are students."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ Takes(x, Calculus) → Evaluated(x, Calculus)) ::: All students taking calculus are evaluated.",
            "∀x (Evaluated(x, Calculus) ∧ PoorPerformance(x) → FailedExam(x)) ::: If a student is evaluated and has poor performance then failed the exam.",
            "∀x (FailedExam(x) → NeedsHelp(x) ∨ RepeatCourse(x)) ::: If a student failed an exam, they need help or repeat the course.",
            "∀x (NeedsHelp(x) ∧ AsksForHelp(x) → GetsBetter(x)) ::: If a student needs help and asks for it, they get better.",
            "∀x (RepeatCourse(x) ∧ WorksHarder(x) → PassesEventually(x)) ::: If a student repeats the course and works harder, they pass eventually.",
            "∀x (Student(x) ∧ FailedExam(x) ∧ AsksForHelp(x) → GetsBetter(x)) ::: A student who failed, and asks for help gets better",
            "∀x (Student(x) ∧ FailedExam(x) ∧ WorksHarder(x) → PassesEventually(x)) ::: A student who failed, and works harder passes eventually",
            "∀x (Takes(x, Calculus) → Student(x)) ::: All the students taking Calculus are students."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Takes(x, y) ::: x takes course y",
            "FailedExam(x) ::: x failed an exam",
            "NeedsHelp(x) ::: x needs help",
            "RepeatCourse(x) ::: x needs to repeat the course",
            "AsksForHelp(x) ::: x asks for help",
            "WorksHarder(x) ::: x works harder",
            "PassesEventually(x) ::: x passes eventually"
        ]
    },
    {
        "premises-NL": [
            "∀x (Student(x) ∧ PaidFees(x) → Registered(x, Fall2024)) ::: All students who have paid their fees are registered for Fall 2024.",
            "∀x (Registered(x, Fall2024) ∧ HasGoodStanding(x) → EligibleToEnroll(x)) ::: All students registered for Fall 2024 and in good standing are eligible to enroll.",
            "∀x (EligibleToEnroll(x) ∧ AttendedOrientation(x) → CanChooseCourses(x)) ::: All eligible students who attended orientation can choose courses.",
            "∀x (CanChooseCourses(x) ∧ CompletedPrerequisites(x, CourseA) → AbleToRequest(x, CourseB)) ::: All students who can choose courses and have completed the prerequisites for CourseA are able to request CourseB.",
            "∀x (AbleToRequest(x, CourseB) ∧ NeedsAdvisorApproval(x, CourseB) → ReceivedApproval(x, CourseB)) ::: All who requested CourseB and NeedsAdvisorApproval for CourseB will eventually ReceiveApproval.",
            "∀x (ReceivedApproval(x, CourseB) → CanEnroll(x, CourseB)) ::: A student who has received approval can enroll.",
            "∀x (CanChooseCourses(x) → NeedsAdvisorApproval(x, CourseB) ∨ CanEnroll(x, CourseB)) ::: A student that CanChooseCourses either NeedsAdvisorApproval or CanEnroll",
            "∀x (AbleToRequest(x, CourseB) → NeedsAdvisorApproval(x, CourseB)) ::: All students able to request CourseB Need Advisor Approval.",
            "∀x (Student(x) → HasGoodStanding(x)) ::: All Students have good standing."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ PaidFees(x) → Registered(x, Fall2024)) ::: All students who have paid their fees are registered for Fall 2024.",
            "∀x (Registered(x, Fall2024) ∧ HasGoodStanding(x) → EligibleToEnroll(x)) ::: All students registered for Fall 2024 and in good standing are eligible to enroll.",
            "∀x (EligibleToEnroll(x) ∧ AttendedOrientation(x) → CanChooseCourses(x)) ::: All eligible students who attended orientation can choose courses.",
            "∀x (CanChooseCourses(x) ∧ CompletedPrerequisites(x, CourseA) → AbleToRequest(x, CourseB)) ::: All students who can choose courses and have completed the prerequisites for CourseA are able to request CourseB.",
            "∀x (AbleToRequest(x, CourseB) ∧ NeedsAdvisorApproval(x, CourseB) → ReceivedApproval(x, CourseB)) ::: All who requested CourseB and NeedsAdvisorApproval for CourseB will eventually ReceiveApproval.",
            "∀x (ReceivedApproval(x, CourseB) → CanEnroll(x, CourseB)) ::: A student who has received approval can enroll.",
            "∀x (CanChooseCourses(x) → NeedsAdvisorApproval(x, CourseB) ∨ CanEnroll(x, CourseB)) ::: A student that CanChooseCourses either NeedsAdvisorApproval or CanEnroll",
            "∀x (AbleToRequest(x, CourseB) → NeedsAdvisorApproval(x, CourseB)) ::: All students able to request CourseB Need Advisor Approval.",
            "∀x (Student(x) → HasGoodStanding(x)) ::: All Students have good standing."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Registered(x, y) ::: x is registered for semester y",
            "CompletedPrerequisites(x, y) ::: x has completed the prerequisites for course y",
            "CanEnroll(x, y) ::: x can enroll in course y",
            "HasGoodStanding(x) ::: x has good standing",
            "PaidFees(x) ::: x has paid fees",
            "AttendedOrientation(x) ::: x has attended orientation",
            "NeedsAdvisorApproval(x, y) ::: x needs advisor approval for course y",
            "ReceivedApproval(x, y) ::: x received approval for y"
        ]
    },
    {
        "premises-NL": [
            "All students must maintain a certain GPA to remain in good academic standing.",
            "If a student has a low GPA, they may be placed on academic probation.",
            "If a student is on academic probation, they may not be eligible for graduation.",
            "If a student retakes courses, the new grade may replace the old grade in GPA calculation.",
            "If a student improves their GPA and is not on academic probation, their academic standing may improve.",
            "If a course is required, the student must pass it.",
            "If a student retakes a course, they need permission.",
            "If a student has low GPA, and retakes course, and improves GPA and student is not under academic probation, they may be on academic standing",
            "If students improve GPA, and are taking courses for graduation, they should be eligible.",
            "If student takes courses and have low GPA then they may retake the courses to improve it."
        ],
        "premises-FOL": [
            "∀x (Student(x) → MaintainGPA(x)) ::: All students must maintain a certain GPA to remain in good academic standing.",
            "∀x (LowGPA(x) → MaybeOnProbation(x)) ::: If a student has a low GPA, they may be placed on academic probation.",
            "∀x (AcademicProbation(x) → ¬EligibleForGraduation(x)) ::: If a student is on academic probation, they may not be eligible for graduation.",
            "∀x ∀y (RetakesCourses(x, y) → ReplaceGrade(x, y)) ::: If a student retakes courses, the new grade may replace the old grade in GPA calculation.",
            "∀x (ImprovesGPA(x) ∧ ¬AcademicProbation(x) → MaybeImproveStanding(x)) ::: If a student improves their GPA and is not on academic probation, their academic standing may improve.",
            "∀y (RequiredCourse(y) → Pass(x, y)) ::: If a course is required, the student must pass it.",
            "∀x ∀y (RetakesCourses(x, y) → HasPermission(x, y)) ::: If a student retakes a course, they need permission.",
            "∀x ∀y (LowGPA(x) ∧ RetakesCourses(x, y) ∧ ImprovesGPA(x) ∧ ¬AcademicProbation(x) → MaybeOnAcademicStanding(x)) ::: If a student has low GPA, and retakes course, and improves GPA and student is not under academic probation, they may be on academic standing",
            "∀x ∀y (ImprovesGPA(x) ∧ TakesCourses(x, Graduation) → EligibleForGraduation(x)) ::: If students improve GPA, and are taking courses for graduation, they should be eligible.",
            "∀x ∀y (TakesCourses(x, y) ∧ LowGPA(x) → MaybeRetake(x)) ::: If student takes courses and have low GPA then they may retake the courses to improve it."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "LowGPA(x) ::: x has a low GPA",
            "RetakesCourses(x, y) ::: x retakes course y",
            "ImprovesGPA(x) ::: Retaking courses improves x's GPA",
            "AcademicProbation(x) ::: x is on academic probation",
            "MaybeImproveStanding(x) ::: x's academic standing may improve",
            "Takes(x, y) ::: x takes course y",
            "Passes(x, y) ::: x passes course y",
            "GetsCredits(x) ::: x gets credits",
            "RequiredCourse(y) ::: course y is required",
            "EligibleForGraduation(x) ::: x is eligible for graduation"
        ]
    },
    {
        "premises-NL": [
            "All students who are waitlisted for a course did not meet the prerequisites or the course is full.",
            "If a course is full, the student is not enrolled.",
            "Students who are not enrolled in a course do not receive credit for that course.",
            "Only students who take courses can receive credit.",
            "If a student is a good student and takes a course, he/she is a smart student.",
            "If a professor teaches a course and a student takes it, the student is enrolled in the course",
            "If a student is enrolled in a course, the student receives credit.",
            "There exists students.",
            "If a student waits for a course, then he takes it.",
            "Some courses are full."
        ],
        "premises-FOL": [
            "∀x ∀y (Student(x) ∧ Waitlisted(x, y) → (¬MeetsPrerequisites(x, y) ∨ CourseFull(y))) ::: All students who are waitlisted for a course did not meet the prerequisites or the course is full.",
            "∀x ∀y (CourseFull(y) → ¬Enrolled(x, y)) ::: If a course is full, the student is not enrolled.",
            "∀x ∀y (¬Enrolled(x, y) → ¬ReceivesCredit(x, y)) ::: Students who are not enrolled in a course do not receive credit for that course.",
            "∀x ∀y (TakesCourse(x,y) → ReceivesCredit(x, y)) ::: Only students who take courses can receive credit.",
            "∀x ∀y ((Student(x) ∧ TakesCourse(x,y)) → SmartStudent(x)) ::: If a student is a good student and takes a course, he/she is a smart student.",
            "∀z ∀x ∀y (ProfessorTeaches(z, y) ∧ TakesCourse(x,y) → Enrolled(x, y)) ::: If a professor teaches a course and a student takes it, the student is enrolled in the course",
            "∀x ∀y (Enrolled(x, y) → ReceivesCredit(x, y)) ::: If a student is enrolled in a course, the student receives credit.",
            "∃x Student(x) ::: There exists students.",
            "∀x ∀y (Student(x) ∧ Waitlisted(x, y) → TakesCourse(x,y)) ::: If a student waits for a course, then he takes it.",
            "∃y CourseFull(y) ::: Some courses are full."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Waitlisted(x, y) ::: x is waitlisted for course y",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "ReceivesCredit(x, y) ::: x receives credit for course y",
            "MeetsPrerequisites(x, y) ::: x meets the prerequisites for course y",
            "CourseFull(y) ::: course y is full",
            "ProfessorTeaches(z, y) ::: Professor z teaches course y",
            "TakesCourse(x,y) ::: x takes the course y",
            "GoodStudent(x) ::: x is a good student",
            "SmartStudent(x) ::: x is a smart student"
        ]
    },
    {
        "premises-NL": [
            "All people are enrolled.",
            "If a person is enrolled, they either pay tuition or meet requirements.",
            "No one can both pay tuition and meet requirements.",
            "If someone is hardworking, they pay tuition.",
            "If someone procrastinates, they meet requirements.",
            "No one is both hardworking and procrastinates."
        ],
        "premises-FOL": [
            "∀x Enrolled(x) ::: All people are enrolled.",
            "∀x (Enrolled(x) → (PaysTuition(x) ∨ MeetsRequirements(x))) ::: If a person is enrolled, they either pay tuition or meet requirements.",
            "¬∃x (PaysTuition(x) ∧ MeetsRequirements(x)) ::: No one can both pay tuition and meet requirements.",
            "∀x (Hardworking(x) → PaysTuition(x)) ::: If someone is hardworking, they pay tuition.",
            "∀x (Procrastinates(x) → MeetsRequirements(x)) ::: If someone procrastinates, they meet requirements.",
            "¬∃x (Hardworking(x) ∧ Procrastinates(x)) ::: No one is both hardworking and procrastinates."
        ],
        "predicates": [
            "Enrolled(x) ::: x is enrolled",
            "PaysTuition(x) ::: x pays tuition",
            "MeetsRequirements(x) ::: x meets requirements",
            "Delayed(x) ::: x is delayed",
            "Hardworking(x) ::: x is hardworking",
            "Procrastinates(x) ::: x procrastinates"
        ]
    },
    {
        "premises-NL": [
            "All courses with prerequisites require a passing grade in the prerequisite.",
            "John is enrolled in a course with prerequisites.",
            "John does not have a passing grade in the prerequisite.",
            "If a student is enrolled in a course they must attend lectures.",
            "If a student attends lectures, they can ask questions.",
            "Only students are allowed to enroll in courses.",
            "If a course requires passing grade, and John has not a passing grade, he can't continue",
            "CSC301 is a course with prerequisites.",
            "John is a student.",
            "Peter is a professor.",
            "Peter teaches CSC301"
        ],
        "premises-FOL": [
            "∀x (CourseWithPrereq(x) → RequiresPassingGrade(x)) ::: All courses with prerequisites require a passing grade in the prerequisite.",
            "∃y (Enrolled(john, y) ∧ CourseWithPrereq(y)) ::: John is enrolled in a course with prerequisites.",
            "∃y (Enrolled(john, y) ∧ ¬HasPassingGrade(john, y)) ::: John does not have a passing grade in the prerequisite.",
            "∀x ∀y (Enrolled(x, y) → AttendsLectures(x)) ::: If a student is enrolled in a course they must attend lectures.",
            "∀x (AttendsLectures(x) → CanAskQuestions(x)) ::: If a student attends lectures, they can ask questions.",
            "∀x ∀y (Enrolled(x, y) → Student(x)) ::: Only students are allowed to enroll in courses.",
            "∀y ((CourseWithPrereq(y) ∧ RequiresPassingGrade(y) ∧ ¬HasPassingGrade(john, y)) → ¬CanContinue(john, y)) ::: If a course requires passing grade, and John has not a passing grade, he can't continue.",
            "CourseWithPrereq(csc301) ::: CSC301 is a course with prerequisites.",
            "Student(john) ::: John is a student.",
            "Professor(peter) ::: Peter is a professor.",
            "Teaches(peter, csc301) ::: Peter teaches CSC301"
        ],
        "predicates": [
            "CourseWithPrereq(x) ::: x is a course with prerequisites",
            "RequiresPassingGrade(x) ::: Course x requires a passing grade in the prerequisite",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "HasPassingGrade(x, y) ::: x has a passing grade in the prerequisite for course y",
            "CanContinue(x, y) ::: x can continue course y",
            "Student(x) ::: x is a student",
            "Professor(x) ::: x is a professor"
        ]
    },
    {
        "premises-NL": [
            "All graduate students hold a bachelor's degree.",
            "John is a graduate student.",
            "Graduate students take courses.",
            "Every course is taught by a professor.",
            "If someone is enrolled in a course, then they attend the course.",
            "Diligent people are graduate students.",
            "Only smart and diligent students graduate.",
            "John is diligent.",
            "John is smart.",
            "John studies hard.",
            "John is enrolled in a course."
        ],
        "premises-FOL": [
            "∀x (GraduateStudent(x) → HoldsBachelors(x)) ::: All graduate students hold a bachelor's degree.",
            "GraduateStudent(john) ::: John is a graduate student.",
            "∀x ∃y (GraduateStudent(x) → TakesCourse(x, y)) ::: Graduate students take courses.",
            "∀y ∃z (TakesCourse(x, y) → Teaches(z, y)) ::: Every course is taught by a professor.",
            "∀x ∀y (Enrolled(x, y) → Attends(x, y)) ::: If someone is enrolled in a course, then they attend the course.",
            "∀x (Diligent(x) → GraduateStudent(x)) ::: Diligent people are graduate students.",
            "∀x (Smart(x) ∧ Diligent(x) → GraduateStudent(x)) ::: Only smart and diligent students graduate.",
            "Diligent(john) ::: John is diligent.",
            "Smart(john) ::: John is smart.",
            "Studies(john, hard) ::: John studies hard.",
            "∃y Enrolled(john, y) ::: John is enrolled in a course."
        ],
        "predicates": [
            "GraduateStudent(x) ::: x is a graduate student",
            "HoldsBachelors(x) ::: x holds a bachelor's degree",
            "TakesCourse(x, y) ::: x takes course y",
            "Professor(y) ::: y is a professor",
            "Teaches(y, z) ::: y teaches z",
            "Attends(x, y) ::: x attends y",
            "Enrolled(x, y) ::: x is enrolled in y",
            "Smart(x) ::: x is smart",
            "Diligent(x) ::: x is diligent",
            "Studies(x,y) ::: x studies y"
        ]
    },
    {
        "premises-NL": [
            "All students take either Math or Logic.",
            "If a student takes Logic, they pass Logic.",
            "If a student passes Logic, they are happy.",
            "John is a student.",
            "John takes Logic."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Takes(x, Math) ∨ Takes(x, Logic))) ::: All students take either Math or Logic.",
            "∀x (Student(x) ∧ Takes(x, Logic) → Passed(x, Logic)) ::: If a student takes Logic, they pass Logic.",
            "∀x (Passed(x, Logic) → Happy(x)) ::: If a student passes Logic, they are happy.",
            "Student(John) ::: John is a student.",
            "Takes(John, Logic) ::: John takes Logic."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Takes(x, y) ::: x takes course y",
            "Passed(x, y) ::: x passed course y",
            "Happy(x) ::: x is happy"
        ]
    },
    {
        "premises-NL": [
            "All experienced professors are well paid.",
            "All tenured professors are well paid.",
            "Some professors who teach Math are experienced.",
            "If someone is both well paid and experienced, then they are tenured.",
            "John is a professor.",
            "John teaches Math.",
            "John is experienced."
        ],
        "premises-FOL": [
            "∀x (Professor(x) ∧ Experienced(x) → WellPaid(x)) ::: All experienced professors are well paid.",
            "∀x (Professor(x) ∧ Tenured(x) → WellPaid(x)) ::: All tenured professors are well paid.",
            "∃x (Professor(x) ∧ Teaches(x, Math) ∧ Experienced(x)) ::: Some professors who teach Math are experienced.",
            "∀x (WellPaid(x) ∧ Experienced(x) → Tenured(x)) ::: If someone is both well paid and experienced, then they are tenured.",
            "Professor(John) ::: John is a professor.",
            "Teaches(John, Math) ::: John teaches Math.",
            "Experienced(John) ::: John is experienced."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches course y",
            "Tenured(x) ::: x is tenured",
            "Experienced(x) ::: x is experienced",
            "WellPaid(x) ::: x is well paid"
        ]
    },
    {
        "premises-NL": [
            "All students must be enrolled in the university.",
            "A student must be enrolled in order to have good standing.",
            "A student must have good standing to be eligible to graduate.",
            "A student who is enrolled must pay tuition.",
            "In order to meet graduation requirements they must complete all courses.",
            "If a student has completed all courses they have passed all courses.",
            "If a student is enrolled, has paid tuition, and meets all requirements, they are eligible to graduate.",
            "To be eligible to graduate, students must be enrolled in the university and have good standing.",
            "If a student has completed all courses then they meet the graduation requirements."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x)) ::: All students must be enrolled in the university.",
            "∀x (Enrolled(x) → HasGoodStanding(x)) ::: A student must be enrolled in order to have good standing.",
            "∀x (HasGoodStanding(x) → EligibleToGraduate(x)) ::: A student must have good standing to be eligible to graduate.",
            "∀x (Enrolled(x) → PaidTuition(x)) ::: A student who is enrolled must pay tuition.",
            "∀x (MeetsRequirements(x) → CompletedAllCourses(x)) ::: In order to meet graduation requirements they must complete all courses.",
            "∀x (CompletedAllCourses(x) → Passes(x, y)) ::: If a student has completed all courses they have passed all courses.",
            "∀x ((Enrolled(x) ∧ PaidTuition(x) ∧ MeetsRequirements(x)) → EligibleToGraduate(x)) ::: If a student is enrolled, has paid tuition, and meets all requirements, they are eligible to graduate.",
            "∀x (EligibleToGraduate(x) → (Enrolled(x) ∧ HasGoodStanding(x))) ::: To be eligible to graduate, students must be enrolled in the university and have good standing.",
            "∀x (CompletedAllCourses(x) → MeetsRequirements(x)) ::: If a student has completed all courses then they meet the graduation requirements."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Takes(x, y) ::: x takes course y",
            "Passes(x, y) ::: x passes course y",
            "EligibleToGraduate(x) ::: x is eligible to graduate",
            "MeetsRequirements(x) ::: x meets all graduation requirements",
            "Enrolled(x) ::: x is enrolled in the university",
            "HasGoodStanding(x) ::: x has good standing at the university",
            "PaidTuition(x) ::: x has paid tuition",
            "CompletedAllCourses(x) ::: x has completed all courses"
        ]
    },
    {
        "premises-NL": [
            "If a student is repeating a course and has a low GPA and the course is difficult, then they should not be allowed to repeat the course.",
            "If a student has a low GPA, then they require advising.",
            "If a student is repeating a course, then they failed the course before.",
            "Calculus 2 is a difficult course.",
            "If a course is difficult, then it has prerequistes.",
            "Jane is a student.",
            "Jane is repeating Calculus 2.",
            "Jane has a low GPA.",
            "Jane is struggling.",
            "If someone is struggling then they are required to seek help.",
            "Jane is honest."
        ],
        "premises-FOL": [
            "∀x ∀y (Student(x) ∧ Repeating(x, y) ∧ LowGPA(x) ∧ Difficult(y) → ¬AllowedToRepeat(x, y)) ::: If a student is repeating a course and has a low GPA and the course is difficult, then they should not be allowed to repeat the course.",
            "∀x (LowGPA(x) → AdvisingRequired(x)) ::: If a student has a low GPA, then they require advising.",
            "∀x ∀y (Repeating(x, y) → FailedBefore(x, y)) ::: If a student is repeating a course, then they failed the course before.",
            "Difficult(calculus2) ::: Calculus 2 is a difficult course.",
            "∀y (Difficult(y) → HasPrerequisites(y)) ::: If a course is difficult, then it has prerequistes.",
            "Student(jane) ::: Jane is a student.",
            "Repeating(jane, calculus2) ::: Jane is repeating Calculus 2.",
            "LowGPA(jane) ::: Jane has a low GPA.",
            "Struggling(jane) ::: Jane is struggling.",
            "∀x (Struggling(x) → AdvisingRequired(x)) ::: If someone is struggling then they are required to seek help.",
            "IsHonest(jane) ::: Jane is honest."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Repeating(x, y) ::: x is repeating y",
            "LowGPA(x) ::: x has a low GPA",
            "Difficult(y) ::: y is a difficult course",
            "AllowedToRepeat(x, y) ::: x is allowed to repeat y",
            "Course(y) ::: y is a course",
            "AdvisingRequired(x) ::: x requires advising",
            "FailedBefore(x,y) ::: x failed y before",
            "HasPrerequisites(y) ::: y has prerequistes",
            "Struggling(x) ::: x is struggling",
            "IsHonest(x) ::: x is honest"
        ]
    },
    {
        "premises-NL": [
            "All students are either dedicated or not.",
            "If a student attends lectures and completes assignments, they are dedicated.",
            "If a student studies hard, they are more likely to pass all courses.",
            "If a student retakes failed exams, they show dedication.",
            "To graduate with honors, a student must be eligible to graduate, pass all courses and have a high GPA.",
            "If a student is dedicated, they are eligible to graduate.",
            "Graduation with honors requires high GPA and dedication.",
            "Enrolled students are students.",
            "High GPA requires a student to pass all courses.",
            "Completing assignments implies being dedicated",
            "High GPA requires the student to study."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Dedicated(x) ∨ ¬Dedicated(x))) ::: All students are either dedicated or not.",
            "∀x (AttendsLectures(x) ∧ CompletesAssignments(x) → Dedicated(x)) ::: If a student attends lectures and completes assignments, they are dedicated.",
            "∀x (StudiesHard(x) → PassesAllCourses(x)) ::: If a student studies hard, they are more likely to pass all courses.",
            "∀x (RetakesFailedExams(x) → Dedicated(x)) ::: If a student retakes failed exams, they show dedication.",
            "∀x ((EligibleToGraduate(x) ∧ PassesAllCourses(x) ∧ HasHighGPA(x)) → GraduatesWithHonors(x)) ::: To graduate with honors, a student must be eligible to graduate, pass all courses and have a high GPA.",
            "∀x (Dedicated(x) → EligibleToGraduate(x)) ::: If a student is dedicated, they are eligible to graduate.",
            "∀x (GraduatesWithHonors(x) → (HasHighGPA(x) ∧ Dedicated(x))) ::: Graduation with honors requires high GPA and dedication.",
            "∀x (Enrolled(x) → Student(x)) ::: Enrolled students are students.",
            "∀x (HasHighGPA(x) → PassesAllCourses(x)) ::: High GPA requires a student to pass all courses.",
            "∀x (CompletesAssignments(x) → Dedicated(x)) ::: Completing assignments implies being dedicated",
            "∀x (HasHighGPA(x) → StudiesHard(x)) ::: High GPA requires the student to study."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x) ::: x is enrolled",
            "AttendsLectures(x) ::: x attends lectures",
            "CompletesAssignments(x) ::: x completes assignments",
            "StudiesHard(x) ::: x studies hard",
            "RetakesFailedExams(x) ::: x retakes failed exams",
            "GraduatesWithHonors(x) ::: x graduates with honors",
            "PassesAllCourses(x) ::: x passes all courses",
            "HasHighGPA(x) ::: x has a high GPA",
            "Dedicated(x) ::: x is a dedicated student",
            "EligibleToGraduate(x) ::: x is eligible to graduate"
        ]
    },
    {
        "premises-NL": [
            "All students are either enrolled or not enrolled.",
            "If someone is enrolled in a course, they are a student.",
            "Difficult courses exist.",
            "If a student studies hard, they usually pass the exam.",
            "Sometimes, students do not study hard.",
            "Passing the exam requires understanding the material.",
            "Understanding the material is harder in difficult courses.",
            "If a student is enrolled in a difficult course, it requires studying hard to pass.",
            "Not studying hard means a student will probably not pass the exam."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Enrolled(x, y) ∨ ¬Enrolled(x, y))) ::: All students are either enrolled or not enrolled.",
            "∀x ∀y (Enrolled(x, y) → Student(x)) ::: If someone is enrolled in a course, they are a student.",
            "∃y DifficultCourse(y) ::: Difficult courses exist.",
            "∀x ∀y (Student(x) ∧ StudiesHard(x) → PassesExam(x, y)) ::: If a student studies hard, they usually pass the exam.",
            "∃x (Student(x) ∧ ¬StudiesHard(x)) ::: Sometimes, students do not study hard.",
            "∀x ∀y (PassesExam(x, y) → Understands(x, y)) ::: Passing the exam requires understanding the material.",
            "∀y (DifficultCourse(y) → RequiresEffort(y)) ::: Understanding the material is harder in difficult courses.",
            "∀x ∀y (Student(x) ∧ Enrolled(x, y) ∧ DifficultCourse(y) → RequiresEffort(x)) ::: If a student is enrolled in a difficult course, it requires studying hard to pass.",
            "∀x (¬StudiesHard(x) → ¬PassesExam(x, y)) ::: Not studying hard means a student will probably not pass the exam."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "DifficultCourse(y) ::: y is a difficult course",
            "StudiesHard(x) ::: x studies hard",
            "PassesExam(x, y) ::: x passes the exam in course y"
        ]
    },
    {
        "premises-NL": [
            "All graduate students need advisor approval to exceed credit limits.",
            "Credit limits exist.",
            "12 is a number.",
            "If a student takes more credits than allowed, they must get advisor approval.",
            "Graduate students are students.",
            "Students that do not get advisor approval are penalized if they exceed the limit.",
            "Some graduate students take credits.",
            "Penalties can involve tuition increases or holds on registration.",
            "If a student takes a number of credits, it is either greater than 12 or less than or equal to 12.",
            "Not getting approval leads to a penalty if the credit limit is exceeded."
        ],
        "premises-FOL": [
            "∀x (GraduateStudent(x) → RequiresApproval(x)) ::: All graduate students need advisor approval to exceed credit limits.",
            "∃y CreditLimit(y) ::: Credit limits exist.",
            "Number(12) ::: 12 is a number.",
            "∀x ∀y (TakesCredits(x, y) ∧ GreaterThan(y, z) → RequiresApproval(x)) ::: If a student takes more credits than allowed, they must get advisor approval.",
            "∀x (GraduateStudent(x) → Student(x)) ::: Graduate students are students.",
            "∀x (TakesCredits(x, y) ∧ GreaterThan(y, 12) ∧ ¬AdvisorApproval(x) → Penalized(x)) ::: Students that do not get advisor approval are penalized if they exceed the limit.",
            "∃x ∃y (GraduateStudent(x) ∧ TakesCredits(x, y)) ::: Some graduate students take credits.",
            "∀x (Penalized(x) → (TuitionIncrease(x) ∨ RegistrationHold(x))) ::: Penalties can involve tuition increases or holds on registration.",
            "∀x ∀y (TakesCredits(x, y) → (GreaterThan(y, 12) ∨ LessThanOrEqual(y, 12))) ::: If a student takes a number of credits, it is either greater than 12 or less than or equal to 12.",
            "∀x ∀y (TakesCredits(x, y) ∧ GreaterThan(y, 12) ∧ ¬AdvisorApproval(x) → Penalized(x)) ::: Not getting approval leads to a penalty if the credit limit is exceeded."
        ],
        "predicates": [
            "GraduateStudent(x) ::: x is a graduate student",
            "TakesCredits(x, y) ::: x takes y credits",
            "GreaterThan(y, z) ::: y is greater than z",
            "AdvisorApproval(x) ::: x has advisor approval",
            "Penalized(x) ::: x is penalized",
            "LessThanOrEqual(y, z) ::: y is less than or equal to z"
        ]
    },
    {
        "premises-NL": [
            "All courses may have prerequisites.",
            "If a course is a prerequisite for another, it must be passed first.",
            "Students that fail a prerequisite cannot enroll in the next course.",
            "Students exist.",
            "Failing a course means a student needs to retake it.",
            "If a student does not retake a failed prerequisite, they cannot enroll in the advanced course.",
            "Some courses are advanced.",
            "Prerequisites are basic courses.",
            "If a student fails a course and does not retake it, they will not be allowed to enroll in future courses related to that failed course.",
            "Enrollment in a course implies that someone is a student.",
            "Students must satisfy prerequisites before enrolling."
        ],
        "premises-FOL": [
            "∀y ∃z PrerequisiteFor(y, z) ∨ ¬PrerequisiteFor(y, z) ::: All courses may have prerequisites.",
            "∀x ∀y (PrerequisiteFor(x, y) → MustPass(x)) ::: If a course is a prerequisite for another, it must be passed first.",
            "∀x ∀y ∀z (Student(x) ∧ Fails(x, y) ∧ PrerequisiteFor(y, z) → ¬Enrolled(x, z)) ::: Students that fail a prerequisite cannot enroll in the next course.",
            "∃x Student(x) ::: Students exist.",
            "∀x ∀y (Student(x) ∧ Fails(x, y) → NeedsToRetake(x, y)) ::: Failing a course means a student needs to retake it.",
            "∀x ∀y ∀z (Student(x) ∧ Fails(x, y) ∧ PrerequisiteFor(y, z) ∧ ¬Retakes(x, y) → ¬Enrolled(x, z)) ::: If a student does not retake a failed prerequisite, they cannot enroll in the advanced course.",
            "∃z AdvancedCourse(z) ::: Some courses are advanced.",
            "∀y (PrerequisiteFor(y, z) → BasicCourse(y)) ::: Prerequisites are basic courses.",
            "∀x ∀y ∀z (Student(x) ∧ Fails(x, y) ∧ ¬Retakes(x, y) → ¬Allowed(x, z)) ::: If a student fails a course and does not retake it, they will not be allowed to enroll in future courses related to that failed course.",
            "∀x ∀y (Enrolled(x, y) → Student(x)) ::: Enrollment in a course implies that someone is a student.",
            "∀x ∀y ∀z (Student(x) ∧ Enrolled(x, z) ∧ PrerequisiteFor(y, z) → SatisfiesPrerequisites(x, y)) ::: Students must satisfy prerequisites before enrolling."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Fails(x, y) ::: x fails course y",
            "PrerequisiteFor(y, z) ::: y is a prerequisite for z",
            "Retakes(x, y) ::: x retakes course y",
            "Enrolled(x, z) ::: x is enrolled in course z",
            "Takes(x,y) ::: x takes course y"
        ]
    },
    {
        "premises-NL": [
            "All students are hardworking.",
            "There exists a professor who teaches a difficult course.",
            "If a student is hardworking and has a high GPA, they are eligible for a scholarship.",
            "If a student needs financial aid, they are eligible for a scholarship.",
            "If a student is eligible for a scholarship and attends a university, they receive a scholarship.",
            "All students attend a university.",
            "There exists a student with a high GPA.",
            "There exists a student who needs financial aid.",
            "There exists a student enrolled in a course.",
            "Every course is taught by a professor."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Hardworking(x)) ::: All students are hardworking.",
            "∃z ∃y (Professor(z) ∧ Teaches(z, y) ∧ DifficultCourse(y)) ::: There exists a professor who teaches a difficult course.",
            "∀x ((Student(x) ∧ Hardworking(x) ∧ HighGPA(x)) → EligibleForScholarship(x)) ::: If a student is hardworking and has a high GPA, they are eligible for a scholarship.",
            "∀x (Student(x) ∧ NeedFinancialAid(x) → EligibleForScholarship(x)) ::: If a student needs financial aid, they are eligible for a scholarship.",
            "∀x ((EligibleForScholarship(x) ∧ Attends(x, w)) → ReceiveScholarship(x)) ::: If a student is eligible for a scholarship and attends a university, they receive a scholarship.",
            "∀x (Student(x) → Attends(x, w)) ::: All students attend a university.",
            "∃x (Student(x) ∧ HighGPA(x)) ::: There exists a student with a high GPA.",
            "∃x (Student(x) ∧ NeedFinancialAid(x)) ::: There exists a student who needs financial aid.",
            "∃x ∃y (Student(x) ∧ EnrolledIn(x, y)) ::: There exists a student enrolled in a course.",
            "∀y ∃z (Course(y) → Teaches(z, y)) ::: Every course is taught by a professor."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in course y",
            "DifficultCourse(y) ::: y is a difficult course",
            "ReceiveScholarship(x) ::: x receives a scholarship",
            "Hardworking(x) ::: x is hardworking",
            "Professor(z) ::: z is a professor",
            "Teaches(z, y) ::: z teaches course y",
            "HighGPA(x) ::: x has a high GPA",
            "NeedFinancialAid(x) ::: x needs financial aid",
            "EligibleForScholarship(x) ::: x is eligible for a scholarship",
            "Attends(x, w) ::: x attends university w"
        ]
    },
    {
        "premises-NL": [
            "All students must complete all required courses to graduate.",
            "All students must have a minimum required GPA to graduate.",
            "All students must have no outstanding fees to graduate.",
            "All students must submit their graduation application to graduate.",
            "Any student with an academic integrity violation on record will not graduate.",
            "Only students who are eligible will graduate.",
            "A student is eligible to graduate if they completed courses, have a GPA, no fees, and a submitted application.",
            "Academic integrity violations are reviewed by a committee.",
            "Graduation is dependent on satisfying all requirements and adhering to university policies.",
            "Integrity violations are a breach of university policies."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ ¬CompletedCourses(x) → ¬Graduates(x)) ::: Students must complete courses to graduate.",
            "∀x (Student(x) ∧ ¬HasMinGPA(x) → ¬Graduates(x)) ::: Students must have min GPA to graduate.",
            "∀x (Student(x) ∧ OwesFees(x) → ¬Graduates(x)) ::: Students cannot owe fees to graduate.",
            "∀x (Student(x) ∧ ¬SubmittedApplication(x) → ¬Graduates(x)) ::: Students need to submit app to graduate.",
            "∀x (Student(x) ∧ HasIntegrityViolation(x) → ¬Graduates(x)) ::: Integrity violations prevent graduation.",
            "∀x (Graduates(x) → EligibleToGraduate(x)) ::: Only eligible students graduate.",
            "∀x (Student(x) ∧ CompletedCourses(x) ∧ HasMinGPA(x) ∧ ¬OwesFees(x) ∧ SubmittedApplication(x) → EligibleToGraduate(x)) ::: Eligibility criteria.",
            "∃x IntegrityCommittee(x) ::: Academic integrity violations are reviewed by a committee.",
            "∀x (Graduates(x) → SatisfiesRequirements(x) ∧ AdheresToPolicies(x)) ::: Graduation requires satisfying policies and requirements.",
            "∀x (HasIntegrityViolation(x) → BreachesPolicies(x)) ::: Integrity violations are breaches of policies."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "CompletedCourses(x) ::: x has completed all required courses",
            "HasMinGPA(x) ::: x has the minimum required GPA",
            "OwesFees(x) ::: x owes fees",
            "SubmittedApplication(x) ::: x has submitted their graduation application",
            "Graduates(x) ::: x graduates",
            "HasIntegrityViolation(x) ::: x has an academic integrity violation on record"
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "If a student took a course and the course is difficult, then the student is smart and well prepared.",
            "If a student is smart and well prepared then the student will pass the course.",
            "There exists a student who took a course.",
            "There exists a course that is difficult.",
            "If a student took a course and passed the course, then the student completed the course."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "∀x ∀y ((Student(x) ∧ Took(x, y) ∧ Difficult(y)) → (Smart(x) ∧ WellPrepared(x))) ::: If a student took a course and the course is difficult, then the student is smart and well prepared.",
            "∀x ∀y ((Smart(x) ∧ WellPrepared(x) ∧ Took(x, y)) → Passed(x, y)) ::: If a student is smart and well prepared and took a course, then the student will pass the course.",
            "∃x ∃y (Student(x) ∧ Took(x, y)) ::: There exists a student who took a course.",
            "∃y Difficult(y) ::: There exists a course that is difficult.",
            "∀x ∀y ((Student(x) ∧ Took(x, y) ∧ Passed(x, y)) → Completed(x, y)) ::: If a student took a course and passed the course, then the student completed the course."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Took(x, y) ::: x took course y",
            "Difficult(y) ::: Course y is difficult",
            "Passed(x, y) ::: x passed course y",
            "Smart(x) ::: x is smart",
            "WellPrepared(x) ::: x is well prepared"
        ]
    },
    {
        "premises-NL": [
            "All students who live on campus have a good GPA.",
            "If a student has a good GPA, they are hardworking.",
            "If a student is hardworking and needs financial aid, then they are eligible for the scholarship.",
            "All students need financial aid if they registered late.",
            "There exists a student who lives on campus.",
            "Some students registered late.",
            "If a student registered late then they need financial aid."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ LivesOnCampus(x) → GoodGPA(x)) ::: All students who live on campus have a good GPA.",
            "∀x (GoodGPA(x) → Hardworking(x)) ::: If a student has a good GPA, they are hardworking.",
            "∀x ((Hardworking(x) ∧ NeedsFinancialAid(x)) → EligibleForScholarship(x)) ::: If a student is hardworking and needs financial aid, then they are eligible for the scholarship.",
            "∀x (Student(x) ∧ LateRegistration(x) → NeedsFinancialAid(x)) ::: All students who registered late need financial aid.",
            "∃x (Student(x) ∧ LivesOnCampus(x)) ::: There exists a student who lives on campus.",
            "∃x (Student(x) ∧ LateRegistration(x)) ::: Some students registered late.",
            "∀x (LateRegistration(x) → NeedsFinancialAid(x)) ::: All students who registered late need financial aid."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "LivesOnCampus(x) ::: x lives on campus",
            "GoodGPA(x) ::: x has a good GPA",
            "EligibleForScholarship(x) ::: x is eligible for the scholarship",
            "NeedsFinancialAid(x) ::: x needs financial aid",
            "Hardworking(x) ::: x is hardworking",
            "LateRegistration(x) ::: x registered late"
        ]
    },
    {
        "premises-NL": [
            "All diligent people are hardworking.",
            "If someone is enrolled in a course and meets the prerequisites, they take the course.",
            "If someone takes a course, attends the lectures, and is prepared, they understand the course.",
            "If someone understands a course and asks questions, they are diligent.",
            "If someone is hardworking, attends lectures and is prepared, they are diligent.",
            "If someone is diligent and takes a course, they attend lectures.",
            "If someone is diligent and takes a course, they are prepared.",
            "If someone is prepared for a course and understands it, they pass the course.",
            "Calculus has prerequisites.",
            "If someone is enrolled in Calculus, they meet the prerequisites."
        ],
        "premises-FOL": [
            "∀x (Diligent(x) → Hardworking(x)) ::: All diligent people are hardworking.",
            "∀x ∀y ((Enrolled(x, y) ∧ PrerequisitesMet(x, y)) → Takes(x, y)) ::: If someone is enrolled in a course and meets the prerequisites, they take the course.",
            "∀x ∀y ((Takes(x, y) ∧ Attends(x, y) ∧ Prepared(x, y)) → Understands(x, y)) ::: If someone takes a course, attends the lectures, and is prepared, they understand the course.",
            "∀x ∀y ((Understands(x, y) ∧ AsksQuestions(x)) → Diligent(x)) ::: If someone understands a course and asks questions, they are diligent.",
            "∀x (Hardworking(x) → Diligent(x)) ::: If someone is hardworking, attends lectures and is prepared, they are diligent.",
            "∀x ∀y ((Diligent(x) ∧ Takes(x, y)) → Attends(x, y)) ::: If someone is diligent and takes a course, they attend lectures.",
            "∀x ∀y ((Diligent(x) ∧ Takes(x, y)) → Prepared(x, y)) ::: If someone is diligent and takes a course, they are prepared.",
            "∀x ∀y ((Prepared(x, y) ∧ Understands(x, y)) → Pass(x, y)) ::: If someone is prepared for a course and understands it, they pass the course.",
            "∃y PrerequisitesMet(y, Calculus) ::: Calculus has prerequisites.",
            "∀x (Enrolled(x, Calculus) → PrerequisitesMet(x, Calculus)) ::: If someone is enrolled in Calculus, they meet the prerequisites."
        ],
        "predicates": [
            "Enrolled(x, y) ::: x is enrolled in y",
            "Diligent(x) ::: x is diligent",
            "Pass(x, y) ::: x passes y",
            "Takes(x, y) ::: x takes y",
            "Hardworking(x) ::: x is hardworking",
            "PrerequisitesMet(x, y) ::: x meets the prerequisites for y",
            "Understands(x, y) ::: x understands y",
            "Attends(x, y) ::: x attends y",
            "Prepared(x, y) ::: x is prepared for y",
            "AsksQuestions(x) ::: x asks questions"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard solve problems.",
            "If someone likes math, they enjoy learning.",
            "If someone enjoys learning, they attend class.",
            "If someone attends class, they ask questions.",
            "If someone asks questions, they understand.",
            "If someone solves problems and understands, they pass.",
            "If someone passes, they get a good grade or do not struggle.",
            "All students study hard.",
            "Students like math.",
            "If a student asks questions, they understand the material.",
            "Some students solve problems."
        ],
        "premises-FOL": [
            "∀x (Student(x) → SolvesProblems(x)) ::: All students who study hard solve problems.",
            "∀x (LikesMath(x) → EnjoysLearning(x)) ::: If someone likes math, they enjoy learning.",
            "∀x (EnjoysLearning(x) → AttendsClass(x)) ::: If someone enjoys learning, they attend class.",
            "∀x (AttendsClass(x) → AsksQuestions(x, Math)) ::: If someone attends class, they ask questions.",
            "∀x (AsksQuestions(x, Math) → Understands(x, Math)) ::: If someone asks questions, they understand.",
            "∀x ((SolvesProblems(x) ∧ Understands(x, Math)) → Passes(x)) ::: If someone solves problems and understands, they pass.",
            "∀x (Passes(x) → (GoodGrade(x) ∨ ¬Struggles(x))) ::: If someone passes, they get a good grade or do not struggle.",
            "∀x (Student(x) → StudiesHard(x)) ::: All students study hard.",
            "∀x (Student(x) → LikesMath(x)) ::: Students like math.",
            "∀x (AsksQuestions(x, Math) → Understands(x, Math)) ::: If a student asks questions, they understand the material.",
            "∃x (Student(x) ∧ SolvesProblems(x)) ::: Some students solve problems."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "LikesMath(x) ::: x likes math",
            "GoodGrade(x) ::: x gets a good grade",
            "Struggles(x) ::: x struggles",
            "AsksQuestions(x, y) ::: x asks questions about y",
            "Understands(x, y) ::: x understands y",
            "SolvesProblems(x) ::: x solves problems",
            "AttendsClass(x) ::: x attends class",
            "EnjoysLearning(x) ::: x enjoys learning",
            "Passes(x) ::: x passes"
        ]
    },
    {
        "premises-NL": [
            "All professors conduct research.",
            "If a professor conducts research, they publish.",
            "If a professor teaches, they mentor students.",
            "If a professor mentors students, they are active on committees.",
            "If a professor is active on committees, they have a good reputation.",
            "If a professor has a good reputation, they are dedicated.",
            "If a professor is dedicated, they are passionate.",
            "If a professor is passionate, they are knowledgeable.",
            "If a professor publishes, then they are dedicated.",
            "If a professor teaches, then they are knowledgeable.",
            "If a professor is knowledgeable, they receive recognition.",
            "If a professor receives recognition, they will be promoted or receive recognition.",
            "All professors teach."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → ConductsResearch(x)) ::: All professors conduct research.",
            "∀x (ConductsResearch(x) → Publishes(x)) ::: If a professor conducts research, they publish.",
            "∀x (Professor(x) → Teaches(x)) ::: All professors teach.",
            "∀x (Teaches(x) → MentorsStudents(x)) ::: If a professor teaches, they mentor students.",
            "∀x (MentorsStudents(x) → ActiveCommittee(x)) ::: If a professor mentors students, they are active on committees.",
            "∀x (ActiveCommittee(x) → GoodReputation(x)) ::: If a professor is active on committees, they have a good reputation.",
            "∀x (GoodReputation(x) → Dedicated(x)) ::: If a professor has a good reputation, they are dedicated.",
            "∀x (Dedicated(x) → Passionate(x)) ::: If a professor is dedicated, they are passionate.",
            "∀x (Passionate(x) → Knowledgeable(x)) ::: If a professor is passionate, they are knowledgeable.",
            "∀x (Publishes(x) → Dedicated(x)) ::: If a professor publishes, then they are dedicated.",
            "∀x (Teaches(x) → Knowledgeable(x)) ::: If a professor teaches, then they are knowledgeable.",
            "∀x (Knowledgeable(x) → ReceivesRecognition(x)) ::: If a professor is knowledgeable, they receive recognition.",
            "∀x (ReceivesRecognition(x) → (Promoted(x) ∨ ReceivesRecognition(x))) ::: If a professor receives recognition, they will be promoted or receive recognition."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "Publishes(x) ::: x publishes papers",
            "Teaches(x) ::: x teaches courses",
            "Promoted(x) ::: x is promoted",
            "ReceivesRecognition(x) ::: x receives recognition",
            "ConductsResearch(x) ::: x conducts research",
            "MentorsStudents(x) ::: x mentors students",
            "ActiveCommittee(x) ::: x is active on committees",
            "GoodReputation(x) ::: x has a good reputation",
            "Dedicated(x) ::: x is dedicated",
            "Passionate(x) ::: x is passionate",
            "Knowledgeable(x) ::: x is knowledgeable"
        ]
    },
    {
        "premises-NL": [
            "All graduate students conduct research.",
            "If someone conducts research, they form a hypothesis.",
            "If someone forms a hypothesis, they analyze data.",
            "If someone analyzes data, they write a paper.",
            "If someone writes a paper, they submit it.",
            "If someone submits a paper, they receive feedback.",
            "If someone receives feedback, they revise the paper.",
            "If someone revises the paper, they publish it.",
            "If someone publishes a paper and it's accepted, they present their findings at conferences.",
            "If someone presents their findings at conferences, they write a dissertation.",
            "If someone publishes papers, their work is recognized.",
            "If someone writes a dissertation, they defend their thesis.",
            "If a graduate student defends their thesis, then they will graduate.",
            "A paper is accepted after submission",
            "All graduate students are students"
        ],
        "premises-FOL": [
            "∀x (GraduateStudent(x) → ConductsResearch(x)) ::: All graduate students conduct research.",
            "∀x (ConductsResearch(x) → FormsHypothesis(x)) ::: If someone conducts research, they form a hypothesis.",
            "∀x (FormsHypothesis(x) → AnalyzesData(x)) ::: If someone forms a hypothesis, they analyze data.",
            "∀x (AnalyzesData(x) → WritesDissertation(x)) ::: If someone analyzes data, they write a paper.",
            "∀x (WritesDissertation(x) → SubmitsPaper(x, y)) ::: If someone writes a paper, they submit it.",
            "∀x (SubmitsPaper(x, y) → ReceivesFeedback(x, y)) ::: If someone submits a paper, they receive feedback.",
            "∀x (ReceivesFeedback(x, y) → RevisesPaper(x, y)) ::: If someone receives feedback, they revise the paper.",
            "∀x (RevisesPaper(x, y) → Publishes(x, y)) ::: If someone revises the paper, they publish it.",
            "∀x ∀y ((Publishes(x, y) ∧ Accepted(y)) → PresentsFindings(x, y)) ::: If someone publishes a paper and it's accepted, they present their findings at conferences.",
            "∀x (PresentsFindings(x, y) → WritesDissertation(x)) ::: If someone presents their findings at conferences, they write a dissertation.",
            "∀x (Publishes(x, y) → Graduates(x)) ::: If someone publishes papers, their work is recognized.",
            "∀x (WritesDissertation(x) → DefendsThesis(x)) ::: If someone writes a dissertation, they defend their thesis.",
            "∀x (GraduateStudent(x) → Graduates(x)) ::: If a graduate student defends their thesis, then they will graduate.",
            "∀y (SubmitsPaper(x, y) → Accepted(y)) ::: A paper is accepted after submission",
            "∀x (GraduateStudent(x) → Student(x)) ::: All graduate students are students"
        ],
        "predicates": [
            "GraduateStudent(x) ::: x is a graduate student",
            "ConductsResearch(x) ::: x conducts research",
            "Publishes(x, y) ::: x publishes paper y",
            "Accepted(y) ::: paper y is accepted",
            "Graduates(x) ::: x graduates",
            "DefendsThesis(x) ::: x defends their thesis",
            "WritesDissertation(x) ::: x writes a dissertation",
            "AttendsConferences(x) ::: x attends conferences",
            "PresentsFindings(x, y) ::: x presents findings at y",
            "ReceivesFeedback(x, y) ::: x receives feedback on y",
            "RevisesPaper(x, y) ::: x revises paper y",
            "SubmitsPaper(x, y) ::: x submits paper y",
            "AnalyzesData(x) ::: x analyzes data",
            "FormsHypothesis(x) ::: x forms a hypothesis"
        ]
    },
    {
        "premises-NL": [
            "All students who complete requirements are eligible to graduate.",
            "If a student is eligible to graduate, then they graduate on time.",
            "If a student takes all required courses and has a good GPA, then they complete requirements.",
            "If a student enrolled late, they are affected by a policy change.",
            "If a student is affected by a policy change, they must work hard to complete requirements.",
            "Not all students who work hard to complete requirements have a good GPA.",
            "There exist students who enrolled late.",
            "There exists a student that did not graduate on time",
            "All students who work hard take all required courses"
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ CompletesRequirements(x) → EligibleToGraduate(x)) ::: All students who complete requirements are eligible to graduate.",
            "∀x (Student(x) ∧ EligibleToGraduate(x) → GraduatesOnTime(x)) ::: If a student is eligible to graduate, then they graduate on time.",
            "∀x (Student(x) ∧ TakesRequiredCourses(x) ∧ HasGoodGPA(x) → CompletesRequirements(x)) ::: If a student takes all required courses and has a good GPA, then they complete requirements.",
            "∀x (Student(x) ∧ EnrolledLate(x) → AffectedByPolicyChange(x)) ::: If a student enrolled late, they are affected by a policy change.",
            "∀x (Student(x) ∧ AffectedByPolicyChange(x) → WorksHard(x) ∧ CompletesRequirements(x)) ::: If a student is affected by a policy change, they must work hard to complete requirements.",
            "∃x (Student(x) ∧ WorksHard(x) ∧ ¬HasGoodGPA(x)) ::: Not all students who work hard to complete requirements have a good GPA.",
            "∃x (Student(x) ∧ EnrolledLate(x)) ::: There exist students who enrolled late.",
            "∃x (Student(x) ∧ ¬GraduatesOnTime(x)) ::: There exists a student that did not graduate on time",
            "∀x (Student(x) ∧ WorksHard(x) → TakesRequiredCourses(x)) ::: All students who work hard take all required courses"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledLate(x) ::: x enrolled late",
            "GraduatesOnTime(x) ::: x graduates on time",
            "CompletesRequirements(x) ::: x completes all requirements",
            "TakesRequiredCourses(x) ::: x takes all required courses",
            "HasGoodGPA(x) ::: x has a good GPA",
            "AffectedByPolicyChange(x) ::: x is affected by a policy change",
            "WorksHard(x) ::: x works hard",
            "EligibleToGraduate(x) ::: x is eligible to graduate"
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled.",
            "A student must be in good standing to pass a subject.",
            "If a student is not in good standing, they will not pass a subject.",
            "Cheating and being reported for it results in a student no longer being in good standing.",
            "If a student cheats, it is because they are enrolled in a subject.",
            "If a student is enrolled in a subject, then they take it.",
            "Professors only report enrolled students for cheating",
            "All students take some subject."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x)) ::: All students are enrolled.",
            "∀x ∀y ((Student(x) ∧ TakesSubject(x, y) ∧ PassesSubject(x, y)) → GoodStanding(x)) ::: A student must be in good standing to pass a subject.",
            "∀x ∀y ((Student(x) ∧ TakesSubject(x, y) ∧ ¬GoodStanding(x)) → ¬PassesSubject(x, y)) ::: If a student is not in good standing, they will not pass a subject.",
            "∀x ∀y ((Cheats(x, y) ∧ ProfessorReports(y, x)) → ¬GoodStanding(x)) ::: Cheating and being reported for it results in a student no longer being in good standing.",
            "∀x ∀y (Cheats(x, y) → TakesSubject(x, y)) ::: If a student cheats, it is because they are enrolled in a subject.",
            "∀x ∀y (TakesSubject(x, y) → TakesSubject(x, y)) ::: If a student is enrolled in a subject, then they take it.",
            "∀x ∀y (ProfessorReports(y, x) → Enrolled(x)) ::: Professors only report enrolled students for cheating",
            "∀x ∃y TakesSubject(x, y) ::: All students take some subject."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Cheats(x, y) ::: x cheats in subject y",
            "ProfessorReports(y, x) ::: Professor reports x for cheating in subject y",
            "PassesSubject(x, y) ::: x passes subject y",
            "TakesSubject(x, y) ::: x takes subject y",
            "Enrolled(x) ::: x is enrolled",
            "GoodStanding(x) ::: x is in good standing",
            "Subject(y) ::: y is a subject"
        ]
    },
    {
        "premises-NL": [
            "All students take some courses.",
            "If a student does not pay tuition, they will be dropped from their courses unless they have a payment plan.",
            "To have a payment plan, you must apply for one.",
            "Applying for a payment plan is equivalent to having one, if its approved.",
            "If a student is dropped from courses, then they don't take them",
            "If a student takes a course, then that course exists.",
            "If a student takes a course, and it's not paid or on payment plan, then the student is dropped.",
            "Only students can apply for payment plans.",
            "All courses are courses."
        ],
        "premises-FOL": [
            "∀x ∃y (Student(x) → Takes(x, y)) ::: All students take some courses.",
            "∀x ((Student(x) ∧ ¬PaysTuition(x) ∧ ¬HasPaymentPlan(x)) → DroppedFromCourses(x)) ::: If a student does not pay tuition, they will be dropped from their courses unless they have a payment plan.",
            "∀x (HasPaymentPlan(x) → AppliesForPlan(x)) ::: To have a payment plan, you must apply for one.",
            "∀x (HasPaymentPlan(x) ↔ ApprovedPlan(x)) ::: Applying for a payment plan is equivalent to having one, if its approved.",
            "∀x ∀y (DroppedFromCourses(x) → ¬Takes(x, y)) ::: If a student is dropped from courses, then they don't take them",
            "∀x ∀y (Takes(x, y) → Course(y)) ::: If a student takes a course, then that course exists.",
            "∀x ∀y (Takes(x, y) ∧ ¬PaysTuition(x) ∧ ¬HasPaymentPlan(x) → DroppedFromCourses(x)) ::: If a student takes a course, and it's not paid or on payment plan, then the student is dropped.",
            "∀x AppliesForPlan(x) → Student(x) ::: Only students can apply for payment plans.",
            "∀y Course(y) → Course(y) ::: All courses are courses."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PaysTuition(x) ::: x pays tuition",
            "HasPaymentPlan(x) ::: x has a payment plan",
            "DroppedFromCourses(x) ::: x is dropped from their courses",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "AppliesForPlan(x) ::: x applies for a payment plan",
            "ApprovedPlan(x) ::: x has an approved payment plan",
            "Takes(x, y) ::: x takes course y",
            "Course(y) ::: y is a course"
        ]
    },
    {
        "premises-NL": [
            "All graduate students are dedicated researchers.",
            "If someone is a dedicated researcher and has published a paper, then they are innovative.",
            "If someone is innovative, they have a high research impact.",
            "Some graduate students have published papers.",
            "Not all graduate students have won awards.",
            "If somebody is a graduate student, they are a researcher",
            "If somebody is a dedicated researcher, they work hard",
            "Somebody who works hard has published a paper"
        ],
        "premises-FOL": [
            "∀x (GraduateStudent(x) → DedicatedResearcher(x)) ::: For all x, if x is a graduate student, then x is a dedicated researcher.",
            "∀x ((DedicatedResearcher(x) ∧ PublishedPaper(x)) → Innovative(x)) ::: For all x, if x is a dedicated researcher and has published a paper, then x is innovative.",
            "∀x (Innovative(x) → HighResearchImpact(x)) ::: For all x, if x is innovative, then x has a high research impact.",
            "∃x (GraduateStudent(x) ∧ PublishedPaper(x)) ::: There exists an x such that x is a graduate student and has published a paper.",
            "∃x (GraduateStudent(x) ∧ ¬WonAward(x)) ::: There exists an x such that x is a graduate student and has not won an award.",
            "∀x (GraduateStudent(x) → DedicatedResearcher(x)) ::: For all x, if x is a graduate student, then x is a dedicated researcher.",
            "∀x (DedicatedResearcher(x) → PublishedPaper(x)) ::: For all x, if x is a dedicated researcher, then x has published a paper.",
            "∀x (GraduateStudent(x) → DedicatedResearcher(x)) ::: If x is a graduate student, then x is a dedicated researcher."
        ],
        "predicates": [
            "GraduateStudent(x) ::: x is a graduate student",
            "PublishedPaper(x) ::: x has published a paper",
            "HighResearchImpact(x) ::: x has a high research impact",
            "WonAward(x) ::: x has won an award",
            "DedicatedResearcher(x) ::: x is a dedicated researcher",
            "Innovative(x) ::: x is innovative",
            "Awarded(x) ::: x is awarded"
        ]
    },
    {
        "premises-NL": [
            "All students are people.",
            "If a course is difficult, it requires effort.",
            "If a student is enrolled in a course that requires effort, they will be stressed.",
            "There exists a course that is difficult.",
            "There exists a student enrolled in some course."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Person(x)) ::: All students are people.",
            "∀y (Difficult(y) → RequiresEffort(y)) ::: If a course is difficult, it requires effort.",
            "∀x ∀y (Student(x) ∧ EnrolledIn(x, y) ∧ RequiresEffort(y) → Stressed(x)) ::: If a student is enrolled in a course that requires effort, they will be stressed.",
            "∃y Difficult(y) ::: There exists a course that is difficult.",
            "∃x ∃y (Student(x) ∧ EnrolledIn(x, y)) ::: There exists a student enrolled in some course."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in course y",
            "Difficult(y) ::: y is a difficult course",
            "RequiresEffort(y) ::: y requires significant effort",
            "Stressed(x) ::: x is stressed"
        ]
    },
    {
        "premises-NL": [
            "All students must meet GPA requirements to be eligible for graduation.",
            "If a student applies for graduation and is not eligible, their graduation will be denied.",
            "A student is not eligible for graduation if they do not meet GPA requirements.",
            "There exists a student who does not meet GPA requirements.",
            "All students must apply for graduation to graduate.",
            "If a student takes courses and passes them they have completed credits",
            "Students who are eligible will not have their graduation denied.",
            "If a student does not meet requirements they are not eligible."
        ],
        "premises-FOL": [
            "∀x (Student(x) → MeetsGPARequirements(x) ∨ ¬MeetsGPARequirements(x)) ::: All students either meet GPA requirements or don't.",
            "∀x (Student(x) ∧ AppliesForGraduation(x) ∧ ¬IsEligible(x) → GraduationDenied(x)) ::: If a student applies for graduation and is not eligible, their graduation will be denied.",
            "∀x (Student(x) ∧ ¬MeetsGPARequirements(x) → ¬IsEligible(x)) ::: A student is not eligible for graduation if they do not meet GPA requirements.",
            "∃x (Student(x) ∧ ¬MeetsGPARequirements(x)) ::: There exists a student who does not meet GPA requirements.",
            "∀x (Student(x) → AppliesForGraduation(x) ∨ ¬AppliesForGraduation(x)) ::: All students either apply for graduation or don't.",
            "∀x ∀y (TakesCourse(x,y) ∧ PassesCourse(x,y) → HasCompletedCredits(x)) ::: If a student takes courses and passes them they have completed credits",
            "∀x (IsEligible(x) → ¬GraduationDenied(x)) ::: Students who are eligible will not have their graduation denied.",
            "∀x (¬MeetsGPARequirements(x) → ¬IsEligible(x)) ::: If a student does not meet requirements they are not eligible."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "MeetsGPARequirements(x) ::: x meets the GPA requirements",
            "AppliesForGraduation(x) ::: x applies for graduation",
            "GraduationDenied(x) ::: x's graduation is denied",
            "TakesCourse(x, y) ::: x takes course y",
            "PassesCourse(x, y) ::: x passes course y",
            "HasCompletedCredits(x) ::: x has completed credits",
            "IsEligible(x) ::: x is eligible."
        ]
    },
    {
        "premises-NL": [
            "All students must attend orientation.",
            "Attending orientation makes students aware of policies.",
            "Knowing the policies prevents late registration.",
            "If a student registers late, they must either appeal or pay a late fee.",
            "Appealing requires a valid reason.",
            "If a student has a valid reason, a waiver is granted.",
            "If a waiver is granted, the late fee is waived.",
            "Students who register late did not attend orientation.",
            "If a student does not know the policy then they do not appeal."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AttendsOrientation(x)) ::: All students must attend orientation.",
            "∀x (AttendsOrientation(x) → KnowsPolicy(x)) ::: Attending orientation makes students aware of policies.",
            "∀x (KnowsPolicy(x) → ¬RegistersLate(x)) ::: Knowing the policies prevents late registration.",
            "∀x (Student(x) ∧ RegistersLate(x) → (Appeals(x) ∨ PaysLateFee(x))) ::: Late registration requires appeal or fee.",
            "∀x (Appeals(x) → ValidReason(x)) ::: Appealing requires a valid reason.",
            "∀x (ValidReason(x) → WaiverGranted(x)) ::: Valid reason grants a waiver.",
            "∀x (WaiverGranted(x) → ¬PaysLateFee(x)) ::: Waiver waives the late fee.",
            "∀x (RegistersLate(x) → ¬AttendsOrientation(x)) ::: If you register late, you did not attend orientation.",
            "∀x (¬KnowsPolicy(x) → ¬Appeals(x)) ::: If a student does not know the policy then they do not appeal."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "RegistersLate(x) ::: x registers late",
            "Appeals(x) ::: x appeals",
            "PaysLateFee(x) ::: x pays a late fee",
            "AttendsOrientation(x) ::: x attends orientation",
            "KnowsPolicy(x) ::: x knows the policy",
            "WaiverGranted(x) ::: Waiver is granted to x",
            "ValidReason(x) ::: x has a valid reason"
        ]
    },
    {
        "premises-NL": [
            "All students are individuals.",
            "If an individual takes a course, then the course exists.",
            "Some courses are difficult.",
            "If a student takes a difficult course and does not study hard, then they will fail the course.",
            "All students are enrolled"
        ],
        "premises-FOL": [
            "∀x (Student(x) → Individual(x)) ::: All students are individuals.",
            "∀x ∀y (Individual(x) ∧ Takes(x, y) → Exists(y)) ::: If an individual takes a course, then the course exists.",
            "∃y DifficultCourse(y) ::: Some courses are difficult.",
            "∀x ∀y (Student(x) ∧ Takes(x, y) ∧ DifficultCourse(y) ∧ ¬StudiesHard(x) → Fails(x, y)) ::: If a student takes a difficult course and does not study hard, then they will fail the course.",
            "∀x (Student(x) → Enrolled(x)) ::: All students are enrolled."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Takes(x, y) ::: x takes course y",
            "DifficultCourse(y) ::: y is a difficult course",
            "StudiesHard(x) ::: x studies hard",
            "Fails(x, y) ::: x fails course y"
        ]
    },
    {
        "premises-NL": [
            "All professors are instructors.",
            "If an instructor teaches a course, then the course exists.",
            "Some courses are advanced.",
            "If a student enrolls in a course, then they are registered.",
            "If a professor teaches an advanced course and a student enrolls in the course, then the student will work hard.",
            "If a student works hard, then they either struggle or succeed."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Instructor(x)) ::: All professors are instructors.",
            "∀x ∀y (Instructor(x) ∧ Teaches(x, y) → Exists(y)) ::: If an instructor teaches a course, then the course exists.",
            "∃y AdvancedCourse(y) ::: Some courses are advanced.",
            "∀z ∀y (Student(z) ∧ Enrolls(z, y) → Registered(z)) ::: If a student enrolls in a course, then they are registered.",
            "∀x ∀y ∀z (Professor(x) ∧ Teaches(x, y) ∧ AdvancedCourse(y) ∧ Student(z) ∧ Enrolls(z, y) → WorksHard(z)) ::: If a professor teaches an advanced course and a student enrolls in the course, then the student will work hard.",
            "∀z (WorksHard(z) → (Struggles(z) ∨ Succeeds(z))) ::: If a student works hard, then they either struggle or succeed."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches course y",
            "AdvancedCourse(y) ::: y is an advanced course",
            "Student(z) ::: z is a student",
            "Enrolls(z, y) ::: z enrolls in course y",
            "Struggles(z) ::: z struggles",
            "Succeeds(z) ::: z succeeds"
        ]
    },
    {
        "premises-NL": [
            "All students must adhere to regulations.",
            "If a course has prerequisites, then those prerequisites exist.",
            "If a student takes a course, they are enrolled or auditing.",
            "Enrolling in a course is the first step to taking it.",
            "If a student enrolls in a course that has prerequisites, they have either met the prerequisites or not.",
            "If a student is not a graduate then they are an undergraduate.",
            "All undergraduate students have advisors."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AdheresToRegulations(x)) ::: All students must adhere to regulations.",
            "∀y (HasPrerequisites(y) → Exists(y)) ::: If a course has prerequisites, then those prerequisites exist.",
            "∀x ∀y (Student(x) ∧ Takes(x, y) → (Enrolls(x, y) ∨ Audits(x, y))) ::: If a student takes a course, they are enrolled or auditing.",
            "∀x ∀y (Enrolls(x, y) → Takes(x, y)) ::: Enrolling in a course is the first step to taking it.",
            "∀x ∀y (Student(x) ∧ Enrolls(x, y) ∧ HasPrerequisites(y) → (MeetsPrerequisites(x, y) ∨ ¬MeetsPrerequisites(x, y))) ::: If a student enrolls in a course that has prerequisites, they have either met the prerequisites or not.",
            "∀x (Student(x) ∧ ¬Graduate(x) → Undergraduate(x)) ::: If a student is not a graduate then they are an undergraduate.",
            "∀x (Undergraduate(x) → HasAdvisor(x)) ::: All undergraduate students have advisors."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolls(x, y) ::: x enrolls in course y",
            "HasPrerequisites(y) ::: course y has prerequisites",
            "MeetsPrerequisites(x, y) ::: x meets the prerequisites for course y",
            "Drops(x, y) ::: x drops course y",
            "Fails(x, y) ::: x fails course y",
            "Takes(x, y) ::: x takes course y"
        ]
    },
    {
        "premises-NL": [
            "All courses are supervised by instructors.",
            "If an instructor teaches a course, then the course is taught.",
            "If a course is taught, the university provides resources.",
            "Some courses have labs.",
            "If a student registers for a course, then they are paying tuition.",
            "Students paying tuition must adhere to attendance policies.",
            "If a student does not adhere to attendance policy, they may not pass the course.",
            "A student may not adhere to attendance policies because they are sick."
        ],
        "premises-FOL": [
            "∀y ∃z (Course(y) → Instructor(z) ∧ Supervises(z, y)) ::: All courses are supervised by instructors.",
            "∀z ∀y (Instructor(z) ∧ Teaches(z, y) → Taught(y)) ::: If an instructor teaches a course, then the course is taught.",
            "∀y (Taught(y) → ProvidesResources(University, y)) ::: If a course is taught, the university provides resources.",
            "∃y HasLab(y) ::: Some courses have labs.",
            "∀x ∀y (Student(x) ∧ Registers(x, y) → PaysTuition(x)) ::: If a student registers for a course, then they are paying tuition.",
            "∀x (PaysTuition(x) → AdheresToAttendancePolicies(x)) ::: Students paying tuition must adhere to attendance policies.",
            "∀x ∀y (Student(x) ∧ ¬AdheresToAttendancePolicies(x) → ¬Passes(x, y)) ::: If a student does not adhere to attendance policy, they may not pass the course.",
            "∀x (Student(x) ∧ Sick(x) → ¬AdheresToAttendancePolicies(x)) ::: A student may not adhere to attendance policies because they are sick."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Registers(x, y) ::: x registers for course y",
            "HasLab(y) ::: course y has a lab",
            "AttendsLab(x, y) ::: x attends the lab for course y",
            "Passes(x, y) ::: x passes course y",
            "Sick(x) ::: x is sick",
            "Instructor(z) ::: z is an instructor",
            "Teaches(z, y) ::: z teaches course y"
        ]
    },
    {
        "premises-NL": [
            "All students must maintain good standing.",
            "To maintain good standing, a student must adhere to the honor code.",
            "Graduation requires adherence to the honor code.",
            "If a student applies for graduation, the registrar reviews their record.",
            "If a registrar reviews the record and there are outstanding fees then fees must be paid.",
            "Fees may be waived by the Dean.",
            "If a student is related to the Dean, fees may be waived.",
            "All students attend courses.",
            "Students attending courses are taught by Professors."
        ],
        "premises-FOL": [
            "∀x (Student(x) → MaintainsGoodStanding(x)) ::: All students must maintain good standing.",
            "∀x (MaintainsGoodStanding(x) → AdheresToHonorCode(x)) ::: To maintain good standing, a student must adhere to the honor code.",
            "∀x (Graduates(x) → AdheresToHonorCode(x)) ::: Graduation requires adherence to the honor code.",
            "∀x (Student(x) ∧ AppliesForGraduation(x) → ReviewsRecord(Registrar, x)) ::: If a student applies for graduation, the registrar reviews their record.",
            "∀x (ReviewsRecord(Registrar, x) ∧ HasOutstandingFees(x) → MustPayFees(x)) ::: If a registrar reviews the record and there are outstanding fees then fees must be paid.",
            "∀x (HasOutstandingFees(x) ∧ WaivesFees(Dean, x) → ¬MustPayFees(x)) ::: Fees may be waived by the Dean.",
            "∀x (HasOutstandingFees(x) ∧ RelatedTo(x, Dean) → WaivesFees(Dean, x)) ::: If a student is related to the Dean, fees may be waived.",
            "∀x ∀y (Student(x) ∧ Course(y) → Attends(x, y)) ::: All students attend courses.",
            "∀x ∀y ∃z (Student(x) ∧ Course(y) ∧ Attends(x, y) → Teaches(z,y) ∧ Professor(z)) ::: Students attending courses are taught by Professors."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AppliesForGraduation(x) ::: x applies for graduation",
            "CompletedCourseRequirements(x) ::: x has completed all course requirements",
            "HasOutstandingFees(x) ::: x has outstanding fees",
            "Graduates(x) ::: x graduates",
            "WaivesFees(y, x) ::: y waives fees for x",
            "RelatedTo(x, y) ::: x is related to y",
            "Dean(z) ::: z is the dean",
            "Attends(x, y) ::: x attends course y"
        ]
    },
    {
        "premises-NL": [
            "All students are either prepared or not prepared.",
            "If a student studies diligently and attends lectures, they are prepared.",
            "If a student is prepared, they understand the material.",
            "If a student understands the material, they will pass the exam.",
            "All students study diligently.",
            "All students attend lectures."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Prepared(x) ∨ ¬Prepared(x))) ::: All students are either prepared or not prepared.",
            "∀x (Student(x) ∧ StudiesDiligently(x) ∧ AttendsLectures(x) → Prepared(x)) ::: If a student studies diligently and attends lectures, they are prepared.",
            "∀x (Prepared(x) → UnderstandsMaterial(x)) ::: If a student is prepared, they understand the material.",
            "∀x (UnderstandsMaterial(x) → PassesExam(x)) ::: If a student understands the material, they will pass the exam.",
            "∀x (Student(x) → StudiesDiligently(x)) ::: All students study diligently.",
            "∀x (Student(x) → AttendsLectures(x)) ::: All students attend lectures."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesDiligently(x) ::: x studies diligently",
            "AttendsLectures(x) ::: x attends lectures",
            "UnderstandsMaterial(x) ::: x understands the material",
            "PassesExam(x) ::: x passes the exam",
            "IsPrepared(x) ::: x is prepared"
        ]
    },
    {
        "premises-NL": [
            "All students are either enrolled or not enrolled.",
            "If a student is enrolled, they must pay tuition to maintain good standing.",
            "If a student pays tuition, they have good standing.",
            "If a student has good standing and attends all courses, they meet the requirements.",
            "If a student meets the requirements, they will graduate.",
            "All students attend all courses.",
            "All students pay tuition."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Enrolled(x) ∨ ¬Enrolled(x))) ::: All students are either enrolled or not enrolled.",
            "∀x (Student(x) ∧ Enrolled(x) → PaysTuition(x) ∧ HasGoodStanding(x)) ::: If a student is enrolled, they must pay tuition to maintain good standing.",
            "∀x (PaysTuition(x) → HasGoodStanding(x)) ::: If a student pays tuition, they have good standing.",
            "∀x (HasGoodStanding(x) ∧ AttendsAllCourses(x) → MeetsRequirements(x)) ::: If a student has good standing and attends all courses, they meet the requirements.",
            "∀x (MeetsRequirements(x) → Graduates(x)) ::: If a student meets the requirements, they will graduate.",
            "∀x (Student(x) → AttendsAllCourses(x)) ::: All students attend all courses.",
            "∀x (Student(x) → PaysTuition(x)) ::: All students pay tuition."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x) ::: x is enrolled",
            "PaysTuition(x) ::: x pays tuition",
            "AttendsAllCourses(x) ::: x attends all courses",
            "MeetsRequirements(x) ::: x meets the requirements",
            "HasGoodStanding(x) ::: x has good standing",
            "Graduates(x) ::: x graduates"
        ]
    },
    {
        "premises-NL": [
            "All students must pay fees.",
            "If a student enrolls in a course, they take the course.",
            "If a student takes a course, they are either prepared or unprepared.",
            "If a student is prepared for a course, they understand the material.",
            "If a student understands the material, they complete the assignment.",
            "If a student completes the assignment, they attend lectures.",
            "If a student attends lectures, they pass the course.",
            "All students are enrolled in courses."
        ],
        "premises-FOL": [
            "∀x (Student(x) → PaysFees(x)) ::: All students must pay fees.",
            "∀x ∀y (Student(x) ∧ Enrolls(x, y) → Takes(x, y) ∧ Course(y)) ::: If a student enrolls in a course, they take the course.",
            "∀x ∀y (Student(x) ∧ Takes(x, y) → (Prepared(x, y) ∨ ¬Prepared(x, y))) ::: If a student takes a course, they are either prepared or unprepared.",
            "∀x ∀y (Prepared(x, y) → UnderstandsMaterial(x, y)) ::: If a student is prepared for a course, they understand the material.",
            "∀x ∀y (UnderstandsMaterial(x, y) → CompletesAssignment(x, y)) ::: If a student understands the material, they complete the assignment.",
            "∀x ∀y (CompletesAssignment(x, y) → AttendsLectures(x, y)) ::: If a student completes the assignment, they attend lectures.",
            "∀x ∀y (AttendsLectures(x, y) → PassesCourse(x, y)) ::: If a student attends lectures, they pass the course.",
            "∀x ∃y (Student(x) → Enrolls(x, y) ∧ Course(y)) ::: All students are enrolled in courses."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Course(y) ::: y is a course",
            "Takes(x, y) ::: x takes y",
            "CompletesAssignment(x, y) ::: x completes the assignment for y",
            "AttendsLectures(x, y) ::: x attends lectures for y",
            "PassesCourse(x, y) ::: x passes y",
            "UnderstandsMaterial(x, y) ::: x understands the material for y",
            "Enrolls(x, y) ::: x enrolls in y",
            "PaysFees(x) ::: x pays fees"
        ]
    },
    {
        "premises-NL": [
            "All students either attend lectures or are lazy.",
            "If a student is lazy, then they do not study hard.",
            "If a student does not study hard, then they fail a course.",
            "If a student fails a course, then they are put on academic probation.",
            "If a student is on academic probation, then they are prevented from graduating.",
            "If a student is prevented from graduating, then they are not able to graduate.",
            "Students either retake courses or need financial aid.",
            "If a student attends lectures then they will not be on academic probation.",
            "If a student is not able to graduate then they need financial aid.",
            "All students have high tuition.",
            "If a student has high tuition, then they study hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (AttendsLectures(x) ∨ Lazy(x))) ::: All students either attend lectures or are lazy.",
            "∀x (Lazy(x) → ¬StudiesHard(x)) ::: If a student is lazy, then they do not study hard.",
            "∀x (¬StudiesHard(x) → FailsCourse(x)) ::: If a student does not study hard, then they fail a course.",
            "∀x (FailsCourse(x) → AcademicProbation(x)) ::: If a student fails a course, then they are put on academic probation.",
            "∀x (AcademicProbation(x) → PreventsGraduation(x)) ::: If a student is on academic probation, then they are prevented from graduating.",
            "∀x (PreventsGraduation(x) → ¬AbleToGraduate(x)) ::: If a student is prevented from graduating, then they are not able to graduate.",
            "∀x (Student(x) → (RetakesCourse(x) ∨ NeedsFinancialAid(x))) ::: Students either retake courses or need financial aid.",
            "∀x (AttendsLectures(x) → ¬AcademicProbation(x)) ::: If a student attends lectures then they will not be on academic probation.",
            "∀x (¬AbleToGraduate(x) → NeedsFinancialAid(x)) ::: If a student is not able to graduate then they need financial aid.",
            "∀x (Student(x) → HighTuition(x)) ::: All students have high tuition.",
            "∀x (HighTuition(x) → StudiesHard(x)) ::: If a student has high tuition, then they study hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "FailsCourse(x) ::: x fails a course",
            "AcademicProbation(x) ::: x is on academic probation",
            "PreventsGraduation(x) ::: Academic probation prevents x from graduating",
            "AbleToGraduate(x) ::: x is able to graduate",
            "RetakesCourse(x) ::: x retakes the course",
            "HighTuition(x) ::: x has high tuition",
            "NeedsFinancialAid(x) ::: x needs financial aid",
            "AttendsLectures(x) ::: x attends lectures",
            "StudiesHard(x) ::: x studies hard",
            "Lazy(x) ::: x is lazy"
        ]
    },
    {
        "premises-NL": [
            "All students study ethically or are under pressure.",
            "If a student is under pressure, then they need to succeed.",
            "If a student needs to succeed, then they will cheat on an exam or work hard.",
            "If a student works hard, then they do not cheat on an exam.",
            "If a student studies ethically, then they have integrity.",
            "If a student has integrity then they do not cheat on exams.",
            "If a student cheats on an exam, then they fail the course.",
            "If a student fails a course, then they are disqualified from the scholarship.",
            "If a student is disqualified from the scholarship, then they do not receive a scholarship.",
            "All students are innocent or have no integrity",
            "If a student attends review sessions they don't cheat on exams",
            "A student either receives a scholarship or was framed",
            "If a student is innocent then they were framed."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (StudiesEthically(x) ∨ UnderPressure(x))) ::: All students study ethically or are under pressure.",
            "∀x (UnderPressure(x) → NeedsToSucceed(x)) ::: If a student is under pressure, then they need to succeed.",
            "∀x (NeedsToSucceed(x) → (CheatsOnExam(x) ∨ WorksHard(x))) ::: If a student needs to succeed, then they will cheat on an exam or work hard.",
            "∀x (WorksHard(x) → ¬CheatsOnExam(x)) ::: If a student works hard, then they do not cheat on an exam.",
            "∀x (StudiesEthically(x) → HasIntegrity(x)) ::: If a student studies ethically, then they have integrity.",
            "∀x (HasIntegrity(x) → ¬CheatsOnExam(x)) ::: If a student has integrity then they do not cheat on exams.",
            "∀x (CheatsOnExam(x) → FailsCourse(x)) ::: If a student cheats on an exam, then they fail the course.",
            "∀x (FailsCourse(x) → DisqualifiedFromScholarship(x)) ::: If a student fails a course, then they are disqualified from the scholarship.",
            "∀x (DisqualifiedFromScholarship(x) → ¬ReceivesScholarship(x)) ::: If a student is disqualified from the scholarship, then they do not receive a scholarship.",
            "∀x (Student(x) → (Innocent(x) ∨ ¬HasIntegrity(x))) ::: All students are innocent or have no integrity",
            "∀x (AttendsReviewSessions(x) → ¬CheatsOnExam(x)) ::: If a student attends review sessions they don't cheat on exams",
            "∀x (Student(x) → (ReceivesScholarship(x) ∨ Framed(x))) ::: A student either receives a scholarship or was framed",
            "∀x (Innocent(x) → Framed(x)) ::: If a student is innocent then they were framed."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "CheatsOnExam(x) ::: x cheats on an exam",
            "FailsCourse(x) ::: x fails the course",
            "DisqualifiedFromScholarship(x) ::: x is disqualified from a scholarship",
            "ReceivesScholarship(x) ::: x receives a scholarship",
            "Framed(x) ::: x was framed",
            "StudiesEthically(x) ::: x studies ethically",
            "HasIntegrity(x) ::: x has integrity",
            "UnderPressure(x) ::: x is under pressure",
            "NeedsToSucceed(x) ::: x needs to succeed",
            "WorksHard(x) ::: x works hard",
            "AttendsReviewSessions(x) ::: x attends review sessions",
            "Innocent(x) ::: x is innocent"
        ]
    },
    {
        "premises-NL": [
            "All students must either study or attend class to pass the course.",
            "If someone is lazy, then they do not study.",
            "If someone attends class, then they may ask questions.",
            "If someone studies, then they may understand the material.",
            "If someone understands the material and asks questions, then they will get good grades.",
            "If someone gets good grades and passes exams, then they will pass the course.",
            "If someone passes exams, then they understand the material.",
            "Students either enjoy learning or they are lazy.",
            "If someone participates in class, they attend class.",
            "If a student attends class and asks questions, they are not lazy.",
            "Someone who does not understand the material fails exams."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Studies(x) ∨ AttendsClass(x) ∨ FailsCourse(x))) ::: If x is a student, then x either studies, attends class, or fails.",
            "∀x (Lazy(x) → ¬Studies(x)) ::: If x is lazy, then x does not study.",
            "∀x (AttendsClass(x) → AsksQuestions(x)) ::: If x attends class, then x asks questions.",
            "∀x (Studies(x) → UnderstandsMaterial(x)) ::: If x studies, then x understands the material.",
            "∀x ((UnderstandsMaterial(x) ∧ AsksQuestions(x)) → GetsGoodGrades(x)) ::: If x understands the material and asks questions, then x gets good grades.",
            "∀x ((GetsGoodGrades(x) ∧ PassesExams(x)) → ¬FailsCourse(x)) ::: If x gets good grades and passes exams, then x does not fail the course.",
            "∀x (PassesExams(x) → UnderstandsMaterial(x)) ::: If x passes exams, then x understands the material.",
            "∀x (Student(x) → (EnjoysLearning(x) ∨ Lazy(x))) ::: If x is a student, then x either enjoys learning or is lazy.",
            "∀x (Participates(x) → AttendsClass(x)) ::: If x participates, then x attends class.",
            "∀x ((Student(x) ∧ AttendsClass(x) ∧ AsksQuestions(x)) → ¬Lazy(x)) ::: If x is a student and attends class and asks questions, then x is not lazy.",
            "∀x (¬UnderstandsMaterial(x) → FailsCourse(x)) ::: If x does not understand the material, then x fails exams."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Lazy(x) ::: x is lazy",
            "AttendsClass(x) ::: x attends class",
            "FailsCourse(x) ::: x fails the course",
            "Studies(x) ::: x studies",
            "UnderstandsMaterial(x) ::: x understands the material",
            "AsksQuestions(x) ::: x asks questions",
            "PassesExams(x) ::: x passes exams",
            "Participates(x) ::: x participates in class",
            "GetsGoodGrades(x) ::: x gets good grades",
            "EnjoysLearning(x) ::: x enjoys learning"
        ]
    },
    {
        "premises-NL": [
            "All students with a low GPA are underperforming.",
            "If a student is underperforming and misses many classes, then they need improvement.",
            "Students who need improvement may receive a warning.",
            "If a student receives a warning, they should talk to an advisor.",
            "If a student talks to an advisor, they may improve their attendance.",
            "If a student studies more and seeks help, they may raise their GPA.",
            "If a student fails courses, then they likely have a low GPA.",
            "Students who are on academic probation must improve their attendance and raise their GPA.",
            "If a student does not improve their attendance or raise their GPA after academic probation, they will be suspended.",
            "If a student is underperforming they fail courses.",
            "Students who are on academic probation are underperforming.",
            "If students miss many classes, they don't study more.",
            "If a student is failing their courses, they miss many classes."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ LowGPA(x) → Underperforming(x)) ::: All students with a low GPA are underperforming.",
            "∀x (Underperforming(x) ∧ MissesManyClasses(x) → NeedsImprovement(x)) ::: If a student is underperforming and misses many classes, then they need improvement.",
            "∀x (NeedsImprovement(x) → ReceivesWarning(x)) ::: Students who need improvement receive a warning.",
            "∀x (ReceivesWarning(x) → TalksToAdvisor(x)) ::: If a student receives a warning, they will talk to an advisor.",
            "∀x (TalksToAdvisor(x) → ImprovesAttendance(x)) ::: If a student talks to an advisor, they may improve their attendance.",
            "∀x (StudiesMore(x) ∧ SeeksHelp(x) → RaisesGPA(x)) ::: If a student studies more and seeks help, they may raise their GPA.",
            "∀x (FailsCourses(x) → LowGPA(x)) ::: If a student fails courses, then they likely have a low GPA.",
            "∀x (AcademicProbation(x) → (ImprovesAttendance(x) ∧ RaisesGPA(x))) ::: Students who are on academic probation must improve their attendance and raise their GPA.",
            "∀x (AcademicProbation(x) ∧ ¬ImprovesAttendance(x) → Underperforming(x)) ::: If a student does not improve their attendance after academic probation, they will be suspended.",
            "∀x (Underperforming(x) → FailsCourses(x)) ::: If a student is underperforming they fail courses.",
            "∀x (AcademicProbation(x) → Underperforming(x)) ::: Students who are on academic probation are underperforming.",
            "∀x (MissesManyClasses(x) → ¬StudiesMore(x)) ::: If students miss many classes, they don't study more.",
            "∀x (FailsCourses(x) → MissesManyClasses(x)) ::: If a student is failing their courses, they miss many classes."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "LowGPA(x) ::: x has a low GPA",
            "MissesManyClasses(x) ::: x misses many classes",
            "AcademicProbation(x) ::: x is on academic probation",
            "Underperforming(x) ::: x is underperforming",
            "NeedsImprovement(x) ::: x needs improvement",
            "ReceivesWarning(x) ::: x receives a warning",
            "TalksToAdvisor(x) ::: x talks to an advisor",
            "ImprovesAttendance(x) ::: x improves attendance",
            "RaisesGPA(x) ::: x raises their GPA",
            "StudiesMore(x) ::: x studies more",
            "SeeksHelp(x) ::: x seeks help",
            "FailsCourses(x) ::: x fails courses"
        ]
    },
    {
        "premises-NL": [
            "All students must pay tuition on time or be eligible for a waiver to remain enrolled.",
            "Students who have financial aid are likely to pay tuition on time.",
            "To be eligible for a waiver, a student must complete the application and meet the income requirements.",
            "If a student does not pay tuition on time, they must follow the instructions to apply for a waiver.",
            "To maintain good standing, a student must attend classes and pass courses.",
            "If a student meets the income requirements for a waiver and provides documentation, then they are likely eligible for a waiver.",
            "Students who complete the application and follow instructions are more likely to be considered for a waiver.",
            "If a student does not have a valid reason, they do not get a waiver.",
            "Enrolled students are expected to maintain good standing.",
            "If a student attends all of their classes and passes their courses then they maintain good academic standing.",
            "If a student meets the income requirements, completes the application, and follows instructions, they will be considered for a waiver.",
            "Providing the necessary documentation is important to be eligible for the tuition waiver.",
            "If someone is eligible for a tuition waiver then they aren't going to be dropped from courses.",
            "Not all students have a valid reason to not pay their tuition on time."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (PaysTuitionOnTime(x) ∨ EligibleForWaiver(x) ∨ DroppedFromCourses(x))) ::: All students must pay tuition on time or be eligible for a waiver to remain enrolled.",
            "∀x (HasFinancialAid(x) → PaysTuitionOnTime(x)) ::: Students who have financial aid are likely to pay tuition on time.",
            "∀x (EligibleForWaiver(x) → (CompletesApplication(x) ∧ MeetsIncomeRequirements(x))) ::: To be eligible for a waiver, a student must complete the application and meet the income requirements.",
            "∀x (¬PaysTuitionOnTime(x) → FollowsInstructions(x)) ::: If a student does not pay tuition on time, they must follow the instructions to apply for a waiver.",
            "∀x (MaintainsGoodStanding(x) → (AttendsClasses(x) ∧ PassesCourses(x))) ::: To maintain good standing, a student must attend classes and pass courses.",
            "∀x (MeetsIncomeRequirements(x) ∧ ProvidesDocumentation(x) → EligibleForWaiver(x)) ::: If a student meets the income requirements for a waiver and provides documentation, then they are likely eligible for a waiver.",
            "∀x (CompletesApplication(x) ∧ FollowsInstructions(x) → EligibleForWaiver(x)) ::: Students who complete the application and follow instructions are more likely to be considered for a waiver.",
            "∀x (¬HasValidReason(x) → ¬EligibleForWaiver(x)) ::: If a student does not have a valid reason, they do not get a waiver.",
            "∀x (Enrolled(x, y) → MaintainsGoodStanding(x)) ::: Enrolled students are expected to maintain good standing.",
            "∀x (AttendsClasses(x) ∧ PassesCourses(x) → MaintainsGoodStanding(x)) ::: If a student attends all of their classes and passes their courses then they maintain good academic standing.",
            "∀x (MeetsIncomeRequirements(x) ∧ CompletesApplication(x) ∧ FollowsInstructions(x) → EligibleForWaiver(x)) ::: If a student meets the income requirements, completes the application, and follows instructions, they will be considered for a waiver.",
            "∀x (ProvidesDocumentation(x) → EligibleForWaiver(x)) ::: Providing the necessary documentation is important to be eligible for the tuition waiver.",
            "∀x (EligibleForWaiver(x) → ¬DroppedFromCourses(x)) ::: If someone is eligible for a tuition waiver then they aren't going to be dropped from courses.",
            "∃x (Student(x) ∧ ¬HasValidReason(x)) ::: Not all students have a valid reason to not pay their tuition on time."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PaysTuitionOnTime(x) ::: x pays tuition on time",
            "EligibleForWaiver(x) ::: x is eligible for a tuition waiver",
            "DroppedFromCourses(x) ::: x is dropped from their courses",
            "HasFinancialAid(x) ::: x has financial aid",
            "MaintainsGoodStanding(x) ::: x maintains good academic standing",
            "CompletesApplication(x) ::: x completes a waiver application",
            "MeetsIncomeRequirements(x) ::: x meets the income requirements for a waiver",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "AttendsClasses(x) ::: x attends classes",
            "PassesCourses(x) ::: x passes courses",
            "FollowsInstructions(x) ::: x follows instructions",
            "ProvidesDocumentation(x) ::: x provides necessary documentation",
            "HasValidReason(x) ::: x has a valid reason for not paying"
        ]
    },
    {
        "premises-NL": [
            "All students must enroll. ::: Enrollment is required.",
            "If a student applies for financial aid and is approved, they can defer their tuition payment. ::: Aid enables payment deferral.",
            "If a student defers tuition, they have not paid their tuition. ::: Deferring means not paying.",
            "There exists a student who applied for financial aid. ::: Someone requested aid.",
            "If a student is approved for financial aid, they have financial aid. ::: Approval grants aid.",
            "If a student has financial aid, they can defer tuition. ::: Aid leads to possible deferral.",
            "Sarah is a student. ::: Sarah is a student.",
            "Sarah applied for financial aid. ::: Sarah applied for financial aid.",
            "Sarah was approved for financial aid. ::: Sarah got approved."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x)) ::: All students must enroll.",
            "∀x (AppliesForAid(x) ∧ ApprovedForAid(x) → DeferredTuition(x)) ::: If a student applies for financial aid and is approved, they can defer their tuition payment.",
            "∀x (DeferredTuition(x) → ¬PaidTuition(x)) ::: If a student defers tuition, they have not paid their tuition.",
            "∃x AppliesForAid(x) ::: There exists a student who applied for financial aid.",
            "∀x (ApprovedForAid(x) → HasFinancialAid(x)) ::: If a student is approved for financial aid, they have financial aid.",
            "∀x (HasFinancialAid(x) → DeferredTuition(x)) ::: If a student has financial aid, they can defer tuition.",
            "Student('Sarah') ::: Sarah is a student.",
            "AppliesForAid('Sarah') ::: Sarah applied for financial aid.",
            "ApprovedForAid('Sarah') ::: Sarah was approved for financial aid."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x) ::: x is enrolled",
            "PaidTuition(x) ::: x has paid tuition",
            "DeferredTuition(x) ::: x has deferred tuition",
            "HasFinancialAid(x) ::: x has financial aid",
            "AppliesForAid(x) ::: x applies for aid",
            "ApprovedForAid(x) ::: x is approved for aid",
            "RequiresPayment(x) ::: x requires payment",
            "Attends(x, y) ::: x attends y"
        ]
    },
    {
        "premises-NL": [
            "All students who are smart and study hard will pass any course that requires effort and is graded.",
            "If a student takes a course, they are a student.",
            "If a course requires effort, it is a difficult course.",
            "Some students are smart.",
            "Some students study hard.",
            "There is a course that is graded and requires effort.",
            "If a student passes a course then the student took the course.",
            "If a student took a course then they are a student."
        ],
        "premises-FOL": [
            "∀x ∀y ((Student(x) ∧ Smart(x) ∧ StudiesHard(x) ∧ Took(x, y) ∧ RequiresEffort(y) ∧ IsGraded(y)) → Passed(x, y)) ::: If a student is smart, studies hard, took a course, the course requires effort and is graded, then they will pass the course.",
            "∀x ∀y (Took(x, y) → Student(x)) ::: If x took a course y, then x is a student.",
            "∀y (RequiresEffort(y) → DifficultCourse(y)) ::: If a course requires effort, then it is a difficult course.",
            "∃x (Student(x) ∧ Smart(x)) ::: There exists a student who is smart.",
            "∃x (Student(x) ∧ StudiesHard(x)) ::: There exists a student who studies hard.",
            "∃y (IsGraded(y) ∧ RequiresEffort(y)) ::: There exists a course that is graded and requires effort.",
            "∀x ∀y (Passed(x, y) → Took(x, y)) ::: If a student passes a course then they took the course.",
            "∀x ∀y (Took(x,y) → Student(x)) ::: If a student took a course then they are a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Took(x, y) ::: x took course y",
            "DifficultCourse(y) ::: y is a difficult course",
            "Passed(x, y) ::: x passed course y",
            "RequiresEffort(y) ::: Course y requires effort",
            "IsGraded(y) ::: Course y has a grade",
            "Smart(x) ::: x is smart",
            "StudiesHard(x) ::: x studies hard"
        ]
    },
    {
        "premises-NL": [
            "All graduate students are students.",
            "If someone is a student, then they are intelligent.",
            "If someone is intelligent and attends all lectures, then they work hard.",
            "If someone works hard and actively participates, then they like research.",
            "If someone likes research, then they read papers.",
            "If someone reads papers and writes well, then they can publish papers.",
            "If a professor advises a graduate student, then the student must write well.",
            "If someone likes research and publishes papers, then they will finish their thesis on time.",
            "If someone writes well, then they can publish papers.",
            "If a graduate student actively participates, then they engage.",
            "If a student finishes their thesis on time and works hard, then they will defend their thesis.",
            "If someone writes well and publishes papers, then they are successful.",
            "If a graduate student is advised and attends lectures, then they learn a lot."
        ],
        "premises-FOL": [
            "∀x (GraduateStudent(x) → Student(x)) ::: All graduate students are students.",
            "∀x (Student(x) → Intelligent(x)) ::: If someone is a student, then they are intelligent.",
            "∀x (Intelligent(x) ∧ AttendsAllLectures(x) → WorksHard(x)) ::: If someone is intelligent and attends all lectures, then they work hard.",
            "∀x (WorksHard(x) ∧ ActivelyParticipates(x) → LikesResearch(x)) ::: If someone works hard and actively participates, then they like research.",
            "∀x (LikesResearch(x) → ReadsPapers(x)) ::: If someone likes research, then they read papers.",
            "∀x (ReadsPapers(x) ∧ WritesWell(x) → PublishesPapers(x)) ::: If someone reads papers and writes well, then they can publish papers.",
            "∀x ∀y (Professor(y) ∧ Advises(y, x) ∧ GraduateStudent(x) → WritesWell(x)) ::: If a professor advises a graduate student, then the student must write well.",
            "∀x (LikesResearch(x) ∧ PublishesPapers(x) → FinishesThesisOnTime(x)) ::: If someone likes research and publishes papers, then they will finish their thesis on time.",
            "∀x (WritesWell(x) → PublishesPapers(x)) ::: If someone writes well, then they can publish papers.",
            "∀x (GraduateStudent(x) ∧ ActivelyParticipates(x) → Engages(x)) ::: If a graduate student actively participates, then they engage.",
            "∀x (FinishesThesisOnTime(x) ∧ WorksHard(x) → SuccessfullyDefendsThesis(x)) ::: If a student finishes their thesis on time and works hard, then they will defend their thesis.",
            "∀x (WritesWell(x) ∧ PublishesPapers(x) → Successful(x)) ::: If someone writes well and publishes papers, then they are successful.",
            "∀x ∀y (GraduateStudent(x) ∧ Advises(y,x) ∧ AttendsAllLectures(x) → LearnsALot(x)) ::: If a graduate student is advised and attends lectures, then they learn a lot."
        ],
        "predicates": [
            "GraduateStudent(x) ::: x is a graduate student",
            "AttendsAllLectures(x) ::: x attends all lectures",
            "ActivelyParticipates(x) ::: x actively participates in lectures",
            "FinishesThesisOnTime(x) ::: x finishes thesis on time",
            "SuccessfullyDefendsThesis(x) ::: x successfully defends thesis",
            "Intelligent(x) ::: x is intelligent",
            "WorksHard(x) ::: x works hard",
            "Professor(y) ::: y is a professor",
            "Advises(y, x) ::: y advises x",
            "LikesResearch(x) ::: x likes research",
            "ReadsPapers(x) ::: x reads papers",
            "WritesWell(x) ::: x writes well",
            "PublishesPapers(x) ::: x publishes papers"
        ]
    },
    {
        "premises-NL": [
            "All students who enroll in a course take it.",
            "If a student takes a difficult course, then the course requires effort.",
            "All difficult courses require effort.",
            "If a course requires effort, then any student taking it is hard-working.",
            "If a student is hard-working and takes a course, then they will graduate.",
            "There exists a student who is enrolled in a difficult course.",
            "All students are hard working."
        ],
        "premises-FOL": [
            "∀x ∀y (Student(x) ∧ EnrolledIn(x, y) → TakesCourse(x, y)) ::: If a student is enrolled in a course, they take the course.",
            "∀x ∀y (Student(x) ∧ TakesCourse(x, y) ∧ Difficult(y) → RequiresEffort(y)) ::: If a student takes a difficult course, the course requires effort.",
            "∀y (Difficult(y) → RequiresEffort(y)) ::: If a course is difficult, it requires effort.",
            "∀x ∀y (RequiresEffort(y) ∧ TakesCourse(x, y) → HardWorking(x)) ::: If a course requires effort, any student taking it is hard working.",
            "∀x ∀y (HardWorking(x) ∧ TakesCourse(x, y) → WillGraduate(x)) ::: If a student is hard-working and takes a course, they will graduate.",
            "∃x ∃y (Student(x) ∧ EnrolledIn(x, y) ∧ Difficult(y)) ::: There exists a student enrolled in a difficult course.",
            "∀x (Student(x) → HardWorking(x)) ::: All students are hard working."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in course y",
            "Difficult(y) ::: y is a difficult course",
            "RequiresEffort(y) ::: y requires significant effort",
            "WillGraduate(x) ::: x will graduate",
            "TakesCourse(x, y) ::: x takes course y",
            "HardWorking(x) ::: x is hard working"
        ]
    },
    {
        "premises-NL": [
            "All students study hard.",
            "If someone studies hard, they attend all lectures.",
            "If someone attends all lectures, they pass all exams.",
            "If someone passes all exams, they have a good GPA.",
            "If someone has a good GPA, they will graduate.",
            "If someone takes many courses, they enjoy learning.",
            "If someone enjoys learning, they are smart.",
            "If someone is smart, they study hard.",
            "All students take many courses."
        ],
        "premises-FOL": [
            "∀x (Student(x) → StudiesHard(x)) ::: All students study hard.",
            "∀x (StudiesHard(x) → AttendsAllLectures(x)) ::: If someone studies hard, they attend all lectures.",
            "∀x (AttendsAllLectures(x) → PassesAllExams(x)) ::: If someone attends all lectures, they pass all exams.",
            "∀x (PassesAllExams(x) → HasGoodGPA(x)) ::: If someone passes all exams, they have a good GPA.",
            "∀x (HasGoodGPA(x) → WillGraduate(x)) ::: If someone has a good GPA, they will graduate.",
            "∀x (TakesManyCourses(x) → EnjoysLearning(x)) ::: If someone takes many courses, they enjoy learning.",
            "∀x (EnjoysLearning(x) → IsSmart(x)) ::: If someone enjoys learning, they are smart.",
            "∀x (IsSmart(x) → StudiesHard(x)) ::: If someone is smart, they study hard.",
            "∀x (Student(x) → TakesManyCourses(x)) ::: All students take many courses."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "AttendsAllLectures(x) ::: x attends all lectures",
            "WillGraduate(x) ::: x will graduate",
            "PassesAllExams(x) ::: x passes all exams",
            "HasGoodGPA(x) ::: x has a good GPA",
            "TakesManyCourses(x) ::: x takes many courses",
            "EnjoysLearning(x) ::: x enjoys learning",
            "IsSmart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled in a university.",
            "If a student takes a course, they must attend lectures.",
            "Difficult courses require significant study time.",
            "If a student does not study, they are likely to fail.",
            "Students who attend lectures and study are likely to pass.",
            "Passing a difficult course is challenging.",
            "Some students find it hard to allocate time for studying.",
            "Students who do not manage time effectively often struggle.",
            "University regulations state failing a course twice results in suspension.",
            "Suspended students are not allowed to take courses."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x, University)) ::: All students are enrolled in a university.",
            "∀x ∀y (Student(x) ∧ Takes(x, y) → AttendsLectures(x, y)) ::: If a student takes a course, they must attend lectures.",
            "∀y (DifficultCourse(y) → RequiresStudyTime(y)) ::: Difficult courses require significant study time.",
            "∀x (Student(x) ∧ ¬Studies(x) → LikelyToFail(x)) ::: If a student does not study, they are likely to fail.",
            "∀x ∀y (AttendsLectures(x, y) ∧ Studies(x) → LikelyToPass(x, y)) ::: Students who attend lectures and study are likely to pass.",
            "∀y (DifficultCourse(y) → ChallengingToPass(y)) ::: Passing a difficult course is challenging.",
            "∃x (Student(x) ∧ HardToAllocateTimeForStudying(x)) ::: Some students find it hard to allocate time for studying.",
            "∀x (Student(x) ∧ ¬ManagesTimeEffectively(x) → Struggles(x)) ::: Students who do not manage time effectively often struggle.",
            "∀x ∀y (Fails(x, y) ∧ FailsTwice(x) → Suspended(x)) ::: University regulations state failing a course twice results in suspension.",
            "∀x (Suspended(x) → ¬AllowedToTakeCourses(x)) ::: Suspended students are not allowed to take courses."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Takes(x, y) ::: x takes course y",
            "DifficultCourse(y) ::: y is a difficult course",
            "Studies(x) ::: x studies",
            "Passes(x, y) ::: x passes course y"
        ]
    },
    {
        "premises-NL": [
            "All diligent students prioritize their studies.",
            "Challenging courses demand a strong foundation.",
            "If a student consistently puts in effort, they are more likely to understand the material.",
            "Understanding the material leads to asking insightful questions.",
            "Asking questions facilitates deeper learning.",
            "Deeper learning increases the chances of success.",
            "Seeking help when needed prevents falling behind.",
            "Preventing falling behind maintains a good GPA.",
            "A good GPA is essential for graduation.",
            "Students who balance studies and extracurriculars are more well-rounded.",
            "Well-rounded students are more competitive in the job market.",
            "The university encourages students to participate in research."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ Diligent(x) → PrioritizesStudies(x)) ::: All diligent students prioritize their studies.",
            "∀y (ChallengingCourse(y) → DemandsStrongFoundation(y)) ::: Challenging courses demand a strong foundation.",
            "∀x ∀y (ConsistentEffort(x, y) → MoreLikelyToUnderstandMaterial(x,y)) ::: If a student consistently puts in effort, they are more likely to understand the material.",
            "∀x ∀y (UnderstandsMaterial(x,y) → AsksInsightfulQuestions(x,y)) ::: Understanding the material leads to asking insightful questions.",
            "∀x ∀y (AsksInsightfulQuestions(x,y) → FacilitatesDeeperLearning(x, y)) ::: Asking questions facilitates deeper learning.",
            "∀x ∀y (FacilitatesDeeperLearning(x,y) → IncreasesChancesOfSuccess(x, y)) ::: Deeper learning increases the chances of success.",
            "∀x ∀y (SeeksHelpWhenNeeded(x, y) → PreventsFallingBehind(x)) ::: Seeking help when needed prevents falling behind.",
            "∀x (PreventsFallingBehind(x) → MaintainsGoodGPA(x)) ::: Preventing falling behind maintains a good GPA.",
            "∀x (MaintainsGoodGPA(x) → EssentialForGraduation(x)) ::: A good GPA is essential for graduation.",
            "∀x (Student(x) → BalancesStudiesAndExtracurriculars(x)) ::: Students who balance studies and extracurriculars are more well-rounded.",
            "∀x (BalancesStudiesAndExtracurriculars(x) → MoreCompetitiveInJobMarket(x)) ::: Well-rounded students are more competitive in the job market.",
            "∀x (Student(x) → EncouragesParticipationInResearch(x, University)) ::: The university encourages students to participate in research."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Diligent(x) ::: x is diligent",
            "ChallengingCourse(y) ::: y is a challenging course",
            "ConsistentEffort(x, y) ::: x puts in consistent effort in course y",
            "SeeksHelpWhenNeeded(x, y) ::: x seeks help when needed in course y",
            "Success(x, y) ::: x succeeds in course y",
            "UnderstandsMaterial(x,y) ::: x understands material in course y",
            "AsksQuestions(x,y) ::: x asks questions about course y"
        ]
    },
    {
        "premises-NL": [
            "All students are expected to adhere to the academic calendar.",
            "Failing to submit assignments on time results in grade deductions.",
            "Active participation is crucial for a comprehensive understanding.",
            "Students who attend classes regularly perform better.",
            "Completing assignments demonstrates engagement with the material.",
            "Students who seek clarification when needed grasp concepts better.",
            "Staying engaged contributes to academic success.",
            "Repeatedly failing to meet deadlines may lead to academic probation.",
            "Academic probation impacts future enrollment eligibility.",
            "The university offers support services for struggling students.",
            "Students on probation must attend mandatory counseling sessions.",
            "Improving academic performance can remove students from probation.",
            "Students are encouraged to form study groups."
        ],
        "premises-FOL": [
            "∀x (Student(x) → ExpectedToAdhereToAcademicCalendar(x)) ::: All students are expected to adhere to the academic calendar.",
            "∀x (FailsToSubmitOnTime(x) → ResultsInGradeDeductions(x)) ::: Failing to submit assignments on time results in grade deductions.",
            "∀x (ParticipatesActively(x) → CrucialForComprehensiveUnderstanding(x)) ::: Active participation is crucial for a comprehensive understanding.",
            "∀x (AttendsClassesRegularly(x) → PerformsBetter(x)) ::: Students who attend classes regularly perform better.",
            "∀x (CompletesAssignments(x) → DemonstratesEngagementWithMaterial(x)) ::: Completing assignments demonstrates engagement with the material.",
            "∀x (SeeksClarification(x) → GraspsConceptsBetter(x)) ::: Students who seek clarification when needed grasp concepts better.",
            "∀x (StaysEngaged(x) → ContributesToAcademicSuccess(x)) ::: Staying engaged contributes to academic success.",
            "∀x (RepeatedlyFailingToMeetDeadlines(x) → MayLeadToAcademicProbation(x)) ::: Repeatedly failing to meet deadlines may lead to academic probation.",
            "∀x (FacesAcademicProbation(x) → ImpactsFutureEnrollmentEligibility(x)) ::: Academic probation impacts future enrollment eligibility.",
            "∀x (Student(x) ∧ Struggles(x) → OffersSupportServices(University, x)) ::: The university offers support services for struggling students.",
            "∀x (FacesAcademicProbation(x) → MustAttendMandatoryCounselingSessions(x)) ::: Students on probation must attend mandatory counseling sessions.",
            "∀x (ImprovingAcademicPerformance(x) → CanRemoveFromProbation(x)) ::: Improving academic performance can remove students from probation.",
            "∀x (Student(x) → EncouragedToFormStudyGroups(x)) ::: Students are encouraged to form study groups."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "FailsToSubmitOnTime(x) ::: x fails to submit assignments on time",
            "ParticipatesActively(x) ::: x participates actively",
            "FacesAcademicProbation(x) ::: x faces academic probation",
            "AttendsClassesRegularly(x) ::: x attends classes regularly",
            "CompletesAssignments(x) ::: x completes assignments",
            "SeeksClarification(x) ::: x seeks clarification",
            "StaysEngaged(x) ::: x stays engaged"
        ]
    },
    {
        "premises-NL": [
            "All students must fulfill course requirements to graduate.",
            "Some courses are considered difficult.",
            "If a student fails a course, the policy requires a retake.",
            "If a course is required and the student fails it, the student has to retake it to graduate."
        ],
        "premises-FOL": [
            "∀x (Student(x) → ToGraduate(x)) ::: All students must fulfill course requirements to graduate.",
            "∃y DifficultCourse(y) ::: Some courses are considered difficult.",
            "∀x ∀y (Student(x) ∧ Fails(x, y) → PolicyRequiresRetake(x, y)) ::: If a student fails a course, the policy requires a retake.",
            "∀x ∀y (Student(x) ∧ Fails(x, y) ∧ EnrolledIn(x, y) → MustRetake(x, y) ∧ ToGraduate(x)) ::: If a course is required and the student fails it, the student has to retake it to graduate."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in course y",
            "DifficultCourse(y) ::: y is a difficult course",
            "Fails(x, y) ::: x fails course y",
            "MustRetake(x, y) ::: x must retake course y",
            "ToGraduate(x) ::: x is eligible to graduate",
            "HasPrerequisites(y, z) ::: Course y has course z as a prerequisite",
            "Passed(x, z) ::: x passed course z",
            "PolicyRequiresRetake(x, y) ::: Policy requires x to retake y"
        ]
    },
    {
        "premises-NL": [
            "Students on academic probation must improve their GPA to avoid suspension.",
            "Failing to improve GPA leads to suspension.",
            "A student is on probation if their GPA is below a certain threshold."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ OnAcademicProbation(x) → ImprovesGPA(x) ∨ ¬WillBeSuspended(x)) ::: Students on academic probation must improve their GPA to avoid suspension.",
            "∀x (Student(x) ∧ ¬ImprovesGPA(x) → WillBeSuspended(x)) ::: Failing to improve GPA leads to suspension.",
            "∀x ∀z ∀w (Student(x) ∧ GPA(x, z) ∧ BelowThreshold(z, w) → OnAcademicProbation(x)) ::: A student is on probation if their GPA is below a certain threshold."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "OnAcademicProbation(x) ::: x is on academic probation",
            "ImprovesGPA(x) ::: x improves their GPA",
            "WillBeSuspended(x) ::: x will be suspended",
            "TakesCourse(x, y) ::: x takes course y",
            "CourseCredits(y, z) ::: Course y is worth z credits",
            "GPA(x, z) ::: Student x has a GPA of z",
            "BelowThreshold(z, w) ::: GPA z is below threshold w",
            "RequiresImprovement(x) ::: x requires improvement"
        ]
    },
    {
        "premises-NL": [
            "Graduate students with research assistantships are expected to submit a thesis.",
            "Failure to submit a thesis results in loss of funding.",
            "All students who are graduate students and are advised by a professor need to submit a thesis",
            "Students who fail to submit thesis will lose funding."
        ],
        "premises-FOL": [
            "∀x (GraduateStudent(x) ∧ HasResearchAssistantship(x) → SubmitsThesis(x) ∨ LosesFunding(x)) ::: Graduate students with research assistantships are expected to submit a thesis.",
            "∀x (GraduateStudent(x) ∧ ¬SubmitsThesis(x) → LosesFunding(x)) ::: Failure to submit a thesis results in loss of funding.",
            "∀x ∀y (GraduateStudent(x) ∧ Advises(y, x) ∧ Professor(y) → SubmitsThesis(x)) ::: All students who are graduate students and are advised by a professor need to submit a thesis.",
            "∀x (Student(x) ∧ ¬SubmitsThesis(x) → LosesFunding(x)) ::: Students who fail to submit thesis will lose funding."
        ],
        "predicates": [
            "GraduateStudent(x) ::: x is a graduate student",
            "HasResearchAssistantship(x) ::: x has a research assistantship",
            "SubmitsThesis(x) ::: x submits their thesis",
            "LosesFunding(x) ::: x loses funding",
            "Professor(y) ::: y is a professor",
            "Advises(y, x) ::: professor y advises student x",
            "WorksOnProject(x, z) ::: x works on project z",
            "ProjectFunded(z) ::: Project z is funded",
            "RequiresThesis(x) ::: x requires to submit thesis"
        ]
    },
    {
        "premises-NL": [
            "All students must pay tuition to attend classes.",
            "Registration is required to enroll in courses.",
            "Outstanding fees can prevent students from attending classes.",
            "Students must be in good financial standing with the university.",
            "Non-payment of tuition can result in academic suspension.",
            "Attending classes is essential for academic progress.",
            "Registration ensures that students are officially enrolled.",
            "Financial responsibility is a requirement for all students.",
            "Academic policies are enforced to ensure fairness.",
            "The university has a right to collect fees.",
            "Students must comply with university regulations.",
            "Access to education is a privilege.",
            "Privileges come with responsibilities."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (AbleToAttendClasses(x) ↔ PaysTuition(x))) ::: All students must pay tuition to attend classes.",
            "∀x (RegistersForCourses(x) ↔ EnrolledInCourses(x)) ::: Registration is required to enroll in courses.",
            "∀x (HasOutstandingFees(x) → ¬AbleToAttendClasses(x)) ::: Outstanding fees can prevent students from attending classes.",
            "∀x (Student(x) → GoodFinancialStanding(x)) ::: Students must be in good financial standing with the university.",
            "∀x (¬PaysTuition(x) → ResultsInSuspension(x)) ::: Non-payment of tuition can result in academic suspension.",
            "∀x (AttendingClasses(x) → EssentialForProgress(x)) ::: Attending classes is essential for academic progress.",
            "∀x (RegistersForCourses(x) → OfficiallyEnrolled(x)) ::: Registration ensures that students are officially enrolled.",
            "∀x (Student(x) → FinancialResponsibility(x)) ::: Financial responsibility is a requirement for all students.",
            "∀x (AcademicPolicies(x) → EnforcedToEnsureFairness(x)) ::: Academic policies are enforced to ensure fairness.",
            "∀x (University(x) → RightToCollectFees(x)) ::: The university has a right to collect fees.",
            "∀x (Student(x) → CompliesWithRegulations(x)) ::: Students must comply with university regulations.",
            "∀x (AccessToEducation(x) → Privilege(x)) ::: Access to education is a privilege.",
            "∀x (Privilege(x) → ComesWithResponsibilities(x)) ::: Privileges come with responsibilities."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PaysTuition(x) ::: x pays tuition",
            "RegistersForCourses(x) ::: x registers for courses",
            "HasOutstandingFees(x) ::: x has outstanding fees",
            "AbleToAttendClasses(x) ::: x is able to attend classes"
        ]
    },
    {
        "premises-NL": [
            "∀x (EligibleGrad(x) → MeetsReq(x) ∧ PaidTuition(x) ∧ HasGPA(x)) ::: To be eligible, you must meet requirements, pay tuition, and have a GPA.",
            "∀x (Student(x) → Enrolled(x)) ::: All students are enrolled.",
            "∀x (LateEnroll(x) → ¬PaidTuition(x) ∨ DelayGrad(x)) ::: If you enroll late, you either haven't paid tuition or you delay graduation.",
            "∀x (¬PaidTuition(x) → ¬EligibleGrad(x)) ::: If you haven't paid tuition, you are not eligible to graduate.",
            "∀x (PolicyChange(x) ∧ AffectsGrad(x) → ¬EligibleGrad(x)) ::: If a policy change affects graduation, you are not eligible.",
            "∀x (MeetsReq(x) → HasGPA(x)) ::: If you meet the requirements, you have a valid GPA.",
            "∀x (LateEnroll(x) → Enrolled(x)) ::: If you enroll late, you are enrolled.",
            "∀x (Student(x) → ¬PolicyChange(x)) ::: A student is not a policy change.",
            "∀x (LateEnroll(x) → Student(x)) ::: If you enroll late, you are a student.",
            "∀x (HasGPA(x) → Enrolled(x)) ::: If you have a GPA you are enrolled"
        ],
        "premises-FOL": [
            "∀x (EligibleGrad(x) → MeetsReq(x) ∧ PaidTuition(x) ∧ HasGPA(x)) ::: To be eligible, you must meet requirements, pay tuition, and have a GPA.",
            "∀x (Student(x) → Enrolled(x)) ::: All students are enrolled.",
            "∀x (LateEnroll(x) → ¬PaidTuition(x) ∨ DelayGrad(x)) ::: If you enroll late, you either haven't paid tuition or you delay graduation.",
            "∀x (¬PaidTuition(x) → ¬EligibleGrad(x)) ::: If you haven't paid tuition, you are not eligible to graduate.",
            "∀x (PolicyChange(x) ∧ AffectsGrad(x) → ¬EligibleGrad(x)) ::: If a policy change affects graduation, you are not eligible.",
            "∀x (MeetsReq(x) → HasGPA(x)) ::: If you meet the requirements, you have a valid GPA.",
            "∀x (LateEnroll(x) → Enrolled(x)) ::: If you enroll late, you are enrolled.",
            "∀x (Student(x) → ¬PolicyChange(x)) ::: A student is not a policy change.",
            "∀x (LateEnroll(x) → Student(x)) ::: If you enroll late, you are a student.",
            "∀x (HasGPA(x) → Enrolled(x)) ::: If you have a GPA you are enrolled"
        ],
        "predicates": [
            "LateEnroll(x) ::: x enrolled late",
            "EligibleGrad(x) ::: x is eligible to graduate",
            "DelayGrad(x) ::: x will delay graduation",
            "MeetsReq(x) ::: x meets all requirements",
            "PaidTuition(x) ::: x has paid tuition",
            "HasGPA(x) ::: x has a valid GPA",
            "Enrolled(x) ::: x is enrolled",
            "Student(x) ::: x is a student",
            "PolicyChange(x) ::: Policy x is changed",
            "AffectsGrad(x) ::: Policy x affects graduation"
        ]
    },
    {
        "premises-NL": [
            "All students must meet the GPA requirement to graduate.",
            "All students must complete all required courses to graduate.",
            "No student who does not meet the GPA requirement has good academic standing.",
            "No student who does not complete all required courses has paid tuition.",
            "All students must pay tuition to graduate.",
            "All students must be enrolled in all semesters.",
            "All students must be in good standing to graduate.",
            "All students must pass all exams to be in good standing.",
            "If student does not graduate then they did not meet GPA requirement.",
            "If student does not graduate then they did not enroll in all semesters.",
            "If student does not graduate then they did not passed all exams.",
            "To graduate a student needs to meet GPA requirements.",
            "To graduate a student needs to completes all required courses.",
            "If a student does not meet GPA requirement then they will not meet GPA requirement."
        ],
        "premises-FOL": [
            "∀x ((Student(x) ∧ Graduates(x)) → MeetsGPARequirement(x)) ::: All students must meet the GPA requirement to graduate.",
            "∀x ((Student(x) ∧ Graduates(x)) → CompletesAllRequiredCourses(x)) ::: All students must complete all required courses to graduate.",
            "∀x (¬MeetsGPARequirement(x) → ¬HasGoodStanding(x)) ::: No student who does not meet the GPA requirement has good academic standing.",
            "∀x (¬CompletesAllRequiredCourses(x) → ¬PaidTuition(x)) ::: No student who does not complete all required courses has paid tuition.",
            "∀x ((Student(x) ∧ Graduates(x)) → PaidTuition(x)) ::: All students must pay tuition to graduate.",
            "∀x Graduates(x) → EnrolledInAllSemesters(x) ::: All students must be enrolled in all semesters.",
            "∀x Graduates(x) → HasGoodStanding(x) ::: All students must be in good standing to graduate.",
            "∀x HasGoodStanding(x) → PassedAllExams(x) ::: All students must pass all exams to be in good standing.",
            "∀x ¬Graduates(x) → ¬MeetsGPARequirement(x) ::: If student does not graduate then they did not meet GPA requirement.",
            "∀x ¬Graduates(x) → ¬EnrolledInAllSemesters(x) ::: If student does not graduate then they did not enroll in all semesters.",
            "∀x ¬Graduates(x) → ¬PassedAllExams(x) ::: If student does not graduate then they did not passed all exams.",
            "∀x ((Student(x) ∧ Graduates(x)) → MeetsGPARequirement(x)) ::: To graduate a student needs to meet GPA requirements.",
            "∀x ((Student(x) ∧ Graduates(x)) → CompletesAllRequiredCourses(x)) ::: To graduate a student needs to completes all required courses.",
            "∀x ¬MeetsGPARequirement(x) → ¬MeetsGPARequirement(x) ::: If a student does not meet GPA requirement then they will not meet GPA requirement."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "MeetsGPARequirement(x) ::: x meets the GPA requirement",
            "CompletesAllRequiredCourses(x) ::: x completes all required courses",
            "Graduates(x) ::: x graduates",
            "HasGoodStanding(x) ::: x has good academic standing",
            "PaidTuition(x) ::: x has paid tuition",
            "EnrolledInAllSemesters(x) ::: x enrolled in all semesters",
            "PassedAllExams(x) ::: x has passed all exams"
        ]
    },
    {
        "premises-NL": [
            "All students are smart.",
            "If a student is smart and likes mathematics, then they are happy.",
            "All students took Calculus I.",
            "Calculus I requires basic algebra.",
            "If someone took Calculus I and passed basic algebra, then they passed Calculus I.",
            "There exists a student.",
            "All students like mathematics."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Smart(x)) ::: All students are smart.",
            "∀x ((Student(x) ∧ Smart(x) ∧ Likes(x, Mathematics)) → Happy(x)) ::: If a student is smart and likes mathematics, then they are happy.",
            "∀x (Student(x) → Took(x, CalculusI)) ::: All students took Calculus I.",
            "Requires(CalculusI, Algebra) ::: Calculus I requires basic algebra.",
            "∀x ((Took(x, CalculusI) ∧ Passed(x, Algebra)) → Passed(x, CalculusI)) ::: If someone took Calculus I and passed basic algebra, then they passed Calculus I.",
            "∃x Student(x) ::: There exists a student.",
            "∀x (Student(x) → Likes(x, Mathematics)) ::: All students like mathematics."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Took(x, y) ::: x took course y",
            "Requires(x, y) ::: course x requires course y",
            "Happy(x) ::: x is happy",
            "Passed(x, y) ::: x passed course y",
            "Smart(x) ::: x is smart",
            "Likes(x, y) ::: x likes y"
        ]
    },
    {
        "premises-NL": [
            "∀x (Student(x) → Enrolled(x, University)) ::: All students are enrolled in the University.",
            "∀x (Takes(x, Math101) → ¬Passed(x, Math101) ∨ Failed(x, Math101)) ::: If someone takes Math101, they either didn't pass or failed.",
            "∀x (Requires(CourseA, x) → Prerequisite(x, CourseA)) ::: If CourseA requires a course, then that course is a prerequisite for CourseA.",
            "∀x (Failed(x, Math101) → ¬Passed(x, Math101)) ::: If someone failed Math101, they did not pass it.",
            "∃x (Student(x) ∧ Takes(x, Math101)) ::: There exists a student taking Math101.",
            "∀x (Enrolled(x, University) → Student(x)) ::: If someone is enrolled in the University, they are a student.",
            "¬∀x (Passed(x, Math101)) ::: Not everyone passed Math101.",
            "∃x (Takes(x, Math101) ∧ Failed(x, Math101)) ::: Someone takes Math101 and fails it."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x, University)) ::: All students are enrolled in the University.",
            "∀x (Takes(x, Math101) → ¬Passed(x, Math101) ∨ Failed(x, Math101)) ::: If someone takes Math101, they either didn't pass or failed.",
            "∀x (Requires(CourseA, x) → Prerequisite(x, CourseA)) ::: If CourseA requires a course, then that course is a prerequisite for CourseA.",
            "∀x (Failed(x, Math101) → ¬Passed(x, Math101)) ::: If someone failed Math101, they did not pass it.",
            "∃x (Student(x) ∧ Takes(x, Math101)) ::: There exists a student taking Math101.",
            "∀x (Enrolled(x, University) → Student(x)) ::: If someone is enrolled in the University, they are a student.",
            "¬∀x (Passed(x, Math101)) ::: Not everyone passed Math101.",
            "∃x (Takes(x, Math101) ∧ Failed(x, Math101)) ::: Someone takes Math101 and fails it."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Takes(x, y) ::: x takes course y",
            "Requires(x, y) ::: Course x requires course y",
            "Passed(x, y) ::: x passed course y",
            "Failed(x, y) ::: x failed course y",
            "Enrolled(x, y) ::: x is enrolled in y",
            "Prerequisite(x, y) ::: x is a prerequisite for y",
            "Math101 ::: Math 101 is a specific course"
        ]
    },
    {
        "premises-NL": [
            "Every student takes an exam.",
            "If a student studies and prepares, they will pass the exam.",
            "If a student is intelligent and takes an exam, they will prepare for the exam.",
            "If a student does not pass the exam, they will not graduate unless they are lucky.",
            "Every student is a student.",
            "No one is lucky and not lucky at the same time.",
            "Studying helps you to prepare",
            "If you prepare for the exam, you will study."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakesExam(x)) ::: Every student takes an exam.",
            "∀x (Student(x) ∧ Studies(x) ∧ Prepares(x) → PassesExam(x)) ::: If a student studies and prepares, they will pass the exam.",
            "∀x (Student(x) ∧ Intelligent(x) ∧ TakesExam(x) → Prepares(x)) ::: If a student is intelligent and takes an exam, they will prepare for the exam.",
            "∀x (Student(x) ∧ ¬PassesExam(x) → (¬Graduates(x) ∨ Lucky(x))) ::: If a student does not pass the exam, they will not graduate unless they are lucky.",
            "∀x (Student(x) → Student(x)) ::: Every student is a student.",
            "∀x ¬(Lucky(x) ∧ ¬Lucky(x)) ::: No one is lucky and not lucky at the same time.",
            "∀x (Prepares(x) → Studies(x)) ::: Studying helps you to prepare",
            "∀x (Prepares(x) → Studies(x)) ::: If you prepare for the exam, you will study."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "PassesExam(x) ::: x passes the exam",
            "Graduates(x) ::: x graduates",
            "Lucky(x) ::: x is lucky",
            "TakesExam(x) ::: x takes an exam",
            "Intelligent(x) ::: x is intelligent",
            "Prepares(x) ::: x prepares for exam"
        ]
    },
    {
        "premises-NL": [
            "Every student is a person.",
            "If a person is enrolled in a course and takes all assessments of that course, and passes all assessments of that course, then that person passes all assessments.",
            "John is a student.",
            "John is enrolled in Calculus 101.",
            "John takes all assessments in Calculus 101.",
            "John passes all assessments in Calculus 101."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Person(x)) ::: Every student is a person.",
            "∀x ∀y ((Person(x) ∧ EnrolledIn(x, y) ∧ TakesAll(x, y)) → PassesAll(x, y)) ::: If a person is enrolled in a course and takes all assessments of that course, and passes all assessments, then that person passes all assessments.",
            "Student(john) ::: John is a student.",
            "EnrolledIn(john, calculus101) ::: John is enrolled in Calculus 101.",
            "TakesAll(john, calculus101) ::: John takes all assessments in Calculus 101.",
            "PassesAll(john, calculus101) ::: John passes all assessments in Calculus 101."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in course y",
            "PassesAll(x, y) ::: x passes all assessments in course y",
            "ReceivesCredit(x, y) ::: x receives credit for course y",
            "TakesAssessment(x, y, z) ::: x takes assessment z in course y",
            "IsAssessment(y, z) ::: z is an assessment of course y"
        ]
    },
    {
        "premises-NL": [
            "All students are people.",
            "If a person is enrolled in a graduate program and their advisor is on sabbatical, their graduation is delayed.",
            "Sarah is a student.",
            "Sarah is enrolled in the Computer Science graduate program.",
            "The Computer Science graduate program is a graduate program.",
            "Professor Smith is Sarah's advisor.",
            "Professor Smith is a professor.",
            "Professor Smith is on sabbatical.",
            "Professor Smith is associated with the Computer Science department."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Person(x)) ::: All students are people.",
            "∀x ((Person(x) ∧ EnrolledIn(x, gradProgram) ∧ Advisor(x, y) ∧ OnSabbatical(y)) → DelayedGraduation(x)) ::: If a person is enrolled in a graduate program and their advisor is on sabbatical, their graduation is delayed.",
            "Student(sarah) ::: Sarah is a student.",
            "EnrolledIn(sarah, csGradProgram) ::: Sarah is enrolled in the Computer Science graduate program.",
            "GraduateProgram(csGradProgram) ::: The Computer Science graduate program is a graduate program.",
            "Advisor(sarah, profSmith) ::: Professor Smith is Sarah's advisor.",
            "Professor(profSmith) ::: Professor Smith is a professor.",
            "OnSabbatical(profSmith) ::: Professor Smith is on sabbatical.",
            "AssociatedWith(profSmith, csDepartment) ::: Professor Smith is associated with the Computer Science department."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in program y",
            "Advisor(x, y) ::: y is the advisor of x",
            "OnSabbatical(x) ::: x is on sabbatical",
            "DelayedGraduation(x) ::: x's graduation is delayed",
            "GraduateProgram(x) ::: x is a graduate program",
            "Professor(x) ::: x is a professor",
            "Department(x) ::: x is a department",
            "AssociatedWith(x, y) ::: x is associated with department y"
        ]
    },
    {
        "premises-NL": [
            "Everyone is a person.",
            "If someone knows someone, then the first person likes the second person.",
            "If someone likes someone, then the first person respects the second person.",
            "If someone respects someone, then the first person trusts the second person.",
            "There exists a person.",
            "If someone likes themselves, then they are happy.",
            "If someone knows someone who knows someone else, then the first person is wise.",
            "Someone likes someone."
        ],
        "premises-FOL": [
            "∀x Person(x) ::: Everyone is a person.",
            "∀x ∀y (Knows(x, y) → Likes(x, y)) ::: If someone knows someone, then the first person likes the second person.",
            "∀x ∀y (Likes(x, y) → Respects(x, y)) ::: If someone likes someone, then the first person respects the second person.",
            "∀x ∀y (Respects(x, y) → Trusts(x, y)) ::: If someone respects someone, then the first person trusts the second person.",
            "∃x Person(x) ::: There exists a person.",
            "∀x (Likes(x, x) → Happy(x)) ::: If someone likes themselves, then they are happy.",
            "∀x ∀y ∀z ((Knows(x, y) ∧ Knows(y, z)) → Wise(x)) ::: If someone knows someone who knows someone else, then the first person is wise.",
            "∃x ∃y Likes(x, y) ::: Someone likes someone.",
            "∀x Person(x) → (Happy(x) ∨ ¬Happy(x)) ::: All people are either happy or not happy."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Knows(x, y) ::: x knows y",
            "Likes(x, y) ::: x likes y",
            "Respects(x, y) ::: x respects y",
            "Trusts(x, y) ::: x trusts y"
        ]
    },
    {
        "premises-NL": [
            "All students must be enrolled to attend classes.",
            "If a student pays tuition, then they are eligible to enroll.",
            "If a student is eligible to enroll and has the required credits, then they are enrolled.",
            "If a student attends orientation and meets prerequisites, they have the required credits.",
            "If a student takes a course and the course is available, they meet prerequisites.",
            "Charlie is a student.",
            "Charlie pays tuition.",
            "Charlie attends orientation.",
            "Charlie takes a course.",
            "The course is available."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ CanAttendClasses(x) → Enrolled(x)) ::: All students must be enrolled to attend classes.",
            "∀x (Student(x) ∧ PaysTuition(x) → IsEligible(x)) ::: If a student pays tuition, then they are eligible to enroll.",
            "∀x (Student(x) ∧ IsEligible(x) ∧ HasRequiredCredits(x) → Enrolled(x)) ::: If a student is eligible to enroll and has the required credits, then they are enrolled.",
            "∀x (Student(x) ∧ AttendsOrientation(x) ∧ MeetsPrerequisites(x) → HasRequiredCredits(x)) ::: If a student attends orientation and meets prerequisites, they have the required credits.",
            "∀x (Student(x) ∧ TakesCourse(x,y) ∧ CourseAvailable(y) → MeetsPrerequisites(x)) ::: If a student takes a course and the course is available, they meet prerequisites.",
            "Student(charlie) ::: Charlie is a student.",
            "PaysTuition(charlie) ::: Charlie pays tuition.",
            "AttendsOrientation(charlie) ::: Charlie attends orientation.",
            "TakesCourse(charlie, courseA) ::: Charlie takes a course.",
            "CourseAvailable(courseA) ::: The course is available."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x) ::: x is enrolled",
            "PaysTuition(x) ::: x pays tuition",
            "CanAttendClasses(x) ::: x can attend classes",
            "HasRequiredCredits(x) ::: x has required credits",
            "AttendsOrientation(x) ::: x attends orientation",
            "IsEligible(x) ::: x is eligible",
            "MeetsPrerequisites(x) ::: x meets prerequisites",
            "TakesCourse(x, y) ::: x takes course y",
            "CourseAvailable(y) ::: course y is available"
        ]
    },
    {
        "premises-NL": [
            "All students who will graduate complete all requirements.",
            "If a student passes all courses and takes required courses, then they complete all requirements.",
            "If a student is enrolled for the minimum semesters, then they take the required courses.",
            "If a student maintains a high GPA, then they meet academic standards.",
            "If a student meets academic standards and completes all requirements and pays the graduation fee, then they are eligible for graduation.",
            "If a student is eligible for graduation, then they will graduate.",
            "If a student has a scholarship, then he pays the graduation fee.",
            "David is a student.",
            "David is enrolled for the minimum semesters.",
            "David passes all courses.",
            "David has a scholarship."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ WillGraduate(x) → CompletesAllRequirements(x)) ::: All students who will graduate complete all requirements.",
            "∀x (Student(x) ∧ PassesAllCourses(x) ∧ TakesRequiredCourses(x) → CompletesAllRequirements(x)) ::: If a student passes all courses and takes required courses, then they complete all requirements.",
            "∀x (Student(x) ∧ EnrolledForMinimumSemesters(x) → TakesRequiredCourses(x)) ::: If a student is enrolled for the minimum semesters, then they take the required courses.",
            "∀x (Student(x) ∧ MaintainsHighGPA(x) → MeetsAcademicStandards(x)) ::: If a student maintains a high GPA, then they meet academic standards.",
            "∀x (Student(x) ∧ MeetsAcademicStandards(x) ∧ CompletesAllRequirements(x) ∧ PaysGraduationFee(x) → EligibleForGraduation(x)) ::: If a student meets academic standards and completes all requirements and pays the graduation fee, then they are eligible for graduation.",
            "∀x (Student(x) ∧ EligibleForGraduation(x) → WillGraduate(x)) ::: If a student is eligible for graduation, then they will graduate.",
            "∀x (Student(x) ∧ HasScholarship(x) → PaysGraduationFee(x)) ::: If a student has a scholarship, then he pays the graduation fee.",
            "Student(david) ::: David is a student.",
            "EnrolledForMinimumSemesters(david) ::: David is enrolled for the minimum semesters.",
            "PassesAllCourses(david) ::: David passes all courses.",
            "HasScholarship(david) ::: David has a scholarship."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "HasScholarship(x) ::: x has a scholarship",
            "MaintainsHighGPA(x) ::: x maintains a high GPA",
            "WillGraduate(x) ::: x will graduate",
            "CompletesAllRequirements(x) ::: x completes all requirements",
            "PassesAllCourses(x) ::: x passes all courses",
            "TakesRequiredCourses(x) ::: x takes required courses",
            "EnrolledForMinimumSemesters(x) ::: x is enrolled for the minimum semesters",
            "MeetsAcademicStandards(x) ::: x meets academic standards",
            "EligibleForGraduation(x) ::: x is eligible for graduation",
            "PaysGraduationFee(x) ::: x pays graduation fee"
        ]
    },
    {
        "premises-NL": [
            "All students may need advising.",
            "Advising is only available on Tuesdays.",
            "If a student needs advising, they must schedule it.",
            "Students cannot attend advising if they have a class at that time.",
            "To attend advising with a conflicting class, the student must either reschedule the class or drop it.",
            "The only way to attend advising with a conflicting class time is to reschedule or drop.",
            "The student has a class on Tuesdays.",
            "The student needs advising."
        ],
        "premises-FOL": [
            "∀x (Student(x) → NeedsAdvising(x) ∨ ¬NeedsAdvising(x)) ::: All students may need advising",
            "∀x (AdvisingOn(x, Tuesday)) ::: Advising is only on Tuesdays",
            "∀x (NeedsAdvising(x) → Schedules(x, y)) ::: If a student needs advising they schedule it.",
            "∀x ∀y (HasClassAt(x, y) → ¬AttendsAdvising(x)) ::: Students cannot attend advising if they have class",
            "∀x (AttendsAdvising(x) ∧ HasClassAt(x, y) → (ReschedulesClass(x) ∨ DropsClass(x))) ::: Student must reschedule or drop class to attend advising",
            "∀x (AttendsAdvising(x) ∧ HasClassAt(x, y) → (ReschedulesClass(x) ∨ DropsClass(x))) ::: Must reschedule or drop to attend.",
            "∃x ∃y HasClassAt(x, Tuesday) ::: The student has a class on Tuesdays",
            "∃x NeedsAdvising(x) ::: The student needs advising."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "NeedsAdvising(x) ::: x needs advising",
            "AdvisingOn(x, y) ::: Advising is on x at y",
            "HasClassAt(x, y) ::: x has class at y",
            "ReschedulesClass(x) ::: x reschedules their class",
            "DropsClass(x) ::: x drops their class",
            "Tuesday(x) ::: x is on Tuesday"
        ]
    },
    {
        "premises-NL": [
            "All students are learners.",
            "If a learner takes a course and fails it, then they failed the course.",
            "If a course is a prerequisite for another course, then it is required before.",
            "Calculus is a prerequisite for advanced calculus.",
            "If a student fails a prerequisite course, then they cannot enroll in the advanced course.",
            "Mary is a student.",
            "Mary takes calculus and fails."
        ],
        "premises-FOL": [
            "∀x Student(x) → Learner(x) ::: All students are learners.",
            "∀x ∀y Learner(x) ∧ Takes(x, y) ∧ Fails(x, y) → Fails(x, y) ::: If a learner takes a course and fails it, then they failed the course.",
            "∀x ∀y Prerequisite(x, y) → RequiredBefore(x, y) ::: If a course is a prerequisite for another course, then it is required before.",
            "Prerequisite(calculus, advancedCalculus) ::: Calculus is a prerequisite for advanced calculus.",
            "∀x ∀y ∀z Student(x) ∧ Fails(x, y) ∧ Prerequisite(y, z) → ¬Enrolls(x, z) ::: If a student fails a prerequisite course, then they cannot enroll in the advanced course.",
            "Student(mary) ::: Mary is a student.",
            "Takes(mary, calculus) ∧ Fails(mary, calculus) ::: Mary takes calculus and fails."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Fails(x, y) ::: x fails y",
            "Course(y) ::: y is a course",
            "Prerequisite(x, y) ::: x is a prerequisite of y",
            "Enrolls(x, y) ::: x enrolls in y",
            "Takes(x, y) ::: x takes y"
        ]
    },
    {
        "premises-NL": [
            "All students are learners.",
            "If a learner is hard-working, then they achieve good grades.",
            "If someone takes a course and achieves a grade, then they either pass or fail.",
            "If a student takes many courses and achieves high grades, then they meet the GPA requirement.",
            "If a student does not meet the GPA requirement, they cannot graduate.",
            "John is a student.",
            "John is a hard-working student.",
            "John takes many courses and achieves high grades."
        ],
        "premises-FOL": [
            "∀x Student(x) → Learner(x) ::: All students are learners.",
            "∀x Learner(x) ∧ HardWorking(x) → Achieves(x, GoodGrades) ::: If a learner is hard-working, then they achieve good grades.",
            "∀x ∀y Takes(x, y) ∧ Achieves(x, grade) → Passes(x, grade) ∨ Fails(x, grade) ::: If someone takes a course and achieves a grade, then they either pass or fail.",
            "∀x Student(x) ∧ TakesManyCourses(x) ∧ AchievesHighGrades(x) → MeetsGPARequirement(x) ::: If a student takes many courses and achieves high grades, then they meet the GPA requirement.",
            "∀x Student(x) ∧ ¬MeetsGPARequirement(x) → ¬CanGraduate(x) ::: If a student does not meet the GPA requirement, they cannot graduate.",
            "Student(john) ::: John is a student.",
            "HardWorking(john) ::: John is a hard-working student.",
            "TakesManyCourses(john) ∧ AchievesHighGrades(john) ::: John takes many courses and achieves high grades."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "MeetsGPARequirement(x) ::: x meets the GPA requirement",
            "CanGraduate(x) ::: x can graduate",
            "Takes(x, y) ::: x takes y",
            "Course(y) ::: y is a course",
            "HardWorking(x) ::: x is a hard-working student",
            "Achieves(x, y) ::: x achieves grade y",
            "Grade(y) ::: y is a valid grade"
        ]
    },
    {
        "premises-NL": [
            "All students are either undergraduates or graduates.",
            "Students who receive financial aid must maintain a minimum GPA.",
            "Students must be in good standing to receive financial aid.",
            "To enroll in maximum credits, a student must either be an undergraduate or a graduate and must have advisor approval.",
            "All students must meet the prerequisites for the courses they take.",
            "Courses must have available space for students to enroll.",
            "Students in good standing have completed all required courses.",
            "A student is eligible to enroll if they have met prerequisites, have available space in courses, and are in good standing.",
            "Approval is granted to students if they are eligible and if they receive financial aid.",
            "All students who receive financial aid and maintain a minimum GPA are undergraduates or graduate students.",
            "A student can enroll in max credits if and only if they receive approval.",
            "For a student to be eligible to enroll, they have to be in good standing and have completed the required courses.",
            "All undergraduates are students.",
            "All graduates are students."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Undergraduate(x) ∨ Graduate(x))) ::: All students are either undergraduates or graduates.",
            "∀x (ReceivesFinancialAid(x) → MaintainsMinimumGPA(x)) ::: Students who receive financial aid must maintain a minimum GPA.",
            "∀x (ReceivesFinancialAid(x) → GoodStanding(x)) ::: Students must be in good standing to receive financial aid.",
            "∀x (CanEnrollInMaximumCredits(x) → ((Undergraduate(x) ∨ Graduate(x)) ∧ HasAdvisorApproval(x))) ::: To enroll in maximum credits, a student must either be an undergraduate or a graduate and must have advisor approval.",
            "∀x ∀y (TakesCourse(x, y) → MeetsPrerequisites(x, y)) ::: All students must meet the prerequisites for the courses they take.",
            "∀y (Course(y) → AvailableSpace(y)) ::: Courses must have available space for students to enroll.",
            "∀x (GoodStanding(x) → HasCompletedRequiredCourses(x)) ::: Students in good standing have completed all required courses.",
            "∀x (IsEligible(x) ↔ (MeetsPrerequisites(x, y) ∧ AvailableSpace(y) ∧ GoodStanding(x))) ::: A student is eligible to enroll if they have met prerequisites, have available space in courses, and are in good standing.",
            "∀x (ApprovalGranted(x) ↔ (IsEligible(x) ∧ ReceivesFinancialAid(x))) ::: Approval is granted to students if they are eligible and if they receive financial aid.",
            "∀x ((ReceivesFinancialAid(x) ∧ MaintainsMinimumGPA(x)) → (Undergraduate(x) ∨ Graduate(x))) ::: All students who receive financial aid and maintain a minimum GPA are undergraduates or graduate students.",
            "∀x (CanEnrollInMaximumCredits(x) ↔ ApprovalGranted(x)) ::: A student can enroll in max credits if and only if they receive approval.",
            "∀x (IsEligible(x) → GoodStanding(x) ∧ HasCompletedRequiredCourses(x)) ::: For a student to be eligible to enroll, they have to be in good standing and have completed the required courses.",
            "∀x (Undergraduate(x) → Student(x)) ::: All undergraduates are students.",
            "∀x (Graduate(x) → Student(x)) ::: All graduates are students."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "ReceivesFinancialAid(x) ::: x receives financial aid",
            "MaintainsMinimumGPA(x) ::: x maintains a minimum GPA",
            "CanEnrollInMaximumCredits(x) ::: x can enroll in maximum credits",
            "ApprovalGranted(x) ::: x has approval granted",
            "Undergraduate(x) ::: x is an undergraduate",
            "Graduate(x) ::: x is a graduate",
            "TakesCourse(x, y) ::: x takes course y",
            "Course(y) ::: y is a course",
            "HasAdvisorApproval(x) ::: x has advisor approval",
            "MeetsPrerequisites(x, y) ::: x meets prerequisites for y",
            "AvailableSpace(y) ::: y has available space",
            "GoodStanding(x) ::: x is in good standing",
            "HasCompletedRequiredCourses(x) ::: x has completed required courses",
            "IsEligible(x) ::: x is eligible"
        ]
    },
    {
        "premises-NL": [
            "If a graduate student's advisor approves their progress, then they will graduate on time.",
            "If a graduate student graduates on time then they meet the requirements.",
            "If a graduate student meets the requirements then they will graduate on time or get a high GPA.",
            "If a graduate student works hard and their advisor approves their progress then the funding is sufficient."
        ],
        "premises-FOL": [
            "∀x (GraduateStudent(x) ∧ AdvisorApproves(x) → GraduatesOnTime(x)) ::: If a graduate student's advisor approves their progress, then they will graduate on time.",
            "∀x (GraduateStudent(x) ∧ GraduatesOnTime(x) → MeetsRequirements(x)) ::: If a graduate student graduates on time then they meet the requirements.",
            "∀x (GraduateStudent(x) ∧ MeetsRequirements(x) → (GraduatesOnTime(x) ∨ HighGPA(x))) ::: If a graduate student meets the requirements then they will graduate on time or get a high GPA.",
            "∀x (GraduateStudent(x) ∧ WorksHard(x) ∧ AdvisorApproves(x) → SufficientFunding(x)) ::: If a graduate student works hard and their advisor approves their progress then the funding is sufficient."
        ],
        "predicates": [
            "GraduateStudent(x) ::: x is a graduate student",
            "WorksHard(x) ::: x works hard",
            "SufficientFunding(x) ::: x has sufficient funding",
            "GraduatesOnTime(x) ::: x graduates on time",
            "HighGPA(x) ::: x has a high GPA",
            "AdvisorApproves(x) ::: x's advisor approves their progress",
            "MeetsRequirements(x) ::: x meets the requirements"
        ]
    },
    {
        "premises-NL": [
            "If a student pays tuition on time, then they are in good standing.",
            "If a student has no holds, then they are in good standing.",
            "If a student is enrolled in a program, they are a student.",
            "If a student is in good standing and satisfies the prerequisites for a course, then they can register for that course.",
            "All students are students.",
            "Smart students are smart.",
            "If a student takes a course, they are a student.",
            "If a student is smart and takes a course then they will satisfy the prerequisites.",
            "Students must be smart or not smart.",
            "A course is a course."
        ],
        "premises-FOL": [
            "∀x (PaysTuitionOnTime(x) → GoodStanding(x)) ::: If a student pays tuition on time, then they are in good standing.",
            "∀x (¬HasHolds(x) → GoodStanding(x)) ::: If a student has no holds, then they are in good standing.",
            "∀x ∀p (EnrolledInProgram(x, p) → Student(x)) ::: If a student is enrolled in a program, they are a student.",
            "∀x (GoodStanding(x) → CanRegister(x)) ::: If a student is in good standing, then they can register.",
            "∀x (Student(x) → Student(x)) ::: All students are students.",
            "∀x (Smart(x) → Smart(x)) ::: Smart students are smart.",
            "∀x ∀c (Takes(x, c) → Student(x)) ::: If a student takes a course, they are a student.",
            "∀x ∀c (Smart(x) ∧ Takes(x, c) → SatisfiesPrerequisites(x,c)) ::: If a student is smart and takes a course then they will satisfy the prerequisites.",
            "∀x (Student(x) → (Smart(x) ∨ ¬Smart(x))) ::: Students must be smart or not smart.",
            "∀c (Course(c) → Course(c)) ::: A course is a course."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledInProgram(x, p) ::: x is enrolled in program p",
            "PaysTuitionOnTime(x) ::: x pays tuition on time",
            "HasHolds(x) ::: x has holds on their account",
            "CanRegister(x) ::: x can register for courses",
            "GoodStanding(x) ::: x is in good standing",
            "SatisfiesPrerequisites(x, c) ::: x satisfies the prerequisites for course c",
            "Course(c) ::: c is a course",
            "Takes(x, c) ::: x takes c",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All students are either hardworking or smart.",
            "If a student is enrolled, they are a student.",
            "If a student takes a required course, they are enrolled.",
            "If a professor teaches a course, the course is a course.",
            "All students who take a course attend the lectures.",
            "If a student is enrolled and does not pay tuition, they are at risk.",
            "If a student is at risk and does not resolve it, they are dropped.",
            "All students are enrolled.",
            "There exists a required course.",
            "All students are students.",
            "If someone is at risk they are not paying tuition."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Hardworking(x) ∨ Smart(x))) ::: All students are either hardworking or smart.",
            "∀x (Enrolled(x) → Student(x)) ::: If a student is enrolled, they are a student.",
            "∀x ∀y (Student(x) ∧ TakesCourse(x, y) ∧ RequiredCourse(y) → Enrolled(x)) ::: If a student takes a required course, they are enrolled.",
            "∀z ∀y (Professor(z) ∧ Teaches(z, y) → Course(y)) ::: If a professor teaches a course, the course is a course.",
            "∀x ∀y (Student(x) ∧ TakesCourse(x, y) → AttendsLecture(x, y)) ::: All students who take a course attend the lectures.",
            "∀x (Student(x) ∧ Enrolled(x) ∧ ¬PaysTuition(x) → AtRisk(x)) ::: If a student is enrolled and does not pay tuition, they are at risk.",
            "∀x (AtRisk(x) ∧ ¬ResolvesIssue(x) → Dropped(x)) ::: If a student is at risk and does not resolve it, they are dropped.",
            "∀x (Student(x) → Enrolled(x)) ::: All students are enrolled.",
            "∃y (RequiredCourse(y)) ::: There exists a required course.",
            "∀x (Student(x) → Student(x)) ::: All students are students.",
            "∀x (AtRisk(x) → ¬PaysTuition(x)) ::: If someone is at risk they are not paying tuition."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x) ::: x is enrolled",
            "PaysTuition(x) ::: x pays tuition",
            "Dropped(x) ::: x is dropped",
            "TakesCourse(x, y) ::: x takes course y",
            "RequiredCourse(y) ::: y is a required course",
            "AttendsLecture(x, z) ::: x attends lecture z",
            "Professor(z) ::: z is a professor",
            "Teaches(z, y) ::: z teaches course y",
            "Hardworking(x) ::: x is hardworking",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All students must pay tuition.",
            "If a student does not pay tuition, they cannot graduate.",
            "All courses have tuition fees.",
            "If a student is enrolled, they must have paid tuition.",
            "If a student is dropped from a course, they lose credit hours.",
            "CS101 is a course.",
            "Professor Smith teaches CS101.",
            "If a student takes CS101, they are enrolled in it.",
            "A student is either graduate or undergraduate.",
            "Every student must pass the prequisites for any course they take, eventually.",
            "If a student is considered for honors they must have all course requisites.",
            "Students that take less than 9 credits are part time.",
            "Courses must be required or elective.",
            "Undergraduates are students."
        ],
        "premises-FOL": [
            "∀x (Student(x) → PaidTuition(x)) ::: All students must pay tuition.",
            "∀x ((Student(x) ∧ ¬PaidTuition(x)) → ¬CanGraduate(x)) ::: If a student does not pay tuition, they cannot graduate.",
            "∀x (Course(x) → HasTuitionFees(x)) ::: All courses have tuition fees.",
            "∀x ∀y (Enrolled(x, y) → PaidTuition(x)) ::: If a student is enrolled, they must have paid tuition.",
            "∀x ∀y (Dropped(x, y) → LoseCreditHours(x)) ::: If a student is dropped from a course, they lose credit hours.",
            "Course(CS101) ::: CS101 is a course.",
            "Teaches(Smith, CS101) ::: Professor Smith teaches CS101.",
            "∀x (Takes(x, CS101) → Enrolled(x, CS101)) ::: If a student takes CS101, they are enrolled in it.",
            "∀x (Student(x) → Graduate(x) ∨ Undergraduate(x)) ::: A student is either graduate or undergraduate.",
            "∀x ∀y ((Student(x) ∧ Takes(x, y)) → EventuallyPassed(x, z)) ::: Every student must pass the prequisites for any course they take, eventually.",
            "∀x (ConsideredForHonors(x) → EventuallyPassed(x, y)) ::: If a student is considered for honors they must have all course requisites.",
            "∀x (Takes(x, y) ∧ LessThan(y, 9) → PartTime(x)) ::: Students that take less than 9 credits are part time.",
            "∀x (Course(x) → RequiredCourse(x) ∨ ElectiveCourse(x)) ::: Courses must be required or elective.",
            "∀x (Undergraduate(x) → Student(x)) ::: Undergraduates are students."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "PaidTuition(x) ::: x has paid tuition",
            "Dropped(x, y) ::: x is dropped from course y",
            "Takes(x, y) ::: x takes course y",
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches course y",
            "Course(x) ::: x is a course",
            "GreaterThan(x, y) ::: x is greater than y",
            "LessThan(x, y) ::: x is less than y",
            "RequiredCourse(x) ::: x is a required course",
            "EventuallyPassed(x, y) ::: x passed the course y eventually",
            "ElectiveCourse(x) ::: x is an elective course",
            "Undergraduate(x) ::: x is an undergraduate"
        ]
    },
    {
        "premises-NL": [
            "Mary is a student.",
            "Mary is enrolled in Physics 101.",
            "Mary is enrolled in Chemistry 101.",
            "Physics 101 has a final exam.",
            "Chemistry 101 has a final exam.",
            "If a student is enrolled in a course with a final exam, they have to take the final exam.",
            "All courses require textbooks.",
            "Professors teach courses."
        ],
        "premises-FOL": [
            "Student(mary) ::: Mary is a student.",
            "Enrolled(mary, Physics101) ::: Mary is enrolled in Physics 101.",
            "Enrolled(mary, Chemistry101) ::: Mary is enrolled in Chemistry 101.",
            "HasFinalExam(Physics101) ::: Physics 101 has a final exam.",
            "HasFinalExam(Chemistry101) ::: Chemistry 101 has a final exam.",
            "∀x ∀y (Student(x) ∧ Enrolled(x, y) ∧ HasFinalExam(y) → TakesFinalExam(x, y)) ::: If a student is enrolled in a course with a final exam, they have to take the final exam.",
            "∀x (Course(x) → RequiresTextbook(x)) ::: All courses require textbooks.",
            "∀x (Professor(x) → TeachesCourse(x)) ::: Professors teach courses."
        ],
        "predicates": [
            "Enrolled(x, y) ::: x is enrolled in course y",
            "HasFinalExam(x) ::: course x has a final exam",
            "TakesFinalExam(x, y) ::: x takes final exam for course y",
            "Student(x) ::: x is a student",
            "Professor(x) ::: x is a professor"
        ]
    },
    {
        "premises-NL": [
            "Professor Smith teaches CS201.",
            "CS201 requires Data Structures.",
            "Data Structures requires Discrete Math.",
            "John is a student.",
            "John has not taken Discrete Math.",
            "If a course requires another, the other is a prerequisite.",
            "If a student has not taken all prerequisites of a course, they cannot enroll.",
            "All courses have assignments.",
            "Assignments must be graded.",
            "Grading follows a rubric."
        ],
        "premises-FOL": [
            "Teaches(smith, CS201) ::: Professor Smith teaches CS201.",
            "Requires(CS201, DataStructures) ::: CS201 requires Data Structures.",
            "Requires(DataStructures, DiscreteMath) ::: Data Structures requires Discrete Math.",
            "Student(john) ::: John is a student.",
            "¬Taken(john, DiscreteMath) ::: John has not taken Discrete Math.",
            "∀x ∀y (Requires(x, y) → Prerequisite(x, y)) ::: If a course requires another, the other is a prerequisite.",
            "∀x ∀y (Student(x) ∧ Requires(y, z) ∧ ¬Taken(x, z) → ¬CanEnroll(x, y)) ::: If a student has not taken the prerequisites of a course, they cannot enroll.",
            "∀x (Course(x) → HasAssignment(x)) ::: All courses have assignments.",
            "∀x (Assignment(x) → MustBeGraded(x)) ::: Assignments must be graded.",
            "∀x (Grading(x) → FollowsRubric(x)) ::: Grading follows a rubric."
        ],
        "predicates": [
            "Teaches(x, y) ::: x teaches course y",
            "Requires(x, y) ::: course x requires course y",
            "Taken(x, y) ::: x has taken course y",
            "CanEnroll(x, y) ::: x can enroll in course y",
            "Student(x) ::: x is a student",
            "Prerequisite(x, y) ::: y is a prerequisite for x"
        ]
    },
    {
        "premises-NL": [
            "All students are responsible for following attendance policies.",
            "Skipping too many classes is a violation of attendance policies.",
            "If someone violates a policy, they will probably receive a penalty.",
            "Failing a final exam is a penalty.",
            "Absence being reported is also a penalty.",
            "Students who skip too many classes violate policies.",
            "If someone is responsible for following a policy then that policy applies to them.",
            "If a policy applies to someone, and they violate it, they face penalties.",
            "If someone is responsible for something and they receive a penalty, their absence will be reported or they will probably fail the final."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Responsible(x, AttendancePolicies)) ::: All students are responsible for following attendance policies.",
            "∀x (SkipsTooManyClasses(x) → PolicyViolation(x)) ::: Skipping too many classes is a violation of attendance policies.",
            "∀x (PolicyViolation(x) → ProbablyReceivePenalty(x)) ::: If someone violates a policy, they will probably receive a penalty.",
            "∀x (FailsFinal(x) → Penalty(x)) ::: Failing a final exam is a penalty.",
            "∀x (AbsenceReported(x) → Penalty(x)) ::: Absence being reported is also a penalty.",
            "∀x (Student(x) ∧ SkipsTooManyClasses(x) → PolicyViolation(x)) ::: Students who skip too many classes violate policies.",
            "∀x (Responsible(x, AttendancePolicies) → Applies(AttendancePolicies, x)) ::: If someone is responsible for following a policy then that policy applies to them.",
            "∀x ∀y (Applies(y, x) ∧ PolicyViolation(x) → ProbablyReceivePenalty(x)) ::: If a policy applies to someone, and they violate it, they face penalties.",
            "∀x (Responsible(x, AttendancePolicies) ∧ ProbablyReceivePenalty(x) → (AbsenceReported(x) ∨ ProbablyFailsFinal(x))) ::: If someone is responsible for something and they receive a penalty, their absence will be reported or they will probably fail the final."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "SkipsTooManyClasses(x) ::: x skips too many classes",
            "ProbablyFailsFinal(x) ::: x probably fails the final",
            "AbsenceReported(x) ::: x's absence is reported",
            "Responsible(x, y) ::: x is responsible for y",
            "PolicyViolation(x) ::: x is a policy violation"
        ]
    },
    {
        "premises-NL": [
            "To pass a course, a student must complete all required assignments or have an extension.",
            "If an assignment is not completed, it is considered incomplete.",
            "If a student has an extension, they are not penalized for incomplete assignments.",
            "Students who complete all required assignments pass all their assignments.",
            "If a student passes all assignments then they pass the course.",
            "If a student doesn't pass a course then they do not pass the course.",
            "Not completing assignments is the same as not passing all assignments.",
            "Assignments are considered something required to pass.",
            "If a student passes all assignments, they complete all required assignments",
            "Students must pass all assignments or have an extension to pass."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (CompletesAllAssignments(x) ∨ HasExtension(x) ∨ PassesCourse(x))) ::: To pass a course, a student must complete all required assignments or have an extension.",
            "∀x ∀y (RequiredAssignment(x, y) ∧ ¬Completes(x, y) → Incomplete(x, y)) ::: If an assignment is not completed, it is considered incomplete.",
            "∀x (HasExtension(x) → ¬PenalizedForIncomplete(x)) ::: If a student has an extension, they are not penalized for incomplete assignments.",
            "∀x (CompletesAllAssignments(x) → PassesAll(x,Assignments)) ::: Students who complete all required assignments pass all their assignments.",
            "∀x (PassesAll(x,Assignments) → PassesCourse(x)) ::: If a student passes all assignments then they pass the course.",
            "∀x (¬PassesCourse(x) → ¬PassesCourse(x)) ::: If a student doesn't pass a course then they do not pass the course.",
            "∀x ¬CompletesAllAssignments(x) ↔ ¬PassesAll(x, Assignments) ::: Not completing assignments is the same as not passing all assignments.",
            "∀y (Assignment(y) → RequiredAssignment(y, Course)) ::: Assignments are considered something required to pass.",
            "∀x (PassesAll(x, Assignments) → CompletesAllAssignments(x)) ::: If a student passes all assignments, they complete all required assignments.",
            "∀x ((PassesAll(x, Assignments) ∨ HasExtension(x)) → PassesCourse(x)) ::: Students must pass all assignments or have an extension to pass."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "CompletesAllAssignments(x) ::: x completes all assignments",
            "HasExtension(x) ::: x has an extension",
            "PassesCourse(x) ::: x passes the course",
            "RequiredAssignment(x, y) ::: x is a required assignment for y",
            "Completes(x, y) ::: x completes y",
            "PassesAll(x,y) ::: x passes all y"
        ]
    },
    {
        "premises-NL": [
            "All students are people.",
            "If a student takes Calculus and passes Calculus, then they have taken Calculus.",
            "Calculus is a required course for graduation.",
            "If someone satisfies all requirements then they are eligible to graduate.",
            "If someone has taken Calculus and satisfied all requirements, they are eligible to graduate.",
            "There exists a student who has passed Calculus.",
            "If a course requires another course as a prerequisite and you have passed the prerequisite course, then you have the required course.",
            "If a student passes Calculus, then they satisfy all requirements.",
            "If a student is a student then they are a person.",
            "If a student is eligible to graduate, then they are a person."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Person(x)) ::: If x is a student, then x is a person.",
            "∀x ∀y ((Student(x) ∧ Takes(x, Calculus) ∧ Passed(x, Calculus)) → Takes(x, Calculus)) ::: If student x takes Calculus and passes Calculus, then they have taken Calculus.",
            "Requires(Graduation, Calculus) ::: Calculus is required for graduation.",
            "∀x (SatisfiesAllRequirements(x) → EligibleToGraduate(x)) ::: If x satisfies all graduation requirements, then x is eligible to graduate.",
            "∀x ((Takes(x, Calculus) ∧ SatisfiesAllRequirements(x)) → EligibleToGraduate(x)) ::: If someone has taken Calculus and satisfied all requirements, they are eligible to graduate.",
            "∃x (Student(x) ∧ Passed(x, Calculus)) ::: There exists a student x who has passed Calculus.",
            "∀x ∀y ∀z ((Requires(x, y) ∧ Passed(z, y)) → HasRequiredCourse(z, x)) ::: If course x requires course y and z passed y, then z has the required course x.",
            "∀x ((Student(x) ∧ Passed(x, Calculus)) → SatisfiesAllRequirements(x)) ::: If student x passes Calculus, then x satisfies all requirements.",
            "∀x (Student(x) → Person(x)) ::: If x is a student, then x is a person.",
            "∀x (EligibleToGraduate(x) → Person(x)) ::: If x is eligible to graduate, then x is a person."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Takes(x, y) ::: x takes course y",
            "Requires(x, y) ::: Course x requires course y as a pre-requisite",
            "Passed(x, y) ::: x has passed course y",
            "EligibleToGraduate(x) ::: x is eligible to graduate",
            "SatisfiesAllRequirements(x) ::: x satisfies all graduation requirements"
        ]
    },
    {
        "premises-NL": [
            "All students are people.",
            "If a student takes Calculus and passes Calculus, then they have taken Calculus.",
            "Calculus is a required course for graduation.",
            "If someone satisfies all requirements then they are eligible to graduate.",
            "If someone has taken Calculus and Physics and satisfied all requirements, they are eligible to graduate.",
            "There exists a student who has passed Calculus and Physics.",
            "If a course requires another course as a prerequisite and you have passed the prerequisite course, then you have the required course.",
            "If a student passes Calculus and Physics, then they satisfy all requirements.",
            "If a student is a student then they are a person.",
            "If a student is eligible to graduate, then they are a person.",
            "Physics is a required course for graduation."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Person(x)) ::: If x is a student, then x is a person.",
            "∀x ∀y ((Student(x) ∧ Takes(x, Calculus) ∧ Passed(x, Calculus)) → Takes(x, Calculus)) ::: If student x takes Calculus and passes Calculus, then they have taken Calculus.",
            "Requires(Graduation, Calculus) ::: Calculus is required for graduation.",
            "∀x (SatisfiesAllRequirements(x) → EligibleToGraduate(x)) ::: If x satisfies all graduation requirements, then x is eligible to graduate.",
            "∀x ((Takes(x, Calculus) ∧ Takes(x, Physics) ∧ SatisfiesAllRequirements(x)) → EligibleToGraduate(x)) ::: If someone has taken Calculus, Physics and satisfied all requirements, they are eligible to graduate.",
            "∃x (Student(x) ∧ Passed(x, Calculus) ∧ Passed(x, Physics)) ::: There exists a student x who has passed Calculus and Physics.",
            "∀x ∀y ∀z ((Requires(x, y) ∧ Passed(z, y)) → HasRequiredCourse(z, x)) ::: If course x requires course y and z passed y, then z has the required course x.",
            "∀x ((Student(x) ∧ Passed(x, Calculus) ∧ Passed(x, Physics)) → SatisfiesAllRequirements(x)) ::: If student x passes Calculus and Physics, then x satisfies all requirements.",
            "∀x (Student(x) → Person(x)) ::: If x is a student, then x is a person.",
            "∀x (EligibleToGraduate(x) → Person(x)) ::: If x is eligible to graduate, then x is a person.",
            "Requires(Graduation, Physics) ::: Physics is required for graduation."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Takes(x, y) ::: x takes course y",
            "Requires(x, y) ::: Course x requires course y as a pre-requisite",
            "Passed(x, y) ::: x has passed course y",
            "EligibleToGraduate(x) ::: x is eligible to graduate",
            "SatisfiesAllRequirements(x) ::: x satisfies all graduation requirements"
        ]
    },
    {
        "premises-NL": [
            "All students are people.",
            "If a student fails a course, it is recorded.",
            "If a student passes a course, it is recorded.",
            "If a student retakes a course, they are still considered a student.",
            "Calculus is a course.",
            "If a student passes a course, they are no longer considered to have failed it.",
            "If a student takes and fails a course, then they have failed the course.",
            "If a student retakes a failed course and passes, they have satisfied the course requirement.",
            "If someone satisfies all the course requirements then they are on track to graduate.",
            "Calculus is a required course for graduation.",
            "If a student is a student then they are a person.",
            "If a student is eligible to graduate, then they are a person."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Person(x)) ::: If x is a student, then x is a person.",
            "∀x ∀y ((Student(x) ∧ Failed(x, y)) → RecordedFailure(x, y)) ::: If student x fails course y, it is recorded.",
            "∀x ∀y ((Student(x) ∧ Passes(x, y)) → RecordedPass(x, y)) ::: If student x passes course y, it is recorded.",
            "∀x ∀y ((Student(x) ∧ Retakes(x, y)) → Student(x)) ::: If student x retakes course y, they are still a student.",
            "Course(Calculus) ::: Calculus is a course.",
            "∀x ∀y ((Student(x) ∧ Passes(x, y)) → ¬Failed(x, y)) ::: If student x passes course y, they are no longer considered to have failed it.",
            "∀x ∀y ((Student(x) ∧ Takes(x, y) ∧ Failed(x, y)) → Failed(x, y)) ::: If student x takes course y and fails, then they have failed the course.",
            "∀x ∀y ((Student(x) ∧ Retakes(x, y) ∧ Failed(x, y) ∧ Passes(x, y)) → SatisfiesRequirement(x, y)) ::: If a student x retakes a failed course y and passes, they have satisfied the course requirement.",
            "∀x (SatisfiesAllRequirements(x) → OnTrackToGraduate(x)) ::: If someone satisfies all the course requirements then they are on track to graduate.",
            "Requires(Graduation, Calculus) ::: Calculus is a required course for graduation.",
            "∀x (Student(x) → Person(x)) ::: If x is a student, then x is a person.",
            "∀x (EligibleToGraduate(x) → Person(x)) ::: If x is eligible to graduate, then x is a person."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Retakes(x, y) ::: x retakes course y",
            "Failed(x, y) ::: x failed course y",
            "Passes(x, y) ::: x passes course y",
            "SatisfiesRequirement(x, y) ::: x satisfies the requirement for course y",
            "Course(y) ::: y is a course",
            "Requires(x, y) ::: Course x requires course y"
        ]
    },
    {
        "premises-NL": [
            "John is a student.",
            "Calculus is a class.",
            "If a student is late for a class, they will be marked absent.",
            "If a student is marked absent and attendance affects the grade of the class, they will fail the course.",
            "Attendance affects the grade of Calculus.",
            "John is late for Calculus.",
            "If a student is late, policy applies"
        ],
        "premises-FOL": [
            "Student(john) ::: John is a student.",
            "Class(calculus) ::: Calculus is a class.",
            "∀x ∀y ((Student(x) ∧ Class(y) ∧ LateFor(x, y)) → MarkedAbsent(x, y)) ::: If a student is late for a class, they will be marked absent.",
            "∀x ∀y ((Student(x) ∧ MarkedAbsent(x, y) ∧ AttendanceAffectsGrade(y)) → FailsCourse(x, y)) ::: If a student is marked absent and attendance affects the grade of the class, they will fail the course.",
            "AttendanceAffectsGrade(calculus) ::: Attendance affects the grade of Calculus.",
            "LateFor(john, calculus) ::: John is late for Calculus.",
            "∀x ∀y ((Student(x) ∧ Class(y) ∧ LateFor(x, y)) → PolicyApplies(absentPolicy, y)) ::: If a student is late for a class policy applies."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Class(y) ::: y is a class",
            "LateFor(x, y) ::: x is late for class y",
            "MarkedAbsent(x, y) ::: x is marked absent for class y",
            "AttendanceAffectsGrade(y) ::: Attendance affects the grade in class y",
            "FailsCourse(x, y) ::: x fails course y",
            "PolicyApplies(x,y) ::: policy x applies to class y"
        ]
    },
    {
        "premises-NL": [
            "All students must take Algorithms.",
            "If a student takes Algorithms and fails it, they must retake it.",
            "If a student must retake Algorithms, they cannot graduate until they pass it.",
            "If a student cannot graduate until they pass Algorithms, then if they must retake Algorithms, they will not graduate.",
            "John is a student and fails Algorithms."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Takes(x, Algorithms)) ::: All students must take Algorithms.",
            "∀x ∀y (Student(x) ∧ Takes(x, y) ∧ Fails(x, y) → MustRetake(x, y)) ::: If a student takes a course and fails it, they must retake it.",
            "∀x (MustRetake(x, Algorithms) → ¬Graduates(x)) ::: If a student must retake Algorithms, they will not graduate.",
            "∀x (¬Graduates(x) ↔ MustRetake(x, Algorithms)) ::: If a student cannot graduate, they must retake Algorithms",
            "Student(John) ∧ Fails(John, Algorithms) ::: John is a student and fails Algorithms."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Takes(x, y) ::: x takes course y",
            "Fails(x, y) ::: x fails course y",
            "MustRetake(x, y) ::: x must retake course y",
            "Graduates(x) ::: x graduates"
        ]
    },
    {
        "premises-NL": [
            "All students are either full-time or part-time.",
            "Full-time students are generally enrolled in 6 courses.",
            "If a student is enrolled in more than 6 courses, they must pay an overload fee.",
            "Students who pay an overload fee are not eligible for a tuition waiver.",
            "If a student is full-time and must pay an overload fee, they must pay an overload fee.",
            "Mary is a student and is enrolled in 7 courses."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (FullTime(x) ∨ ¬FullTime(x))) ::: All students are either full-time or part-time.",
            "∀x (FullTime(x) → EnrolledIn(x, 6)) ::: Full-time students are generally enrolled in 6 courses.",
            "∀x ∀y (Student(x) ∧ EnrolledIn(x, y) ∧ GreaterThan(y, 6) → PayOverloadFee(x)) ::: If a student is enrolled in more than 6 courses, they must pay an overload fee.",
            "∀x (PayOverloadFee(x) → ¬EligibleForWaiver(x)) ::: Students who pay an overload fee are not eligible for a tuition waiver.",
            "∀x (FullTime(x) ∧ PayOverloadFee(x) → PayOverloadFee(x)) ::: If a student is full-time and must pay an overload fee, they must pay an overload fee.",
            "Student(Mary) ∧ EnrolledIn(Mary, 7) ::: Mary is a student and is enrolled in 7 courses."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in y courses",
            "GreaterThan(x, y) ::: x is greater than y",
            "PayOverloadFee(x) ::: x must pay an overload fee",
            "EligibleForWaiver(x) ::: x is eligible for a tuition waiver",
            "FullTime(x) ::: x is a full-time student"
        ]
    },
    {
        "premises-NL": [
            "All students must apply for graduation to be considered for graduation.",
            "To graduate, a student must meet all graduation requirements and pay all tuition.",
            "Having an outstanding tuition balance means a student has not paid all tuition.",
            "If a student has an outstanding tuition balance, they may arrange a payment plan.",
            "If a student does not pay all tuition, they cannot graduate.",
            "Students who cannot graduate will not receive their transcript.",
            "If a student has an outstanding tuition balance and does not arrange a payment plan, they have not paid all tuition.",
            "Jane is a student, has an outstanding balance, and does not arrange a payment plan."
        ],
        "premises-FOL": [
            "∀x (Student(x) → AppliesForGraduation(x) ∨ ¬AppliesForGraduation(x)) ::: All students must apply for graduation to be considered for graduation.",
            "∀x (Student(x) ∧ AppliesForGraduation(x) ∧ MeetsRequirements(x) ∧ PaysTuition(x) → Graduates(x)) ::: To graduate, a student must meet all graduation requirements and pay all tuition.",
            "∀x (HasOutstandingBalance(x) → ¬PaysTuition(x)) ::: Having an outstanding tuition balance means a student has not paid all tuition.",
            "∀x (HasOutstandingBalance(x) → ArrangesPaymentPlan(x) ∨ ¬ArrangesPaymentPlan(x)) ::: If a student has an outstanding tuition balance, they may arrange a payment plan.",
            "∀x (¬PaysTuition(x) → ¬Graduates(x)) ::: If a student does not pay all tuition, they cannot graduate.",
            "∀x (¬Graduates(x) → ¬ReceivesTranscript(x)) ::: Students who cannot graduate will not receive their transcript.",
            "∀x (HasOutstandingBalance(x) ∧ ¬ArrangesPaymentPlan(x) → ¬PaysTuition(x)) ::: If a student has an outstanding tuition balance and does not arrange a payment plan, they have not paid all tuition.",
            "Student(Jane) ∧ HasOutstandingBalance(Jane) ∧ ¬ArrangesPaymentPlan(Jane) ::: Jane is a student, has an outstanding balance, and does not arrange a payment plan."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "HasOutstandingBalance(x) ::: x has an outstanding tuition balance",
            "ArrangesPaymentPlan(x) ::: x arranges a payment plan",
            "Graduates(x) ::: x graduates",
            "ReceivesTranscript(x) ::: x receives their transcript",
            "AppliesForGraduation(x) ::: x applies for graduation",
            "MeetsRequirements(x) ::: x meets all graduation requirements",
            "PaysTuition(x) ::: x pays all tuition"
        ]
    },
    {
        "premises-NL": [
            "All students are human.",
            "There exists a difficult course.",
            "If a student is enrolled in a difficult course, it requires a lot of effort.",
            "If a course requires a lot of effort and the student is not putting effort, that student will struggle.",
            "There exists a student enrolled in a difficult course who is not putting in enough effort."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Human(x)) ::: All students are human.",
            "∃y DifficultCourse(y) ::: There exists a difficult course y.",
            "∀x ∀y (Student(x) ∧ Enrolled(x, y) ∧ DifficultCourse(y) → RequiresEffort(y, 'high')) ::: If student x is enrolled in difficult course y, then course y requires high effort.",
            "∀x ∀y (Enrolled(x, y) ∧ RequiresEffort(y, 'high') ∧ ¬PuttingEffort(x, 'high') → WillStruggle(x)) ::: If x is enrolled in y, y requires high effort, and x is not putting in high effort, then x will struggle.",
            "∃x ∃y (Student(x) ∧ Enrolled(x, y) ∧ DifficultCourse(y) ∧ ¬PuttingEffort(x, 'high')) ::: There exists a student x enrolled in a difficult course y who is not putting in high effort."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "DifficultCourse(y) ::: Course y is considered difficult",
            "RequiresEffort(y, z) ::: Course y requires effort z",
            "WillStruggle(x) ::: x will struggle academically"
        ]
    },
    {
        "premises-NL": [
            "There is a student named Charlie.",
            "Math101 is a course.",
            "Physics101 is a course.",
            "If someone is enrolled in a course, then they take that course.",
            "Professor Davis teaches Math101.",
            "Professor Davis is a professor.",
            "Charlie is enrolled in Math101.",
            "Charlie is enrolled in Physics101."
        ],
        "premises-FOL": [
            "∃x (Student(x) ∧ Name(x, charlie)) ::: There is a student named Charlie.",
            "Course(Math101) ::: Math101 is a course.",
            "Course(Physics101) ::: Physics101 is a course.",
            "∀x ∀y (Enrolled(x, y) → Takes(x, y)) ::: If someone is enrolled in a course, then they take that course.",
            "Teaches(davis, Math101) ::: Professor Davis teaches Math101.",
            "Professor(davis) ::: Professor Davis is a professor.",
            "Enrolled(charlie, Math101) ::: Charlie is enrolled in Math101.",
            "Enrolled(charlie, Physics101) ::: Charlie is enrolled in Physics101."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Name(x, y) ::: x has name y",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "Takes(x, y) ::: x takes course y",
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches course y",
            "Course(x) ::: x is a course",
            "Prerequisite(x, y) ::: x is a prerequisite for y"
        ]
    },
    {
        "premises-NL": [
            "David is a student.",
            "Math201 is a course.",
            "Professor Evans teaches Math201.",
            "Professor Evans is a professor.",
            "If someone is enrolled in Math201, then they are taking Math201.",
            "Math201 is required for graduation.",
            "David is enrolled in Math201.",
            "If someone fails a course required for graduation, then they failed a required course.",
            "David has not failed any course required for graduation."
        ],
        "premises-FOL": [
            "Student(david) ::: David is a student.",
            "Course(Math201) ::: Math201 is a course.",
            "Teaches(evans, Math201) ::: Professor Evans teaches Math201.",
            "Professor(evans) ::: Professor Evans is a professor.",
            "∀x (Enrolled(x, Math201) → Takes(x, Math201)) ::: If someone is enrolled in Math201, then they are taking Math201.",
            "RequiredForGraduation(Math201) ::: Math201 is required for graduation.",
            "Enrolled(david, Math201) ::: David is enrolled in Math201.",
            "∀x ∀y (FailedCourse(x, y) ∧ RequiredForGraduation(y) → FailedRequiredCourse(x)) ::: If someone fails a course required for graduation, then they failed a required course.",
            "¬FailedRequiredCourse(david) ::: David has not failed any course required for graduation."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "Course(x) ::: x is a course",
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches course y",
            "RequiredForGraduation(x) ::: x is required for graduation",
            "FailedCourse(x, y) ::: x failed course y",
            "Graduates(x) ::: x graduates",
            "FailedRequiredCourse(x) ::: x failed a required course"
        ]
    },
    {
        "premises-NL": [
            "All students are individuals.",
            "If a student is enrolled in a course, then the student is taking the course.",
            "If a course is difficult, then it requires extra effort.",
            "If a course requires a textbook, the textbook is necessary for the course.",
            "If a student fails a course, and it is required to retake or get new material, the student has to retake or buy new material."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Individual(x)) ::: All students are individuals.",
            "∀x ∀y (Student(x) ∧ EnrolledIn(x, y) → TakingCourse(x, y)) ::: If a student is enrolled in a course, then the student is taking the course.",
            "∀y (DifficultCourse(y) → RequiresExtraEffort(y)) ::: If a course is difficult, then it requires extra effort.",
            "∀y (RequiresTextbook(y) → NecessaryForCourse(y)) ::: If a course requires a textbook, the textbook is necessary for the course.",
            "∀x ∀y (Fails(x, y) ∧ (Retake(x, y) ∨ BuyNewTextbook(x, y)) → (Retake(x, y) ∨ BuyNewTextbook(x, y))) ::: If a student fails a course, and it is required to retake or get new material, the student has to retake or buy new material."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in course y",
            "DifficultCourse(y) ::: y is a difficult course",
            "RequiresTextbook(y) ::: y requires a textbook",
            "Fails(x, y) ::: x fails course y",
            "Retake(x, y) ::: x has to retake course y",
            "BuyNewTextbook(x, y) ::: x has to buy a new textbook for course y"
        ]
    },
    {
        "premises-NL": [
            "All students must pass exams to graduate.",
            "If a student is enrolled in a course, then the student is taking the course.",
            "All graduate courses require a thesis.",
            "If a student does not submit a thesis for a course, they will not pass the requirements for the course.",
            "If a student doesn't pass the requirements, they won't graduate.",
            "If a student does not pass the requirements, they have to withdraw from course."
        ],
        "premises-FOL": [
            "∀x (Student(x) → PassesExam(x, y)) ::: All students must pass exams to graduate.",
            "∀x ∀y (Student(x) ∧ EnrolledIn(x, y) → TakingCourse(x, y)) ::: If a student is enrolled in a course, then the student is taking the course.",
            "∀y (GraduateCourse(y) → RequiresThesis(y)) ::: All graduate courses require a thesis.",
            "∀x ∀y (¬SubmitsThesis(x, y) → ¬PassesRequirements(x, y)) ::: If a student does not submit a thesis for a course, they will not pass the requirements for the course.",
            "∀x ∀y (¬PassesRequirements(x, y) → ¬Graduates(x)) ::: If a student doesn't pass the requirements, they won't graduate.",
            "∀x ∀y (¬PassesRequirements(x, y) → Withdraws(x, y)) ::: If a student does not pass the requirements, they have to withdraw from course."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in course y",
            "GraduateCourse(y) ::: y is a graduate course",
            "RequiresThesis(y) ::: y requires a thesis",
            "SubmitsThesis(x, y) ::: x submits a thesis for course y",
            "Graduates(x) ::: x graduates",
            "Withdraws(x, y) ::: x withdraws from course y",
            "PassesExam(x, y) ::: x passes the exam for course y"
        ]
    },
    {
        "premises-NL": [
            "All enrolled students must either pay tuition or be on a scholarship.",
            "Students on academic probation cannot receive scholarships.",
            "Sarah is enrolled.",
            "Sarah pays tuition.",
            "If someone pays tuition, then they pay tuition",
            "If someone is enrolled, then they are enrolled",
            "If someone is on academic probation, then they are on academic probation",
            "If someone has scholarship, then they have scholarship",
            "If someone majors in CS, then they major in CS"
        ],
        "premises-FOL": [
            "∀x (Enrolled(x) → (PaysTuition(x) ∨ Scholarship(x))) ::: All enrolled students must either pay tuition or be on a scholarship.",
            "∀x (AcademicProbation(x) → ¬Scholarship(x)) ::: Students on academic probation cannot receive scholarships.",
            "Enrolled(sarah) ::: Sarah is enrolled.",
            "PaysTuition(sarah) ::: Sarah pays tuition.",
            "∀x (PaysTuition(x) → PaysTuition(x)) ::: If someone pays tuition, then they pay tuition",
            "∀x (Enrolled(x) → Enrolled(x)) ::: If someone is enrolled, then they are enrolled",
            "∀x (AcademicProbation(x) → AcademicProbation(x)) ::: If someone is on academic probation, then they are on academic probation",
            "∀x (Scholarship(x) → Scholarship(x)) ::: If someone has scholarship, then they have scholarship",
            "∀x (MajorIn(x, CS) → MajorIn(x, CS)) ::: If someone majors in CS, then they major in CS"
        ],
        "predicates": [
            "Enrolled(x) ::: x is enrolled",
            "PaysTuition(x) ::: x pays tuition",
            "AcademicProbation(x) ::: x is on academic probation",
            "MajorIn(x, y) ::: x majors in y",
            "Prereq(x, y) ::: x is a prerequisite for y"
        ]
    },
    {
        "premises-NL": [
            "Only students can fail courses.",
            "If a student fails a course, they can retake it.",
            "If a course allows grade replacement, retaking it gives credits to the student if the student retakes the course.",
            "A student must be enrolled to have credits.",
            "All enrolled students pay tuition.",
            "If someone fails a course, then they failed the course.",
            "If someone retakes a course, then they retake the course.",
            "If a course has grade replacement, then it has grade replacement",
            "If someone has credits, then they have credits.",
            "If someone is a student, then they are a student",
            "If someone pays tuition, they pay tuition"
        ],
        "premises-FOL": [
            "∀x ∀y (Fails(x, y) → Student(x)) ::: Only students can fail courses.",
            "∀x ∀y (Fails(x, y) → Retakes(x, y)) ::: If a student fails a course, they can retake it.",
            "∀x ∀y (GradeReplacement(y) ∧ Retakes(x, y) → HasCredits(x)) ::: If a course allows grade replacement, retaking it gives credits to the student if the student retakes the course.",
            "∀x (HasCredits(x) → Enrolled(x)) ::: A student must be enrolled to have credits.",
            "∀x (Enrolled(x) → PaysTuition(x)) ::: All enrolled students pay tuition.",
            "∀x ∀y (Fails(x, y) → Fails(x, y)) ::: If someone fails a course, then they failed the course.",
            "∀x ∀y (Retakes(x, y) → Retakes(x, y)) ::: If someone retakes a course, then they retake the course.",
            "∀x (GradeReplacement(x) → GradeReplacement(x)) ::: If a course has grade replacement, then it has grade replacement",
            "∀x (HasCredits(x) → HasCredits(x)) ::: If someone has credits, then they have credits.",
            "∀x (Student(x) → Student(x)) ::: If someone is a student, then they are a student",
            "∀x (PaysTuition(x) → PaysTuition(x)) ::: If someone pays tuition, they pay tuition"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Fails(x, y) ::: x fails course y",
            "Retakes(x, y) ::: x retakes course y",
            "GradeReplacement(y) ::: Course y allows grade replacement",
            "HasCredits(x) ::: x has credits",
            "Enrolled(x) ::: x is enrolled",
            "PaysTuition(x) ::: x pays tuition"
        ]
    },
    {
        "premises-NL": [
            "All students are either enrolled or not enrolled.",
            "If a student is enrolled and has not paid tuition, and the tuition is above the threshold, then they will be dropped from all courses.",
            "John is a student.",
            "If someone is a student then they are enrolled or not enrolled.",
            "John takes an expensive course.",
            "If someone takes an expensive course then tuition is above the threshold",
            "John has not paid tuition."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Enrolled(x) ∨ ¬Enrolled(x))) ::: All students are either enrolled or not enrolled.",
            "∀x ((Enrolled(x) ∧ ¬PaidTuition(x)) → DroppedFromAll(x)) ::: If a student is enrolled and has not paid tuition, then they will be dropped from all courses.",
            "Student(John) ::: John is a student.",
            "∀x (Student(x) → (Enrolled(x) ∨ ¬Enrolled(x))) ::: If someone is a student then they are enrolled or not enrolled.",
            "∃y (Takes(John, y) ∧ ExpensiveCourse(y)) ::: John takes an expensive course.",
            "∀x ∀y ((Takes(x, y) ∧ ExpensiveCourse(y)) → ¬PaidTuition(x)) ::: If someone takes an expensive course then they have not paid tuition",
            "¬PaidTuition(John) ::: John has not paid tuition."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x) ::: x is enrolled",
            "PaidTuition(x) ::: x has paid tuition",
            "DroppedFromAll(x) ::: x is dropped from all courses",
            "Takes(x, y) ::: x takes course y",
            "ExpensiveCourse(y) ::: y is an expensive course",
            "∀x ∀y ((Takes(x, y) ∧ ExpensiveCourse(y)) → TuitionAboveThreshold(x)) ::: If a student takes an expensive course, then their tuition is above the threshold."
        ]
    },
    {
        "premises-NL": [
            "All students must take required courses to graduate.",
            "If a student takes a course, they either pass or have a failing grade in that course.",
            "If a student has high tuition, they must pay it.",
            "If a student does not pay tuition, then they will not graduate",
            "If a student has a failing grade in a required course, then they must retake it.",
            "All students are students.",
            "There exists required courses.",
            "All high tuition students do not pay tuition"
        ],
        "premises-FOL": [
            "∀x ∀y ((Student(x) ∧ RequiredCourse(y)) → Takes(x, y)) ::: All students must take required courses to graduate.",
            "∀x ∀y (Takes(x, y) → (¬HasFailingGrade(x, y) ∨ HasFailingGrade(x, y))) ::: If a student takes a course, they either pass or have a failing grade in that course.",
            "∀x (HighTuition(x) → ¬PayTuition(x)) ::: If a student has high tuition, they must pay it.",
            "∀x (¬PayTuition(x) → ¬Graduate(x)) ::: If a student does not pay tuition, then they will not graduate",
            "∀x ∀y ((HasFailingGrade(x, y) ∧ RequiredCourse(y)) → MustRetake(x, y)) ::: If a student has a failing grade in a required course, then they must retake it.",
            "∀x (Student(x) → Student(x)) ::: All students are students.",
            "∃y RequiredCourse(y) ::: There exists required courses.",
            "∀x (HighTuition(x) → ¬PayTuition(x)) ::: All high tuition students do not pay tuition"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "HasFailingGrade(x, y) ::: x has a failing grade in course y",
            "RequiredCourse(y) ::: y is a required course",
            "MustRetake(x, y) ::: x must retake course y",
            "Graduate(x) ::: x can graduate",
            "Takes(x, y) ::: x takes course y",
            "HighTuition(x) ::: x has high tuition costs",
            "¬PayTuition(x) ::: x does not pay tuition"
        ]
    },
    {
        "premises-NL": [
            "Every student either studies or is distracted.",
            "If someone is intelligent and studies, then they will pass the exam.",
            "If someone is hardworking and studies, then they will pass the exam.",
            "All intelligent students are not distracted.",
            "All hardworking students are not distracted.",
            "Everyone is either intelligent or hardworking."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Studies(x) ∨ Distracted(x))) ::: Every student either studies or is distracted.",
            "∀x ((Student(x) ∧ Intelligent(x) ∧ Studies(x)) → PassExam(x)) ::: If someone is intelligent and studies, then they will pass the exam.",
            "∀x ((Student(x) ∧ Hardworking(x) ∧ Studies(x)) → PassExam(x)) ::: If someone is hardworking and studies, then they will pass the exam.",
            "∀x (Student(x) ∧ Intelligent(x) → ¬Distracted(x)) ::: All intelligent students are not distracted.",
            "∀x (Student(x) ∧ Hardworking(x) → ¬Distracted(x)) ::: All hardworking students are not distracted.",
            "∀x (Student(x) → (Intelligent(x) ∨ Hardworking(x))) ::: Everyone is either intelligent or hardworking."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "Distracted(x) ::: x is distracted",
            "PassExam(x) ::: x passes the exam",
            "Intelligent(x) ::: x is intelligent",
            "Hardworking(x) ::: x is hardworking"
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled in courses.",
            "If someone is a student and studies, then they study hard.",
            "If someone is enrolled in a difficult course, then they study.",
            "All students are enrolled.",
            "Someone is enrolled in a difficult course."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x)) ::: All students are enrolled in courses.",
            "∀x (Student(x) ∧ Studies(x) → StudiesHard(x)) ::: If someone is a student and studies, then they study hard.",
            "∀x (Enrolled(x) ∧ DifficultCourse(x) → Studies(x)) ::: If someone is enrolled in a difficult course, then they study.",
            "∀x Student(x) → Enrolled(x) ::: All students are enrolled.",
            "∃x (Enrolled(x) ∧ DifficultCourse(x)) ::: Someone is enrolled in a difficult course."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x) ::: x is enrolled in a course",
            "DifficultCourse(x) ::: x is a difficult course",
            "Studies(x) ::: x studies",
            "StudiesHard(x) ::: x studies hard"
        ]
    },
    {
        "premises-NL": [
            "All students are registered.",
            "If someone is registered, they are a student.",
            "If someone has outstanding tuition, then they are not eligible to graduate.",
            "If someone has completed all courses and meets the GPA requirement, then they are eligible to graduate.",
            "If someone is a student, then they have completed all courses.",
            "All students meet the GPA requirement."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Registered(x)) ::: All students are registered.",
            "∀x (Registered(x) → Student(x)) ::: If someone is registered, they are a student.",
            "∀x (OutstandingTuition(x) → ¬EligibleToGraduate(x)) ::: If someone has outstanding tuition, then they are not eligible to graduate.",
            "∀x (CompletedAllCourses(x) ∧ MeetsGPA(x) → EligibleToGraduate(x)) ::: If someone has completed all courses and meets the GPA requirement, then they are eligible to graduate.",
            "∀x (Student(x) → CompletedAllCourses(x)) ::: If someone is a student, then they have completed all courses.",
            "∀x (Student(x) → MeetsGPA(x)) ::: All students meet the GPA requirement."
        ],
        "predicates": [
            "Registered(x) ::: x is registered",
            "OutstandingTuition(x) ::: x has outstanding tuition",
            "CompletedAllCourses(x) ::: x has completed all courses",
            "MeetsGPA(x) ::: x meets the GPA requirement",
            "EligibleToGraduate(x) ::: x is eligible to graduate",
            "Student(x) ::: x is a student"
        ]
    },
    {
        "premises-NL": [
            "All teaching assistants are registered.",
            "If someone is registered, then they are a student.",
            "If someone is a teaching assistant, then they are not an undergraduate student.",
            "All graduate students are students.",
            "If someone is a graduate student, then they are registered.",
            "If someone is a teaching assistant, then they know the course material well.",
            "If someone is a graduate student then they are not an undergraduate student."
        ],
        "premises-FOL": [
            "∀x (TeachingAssistant(x) → Registered(x)) ::: All teaching assistants are registered.",
            "∀x (Registered(x) → Student(x)) ::: If someone is registered, then they are a student.",
            "∀x (TeachingAssistant(x) → ¬UndergraduateStudent(x)) ::: If someone is a teaching assistant, then they are not an undergraduate student.",
            "∀x (GraduateStudent(x) → Student(x)) ::: All graduate students are students.",
            "∀x (GraduateStudent(x) → Registered(x)) ::: If someone is a graduate student, then they are registered.",
            "∀x (TeachingAssistant(x) → KnowsCourseMaterial(x)) ::: If someone is a teaching assistant, then they know the course material well.",
            "∀x (GraduateStudent(x) → ¬UndergraduateStudent(x)) ::: If someone is a graduate student then they are not an undergraduate student."
        ],
        "predicates": [
            "TeachingAssistant(x) ::: x is a teaching assistant",
            "GraduateStudent(x) ::: x is a graduate student",
            "UndergraduateStudent(x) ::: x is an undergraduate student",
            "KnowsCourseMaterial(x) ::: x knows the course material well",
            "Registered(x) ::: x is registered",
            "TakesCourse(x) ::: x takes a course",
            "Student(x) ::: x is a student"
        ]
    },
    {
        "premises-NL": [
            "All students must be registered for their courses.",
            "If someone is taking advanced math and physics, then they are smart.",
            "Advanced calculus is a prerequisite for advanced math.",
            "Someone taking advanced math is a student.",
            "If someone is not registered for a course, then they are not taking it.",
            "Everyone who is registered for a course is a student.",
            "If someone is a student then they are smart.",
            "If a student is smart and is not registered for physics, then they should consult their advisor."
        ],
        "premises-FOL": [
            "∀x ∀y (Takes(x, y) → Registered(x, y)) ::: All students must be registered for their courses.",
            "∀x (Takes(x, AdvancedMath) ∧ Takes(x, Physics) → Smart(x)) ::: If someone is taking advanced math and physics, then they are smart.",
            "Prerequisite(AdvancedCalculus, AdvancedMath) ::: Advanced calculus is a prerequisite for advanced math.",
            "∀x (Takes(x, AdvancedMath) → Student(x)) ::: Someone taking advanced math is a student.",
            "∀x ∀y (¬Registered(x, y) → ¬Takes(x, y)) ::: If someone is not registered for a course, then they are not taking it.",
            "∀x ∀y (Registered(x, y) → Student(x)) ::: Everyone who is registered for a course is a student.",
            "∀x (Student(x) → Smart(x)) ::: If someone is a student then they are smart.",
            "∀x (Student(x) ∧ Smart(x) ∧ ¬Registered(x, Physics) → ConsultAdvisor(x)) ::: If a student is smart and is not registered for physics, then they should consult their advisor."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Takes(x, y) ::: x takes y",
            "Registered(x, y) ::: x is registered for y",
            "Prerequisite(x, y) ::: x is a prerequisite for y",
            "ConsultAdvisor(x) ::: x should consult their advisor",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All students are either enrolled or not.",
            "If a student has a low GPA, they receive a warning.",
            "If a student is enrolled, they take courses.",
            "If a student has a low GPA and receives a warning and doesn't improve, they are on probation.",
            "To have a GPA, a student must be enrolled.",
            "All students are students.",
            "If someone is a student, they are enrolled or not."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (IsEnrolled(x) ∨ ¬IsEnrolled(x))) ::: All students are either enrolled or not.",
            "∀x (Student(x) ∧ HasLowGPA(x) → ReceivesWarning(x)) ::: If a student has a low GPA, they receive a warning.",
            "∀x ∀y (Student(x) ∧ IsEnrolled(x) → TakesCourse(x, y)) ::: If a student is enrolled, they take courses.",
            "∀x (Student(x) ∧ HasLowGPA(x) ∧ ReceivesWarning(x) ∧ ¬ImprovesGPA(x) → AcademicProbation(x)) ::: If a student has a low GPA and receives a warning and doesn't improve, they are on probation.",
            "∀x (HasLowGPA(x) → IsEnrolled(x)) ::: To have a GPA, a student must be enrolled.",
            "∀x (Student(x) → Student(x)) ::: All students are students.",
            "∀x (Student(x) → (IsEnrolled(x) ∨ ¬IsEnrolled(x))) ::: If someone is a student, they are enrolled or not."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "HasLowGPA(x) ::: x has a low GPA",
            "ReceivesWarning(x) ::: x receives a warning",
            "ImprovesGPA(x) ::: x improves their GPA",
            "AcademicProbation(x) ::: x is placed on academic probation",
            "IsEnrolled(x) ::: x is enrolled",
            "TakesCourse(x, y) ::: x takes course y"
        ]
    },
    {
        "premises-NL": [
            "All seniors want to enroll in courses.",
            "If a student requires a course and the course is full with a waitlist, they are on the waitlist.",
            "If a student is on the waitlist they want to enroll.",
            "Seniority sometimes grants priority.",
            "If a student requires a course, and it's full, has a waitlist, they are on it, and they are a senior, they get priority.",
            "All students are students.",
            "Seniors are students.",
            "Students want to enroll in courses."
        ],
        "premises-FOL": [
            "∀x ∀y (Student(x) ∧ IsSenior(x) → WantsToEnroll(x,y)) ::: All seniors want to enroll in courses.",
            "∀x ∀y (Student(x) ∧ RequiresCourse(x, y) ∧ CourseFull(y) ∧ HasWaitlist(y) → OnWaitlist(x, y)) ::: If a student requires a course and the course is full with a waitlist, they are on the waitlist.",
            "∀x ∀y (Student(x) ∧ OnWaitlist(x, y) → WantsToEnroll(x, y)) ::: If a student is on the waitlist they want to enroll.",
            "∃x (IsSenior(x) → PriorityEnrollment(x,y)) ::: Seniority sometimes grants priority.",
            "∀x ∀y (Student(x) ∧ RequiresCourse(x, y) ∧ CourseFull(y) ∧ HasWaitlist(y) ∧ OnWaitlist(x, y) ∧ IsSenior(x) → PriorityEnrollment(x, y)) ::: If a student requires a course, and it's full, has a waitlist, they are on it, and they are a senior, they get priority.",
            "∀x (Student(x) → Student(x)) ::: All students are students.",
            "∀x (IsSenior(x) → Student(x)) ::: Seniors are students.",
            "∀x ∀y (Student(x) → WantsToEnroll(x,y)) ::: Students want to enroll in courses."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "RequiresCourse(x, y) ::: x requires course y for their major",
            "CourseFull(y) ::: course y is full",
            "HasWaitlist(y) ::: course y has a waitlist",
            "OnWaitlist(x, y) ::: x is on the waitlist for course y",
            "IsSenior(x) ::: x is a senior",
            "PriorityEnrollment(x, y) ::: x will be given priority enrollment in course y",
            "WantsToEnroll(x, y) ::: x wants to enroll in course y"
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled or not.",
            "To be enrolled, a student must take courses.",
            "If a student has completed all courses and has minimum GPA and has paid tuition and no holds, they are eligible to graduate and receive diploma.",
            "If a student takes courses, they are enrolled.",
            "To pay tuition, they must be enrolled.",
            "To have a GPA, a student must be enrolled.",
            "All students must be students.",
            "Eligibility requirements must be fulfilled.",
            "All enrolled students take courses."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (IsEnrolled(x) ∨ ¬IsEnrolled(x))) ::: All students are enrolled or not.",
            "∀x ∀y (Student(x) ∧ IsEnrolled(x) → TakesCourse(x, y)) ::: To be enrolled, a student must take courses.",
            "∀x (Student(x) ∧ CompletedAllCourses(x) ∧ HasMinimumGPA(x) ∧ PaidTuition(x) ∧ ¬HasHolds(x) → EligibleForGraduation(x) ∧ ReceivesDiploma(x)) ::: If a student has completed all courses and has minimum GPA and has paid tuition and no holds, they are eligible to graduate and receive diploma.",
            "∀x ∀y (Student(x) ∧ TakesCourse(x,y) → IsEnrolled(x)) ::: If a student takes courses, they are enrolled.",
            "∀x (Student(x) ∧ PaidTuition(x) → IsEnrolled(x)) ::: To pay tuition, they must be enrolled.",
            "∀x (HasMinimumGPA(x) → IsEnrolled(x)) ::: To have a GPA, a student must be enrolled.",
            "∀x (Student(x) → Student(x)) ::: All students must be students.",
            "∃x (EligibleForGraduation(x) → (CompletedAllCourses(x) ∧ HasMinimumGPA(x) ∧ PaidTuition(x) ∧ ¬HasHolds(x))) ::: Eligibility requirements must be fulfilled.",
            "∀x ∀y (Student(x) ∧ IsEnrolled(x) → TakesCourse(x, y)) ::: All enrolled students take courses."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "CompletedAllCourses(x) ::: x has completed all required courses for their degree",
            "HasMinimumGPA(x) ::: x has the minimum required GPA",
            "PaidTuition(x) ::: x has paid all tuition fees",
            "HasHolds(x) ::: x has holds on their account",
            "EligibleForGraduation(x) ::: x is eligible for graduation",
            "ReceivesDiploma(x) ::: x receives their diploma",
            "IsEnrolled(x) ::: x is enrolled",
            "TakesCourse(x, y) ::: x takes course y"
        ]
    },
    {
        "premises-NL": [
            "All students who have a good GPA and have completed all courses are eligible for graduation.",
            "If a student is eligible for graduation and meets all requirements, then they can graduate.",
            "If a student has outstanding fees, they have not paid tuition.",
            "A student has outstanding fees if they have not paid tuition.",
            "To be eligible for graduation, a student must meet all requirements and have no outstanding fees.",
            "Students are required to register for courses before graduation.",
            "If a student is registered for courses, then they must take a required course.",
            "Students who have not paid tuition will have outstanding fees.",
            "To complete all courses, the student must have good GPA.",
            "Students who are not registered for the current semester must delay graduation.",
            "Students who are not good are not eligible for graduation."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ HasGoodGPA(x) ∧ CompletedAllCourses(x) → EligibleForGraduation(x)) ::: All students who have a good GPA and have completed all courses are eligible for graduation.",
            "∀x (Student(x) ∧ EligibleForGraduation(x) ∧ MeetsAllRequirements(x) → Graduate(x)) ::: If a student is eligible for graduation and meets all requirements, then they can graduate.",
            "∀x (Student(x) ∧ HasOutstandingFees(x) → ¬PaidTuition(x)) ::: If a student has outstanding fees, they have not paid tuition.",
            "∀x (Student(x) ∧ ¬PaidTuition(x) → HasOutstandingFees(x)) ::: A student has outstanding fees if they have not paid tuition.",
            "∀x (Student(x) ∧ EligibleForGraduation(x) → MeetsAllRequirements(x) ∧ ¬HasOutstandingFees(x)) ::: To be eligible for graduation, a student must meet all requirements and have no outstanding fees.",
            "∀x (Student(x) → RegisteredForCourses(x)) ::: Students are required to register for courses before graduation.",
            "∀x (Student(x) ∧ RegisteredForCourses(x) → TakesRequiredCourse(x)) ::: If a student is registered for courses, then they must take a required course.",
            "∀x (Student(x) ∧ ¬PaidTuition(x) → HasOutstandingFees(x)) ::: Students who have not paid tuition will have outstanding fees.",
            "∀x (Student(x) ∧ CompletedAllCourses(x) → HasGoodGPA(x)) ::: To complete all courses, the student must have good GPA.",
            "∀x (Student(x) ∧ ¬RegisteredForCourses(x) → DelayGraduation(x)) ::: Students who are not registered for the current semester must delay graduation.",
            "∀x (Student(x) ∧ ¬HasGoodGPA(x) → ¬EligibleForGraduation(x)) ::: Students who are not good are not eligible for graduation."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EligibleForGraduation(x) ::: x is eligible for graduation",
            "PaidTuition(x) ::: x has paid tuition",
            "Graduate(x) ::: x will graduate",
            "DelayGraduation(x) ::: x will delay graduation",
            "HasGoodGPA(x) ::: x has a good GPA",
            "CompletedAllCourses(x) ::: x has completed all courses",
            "MeetsAllRequirements(x) ::: x meets all requirements",
            "HasOutstandingFees(x) ::: x has outstanding fees",
            "RegisteredForCourses(x) ::: x has registered for courses",
            "TakesRequiredCourse(x) ::: x takes a required course"
        ]
    },
    {
        "premises-NL": [
            "All students must attend lectures.",
            "If a student studies hard, they will understand the material.",
            "If a student understands the material, they will receive a good grade.",
            "If a student attends lectures and asks questions, they study hard.",
            "A student who studies hard completes all assignments.",
            "If a student receives a good grade they do not fail.",
            "The student is a student",
            "If a student asks questions, then they will understand material better.",
            "The course exists."
        ],
        "premises-FOL": [
            "∀x ∀y (Student(x) → AttendsLectures(x, y)) ::: All students must attend lectures.",
            "∀x (Student(x) ∧ StudiesHard(x) → UnderstandsMaterial(x,y)) ::: If a student studies hard, they will understand the material.",
            "∀x ∀y (UnderstandsMaterial(x,y) → ReceivesGoodGrade(x,y)) ::: If a student understands the material, they will receive a good grade.",
            "∀x ∀y (AttendsLectures(x, y) ∧ AsksQuestions(x,y) → StudiesHard(x)) ::: If a student attends lectures and asks questions, they study hard.",
            "∀x ∀y (StudiesHard(x) → CompletesAllAssignments(x, y)) ::: A student who studies hard completes all assignments.",
            "∀x ∀y (ReceivesGoodGrade(x,y) → ¬Fails(x, y)) ::: If a student receives a good grade they do not fail.",
            "∀x Student(x) ::: The student is a student",
            "∀x ∀y (AsksQuestions(x,y) → UnderstandsMaterial(x,y)) ::: If a student asks questions, then they will understand material better.",
            "∃y Course(y) ::: The course exists."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "CompletesAllAssignments(x, y) ::: x completes all assignments for course y",
            "TooDifficult(y) ::: course y is too difficult",
            "Fails(x, y) ::: x fails course y",
            "AttendsLectures(x, y) ::: x attends lectures for course y",
            "AsksQuestions(x,y) ::: x asks questions in course y",
            "UnderstandsMaterial(x,y) ::: x understands the material in course y",
            "ReceivesGoodGrade(x,y) ::: x receives a good grade in course y"
        ]
    },
    {
        "premises-NL": [
            "All students must attend class.",
            "If a student is hardworking, they submit their homework.",
            "If a professor does not allow late submissions, and a student does not submit their homework, then that student is penalized.",
            "If a student is penalized, they will not pass the course.",
            "All professors teach at least one course.",
            "Attending class helps students to pass the course.",
            "Being smart helps a student pass a course.",
            "If a student reads the textbook, they can submit their homework.",
            "If a student attends class and asks questions, then they are hardworking.",
            "All smart people ask questions."
        ],
        "premises-FOL": [
            "∀x ∀y (Student(x) → AttendsClass(x, y)) ::: All students must attend class.",
            "∀x ∀y (Hardworking(x) → SubmitHomework(x, y)) ::: If a student is hardworking, they submit their homework.",
            "∀z ∀x ∀y (¬AllowsLateSubmissions(z) ∧ Student(x) ∧ ¬SubmitHomework(x, y) → Penalized(x)) ::: If a professor does not allow late submissions, and a student does not submit their homework, then that student is penalized.",
            "∀x ∀y (Penalized(x) → ¬PassesCourse(x, y)) ::: If a student is penalized, they will not pass the course.",
            "∀z ∃y (Professor(z) → Teaches(z, y)) ::: All professors teach at least one course.",
            "∀x ∀y (AttendsClass(x, y) → HelpsPass(x,y)) ::: Attending class helps students to pass the course.",
            "∀x ∀y (IsSmart(x) → HelpsPass(x,y)) ::: Being smart helps a student pass a course.",
            "∀x ∀y (ReadsTextbook(x,y) → SubmitHomework(x, y)) ::: If a student reads the textbook, they can submit their homework.",
            "∀x ∀y (AttendsClass(x, y) ∧ AsksQuestions(x) → Hardworking(x)) ::: If a student attends class and asks questions, then they are hardworking.",
            "∀x (IsSmart(x) → AsksQuestions(x)) ::: All smart people ask questions."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "SubmitHomework(x, y) ::: x submits homework for course y",
            "PassesCourse(x, y) ::: x passes course y",
            "AllowsLateSubmissions(z) ::: professor z allows late submissions",
            "Professor(z) ::: z is a professor",
            "Teaches(z, y) ::: professor z teaches course y",
            "AttendsClass(x, y) ::: x attends class y",
            "ReadsTextbook(x,y) ::: x reads the textbook for course y",
            "IsSmart(x) ::: x is smart",
            "AsksQuestions(x) ::: x asks questions",
            "Hardworking(x) ::: x is hardworking"
        ]
    },
    {
        "premises-NL": [
            "If a student fails a course, they need to retake it.",
            "If a student needs to retake a course and it is not eligible for retakes, they will not graduate.",
            "Some advanced courses are not eligible for retakes.",
            "All students are enrolled in courses.",
            "If a student is not hardworking, they are likely to fail advanced courses.",
            "All students pass at least one course.",
            "Advanced courses are difficult.",
            "All students are hardworking or not hardworking.",
            "There exists a student that is not hardworking."
        ],
        "premises-FOL": [
            "∀x ∀y ((Student(x) ∧ Fails(x, y)) → NeedsToRetake(x, y)) ::: If a student fails a course, they need to retake it.",
            "∀x ∀y ((Student(x) ∧ NeedsToRetake(x, y) ∧ ¬EligibleForRetakes(y)) → ¬Graduates(x)) ::: If a student needs to retake a course and it is not eligible for retakes, they will not graduate.",
            "∃y (AdvancedCourse(y) ∧ ¬EligibleForRetakes(y)) ::: Some advanced courses are not eligible for retakes.",
            "∀x ∃y (Student(x) → EnrolledIn(x, y)) ::: All students are enrolled in courses.",
            "∀x ∀y ((Student(x) ∧ AdvancedCourse(y) ∧ EnrolledIn(x, y) ∧ ¬Hardworking(x)) → Fails(x, y)) ::: If a student is not hardworking, they are likely to fail advanced courses.",
            "∀x ∃y (Student(x) → EnrolledIn(x, y)) ::: All students are enrolled in courses.",
            "∀y (AdvancedCourse(y) → DifficultCourse(y)) ::: Advanced courses are difficult.",
            "∀x (Student(x) → (Hardworking(x) ∨ ¬Hardworking(x))) ::: All students are hardworking or not hardworking.",
            "∃x (Student(x) ∧ ¬Hardworking(x)) ::: There exists a student that is not hardworking."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "NeedsToRetake(x, y) ::: x needs to retake y",
            "AllowedToRetake(x, y) ::: x is allowed to retake y",
            "Graduates(x) ::: x graduates",
            "Fails(x, y) ::: x fails y",
            "EligibleForRetakes(y) ::: y is eligible for retakes",
            "EnrolledIn(x, y) ::: x is enrolled in y",
            "AdvancedCourse(y) ::: y is an advanced course",
            "Hardworking(x) ::: x is hardworking"
        ]
    },
    {
        "premises-NL": [
            "Professors teach courses.",
            "Students enroll in courses.",
            "If a course requires assignments, students must submit them to pass.",
            "Good grades are only given to those who pass.",
            "Passing requires submitting all assignments if the course is graded on assignments.",
            "Submitting assignments requires effort.",
            "Courses are graded on assignments, if assignments are required.",
            "If someone doesn't put in effort, they will not get a good grade.",
            "Students who attend classes do better on assignments.",
            "Submitting assignments implies enrollment.",
            "To pass a course you must submit assignments if assignments are required."
        ],
        "premises-FOL": [
            "∀z ∃y Teaches(z, y) ::: Professors teach courses.",
            "∀x ∃y Enrolled(x, y) ::: Students enroll in courses.",
            "∀x ∀y (AssignmentsRequired(y) ∧ Student(x) → SubmitsAssignments(x, y)) ::: If a course requires assignments, students must submit them to pass.",
            "∀x ∀y (GoodGrade(x, y) → Passes(x, y)) ::: Good grades are only given to those who pass.",
            "∀x ∀y (Passes(x, y) ∧ GradedOnAssignments(y) → SubmitsAssignments(x, y)) ::: Passing requires submitting all assignments if the course is graded on assignments.",
            "∀x ∀y (SubmitsAssignments(x, y) → PutsEffort(x)) ::: Submitting assignments requires effort.",
            "∀y (AssignmentsRequired(y) → GradedOnAssignments(y)) ::: Courses are graded on assignments, if assignments are required.",
            "∀x ∀y (¬PutsEffort(x) → ¬GoodGrade(x, y)) ::: If someone doesn't put in effort, they will not get a good grade.",
            "∀x ∀y (Attends(x, y) → ImprovesAssignments(x, y)) ::: Students who attend classes do better on assignments.",
            "∀x ∀y (SubmitsAssignments(x, y) → Enrolled(x, y)) ::: Submitting assignments implies enrollment.",
            "∀x ∀y (AssignmentsRequired(y) ∧ Passes(x, y) → SubmitsAssignments(x, y)) ::: To pass a course you must submit assignments if assignments are required."
        ],
        "predicates": [
            "Professor(z) ::: z is a professor",
            "Teaches(z, y) ::: z teaches course y",
            "Student(x) ::: x is a student",
            "Enrolled(x, y) ::: x is enrolled in y",
            "SubmitsAssignments(x, y) ::: x submits assignments for y",
            "AssignmentsRequired(y) ::: Assignments are required for y",
            "GoodGrade(x, y) ::: x gets a good grade in y",
            "Passes(x, y) ::: x passes y",
            "Studies(x) ::: x studies",
            "Attends(x, y) ::: x attends y",
            "GradedOnAssignments(y) ::: Course y is graded on assignments"
        ]
    },
    {
        "premises-NL": [
            "Students on academic probation must improve their GPA to remain in good standing.",
            "Good standing is required to avoid suspension.",
            "If a student does not improve their GPA, they are not in good standing.",
            "To improve GPA, a student must attend classes and study.",
            "If a student fails to improve and time has exceeded, suspension follows.",
            "Failing all required courses leads to academic probation.",
            "Passing required courses helps improve GPA.",
            "Attending and studying increases the likelihood of passing courses.",
            "Remaining enrolled is necessary to improve GPA.",
            "Improving GPA requires effort.",
            "Suspension occurs if a student does not improve after academic probation and after the time is exceeded.",
            "Minimum GPA must be maintained"
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ AcademicProbation(x) → ImprovesGPA(x)) ::: Students on academic probation must improve their GPA to remain in good standing.",
            "∀x (GoodStanding(x) → ¬Suspended(x)) ::: Good standing is required to avoid suspension.",
            "∀x (¬ImprovesGPA(x) → ¬GoodStanding(x)) ::: If a student does not improve their GPA, they are not in good standing.",
            "∀x (ImprovesGPA(x) → (AttendsClasses(x) ∧ Studies(x))) ::: To improve GPA, a student must attend classes and study.",
            "∀x ((Student(x) ∧ AcademicProbation(x) ∧ ¬ImprovesGPA(x) ∧ TimeExceeded(x)) → Suspended(x)) ::: If a student fails to improve and time has exceeded, suspension follows.",
            "∀x (FailsAllRequiredCourses(x) → AcademicProbation(x)) ::: Failing all required courses leads to academic probation.",
            "∀x ∀z (RequiredCourses(z) ∧ Passes(x, z) → ImprovesGPA(x)) ::: Passing required courses helps improve GPA.",
            "∀x ∀z ((AttendsClasses(x) ∧ Studies(x)) → IncreasesLikelihood(x, z)) ::: Attending and studying increases the likelihood of passing courses.",
            "∀x (ImprovesGPA(x) → Enrolled(x, z)) ::: Remaining enrolled is necessary to improve GPA.",
            "∀x (ImprovesGPA(x) → PutsEffort(x)) ::: Improving GPA requires effort.",
            "∀x (AcademicProbation(x) ∧ ¬ImprovesGPA(x) ∧ TimeExceeded(x) → Suspended(x)) ::: Suspension occurs if a student does not improve after academic probation and after the time is exceeded.",
            "∀x ∀y (GPA(x,y) → MinimumGPA(y)) ::: Minimum GPA must be maintained."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AcademicProbation(x) ::: x is on academic probation",
            "ImprovesGPA(x) ::: x improves GPA above minimum",
            "Suspended(x) ::: x is suspended",
            "AttendsClasses(x) ::: x attends classes",
            "Studies(x) ::: x studies",
            "MinimumGPA(y) ::: y is a minimum GPA",
            "GPA(x,y) ::: x has GPA y",
            "TimeExceeded(x) ::: Time limit for improvement exceeded for x",
            "Enrolled(x, z) ::: x is enrolled in course z",
            "Passes(x, z) ::: x passes course z",
            "GoodStanding(x) ::: x is in good academic standing",
            "RequiredCourses(z) ::: z is required course"
        ]
    },
    {
        "premises-NL": [
            "Students must be enrolled in a course to be officially registered for it.",
            "Courses cannot be full for a student to be officially registered.",
            "Available seats are needed for a student to be officially registered.",
            "Students cannot be on the waitlist for conflicting courses to be officially registered.",
            "A student is only officially registered if they are enrolled, there are available seats, and they are not waitlisted for a conflicting course.",
            "If a course is not full, there are available seats.",
            "Enrollment is necessary for being waitlisted.",
            "Only students can be enrolled.",
            "If a course is full it does not have available seats."
        ],
        "premises-FOL": [
            "∀x ∀y (OfficiallyRegistered(x, y) → EnrolledIn(x, y)) ::: Students must be enrolled in a course to be officially registered for it.",
            "∀x ∀y (OfficiallyRegistered(x, y) → ¬CourseFull(y)) ::: Courses cannot be full for a student to be officially registered.",
            "∀y (OfficiallyRegistered(x, y) → HasAvailableSeats(y)) ::: Available seats are needed for a student to be officially registered.",
            "∀x ∀y (OfficiallyRegistered(x, y) → ¬OnWaitlistForConflictingCourse(x, y)) ::: Students cannot be on the waitlist for conflicting courses to be officially registered.",
            "∀x ∀y (OfficiallyRegistered(x, y) ↔ (EnrolledIn(x, y) ∧ HasAvailableSeats(y) ∧ ¬OnWaitlistForConflictingCourse(x, y))) ::: A student is only officially registered if they are enrolled, there are available seats, and they are not waitlisted for a conflicting course.",
            "∀y (¬CourseFull(y) → HasAvailableSeats(y)) ::: If a course is not full, there are available seats.",
            "∀x ∀y (OnWaitlistForConflictingCourse(x, y) → EnrolledIn(x, z)) ::: Enrollment is necessary for being waitlisted.",
            "∀x ∀y (EnrolledIn(x, y) → Student(x)) ::: Only students can be enrolled.",
            "∀y (CourseFull(y) → ¬HasAvailableSeats(y)) ::: If a course is full it does not have available seats."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Course(y) ::: y is a course",
            "EnrolledIn(x, y) ::: x is enrolled in course y",
            "HasAvailableSeats(y) ::: y has available seats",
            "OnWaitlistForConflictingCourse(x, y) ::: x is on the waitlist for a course that conflicts with y",
            "OfficiallyRegistered(x, y) ::: x is officially registered for course y",
            "CourseFull(y) ::: Course y is full"
        ]
    },
    {
        "premises-NL": [
            "All graduate students are students.",
            "Some courses are advanced.",
            "Advanced courses require prerequisites.",
            "If you don't have a prerequisite, you are not prepared.",
            "If you're not prepared, you won't succeed.",
            "Passing requires succeeding.",
            "If a student does not succeed, they will not pass.",
            "All students are registered."
        ],
        "premises-FOL": [
            "∀x (GraduateStudent(x) → Student(x)) ::: All graduate students are students.",
            "∃y AdvancedCourse(y) ::: Some courses are advanced.",
            "∀y (AdvancedCourse(y) → RequiresPrerequisite(y)) ::: Advanced courses require prerequisites.",
            "∀x ∀y (¬HasPrerequisite(x, y) → ¬Prepared(x, y)) ::: If you don't have a prerequisite, you are not prepared.",
            "∀x ∀y (¬Prepared(x, y) → ¬Succeeds(x)) ::: If you're not prepared, you won't succeed.",
            "∀x ∀y (Passes(x, y) → Succeeds(x)) ::: Passing requires succeeding.",
            "∀x ∀y (Student(x) ∧ ¬Succeeds(x) → ¬Passes(x, y)) ::: If a student does not succeed, they will not pass.",
            "∀x (Student(x) → Registered(x)) ::: All students are registered."
        ],
        "predicates": [
            "GraduateStudent(x) ::: x is a graduate student",
            "Takes(x, y) ::: x takes y",
            "AdvancedCourse(y) ::: y is an advanced course",
            "HasPrerequisite(x, y) ::: x has the prerequisite for y",
            "Passes(x, y) ::: x passes y",
            "Course(y) ::: y is a course",
            "Professor(z) ::: z is a professor"
        ]
    },
    {
        "premises-NL": [
            "Alice is a student.",
            "If someone is a student and studies diligently, then they are hardworking.",
            "If someone is hardworking and attends all lectures, then they are intelligent.",
            "If someone is intelligent, then they are dedicated.",
            "If someone is dedicated, then they are successful.",
            "If someone is successful, then they pass the exam.",
            "Alice studies diligently.",
            "Alice attends all lectures.",
            "Studying diligently implies success.",
            "Attending all lectures implies dedication."
        ],
        "premises-FOL": [
            "Student(alice) ::: Alice is a student.",
            "∀x (Student(x) ∧ StudiesDiligently(x) → Hardworking(x)) ::: If someone is a student and studies diligently, then they are hardworking.",
            "∀x (Hardworking(x) ∧ AttendsAllLectures(x) → Intelligent(x)) ::: If someone is hardworking and attends all lectures, then they are intelligent.",
            "∀x (Intelligent(x) → Dedicated(x)) ::: If someone is intelligent, then they are dedicated.",
            "∀x (Dedicated(x) → Successful(x)) ::: If someone is dedicated, then they are successful.",
            "∀x (Successful(x) → PassExam(x)) ::: If someone is successful, then they pass the exam.",
            "StudiesDiligently(alice) ::: Alice studies diligently.",
            "AttendsAllLectures(alice) ::: Alice attends all lectures.",
            "∀x (StudiesDiligently(x) → Successful(x)) ::: Studying diligently implies success.",
            "∀x (AttendsAllLectures(x) → Dedicated(x)) ::: Attending all lectures implies dedication."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "TakesCourse(x, y) ::: x takes course y",
            "StudiesDiligently(x) ::: x studies diligently",
            "AttendsAllLectures(x) ::: x attends all lectures",
            "PassExam(x) ::: x passes the exam",
            "Prerequisite(x, y) ::: x is a prerequisite of y",
            "Hardworking(x) ::: x is hardworking",
            "Intelligent(x) ::: x is intelligent",
            "Dedicated(x) ::: x is dedicated",
            "Successful(x) ::: x is successful"
        ]
    },
    {
        "premises-NL": [
            "All students are either full-time or not full-time.",
            "If a student is full-time, then they likely do not work.",
            "If a course is very expensive, then its tuition costs are high.",
            "If tuition costs are high and a student has not applied for aid, the student has a financial burden.",
            "If a student is enrolled in a course, they are a student.",
            "If a student does not work, they have limited funds.",
            "If a student has limited funds and a financial burden, they have a significant financial burden."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (FullTimeStudent(x) ∨ ¬FullTimeStudent(x))) ::: All students are either full-time or not full-time.",
            "∀x (Student(x) ∧ FullTimeStudent(x) → ¬Works(x)) ::: If a student is full-time, then they likely do not work.",
            "∀y (VeryExpensive(y) → HighTuition(y)) ::: If a course is very expensive, then its tuition costs are high.",
            "∀x (HighTuition(x) ∧ ¬AppliedForAid(x) → FinancialBurden(x)) ::: If tuition costs are high and a student has not applied for aid, the student has a financial burden.",
            "∀x ∀y (Enrolled(x, y) → Student(x)) ::: If a student is enrolled in a course, they are a student.",
            "∀x (Student(x) ∧ ¬Works(x) → LimitedFunds(x)) ::: If a student does not work, they have limited funds.",
            "∀x (LimitedFunds(x) ∧ FinancialBurden(x) → SignificantBurden(x)) ::: If a student has limited funds and a financial burden, they have a significant financial burden."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "VeryExpensive(y) ::: y is a very expensive course",
            "AppliedForAid(x) ::: x has applied for financial aid",
            "SignificantBurden(x) ::: x has a significant financial burden",
            "Works(x) ::: x works",
            "FullTimeStudent(x) ::: x is a full-time student"
        ]
    },
    {
        "premises-NL": [
            "All graduate students must meet prerequisites for courses.",
            "Some graduate students take difficult courses.",
            "If a student does not pass the final exam, they must retake the course.",
            "All courses require a final exam.",
            "Difficult courses have challenging final exams.",
            "If a graduate student is enrolled in a course and does not pass the final exam, they must retake the course.",
            "Enrolled students attend lectures.",
            "Studying helps students pass exams.",
            "Attending lectures is beneficial for understanding the material.",
            "Some graduate students struggle even if they study.",
            "Not all graduate students pass the final exam."
        ],
        "premises-FOL": [
            "∀x ∀y ((GraduateStudent(x) ∧ Enrolled(x, y)) → PrerequisitesMet(x, y)) ::: All graduate students must meet prerequisites for courses.",
            "∃x ∃y (GraduateStudent(x) ∧ Takes(x, y) ∧ DifficultCourse(y)) ::: Some graduate students take difficult courses.",
            "∀x (¬PassesFinalExam(x) → MustRetake(x, y)) ::: If a student does not pass the final exam, they must retake the course.",
            "∀y (Course(y) → HasFinalExam(y)) ::: All courses require a final exam.",
            "∀y (DifficultCourse(y) → ChallengingFinalExam(y)) ::: Difficult courses have challenging final exams.",
            "∀x ∀y ((GraduateStudent(x) ∧ Enrolled(x, y) ∧ ¬PassesFinalExam(x)) → MustRetake(x, y)) ::: If a graduate student is enrolled in a course and does not pass the final exam, they must retake the course.",
            "∀x ∀y (Enrolled(x, y) → AttendsLectures(x)) ::: Enrolled students attend lectures.",
            "∀x (Studies(x) → HelpsPassExams(x)) ::: Studying helps students pass exams.",
            "∀x (AttendsLectures(x) → BenefitsUnderstanding(x)) ::: Attending lectures is beneficial for understanding the material.",
            "∃x (GraduateStudent(x) ∧ Studies(x) ∧ ¬PassesFinalExam(x)) ::: Some graduate students struggle even if they study.",
            "∃x (GraduateStudent(x) ∧ ¬PassesFinalExam(x)) ::: Not all graduate students pass the final exam."
        ],
        "predicates": [
            "GraduateStudent(x) ::: x is a graduate student",
            "Takes(x, y) ::: x takes course y",
            "DifficultCourse(y) ::: y is a difficult course",
            "PassesFinalExam(x) ::: x passes the final exam",
            "MustRetake(x,y) ::: x must retake course y",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "PrerequisitesMet(x, y) ::: x meets prerequisites for y",
            "Studies(x) ::: x studies",
            "Helpful(x, y) ::: x helps y",
            "AttendsLectures(x) ::: x attends lectures"
        ]
    },
    {
        "premises-NL": [
            "Everyone enrolled in a course takes that course.",
            "If someone takes a course and passes it, then they are considered to have passed the course.",
            "If a student is enrolled in a course, they take the course.",
            "If a student passes a course, they receive credit.",
            "For all courses, if you take a course and pass it, you are enrolled."
        ],
        "premises-FOL": [
            "∀x ∀y (Enrolled(x, y) → Takes(x, y)) ::: Everyone enrolled in a course takes that course.",
            "∀x ∀y (Takes(x, y) ∧ Passes(x, y) → Passes(x, y)) ::: If someone takes a course and passes it, then they are considered to have passed the course.",
            "∀x ∀y (Enrolled(x, y) → Takes(x, y)) ::: If a student is enrolled in a course, they take the course.",
            "∀x ∀y (Passes(x, y) → ReceivesCredit(x, y)) ::: If a student passes a course, they receive credit.",
            "∀x ∀y (Takes(x, y) ∧ Passes(x, y) → Enrolled(x, y)) ::: For all courses, if you take a course and pass it, you are enrolled."
        ],
        "predicates": [
            "Enrolled(x, y) ::: Student x is enrolled in course y",
            "Passes(x, y) ::: Student x passes course y",
            "Requires(y, z) ::: Course y requires course z as a prerequisite",
            "ReceivesCredit(x, y) ::: Student x receives credit for course y",
            "Takes(x,y) ::: Student x takes course y"
        ]
    },
    {
        "premises-NL": [
            "All courses are offered.",
            "Some courses require other courses as prerequisites.",
            "If course x requires course y as a prerequisite, then course y satisfies the prerequisite for course x.",
            "If a student completes a course, it means the course is offered.",
            "If a student has completed the prerequisite of a course, they are allowed to enroll in the course.",
            "If a student is allowed to enroll, they can enroll.",
            "Every student is a student.",
            "There exists a student.",
            "There exists a course."
        ],
        "premises-FOL": [
            "∀x (Course(x) → Offered(x)) ::: All courses are offered.",
            "∃x ∃y (Course(x) ∧ Course(y) ∧ Requires(x, y)) ::: Some courses require other courses as prerequisites.",
            "∀x ∀y (Requires(x, y) → SatisfiesPrerequisite(y, x)) ::: If course x requires course y as a prerequisite, then course y satisfies the prerequisite for course x.",
            "∀x ∀y (Student(x) ∧ Completed(x, y) → Offered(y)) ::: If a student completes a course, it means the course is offered.",
            "∀x ∀y (Student(x) ∧ Completed(x, y) ∧ SatisfiesPrerequisite(y, z) → Allowed(x, z)) ::: If a student has completed the prerequisite of a course, they are allowed to enroll in the course.",
            "∀x ∀y (Allowed(x, y) → CanEnroll(x, y)) ::: If a student is allowed to enroll, they can enroll.",
            "∀x (Student(x) → Student(x)) ::: Every student is a student.",
            "∃x Student(x) ::: There exists a student.",
            "∃x Course(x) ::: There exists a course."
        ],
        "predicates": [
            "Course(x) ::: x is a course",
            "Student(x) ::: x is a student",
            "SatisfiesPrerequisite(x, y) ::: Course x satisfies the prerequisite for course y",
            "Completed(x, y) ::: Student x has completed course y",
            "CanEnroll(x, y) ::: Student x can enroll in course y",
            "Requires(x, y) ::: Course x requires course y as a prerequisite",
            "Offered(x) ::: Course x is offered",
            "Enrolled(x,y) ::: Student x is enrolled in course y",
            "Allowed(x, y) ::: Student x is allowed to enroll in course y"
        ]
    },
    {
        "premises-NL": [
            "All students must pay their tuition or apply for a deferral.",
            "Students who have not paid tuition and have not applied for a deferral will be dropped from their courses.",
            "Students with an outstanding balance are not eligible for housing.",
            "Students who receive financial aid are eligible for housing.",
            "Students who receive financial aid have no outstanding balances.",
            "Students who live on campus are eligible for housing.",
            "Any student who is in good academic standing is a student",
            "All students are eligible for housing",
            "Anyone is a student"
        ],
        "premises-FOL": [
            "∀x (Student(x) → PaidTuition(x) ∨ AppliedForDeferral(x)) ::: All students must pay their tuition or apply for a deferral.",
            "∀x ((Student(x) ∧ ¬PaidTuition(x) ∧ ¬AppliedForDeferral(x)) → DroppedFromCourses(x)) ::: Students who have not paid tuition and have not applied for a deferral will be dropped from their courses.",
            "∀x (HasOutstandingBalance(x) → ¬EligibleForHousing(x)) ::: Students with an outstanding balance are not eligible for housing.",
            "∀x (ReceivesFinancialAid(x) → EligibleForHousing(x)) ::: Students who receive financial aid are eligible for housing.",
            "∀x (ReceivesFinancialAid(x) → ¬HasOutstandingBalance(x)) ::: Students who receive financial aid have no outstanding balances.",
            "∀x (LivesInCampus(x) → EligibleForHousing(x)) ::: Students who live on campus are eligible for housing.",
            "∀x Student(x) ::: Any student who is in good academic standing is a student",
            "∀x (Student(x) → EligibleForHousing(x)) ::: All students are eligible for housing",
            "∀x Student(x) ::: Anyone is a student"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PaidTuition(x) ::: x has paid their tuition",
            "AppliedForDeferral(x) ::: x has applied for a tuition deferral",
            "DroppedFromCourses(x) ::: x is dropped from their courses",
            "TakesCourse(x, y) ::: x takes course y",
            "HasOutstandingBalance(x) ::: x has an outstanding balance",
            "ReceivesFinancialAid(x) ::: x receives financial aid",
            "LivesInCampus(x) ::: x lives on campus",
            "EligibleForHousing(x) ::: x is eligible for campus housing"
        ]
    },
    {
        "premises-NL": [
            "All students are either studying hard or not.",
            "If a student studies hard, they pass the course.",
            "If a student passes the course, they understand the material.",
            "If a student doesn't understand the material, they fail the course.",
            "If a student fails a difficult course, they need to attend tutoring sessions.",
            "Difficult courses exist.",
            "Some students are enrolled in courses.",
            "If a student is enrolled in a course, then that course is difficult or not."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (StudyHard(x) ∨ ¬StudyHard(x))) ::: All students are either studying hard or not.",
            "∀x ∀y (Student(x) ∧ StudyHard(x) ∧ Enrolled(x, y) → Passes(x, y)) ::: If a student studies hard, they pass the course.",
            "∀x ∀y (Student(x) ∧ Passes(x, y) → UnderstandsMaterial(x)) ::: If a student passes the course, they understand the material.",
            "∀x ∀y (Student(x) ∧ ¬UnderstandsMaterial(x) ∧ Enrolled(x, y) → Fails(x, y)) ::: If a student doesn't understand the material, they fail the course.",
            "∀x ∀y (Student(x) ∧ Fails(x, y) ∧ DifficultCourse(y) → AttendsTutoring(x)) ::: If a student fails a difficult course, they need to attend tutoring sessions.",
            "∃y DifficultCourse(y) ::: Difficult courses exist.",
            "∃x ∃y (Student(x) ∧ Enrolled(x, y)) ::: Some students are enrolled in courses.",
            "∀y (Enrolled(x, y) → (DifficultCourse(y) ∨ ¬DifficultCourse(y))) ::: If a student is enrolled in a course, then that course is difficult or not."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "DifficultCourse(y) ::: y is a difficult course",
            "StudyHard(x) ::: x studies hard",
            "AttendsTutoring(x) ::: x attends tutoring sessions",
            "Passes(x, y) ::: x passes course y",
            "Fails(x, y) ::: x fails course y",
            "UnderstandsMaterial(x) ::: x understands the material"
        ]
    },
    {
        "premises-NL": [
            "All graduate students are diligent.",
            "If a student is diligent, they are dedicated.",
            "If a graduate student publishes a paper, they are successful.",
            "If a graduate student conducts research, they are successful.",
            "If a graduate student is successful, then they are diligent or exceptionally skilled.",
            "All advisors support their students.",
            "Graduate students have advisors.",
            "If a graduate student is supported, they are successful.",
            "If a student is diligent and dedicated, then that student is successful."
        ],
        "premises-FOL": [
            "∀x (GraduateStudent(x) → Diligent(x)) ::: All graduate students are diligent.",
            "∀x (Diligent(x) → Dedicated(x)) ::: If a student is diligent, they are dedicated.",
            "∀x (GraduateStudent(x) ∧ PublishesPaper(x) → Successful(x)) ::: If a graduate student publishes a paper, they are successful.",
            "∀x (GraduateStudent(x) ∧ ConductsResearch(x) → Successful(x)) ::: If a graduate student conducts research, they are successful.",
            "∀x (GraduateStudent(x) ∧ Successful(x) → (Diligent(x) ∨ ExceptionallySkilled(x))) ::: If a graduate student is successful, then they are diligent or exceptionally skilled.",
            "∀x ∀y (Advisor(y, x) → Supports(y, x)) ::: All advisors support their students.",
            "∀x ∃y (GraduateStudent(x) → Advisor(y, x)) ::: Graduate students have advisors.",
            "∀x (GraduateStudent(x) ∧ Supports(y, x) → Successful(x)) ::: If a graduate student is supported, they are successful.",
            "∀x (Diligent(x) ∧ Dedicated(x) → Successful(x)) ::: If a student is diligent and dedicated, then that student is successful."
        ],
        "predicates": [
            "GraduateStudent(x) ::: x is a graduate student",
            "PublishesPaper(x) ::: x publishes a paper",
            "ConductsResearch(x) ::: x conducts research",
            "Supports(y, x) ::: y supports x",
            "Advisor(y, x) ::: y is the advisor of x",
            "ExceptionallySkilled(x) ::: x is exceptionally skilled",
            "Successful(x) ::: x is successful",
            "Diligent(x) ::: x is diligent",
            "Dedicated(x) ::: x is dedicated"
        ]
    },
    {
        "premises-NL": [
            "All students are either dedicated or struggle with difficult courses.",
            "There exists a course that is considered difficult.",
            "Difficult courses require significant effort.",
            "If a student is not dedicated and a course requires significant effort, the student will struggle.",
            "There exists a student who is enrolled in at least one course."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Dedicated(x) ∨ WillStruggle(x))) ::: All students are either dedicated or struggle.",
            "∃y DifficultCourse(y) ::: There exists a difficult course.",
            "∀y (DifficultCourse(y) → RequiresEffort(y)) ::: Difficult courses require effort.",
            "∀x ∀y ((Student(x) ∧ EnrolledIn(x, y) ∧ RequiresEffort(y) ∧ ¬Dedicated(x)) → WillStruggle(x)) ::: Students not dedicated will struggle.",
            "∃x ∃y (Student(x) ∧ EnrolledIn(x, y)) ::: There exists a student enrolled in a course."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in course y",
            "DifficultCourse(y) ::: y is a difficult course",
            "RequiresEffort(y) ::: y requires significant effort",
            "WillStruggle(x) ::: x will struggle to get a good grade"
        ]
    },
    {
        "premises-NL": [
            "All students are people.",
            "If a course is difficult then it requires effort.",
            "If a course requires effort, any student enrolled will be stressed.",
            "There exists a student enrolled in a course.",
            "There exists a difficult course."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Person(x)) ::: All students are people.",
            "∀y (DifficultCourse(y) → RequiresEffort(y)) ::: If a course is difficult then it requires effort.",
            "∀x ∀y ((Student(x) ∧ EnrolledIn(x, y) ∧ RequiresEffort(y)) → WillBeStressed(x)) ::: If a course requires effort, then any student enrolled will be stressed.",
            "∃x ∃y (Student(x) ∧ EnrolledIn(x, y)) ::: There exists a student enrolled in a course.",
            "∃y (DifficultCourse(y)) ::: There exists a difficult course."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in course y",
            "DifficultCourse(y) ::: y is a difficult course",
            "RequiresEffort(y) ::: y requires effort",
            "WillBeStressed(x) ::: x will be stressed"
        ]
    },
    {
        "premises-NL": [
            "All students must meet graduation requirements to graduate.",
            "If a student has overdue fees, they are not eligible to graduate.",
            "Overdue fees result in the student having debt.",
            "If a student has debt, they are not eligible to graduate.",
            "If a student has overdue fees, they must pay before graduation.",
            "To meet graduation requirements, a student must be registered.",
            "To meet graduation requirements, a student must have enough credits.",
            "Fees must be paid before a student can be registered.",
            "If a student is registered, and has enough credits, then they meet graduation requirements",
            "If a student has unpaid fees, they have overdue fees."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ EligibleToGraduate(x) → MeetsGraduationRequirements(x)) ::: All students must meet graduation requirements to graduate",
            "∀x (Student(x) ∧ OverdueFees(x) → ¬EligibleToGraduate(x)) ::: If a student has overdue fees, they are not eligible to graduate",
            "∀x (Student(x) ∧ OverdueFees(x) → HasDebt(x)) ::: Overdue fees result in the student having debt",
            "∀x (Student(x) ∧ HasDebt(x) → ¬EligibleToGraduate(x)) ::: If a student has debt, they are not eligible to graduate",
            "∀x (Student(x) ∧ OverdueFees(x) → Unpaid(x)) ::: If a student has overdue fees, they must pay before graduation",
            "∀x (Student(x) ∧ MeetsGraduationRequirements(x) → Registered(x)) ::: To meet graduation requirements, a student must be registered.",
            "∀x (Student(x) ∧ MeetsGraduationRequirements(x) → Credits(x)) ::: To meet graduation requirements, a student must have enough credits.",
            "∀x (Student(x) ∧ Unpaid(x) → ¬Registered(x)) ::: Fees must be paid before a student can be registered",
            "∀x ((Student(x) ∧ Registered(x) ∧ Credits(x)) → MeetsGraduationRequirements(x)) ::: If a student is registered, and has enough credits, then they meet graduation requirements",
            "∀x (Student(x) ∧ Unpaid(x) → OverdueFees(x)) ::: If a student has unpaid fees, they have overdue fees"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "MeetsGraduationRequirements(x) ::: x meets graduation requirements",
            "OverdueFees(x) ::: x has overdue fees",
            "EligibleToGraduate(x) ::: x is eligible to graduate",
            "TakesCourse(x, y) ::: x takes course y",
            "Course(y) ::: y is a course",
            "HasDebt(x) ::: x has debt",
            "Unpaid(x) ::: x is unpaid",
            "Registered(x) ::: x is registered",
            "Credits(x) ::: x has the credits"
        ]
    },
    {
        "premises-NL": [
            "All students are either studying or lazy.",
            "Not all students are lazy.",
            "If a student is not lazy, they are dedicated.",
            "If a student studies and is dedicated, they contribute to the university's reputation.",
            "A reputable university is a good university.",
            "The university's reputation is influenced by its students' dedication."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Studies(x) ∨ Lazy(x))) ::: Every student is either studying or lazy.",
            "∃x (Student(x) ∧ ¬Lazy(x)) ::: There exists a student who is not lazy.",
            "∀x (Student(x) ∧ ¬Lazy(x) → Dedicated(x)) ::: If a student is not lazy, they are dedicated.",
            "∀x (Student(x) ∧ Studies(x) ∧ Dedicated(x) → ContributesToReputation(x, university)) ::: If a student studies and is dedicated, they contribute to the university's reputation.",
            "∀x (ContributesToReputation(x, university) → Reputable(university)) ::: If someone contributes to university reputation, then the university is reputable",
            "GoodUniversity(university) ↔ Reputable(university) ::: A reputable university is a good university."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Studies(x) ::: x studies",
            "Dedicated(x) ::: x is dedicated",
            "Reputable(y) ::: y is reputable"
        ]
    },
    {
        "premises-NL": [
            "Some people who enjoy challenges can learn programming.",
            "Everyone who loves algorithms also enjoys challenges.",
            "Some people who seek perfection love algorithms.",
            "Everyone who is creative seeks perfection.",
            "Some people who are motivated are creative.",
            "Everyone who is persistent is motivated.",
            "Some people who solve problems are persistent.",
            "Everyone who can learn programming is able to solve problems.",
            "Not everyone who can learn programming practices regularly."
        ],
        "premises-FOL": [
            "∃x (EnjoysChallenges(x) ∧ CanLearnProgramming(x)) ::: Some people who enjoy challenges can learn programming.",
            "∀x (LovesAlgorithms(x) → EnjoysChallenges(x)) ::: Everyone who loves algorithms also enjoys challenges.",
            "∃x (SeeksPerfection(x) ∧ LovesAlgorithms(x)) ::: Some people who seek perfection love algorithms.",
            "∀x (IsCreative(x) → SeeksPerfection(x)) ::: Everyone who is creative seeks perfection.",
            "∃x (Motivated(x) ∧ IsCreative(x)) ::: Some people who are motivated are creative.",
            "∀x (Persistent(x) → Motivated(x)) ::: Everyone who is persistent is motivated.",
            "∃x (SolvesProblems(x) ∧ Persistent(x)) ::: Some people who solve problems are persistent.",
            "∀x (CanLearnProgramming(x) → SolvesProblems(x)) ::: Everyone who can learn programming is able to solve problems.",
            "∃x (CanLearnProgramming(x) ∧ ¬PracticesRegularly(x)) ::: Not everyone who can learn programming practices regularly."
        ],
        "predicates": [
            "CanLearnProgramming(x) ::: x can learn programming",
            "PracticesRegularly(x) ::: x practices regularly",
            "EnjoysChallenges(x) ::: x enjoys challenges",
            "LovesAlgorithms(x) ::: x loves algorithms",
            "SeeksPerfection(x) ::: x seeks perfection",
            "IsCreative(x) ::: x is creative",
            "Motivated(x) ::: x is motivated",
            "Persistent(x) ::: x is persistent",
            "SolvesProblems(x) ::: x solves problems"
        ]
    },
    {
        "premises-NL": [
            "All ambitious people are successful.",
            "All successful people are wealthy.",
            "Some wealthy people are not kind.",
            "All kind people are generous.",
            "Some generous people are not content.",
            "All content people are grateful.",
            "Some grateful people are not healthy.",
            "All healthy people are resourceful.",
            "Some resourceful people are not patient.",
            "All patient people are happy.",
            "Some ambitious individuals exist."
        ],
        "premises-FOL": [
            "∀x (Ambitious(x) → Successful(x)) ::: All ambitious people are successful.",
            "∀x (Successful(x) → Wealthy(x)) ::: All successful people are wealthy.",
            "∃x (Wealthy(x) ∧ ¬Kind(x)) ::: Some wealthy people are not kind.",
            "∀x (Kind(x) → Generous(x)) ::: All kind people are generous.",
            "∃x (Generous(x) ∧ ¬Content(x)) ::: Some generous people are not content.",
            "∀x (Content(x) → Grateful(x)) ::: All content people are grateful.",
            "∃x (Grateful(x) ∧ ¬Healthy(x)) ::: Some grateful people are not healthy.",
            "∀x (Healthy(x) → Resourceful(x)) ::: All healthy people are resourceful.",
            "∃x (Resourceful(x) ∧ ¬Patient(x)) ::: Some resourceful people are not patient.",
            "∀x (Patient(x) → Happy(x)) ::: All patient people are happy.",
            "∃x Ambitious(x) ::: Some ambitious individuals exist."
        ],
        "predicates": [
            "Ambitious(x) ::: x is ambitious",
            "Successful(x) ::: x is successful",
            "Happy(x) ::: x is happy",
            "Kind(x) ::: x is kind",
            "Generous(x) ::: x is generous",
            "Wealthy(x) ::: x is wealthy",
            "Content(x) ::: x is content",
            "Grateful(x) ::: x is grateful",
            "Healthy(x) ::: x is healthy",
            "Resourceful(x) ::: x is resourceful",
            "Patient(x) ::: x is patient"
        ]
    },
    {
        "premises-NL": [
            "Some students procrastinate.",
            "Everyone who procrastinates submits late.",
            "If a student submits late, they need an extension.",
            "If someone needs an extension, then they do not meets deadline.",
            "Students who procrastinate, do not meet deadline.",
            "Those that meet the deadline, complete assignment.",
            "Some students are organized.",
            "If someone is organized, they have good time management skills.",
            "If a student has good time management skills, they are an effective planner.",
            "If a student is an effective planner, they manage their time well.",
            "Every student that manages their time is a good student.",
            "All good students attend class.",
            "Every student attending class participates in activities."
        ],
        "premises-FOL": [
            "∃x (Student(x) ∧ Procrastinates(x)) ::: Some students procrastinate.",
            "∀x (Student(x) ∧ Procrastinates(x) → SubmitsLate(x)) ::: Everyone who procrastinates submits late.",
            "∀x (Student(x) ∧ SubmitsLate(x) → NeedsExtension(x)) ::: If a student submits late, they need an extension.",
            "∀x (NeedsExtension(x) → ¬MeetsDeadline(x)) ::: If someone needs an extension, then they do not meets deadline.",
            "∀x (Student(x) ∧ Procrastinates(x) → ¬MeetsDeadline(x)) ::: Students who procrastinate, do not meet deadline.",
            "∀x (MeetsDeadline(x) → CompletesAssignment(x)) ::: Those that meet the deadline, complete assignment.",
            "∃x (Student(x) ∧ Organized(x)) ::: Some students are organized.",
            "∀x (Student(x) ∧ Organized(x) → TimeManagementSkills(x)) ::: If someone is organized, they have good time management skills.",
            "∀x (Student(x) ∧ TimeManagementSkills(x) → EffectivePlanner(x)) ::: If a student has good time management skills, they are an effective planner.",
            "∀x (Student(x) ∧ EffectivePlanner(x) → ManagesTime(x)) ::: If a student is an effective planner, they manage their time well.",
            "∀x (Student(x) ∧ ManagesTime(x) → GoodStudent(x)) ::: Every student that manages their time is a good student.",
            "∀x (Student(x) ∧ GoodStudent(x) → AttendsClass(x)) ::: All good students attend class.",
            "∀x (Student(x) ∧ AttendsClass(x) → Participates(x)) ::: Every student attending class participates in activities."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Procrastinates(x) ::: x procrastinates",
            "MeetsDeadline(x) ::: x meets the deadline",
            "NeedsExtension(x) ::: x needs an extension",
            "SubmitsLate(x) ::: x submits late",
            "CompletesAssignment(x) ::: x completes assignment",
            "Organized(x) ::: x is organized",
            "TimeManagementSkills(x) ::: x has time management skills",
            "EffectivePlanner(x) ::: x is an effective planner",
            "ManagesTime(x) ::: x manages time",
            "GoodStudent(x) ::: x is a good student",
            "AttendsClass(x) ::: x attends class",
            "Participates(x) ::: x participates"
        ]
    },
    {
        "premises-NL": [
            "∀x (Student(x) → TakesCourse(x, 'CalculusI')) ::: All students take Calculus I.",
            "∀x ∀y (TakesCourse(x, y) ∧ PrerequisitesMet(x, y) → ¬FailsCourse(x, y)) ::: If a student takes a course and meets the prerequisites, then they do not fail the course.",
            "∀x (Student(x) → PrerequisitesMet(x, 'CalculusI')) ::: All students meet the prerequisites for Calculus I.",
            "∀x (Student(x) → Enrolled(x, 'CalculusI')) ::: All students are enrolled in Calculus I.",
            "∀x ∀y (Enrolled(x, y) ∧ ¬FailsCourse(x, y) → PassesCourse(x, y)) ::: If a student is enrolled in a course and does not fail the course, then they pass the course.",
            "∀x (PassesCourse(x, 'CalculusI') → ¬FailsMajorExam(x)) ::: If a student passes Calculus I, then they do not fail the major exam.",
            "∀x (Student(x) → Student(x)) ::: If x is a student, then x is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → TakesCourse(x, 'CalculusI')) ::: All students take Calculus I.",
            "∀x ∀y (TakesCourse(x, y) ∧ PrerequisitesMet(x, y) → ¬FailsCourse(x, y)) ::: If a student takes a course and meets the prerequisites, then they do not fail the course.",
            "∀x (Student(x) → PrerequisitesMet(x, 'CalculusI')) ::: All students meet the prerequisites for Calculus I.",
            "∀x (Student(x) → Enrolled(x, 'CalculusI')) ::: All students are enrolled in Calculus I.",
            "∀x ∀y (Enrolled(x, y) ∧ ¬FailsCourse(x, y) → PassesCourse(x, y)) ::: If a student is enrolled in a course and does not fail the course, then they pass the course.",
            "∀x (PassesCourse(x, 'CalculusI') → ¬FailsMajorExam(x)) ::: If a student passes Calculus I, then they do not fail the major exam.",
            "∀x (Student(x) → Student(x)) ::: If x is a student, then x is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "TakesCourse(x, y) ::: x takes course y",
            "PrerequisitesMet(x, y) ::: x has met the prerequisites for course y",
            "FailsCourse(x, y) ::: x fails course y",
            "FailsMajorExam(x) ::: x fails the major exam",
            "Enrolled(x, y) ::: x is enrolled in y",
            "PassesCourse(x, y) ::: x passes course y"
        ]
    },
    {
        "premises-NL": [
            "∀x (Professor(x) → Teaches(x, 'Logic')) ::: All professors teach Logic.",
            "∀x (Teaches(x, 'Logic') → Expert(x, 'Logic')) ::: If someone teaches Logic, they are an expert in Logic.",
            "∀x (Expert(x, 'Logic') → HighGPA(x)) ::: If someone is an expert in Logic, they have a high GPA.",
            "∀x (HighGPA(x) → Advises(x, 'Alice')) ::: If someone has a high GPA, they advise Alice.",
            "∀x (Advises(x, 'Alice') → Student('Alice')) ::: If someone advises Alice, then Alice is a student.",
            "∀x (Professor(x) → ¬TakesCourse(x, 'Quantum Physics')) ::: All professors do not take Quantum Physics.",
            "∀x (¬TakesCourse(x, 'Quantum Physics') → ¬TakesCourse(x, 'Underwater Basket Weaving')) ::: If someone does not take Quantum Physics, then they do not take Underwater Basket Weaving.",
            "∀x (Professor(x) → Professor(x)) ::: If x is a professor, then x is a professor."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Teaches(x, 'Logic')) ::: All professors teach Logic.",
            "∀x (Teaches(x, 'Logic') → Expert(x, 'Logic')) ::: If someone teaches Logic, they are an expert in Logic.",
            "∀x (Expert(x, 'Logic') → HighGPA(x)) ::: If someone is an expert in Logic, they have a high GPA.",
            "∀x (HighGPA(x) → Advises(x, 'Alice')) ::: If someone has a high GPA, they advise Alice.",
            "∀x (Advises(x, 'Alice') → Student('Alice')) ::: If someone advises Alice, then Alice is a student.",
            "∀x (Professor(x) → ¬TakesCourse(x, 'Quantum Physics')) ::: All professors do not take Quantum Physics.",
            "∀x (¬TakesCourse(x, 'Quantum Physics') → ¬TakesCourse(x, 'Underwater Basket Weaving')) ::: If someone does not take Quantum Physics, then they do not take Underwater Basket Weaving.",
            "∀x (Professor(x) → Professor(x)) ::: If x is a professor, then x is a professor."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches course y",
            "HighGPA(x) ::: x has a high GPA",
            "TakesCourse(x, y) ::: x takes course y",
            "Advises(x, y) ::: x advises student y",
            "Student(y) ::: y is a student",
            "Expert(x, z) ::: x is an expert in z",
            "Topic(z) ::: z is a topic"
        ]
    },
    {
        "premises-NL": [
            "∃x (Student(x) ∧ TakesCourse(x, 'Advanced Basket Weaving')) ::: There exists a student who takes Advanced Basket Weaving.",
            "∀x (Student(x) → (Lazy(x) ∨ Studies(x))) ::: All students are either lazy or they study.",
            "∀x (Lazy(x) → ¬Studies(x)) ::: If someone is lazy, then they do not study.",
            "∀x (¬Studies(x) → ¬PassesExam(x)) ::: If someone does not study, then they do not pass the exam.",
            "∀x (TakesCourse(x, 'Advanced Basket Weaving') → Enrolled(x, 'Advanced Basket Weaving')) ::: If someone takes Advanced Basket Weaving, they are enrolled in it.",
            "∀x (Enrolled(x, 'Advanced Basket Weaving') ∧ ¬PassesExam(x) → FailedCourse(x, 'Advanced Basket Weaving')) ::: If someone is enrolled in Advanced Basket Weaving and does not pass the exam, they failed the course.",
            "∃x (Student(x) ∧ Lazy(x)) ::: There exists a student who is lazy.",
            "∀x (FailsMajorExam(x) → FailsMajorExam(x)) ::: If x fails major exam, then x fails major exam.",
            "∀x (Student(x) → Student(x)) ::: If x is a student, then x is a student."
        ],
        "premises-FOL": [
            "∃x (Student(x) ∧ TakesCourse(x, 'Advanced Basket Weaving')) ::: There exists a student who takes Advanced Basket Weaving.",
            "∀x (Student(x) → (Lazy(x) ∨ Studies(x))) ::: All students are either lazy or they study.",
            "∀x (Lazy(x) → ¬Studies(x)) ::: If someone is lazy, then they do not study.",
            "∀x (¬Studies(x) → ¬PassesExam(x)) ::: If someone does not study, then they do not pass the exam.",
            "∀x (TakesCourse(x, 'Advanced Basket Weaving') → Enrolled(x, 'Advanced Basket Weaving')) ::: If someone takes Advanced Basket Weaving, they are enrolled in it.",
            "∀x (Enrolled(x, 'Advanced Basket Weaving') ∧ ¬PassesExam(x) → FailedCourse(x, 'Advanced Basket Weaving')) ::: If someone is enrolled in Advanced Basket Weaving and does not pass the exam, they failed the course.",
            "∃x (Student(x) ∧ Lazy(x)) ::: There exists a student who is lazy.",
            "∀x (FailsMajorExam(x) → FailsMajorExam(x)) ::: If x fails major exam, then x fails major exam.",
            "∀x (Student(x) → Student(x)) ::: If x is a student, then x is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "TakesCourse(x, y) ::: x takes course y",
            "PrerequisitesMet(x, y) ::: x has met the prerequisites for course y",
            "FailedCourse(x, y) ::: x failed course y",
            "Enrolled(x, y) ::: x is enrolled in y",
            "Lazy(x) ::: x is lazy",
            "Studies(x) ::: x studies",
            "PassesExam(x) ::: x passes exam",
            "FailsMajorExam(x) ::: x fails major exam"
        ]
    },
    {
        "premises-NL": [
            "∀x (Applies(x) → (Qualified(x) ∨ ¬Qualified(x))) ::: Everyone who applies is either qualified or not qualified.",
            "∀x (Qualified(x) → ¬Rejected(x)) ::: If someone is qualified, they are not rejected.",
            "∀x (Applies(x) ∧ ¬Qualified(x) → Rejected(x)) ::: If someone applies and is not qualified, they are rejected.",
            "∀x (Qualified(x) → Studies(x)) ::: If someone is qualified, they study.",
            "∀x (Studies(x) → Hardworking(x)) ::: If someone studies, they are hardworking.",
            "∀x (Hardworking(x) → TakesCourse(x, 'CS101')) ::: If someone is hardworking, they take CS101.",
            "∀x (TakesCourse(x, 'CS101') → Enrolled(x, 'CS101')) ::: If someone takes CS101, they are enrolled in CS101.",
            "∀x (Rejected(x) → ¬Enrolled(x, 'CS101')) ::: If someone is rejected, they are not enrolled in CS101.",
            "∀x (Applies(x) → Applies(x)) ::: If x applies, then x applies.",
            "∀x (Student(x) → Student(x)) ::: If x is a student, then x is a student."
        ],
        "premises-FOL": [
            "∀x (Applies(x) → (Qualified(x) ∨ ¬Qualified(x))) ::: Everyone who applies is either qualified or not qualified.",
            "∀x (Qualified(x) → ¬Rejected(x)) ::: If someone is qualified, they are not rejected.",
            "∀x (Applies(x) ∧ ¬Qualified(x) → Rejected(x)) ::: If someone applies and is not qualified, they are rejected.",
            "∀x (Qualified(x) → Studies(x)) ::: If someone is qualified, they study.",
            "∀x (Studies(x) → Hardworking(x)) ::: If someone studies, they are hardworking.",
            "∀x (Hardworking(x) → TakesCourse(x, 'CS101')) ::: If someone is hardworking, they take CS101.",
            "∀x (TakesCourse(x, 'CS101') → Enrolled(x, 'CS101')) ::: If someone takes CS101, they are enrolled in CS101.",
            "∀x (Rejected(x) → ¬Enrolled(x, 'CS101')) ::: If someone is rejected, they are not enrolled in CS101.",
            "∀x (Applies(x) → Applies(x)) ::: If x applies, then x applies.",
            "∀x (Student(x) → Student(x)) ::: If x is a student, then x is a student."
        ],
        "predicates": [
            "Applies(x) ::: x applies to the university",
            "Qualified(x) ::: x is qualified",
            "Rejected(x) ::: x is rejected",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "Attends(x, y) ::: x attends course y",
            "TakesCourse(x, y) ::: x takes course y",
            "Advisor(x, y) ::: x is an advisor of y",
            "Studies(x) ::: x studies",
            "Hardworking(x) ::: x is hardworking",
            "PassesCourse(x, y) ::: x passes course y"
        ]
    },
    {
        "premises-NL": [
            "All students are people.",
            "If someone fails a course, they have not passed it.",
            "If a student takes CS101 and fails it, they are eligible for a retake.",
            "John is a student.",
            "John takes CS101.",
            "John failed CS101.",
            "CS101 is a course."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Person(x)) ::: All students are people.",
            "∀x ∀y (Failed(x, y) → ¬Passed(x, y)) ::: If someone fails a course, they have not passed it.",
            "∀x (Student(x) ∧ Takes(x, cs101) ∧ Failed(x, cs101) → EligibleForRetake(x, cs101)) ::: If a student takes CS101 and fails it, they are eligible for a retake.",
            "Student(john) ::: John is a student.",
            "Takes(john, cs101) ::: John takes CS101.",
            "Failed(john, cs101) ::: John failed CS101.",
            "Course(cs101) ::: CS101 is a course."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Takes(x, y) ::: x takes course y",
            "Failed(x, y) ::: x failed course y",
            "EligibleForRetake(x, y) ::: x is eligible for a retake of course y",
            "Passed(x, y) ::: x passed course y",
            "Prerequisite(x, y) ::: x is a prerequisite for y"
        ]
    },
    {
        "premises-NL": [
            "All professors are employees.",
            "If someone is a professor, they have a high salary.",
            "If someone is tenured, they are unavailable on Mondays.",
            "Professor Smith is tenured.",
            "Professor Smith teaches Math201.",
            "Professor Smith is a professor.",
            "Math201 is a course.",
            "All professors are in the Math department."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Employee(x)) ::: All professors are employees.",
            "∀x (Professor(x) → HighSalary(x)) ::: If someone is a professor, they have a high salary.",
            "∀x (Tenured(x) → ¬Available(x, monday)) ::: If someone is tenured, they are unavailable on Mondays.",
            "Tenured(smith) ::: Professor Smith is tenured.",
            "Teaches(smith, math201) ::: Professor Smith teaches Math201.",
            "Professor(smith) ::: Professor Smith is a professor.",
            "Course(math201) ::: Math201 is a course.",
            "∀x (Professor(x) → Department(x, math)) ::: All professors are in the Math department."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches course y",
            "Available(x, y) ::: x is available on day y",
            "Course(x) ::: x is a course",
            "HighSalary(x) ::: x has a high salary",
            "Tenured(x) ::: x is tenured",
            "Department(x, y) ::: x is in department y"
        ]
    },
    {
        "premises-NL": [
            "All students are learners.",
            "If a student is enrolled in a course and fails an exam required for the course, they have not passed the course.",
            "Exam A is required for course A.",
            "John is a student.",
            "John is enrolled in course A.",
            "John takes exam A.",
            "John does not pass exam A.",
            "Course A is a course.",
            "Exam A is an exam.",
            "All students must be registered for any course they are enrolled in."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Learner(x)) ::: All students are learners.",
            "∀x ∀y ∀z (Student(x) ∧ Enrolled(x, y) ∧ Requires(y, z) ∧ TakesExam(x, z) ∧ ¬PassesExam(x, z) → ¬HasPassed(x, y)) ::: If a student is enrolled in a course and fails an exam required for the course, they have not passed the course.",
            "Requires(courseA, examA) ::: Exam A is required for course A.",
            "Student(john) ::: John is a student.",
            "Enrolled(john, courseA) ::: John is enrolled in course A.",
            "TakesExam(john, examA) ::: John takes exam A.",
            "¬PassesExam(john, examA) ::: John does not pass exam A.",
            "Course(courseA) ::: Course A is a course.",
            "Exam(examA) ::: Exam A is an exam.",
            "∀x ∀y (Student(x) ∧ Enrolled(x, y) → Registered(x, y)) ::: All students must be registered for any course they are enrolled in."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "HasPassed(x, y) ::: x has passed course y",
            "TakesExam(x, y) ::: x takes exam y",
            "PassesExam(x, y) ::: x passes exam y",
            "Course(x) ::: x is a course",
            "Exam(x) ::: x is an exam",
            "Requires(x, y) ::: course x requires exam y",
            "Prerequisite(x, y) ::: x is a prerequisite for y",
            "Registered(x, y) ::: student x is registered for course y"
        ]
    },
    {
        "premises-NL": [
            "All students must maintain a certain GPA to remain in good standing.",
            "Athletes must maintain a certain GPA to be eligible for sports.",
            "Students with a low GPA are placed on academic probation.",
            "Students on academic probation need an academic advisor.",
            "Academic advisors help students improve their GPA.",
            "Athletes have mandatory training schedules.",
            "Maintaining GPA is required for all the students.",
            "Athletes need to balance their training schedules with academics.",
            "Students with an academic advisor attend mandatory meetings.",
            "Not all students with low GPAs are athletes.",
            "Being an athlete implies that the student is part of a team.",
            "Some students are not athletes."
        ],
        "premises-FOL": [
            "∀x (Student(x) → MaintainGoodStanding(x)) ::: All students must maintain a certain GPA to remain in good standing.",
            "∀x (Athlete(x) → EligibleForSports(x)) ::: Athletes must maintain a certain GPA to be eligible for sports.",
            "∀x (LowGPA(x) → AcademicProbation(x)) ::: Students with a low GPA are placed on academic probation.",
            "∀x (AcademicProbation(x) → NeedsAcademicAdvisor(x)) ::: Students on academic probation need an academic advisor.",
            "∀x (NeedsAcademicAdvisor(x) → HelpsImproveGPA(x)) ::: Academic advisors help students improve their GPA.",
            "∀x (Athlete(x) → HasTrainingSchedule(x)) ::: Athletes have mandatory training schedules.",
            "∀x (Student(x) → RequiredToMaintainGPA(x)) ::: Maintaining GPA is required for all the students.",
            "∀x (Athlete(x) → BalanceTrainingWithAcademics(x)) ::: Athletes need to balance their training schedules with academics.",
            "∀x (NeedsAcademicAdvisor(x) → AttendMandatoryMeetings(x)) ::: Students with an academic advisor attend mandatory meetings.",
            "∃x (LowGPA(x) ∧ ¬Athlete(x)) ::: Not all students with low GPAs are athletes.",
            "∀x (Athlete(x) → PartOfTeam(x)) ::: Being an athlete implies that the student is part of a team.",
            "∃x ¬Athlete(x) ::: Some students are not athletes."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "LowGPA(x) ::: x has a low GPA",
            "Athlete(x) ::: x is an athlete",
            "NeedsAcademicAdvisor(x) ::: x needs an academic advisor",
            "EligibleForSports(x) ::: x is eligible for sports",
            "AttendMandatoryMeetings(x) ::: x attends mandatory meetings"
        ]
    },
    {
        "premises-NL": [
            "All students enrolled in a course with a failing grade are notified if the course requires remediation.",
            "If a student takes remediation for a course, then they are enrolled in that course.",
            "Course policy states that any student enrolled in a course with a failing grade, if that course requires remediation, they must take remediation.",
            "There is a student who is enrolled in a course and has a failing grade.",
            "Course A requires remediation.",
            "John is a student",
            "Policy A applies"
        ],
        "premises-FOL": [
            "∀x ∀y (Student(x) ∧ EnrolledIn(x, y) ∧ FailingGrade(x, y) ∧ RequiresRemediation(y) → Notified(x)) ::: For all students x and courses y, if x is a student enrolled in course y, has a failing grade in course y, and course y requires remediation, then x is notified.",
            "∀x ∀y (TakesRemediation(x, y) → EnrolledIn(x, y)) ::: If x takes remediation for course y, then x is enrolled in course y.",
            "∀x ∀y (Student(x) ∧ EnrolledIn(x, y) ∧ FailingGrade(x, y) ∧ RequiresRemediation(y) ∧ PolicyApplies(z) → TakesRemediation(x, y)) ::: For all students x and courses y, if x is a student enrolled in course y and has a failing grade and the course requires remediation and Policy z applies, then x takes remediation for course y.",
            "∃x ∃y (Student(x) ∧ EnrolledIn(x, y) ∧ FailingGrade(x, y)) ::: There exists a student x enrolled in a course y who has a failing grade.",
            "RequiresRemediation(courseA) ::: Course A requires remediation.",
            "Student(john) ::: John is a student",
            "PolicyApplies(policyA) ::: Policy A applies"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in course y",
            "FailingGrade(x, y) ::: x has a failing grade in course y",
            "RequiresRemediation(y) ::: Course y requires remediation",
            "TakesRemediation(x, y) ::: x takes remediation for course y",
            "Notified(x) ::: x is notified",
            "PolicyApplies(x) ::: policy x applies"
        ]
    },
    {
        "premises-NL": [
            "All students are students.",
            "If a student meets all requirements, then they are eligible for graduation.",
            "If a student is eligible for graduation and has completed all required courses and has paid all tuition fees, then the student is expected to graduate.",
            "Graduation requires that the student has a clear account.",
            "Account holds prevents graduation.",
            "If a student is in good standing and meets all academic requirements then he is graduating.",
            "If a student has a good standing, then the student has paid all fees and meets all academic requirements",
            "Exception cases are possible if they are evaluated by the dean.",
            "Some students have account holds"
        ],
        "premises-FOL": [
            "∀x Student(x) ::: All x are students.",
            "∀x (Student(x) ∧ MeetsAllRequirements(x) → EligibleForGraduation(x)) ::: If x is a student and meets all requirements, then x is eligible for graduation.",
            "∀x (Student(x) ∧ EligibleForGraduation(x) ∧ CompletedAllCourses(x) ∧ PaidAllFees(x) → Graduates(x)) ::: If x is a student and eligible for graduation and has completed all required courses and has paid all tuition fees, then x graduates.",
            "∀x (Graduates(x) → ¬AccountHold(x)) ::: Graduation requires that the student has a clear account.",
            "∀x (AccountHold(x) → ¬Graduates(x)) ::: Account holds prevents graduation.",
            "∀x (HasGoodStanding(x) ∧ MeetsAllRequirements(x) → Graduates(x)) ::: If a student is in good standing and meets all academic requirements then he is graduating.",
            "∀x (HasGoodStanding(x) → PaidAllFees(x) ∧ MeetsAllRequirements(x)) ::: If a student has a good standing, then the student has paid all fees and meets all academic requirements.",
            "∀x ExceptionGranted(x) ::: Exception cases are possible if they are evaluated by the dean.",
            "∃x AccountHold(x) ::: Some students have account holds."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EligibleForGraduation(x) ::: x is eligible for graduation",
            "CompletedAllCourses(x) ::: x has completed all required courses",
            "PaidAllFees(x) ::: x has paid all tuition fees",
            "Graduates(x) ::: x graduates",
            "AccountHold(x) ::: there is a hold on x's account",
            "ExceptionGranted(x) ::: an exception is granted for x",
            "MeetsAllRequirements(x) ::: x meets all academic requirements",
            "HasGoodStanding(x) ::: x is in good standing"
        ]
    },
    {
        "premises-NL": [
            "All students are students.",
            "If a student enrolls in a course that has a lab component, then the student needs to pass the lab to pass the course.",
            "If a student fails the lab, then the student fails the course.",
            "Attending lab is required if enrolled.",
            "The exception has a formal process",
            "John is a student",
            "John enrolled in the course A",
            "Course A has a lab component.",
            "John fails the lab",
            "John attends the lectures",
            "To enroll, a student must be registered and have the prequisites"
        ],
        "premises-FOL": [
            "∀x Student(x) ::: All x are students.",
            "∀x ∀y (Student(x) ∧ EnrolledIn(x, y) ∧ HasLabComponent(y) → NeedsToPassLab(x, y)) ::: If x is a student and enrolled in course y and course y has a lab component, then x needs to pass the lab to pass the course.",
            "∀x ∀y (Student(x) ∧ FailsLab(x, y) → FailsCourse(x, y)) ::: If x fails the lab, then x fails the course.",
            "∀x ∀y (Student(x) ∧ EnrolledIn(x,y) → AttendingLab(x,y)) ::: Attending lab is required if enrolled.",
            "∀x ExceptionFromProfessor(x, y) ::: The exception has a formal process",
            "Student(john) ::: John is a student",
            "EnrolledIn(john, courseA) ::: John enrolled in the course A",
            "HasLabComponent(courseA) ::: Course A has a lab component.",
            "FailsLab(john, courseA) ::: John fails the lab",
            "AttendsLectures(john,courseA) ::: John attends the lectures",
            "∀x ∀y (EnrolledIn(x,y) → Registered(x,y) ∧ PrerequisitesMet(x,y)) ::: To enroll, a student must be registered and have the prequisites"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in course y",
            "HasLabComponent(y) ::: course y has a lab component",
            "FailsLab(x, y) ::: x fails the lab for course y",
            "FailsCourse(x, y) ::: x fails course y",
            "ExceptionFromProfessor(x, y) ::: the professor gives x an exception for course y",
            "AttendingLab(x,y) ::: x is attending lab for y",
            "NeedsToPassLab(x,y) ::: x needs to pass the lab for course y",
            "AttendsLectures(x,y) ::: x attends the lectures for course y",
            "Registered(x,y) ::: x is registered in y",
            "PrerequisitesMet(x,y) ::: x has met prerequisites for y"
        ]
    },
    {
        "premises-NL": [
            "All students are motivated.",
            "If a student is motivated and disciplined, they study hard.",
            "If a student studies hard, they attend office hours.",
            "If a student attends office hours, they complete assignments.",
            "If a student completes assignments and passes exams, they receive good grades.",
            "If a student receives good grades, they have a good GPA.",
            "If a student participates in research, they take challenging courses.",
            "All motivated students are disciplined.",
            "If a student studies hard, they participates in research.",
            "If a student is motivated, they complete assignments.",
            "If a student completes assignments, they passes exams.",
            "If a student is disciplined, they passes exams."
        ],
        "premises-FOL": [
            "∀x (Student(x) → IsMotivated(x)) ::: All students are motivated.",
            "∀x (IsMotivated(x) ∧ IsDisciplined(x) → StudiesHard(x)) ::: If a student is motivated and disciplined, they study hard.",
            "∀x (StudiesHard(x) → AttendsOfficeHours(x)) ::: If a student studies hard, they attend office hours.",
            "∀x (AttendsOfficeHours(x) → CompletesAssignments(x)) ::: If a student attends office hours, they complete assignments.",
            "∀x (CompletesAssignments(x) ∧ PassesExams(x) → ReceivesGoodGrades(x)) ::: If a student completes assignments and passes exams, they receive good grades.",
            "∀x (ReceivesGoodGrades(x) → HasGoodGPA(x)) ::: If a student receives good grades, they have a good GPA.",
            "∀x (ParticipatesInResearch(x) → TakesChallengingCourses(x)) ::: If a student participates in research, they take challenging courses.",
            "∀x (IsMotivated(x) → IsDisciplined(x)) ::: All motivated students are disciplined.",
            "∀x (StudiesHard(x) → ParticipatesInResearch(x)) ::: If a student studies hard, they participates in research.",
            "∀x (IsMotivated(x) → CompletesAssignments(x)) ::: If a student is motivated, they complete assignments.",
            "∀x (CompletesAssignments(x) → PassesExams(x)) ::: If a student completes assignments, they passes exams.",
            "∀x (IsDisciplined(x) → PassesExams(x)) ::: If a student is disciplined, they passes exams."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "HasGoodGPA(x) ::: x has a good GPA",
            "TakesChallengingCourses(x) ::: x takes challenging courses",
            "EligibleForHonors(x) ::: x is eligible for honors",
            "StudiesHard(x) ::: x studies hard",
            "AttendsOfficeHours(x) ::: x attends office hours",
            "ParticipatesInResearch(x) ::: x participates in research",
            "CompletesAssignments(x) ::: x completes assignments",
            "PassesExams(x) ::: x passes exams",
            "ReceivesGoodGrades(x) ::: x receives good grades",
            "IsMotivated(x) ::: x is motivated",
            "IsDisciplined(x) ::: x is disciplined"
        ]
    },
    {
        "premises-NL": [
            "All teaching assistants communicate effectively.",
            "If a TA communicates effectively, they are prepared.",
            "If a TA is prepared, they grade fairly.",
            "If a TA grades fairly, they provide helpful feedback.",
            "Students attend lectures.",
            "If a student attends lectures, they do assignments.",
            "If a student does assignments, they study regularly.",
            "If a student studies regularly, they attend recitation.",
            "If a student attends recitation, they ask questions.",
            "If a student asks questions, they understand concepts.",
            "If students understand concepts, they perform well in the course.",
            "If a TA is prepared, they are engaged.",
            "If a TA is engaged, they communicates effectively."
        ],
        "premises-FOL": [
            "∀x (TeachingAssistant(x) → CommunicatesEffectively(x)) ::: All teaching assistants communicate effectively.",
            "∀x (CommunicatesEffectively(x) → IsPrepared(x)) ::: If a TA communicates effectively, they are prepared.",
            "∀x (IsPrepared(x) → GradesFairly(x)) ::: If a TA is prepared, they grade fairly.",
            "∀x (GradesFairly(x) → ProvidesHelpfulFeedback(x)) ::: If a TA grades fairly, they provide helpful feedback.",
            "∀x (Student(x) → AttendsLectures(x)) ::: Students attend lectures.",
            "∀x (AttendsLectures(x) → DoesAssignments(x)) ::: If a student attends lectures, they do assignments.",
            "∀x (DoesAssignments(x) → StudiesRegularly(x)) ::: If a student does assignments, they study regularly.",
            "∀x (StudiesRegularly(x) → AttendsRecitation(x)) ::: If a student studies regularly, they attend recitation.",
            "∀x (AttendsRecitation(x) → AsksQuestions(x)) ::: If a student attends recitation, they ask questions.",
            "∀x (AsksQuestions(x) → UnderstandsConcepts(x)) ::: If a student asks questions, they understand concepts.",
            "∀x (UnderstandsConcepts(x) → StudentsPerformWell(x)) ::: If students understand concepts, they perform well in the course.",
            "∀x (IsPrepared(x) → IsEngaged(x)) ::: If a TA is prepared, they are engaged.",
            "∀x (IsEngaged(x) → CommunicatesEffectively(x)) ::: If a TA is engaged, they communicates effectively."
        ],
        "predicates": [
            "TeachingAssistant(x) ::: x is a teaching assistant",
            "GradesFairly(x) ::: x grades fairly",
            "ProvidesHelpfulFeedback(x) ::: x provides helpful feedback",
            "StudentsPerformWell(x) ::: students perform well under x",
            "AttendsRecitation(x) ::: x attends recitation",
            "AsksQuestions(x) ::: x asks questions",
            "UnderstandsConcepts(x) ::: x understands concepts",
            "StudiesRegularly(x) ::: x studies regularly",
            "DoesAssignments(x) ::: x does assignments",
            "AttendsLectures(x) ::: x attends lectures",
            "IsPrepared(x) ::: x is prepared",
            "IsEngaged(x) ::: x is engaged",
            "CommunicatesEffectively(x) ::: x communicates effectively"
        ]
    },
    {
        "premises-NL": [
            "All students set academic goals.",
            "If a student sets academic goals and is organized, they manage their time well.",
            "If a student manages their time well, they attend all classes.",
            "If a student attends all classes, they complete all homework.",
            "If a student completes all homework, they are diligent.",
            "If a student is diligent, they are focused.",
            "If a student is focused, they reviews material regularly.",
            "If a student reviews material regularly, they asks questions in class.",
            "If a student asks questions in class, they seeks help when needed.",
            "If a student seeks help when needed, they participates in study groups.",
            "If a student participates in study groups, they uses resources effectively.",
            "If a student uses resources effectively, they manages time well.",
            "If a student is organized, they attends all classes.",
            "If a student is organized, they are diligent."
        ],
        "premises-FOL": [
            "∀x (Student(x) → SetsAcademicGoals(x)) ::: All students set academic goals.",
            "∀x (SetsAcademicGoals(x) ∧ IsOrganized(x) → ManagesTimeWell(x)) ::: If a student sets academic goals and is organized, they manage their time well.",
            "∀x (ManagesTimeWell(x) → AttendsAllClasses(x)) ::: If a student manages their time well, they attend all classes.",
            "∀x (AttendsAllClasses(x) → CompletesAllHomework(x)) ::: If a student attends all classes, they complete all homework.",
            "∀x (CompletesAllHomework(x) → Diligent(x)) ::: If a student completes all homework, they are diligent.",
            "∀x (Diligent(x) → IsFocused(x)) ::: If a student is diligent, they are focused.",
            "∀x (IsFocused(x) → ReviewsMaterialRegularly(x)) ::: If a student is focused, they reviews material regularly.",
            "∀x (ReviewsMaterialRegularly(x) → AsksQuestionsInClass(x)) ::: If a student reviews material regularly, they asks questions in class.",
            "∀x (AsksQuestionsInClass(x) → SeeksHelpWhenNeeded(x)) ::: If a student asks questions in class, they seeks help when needed.",
            "∀x (SeeksHelpWhenNeeded(x) → ParticipatesInStudyGroups(x)) ::: If a student seeks help when needed, they participates in study groups.",
            "∀x (ParticipatesInStudyGroups(x) → UsesResourcesEffectively(x)) ::: If a student participates in study groups, they uses resources effectively.",
            "∀x (UsesResourcesEffectively(x) → ManagesTimeWell(x)) ::: If a student uses resources effectively, they manages time well.",
            "∀x (IsOrganized(x) → AttendsAllClasses(x)) ::: If a student is organized, they attends all classes.",
            "∀x (IsOrganized(x) → Diligent(x)) ::: If a student is organized, they are diligent."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Diligent(x) ::: x is diligent",
            "UsesResourcesEffectively(x) ::: x uses resources effectively",
            "SucceedsAcademically(x) ::: x succeeds academically",
            "AttendsAllClasses(x) ::: x attends all classes",
            "CompletesAllHomework(x) ::: x completes all homework",
            "SeeksHelpWhenNeeded(x) ::: x seeks help when needed",
            "ParticipatesInStudyGroups(x) ::: x participates in study groups",
            "ManagesTimeWell(x) ::: x manages time well",
            "SetsAcademicGoals(x) ::: x sets academic goals",
            "ReviewsMaterialRegularly(x) ::: x reviews material regularly",
            "IsOrganized(x) ::: x is organized",
            "IsFocused(x) ::: x is focused",
            "AsksQuestionsInClass(x) ::: x asks questions in class"
        ]
    },
    {
        "premises-NL": [
            "All students are either smart or require effort.",
            "If a student takes a course and that course requires effort, then the student attends that course.",
            "If a student attends a course, then that student takes that course.",
            "All difficult courses require effort.",
            "There exists a student.",
            "If a student attends a course then they pass it or fail it.",
            "No student fails a course that they pass.",
            "There is a difficult course."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Smart(x) ∨ RequiresEffort(x))) ::: All students are either smart or require effort.",
            "∀x ∀y ((Student(x) ∧ Takes(x, y) ∧ RequiresEffort(y)) → Attends(x, y)) ::: If a student takes a course and that course requires effort, then the student attends that course.",
            "∀x ∀y (Attends(x, y) → Takes(x, y)) ::: If a student attends a course, then that student takes that course.",
            "∀y (DifficultCourse(y) → RequiresEffort(y)) ::: All difficult courses require effort.",
            "∃x Student(x) ::: There exists a student.",
            "∀x ∀y (Attends(x, y) → (Passes(x,y) ∨ Fails(x,y))) ::: If a student attends a course then they pass it or fail it.",
            "∀x ∀y ¬(Passes(x,y) ∧ Fails(x,y)) ::: No student fails a course that they pass.",
            "∃y DifficultCourse(y) ::: There is a difficult course."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Takes(x, y) ::: x takes course y",
            "DifficultCourse(y) ::: y is a difficult course",
            "Passes(x,y) ::: x passes y",
            "RequiresEffort(y) ::: y requires effort",
            "Smart(x) ::: x is smart",
            "Attends(x, y) ::: x attends y"
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled in the university.",
            "If a student takes Calculus and passes, they are proficient in Mathematics.",
            "To graduate, a student must be proficient in Mathematics.",
            "To be proficient in Mathematics, a student needs to have at least 120 credits.",
            "John is a student.",
            "John took Calculus.",
            "John passed Calculus."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x, University)) ::: All students are enrolled in the university.",
            "∀x (Student(x) ∧ Took(x, Calculus) ∧ Passed(x, Calculus) → Proficient(x, Mathematics)) ::: If a student takes Calculus and passes, they are proficient in Mathematics.",
            "∀x (Student(x) ∧ Eligible(x) → Proficient(x, Mathematics)) ::: To graduate, a student must be proficient in Mathematics.",
            "∀x (Proficient(x, Mathematics) → HasCredits(x, 120)) ::: To be proficient in Mathematics, a student needs to have at least 120 credits.",
            "Student(John) ::: John is a student.",
            "Took(John, Calculus) ::: John took Calculus.",
            "Passed(John, Calculus) ::: John passed Calculus."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Took(x, y) ::: x took course y",
            "Passed(x, y) ::: x passed course y",
            "Proficient(x, y) ::: x is proficient in y",
            "Requires(x, y) ::: x requires course y",
            "HasCredits(x, y) ::: x has y credits",
            "Eligible(x) ::: x is eligible to graduate"
        ]
    },
    {
        "premises-NL": [
            "All students enrolled in CS101 take CS101.",
            "If someone takes CS101, they are enrolled in CS101.",
            "To pass CS101, one must pass the exam or be exceptionally proficient in labs.",
            "If a student is enrolled in a course, they take the exam.",
            "Everyone who passes the exam for CS101 passes the exam.",
            "If someone is enrolled in CS101 and passes the exam for CS101, then they pass CS101."
        ],
        "premises-FOL": [
            "∀x (Enrolled(x, CS101) → Takes(x, CS101)) ::: All students enrolled in CS101 take CS101.",
            "∀x (Takes(x, CS101) → Enrolled(x, CS101)) ::: If someone takes CS101, they are enrolled in CS101.",
            "∀x ((Takes(x, CS101)) → (PassesExam(x, CS101) ∨ ExceptionallyProficientInLabs(x, CS101))) ::: To pass CS101, one must pass the exam or be exceptionally proficient in labs.",
            "∀x ∀y (Enrolled(x, y) → TakesExam(x, y)) ::: If a student is enrolled in a course, they take the exam.",
            "∀x (PassesExam(x, CS101) → PassesExam(x, CS101)) ::: Everyone who passes the exam for CS101 passes the exam.",
            "∀x ((Enrolled(x, CS101) ∧ PassesExam(x, CS101)) → PassesCourse(x, CS101)) ::: If someone is enrolled in CS101 and passes the exam for CS101, then they pass CS101."
        ],
        "predicates": [
            "Enrolled(x, y) ::: x is enrolled in course y",
            "Takes(x, y) ::: x takes course y",
            "PassesExam(x, y) ::: x passes the exam for course y",
            "PassesCourse(x, y) ::: x passes course y",
            "HardCourse(y) ::: Course y is a hard course",
            "Studies(x, y) ::: x studies for course y"
        ]
    },
    {
        "premises-NL": [
            "All graduate students must study.",
            "If a graduate student does not complete their thesis on time or does not attend required seminars, they will not graduate.",
            "If a graduate student does not graduate, they will not get a job.",
            "All intelligent students pass exams.",
            "If a student works hard, they complete their thesis on time.",
            "Hard work helps",
            "Intelligence matters.",
            "Seminars are required.",
            "If you don't pass your exams you cannot be a graduate student.",
            "Graduation is important"
        ],
        "premises-FOL": [
            "∀x (GradStudent(x) → Studies(x)) ::: All graduate students must study.",
            "∀x (GradStudent(x) ∧ (¬CompletesThesisOnTime(x) ∨ ¬AttendsSeminars(x)) → ¬Graduates(x)) ::: If a graduate student does not complete their thesis on time or does not attend required seminars, they will not graduate.",
            "∀x (GradStudent(x) ∧ ¬Graduates(x) → ¬GetsJob(x)) ::: If a graduate student does not graduate, they will not get a job.",
            "∀x (Intelligent(x) → PassesExams(x)) ::: All intelligent students pass exams.",
            "∀x (WorksHard(x) → CompletesThesisOnTime(x)) ::: If a student works hard, they complete their thesis on time.",
            "∀x (WorksHard(x) → Helps(x)) ::: Hard work helps",
            "∀x (Intelligent(x) → Matters(x)) ::: Intelligence matters.",
            "∀x (AttendsSeminars(x) → Required(x)) ::: Seminars are required.",
            "∀x (¬PassesExams(x) → ¬GradStudent(x)) ::: If you don't pass your exams you cannot be a graduate student.",
            "∀x (Graduates(x) → Important(x)) ::: Graduation is important"
        ],
        "predicates": [
            "GradStudent(x) ::: x is a graduate student",
            "CompletesThesisOnTime(x) ::: x completes their thesis on time",
            "AttendsSeminars(x) ::: x attends required seminars",
            "Graduates(x) ::: x graduates",
            "GetsJob(x) ::: x gets a job",
            "Studies(x) ::: x studies",
            "Intelligent(x) ::: x is intelligent",
            "WorksHard(x) ::: x works hard",
            "PassesExams(x) ::: x passes exams"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard are either intelligent or not intelligent.",
            "If a student studies hard and takes a difficult course, they either pass or fail.",
            "If a student studies hard, attends the course, and asks questions, they are intelligent.",
            "If a student fails a difficult course, they are still eligible for a scholarship.",
            "If a student is eligible for a scholarship and is intelligent, they get a scholarship.",
            "All students enrolled in a course takes that course.",
            "Some courses are difficult.",
            "Some students study hard.",
            "If a student attends a course, they are enrolled in that course.",
            "If a student studies hard and takes a course, they attend that course.",
            "Some students ask questions in the courses they take.",
            "If a student gets a scholarship, they are a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) → (Intelligent(x) ∨ ¬Intelligent(x))) ::: All students who study hard are either intelligent or not intelligent.",
            "∀x ∀y (Student(x) ∧ StudiesHard(x) ∧ Takes(x, y) ∧ Difficult(y) → (Passes(x) ∨ Fails(x))) ::: If a student studies hard and takes a difficult course, they either pass or fail.",
            "∀x ∀y (Student(x) ∧ StudiesHard(x) ∧ Attends(x, y) ∧ AsksQuestions(x, y) → Intelligent(x)) ::: If a student studies hard, attends the course, and asks questions, they are intelligent.",
            "∀x ∀y (Student(x) ∧ Takes(x, y) ∧ Difficult(y) ∧ Fails(x) → EligibleForScholarship(x)) ::: If a student fails a difficult course, they are still eligible for a scholarship.",
            "∀x (EligibleForScholarship(x) ∧ Intelligent(x) → GetsScholarship(x)) ::: If a student is eligible for a scholarship and is intelligent, they get a scholarship.",
            "∀x ∀y (Student(x) ∧ Enrolled(x, y) → Takes(x, y)) ::: All students enrolled in a course takes that course.",
            "∃y Difficult(y) ::: Some courses are difficult.",
            "∃x (Student(x) ∧ StudiesHard(x)) ::: Some students study hard.",
            "∀x ∀y (Student(x) ∧ Attends(x, y) → Enrolled(x, y)) ::: If a student attends a course, they are enrolled in that course.",
            "∀x ∀y (Student(x) ∧ StudiesHard(x) ∧ Takes(x, y) → Attends(x, y)) ::: If a student studies hard and takes a course, they attend that course.",
            "∃x ∃y (Student(x) ∧ Takes(x, y) ∧ AsksQuestions(x, y)) ::: Some students ask questions in the courses they take.",
            "∀x (GetsScholarship(x) → Student(x)) ::: If a student gets a scholarship, they are a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "Takes(x, y) ::: x takes course y",
            "Difficult(y) ::: y is a difficult course",
            "Fails(x) ::: x fails the course",
            "GetsScholarship(x) ::: x gets a scholarship",
            "Intelligent(x) ::: x is intelligent",
            "Passes(x) ::: x passes the course",
            "Attends(x, y) ::: x attends course y",
            "AsksQuestions(x, y) ::: x asks questions in course y",
            "EligibleForScholarship(x) ::: x is eligible for a scholarship",
            "Enrolled(x, y) ::: x is enrolled in course y"
        ]
    },
    {
        "premises-NL": [
            "Everyone who studies hard and is smart will pass the exam.",
            "If someone attends lectures and asks questions, they understand the material.",
            "If someone understands the material, they are smart.",
            "If someone procrastinates, they are distracted.",
            "If someone is distracted, they do not study hard.",
            "If someone needs help they are not smart.",
            "Attending lectures and asking questions helps someone understand material.",
            "John studies hard or procrastinates."
        ],
        "premises-FOL": [
            "∀x (StudiesHard(x) ∧ Smart(x) → Passes(x, Exam)) ::: Everyone who studies hard and is smart will pass the exam.",
            "∀x (AttendsLectures(x) ∧ AsksQuestions(x) → UnderstandsMaterial(x)) ::: If someone attends lectures and asks questions, they understand the material.",
            "∀x (UnderstandsMaterial(x) → Smart(x)) ::: If someone understands the material, they are smart.",
            "∀x (Procrastinates(x) → Distracted(x)) ::: If someone procrastinates, they are distracted.",
            "∀x (Distracted(x) → ¬StudiesHard(x)) ::: If someone is distracted, they do not study hard.",
            "∀x (GetsHelp(x) → ¬Smart(x)) ::: If someone needs help, they are not smart.",
            "∀x (AttendsLectures(x) ∧ AsksQuestions(x) ↔ UnderstandsMaterial(x)) ::: Attending lectures and asking questions helps someone understand material.",
            "StudiesHard(John) ∨ Procrastinates(John) ::: John studies hard or procrastinates."
        ],
        "predicates": [
            "StudiesHard(x) ::: x studies hard",
            "Distracted(x) ::: x is distracted",
            "Passes(x, y) ::: x passes y",
            "Smart(x) ::: x is smart",
            "AttendsLectures(x) ::: x attends lectures",
            "AsksQuestions(x) ::: x asks questions",
            "Procrastinates(x) ::: x procrastinates",
            "UnderstandsMaterial(x) ::: x understands the material",
            "GetsHelp(x) ::: x gets help"
        ]
    },
    {
        "premises-NL": [
            "All students must pay tuition.",
            "Students cannot enroll if they have not paid their tuition.",
            "All courses require attendance.",
            "Elective courses do not affect graduation if the student has sufficient credits.",
            "A student can only enroll in a course if they attend all of its lectures.",
            "To graduate, a student must both pay tuition and not have any outstanding required courses failed.",
            "If a student has not paid tuition, they cannot graduate.",
            "Every course has a final exam.",
            "Students need advisor approval to drop courses."
        ],
        "premises-FOL": [
            "∀x (Student(x) → RequiresTuition(x)) ::: All students must pay tuition.",
            "∀x (¬PaidTuition(x) → ¬EnrolledIn(x, y)) ::: Students cannot enroll if they have not paid their tuition.",
            "∀y ∀x ((EnrolledIn(x,y)) → AttendsAll(x, y)) ::: All courses require attendance.",
            "∀x ∀y ((Student(x) ∧ EnrolledIn(x, y) ∧ IsElective(y) ∧ Fails(x, y) ∧ HasEnoughCredits(x)) → ¬AffectsGraduation(x, y)) ::: Elective courses do not affect graduation if the student has sufficient credits.",
            "∀x ∀y (EnrolledIn(x, y) → AttendsAll(x, y)) ::: A student can only enroll in a course if they attend all of its lectures.",
            "∀x ((Student(x) ∧ PaidTuition(x)) → CanGraduate(x)) ::: To graduate, a student must both pay tuition and not have any outstanding required courses failed.",
            "∀x (¬PaidTuition(x) → ¬CanGraduate(x)) ::: If a student has not paid tuition, they cannot graduate.",
            "∀y ∃z FinalExam(y, z) ::: Every course has a final exam.",
            "∀x (EnrolledIn(x,y) → AdvisorApproval(x)) ::: Students need advisor approval to drop courses."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in course y",
            "IsElective(y) ::: Course y is an elective",
            "Fails(x, y) ::: x fails course y",
            "HasEnoughCredits(x) ::: x has enough credits",
            "AffectsGraduation(x, y) ::: Failing course y affects x's graduation",
            "RequiresTuition(x) ::: x requires tuition payment",
            "PaidTuition(x) ::: x has paid their tuition",
            "AttendsAll(x, y) ::: x attends all lectures of course y"
        ]
    },
    {
        "premises-NL": [
            "Only students can enroll in courses.",
            "To receive credit for a course, a student must have paid tuition.",
            "All courses are gradable.",
            "If a course is gradable then it requires a passing grade.",
            "A student can take a course only if it is gradable.",
            "If a student takes a course and passes it, they might still not receive credit.",
            "There exists at least one student.",
            "There exists at least one course.",
            "Every course requires passing grades."
        ],
        "premises-FOL": [
            "∀x ∀y (EnrolledIn(x, y) → Student(x)) ::: Only students can enroll",
            "∀x ∀y (Student(x) ∧ EnrolledIn(x, y) ∧ ReceivesCredit(x, y) → PaidTuition(x)) ::: To receive credit, tuition must be paid",
            "∀y (Course(y) → Gradable(y)) ::: All courses are gradable",
            "∀y (Gradable(y) → RequiresPassing(y)) ::: If gradable then requires passing grade",
            "∀x ∀y (Student(x) ∧ Takes(x, y) → Gradable(y)) ::: Student can take course only if it is gradable",
            "∀x ∀y (Takes(x, y) ∧ Passes(x, y) → ReceivesCredit(x, y)) ::: If a student takes a course and passes it, they might still not receive credit.",
            "∃x Student(x) ::: There exists a student",
            "∃y Course(y) ::: There exists a course",
            "∀y (Course(y) → RequiresPassing(y)) ::: Every course requires passing grades"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in course y",
            "PaidTuition(x) ::: x has paid tuition",
            "ReceivesCredit(x, y) ::: x receives credit for course y",
            "Course(y) ::: y is a course",
            "RequiresPassing(y) ::: Course y requires passing grade",
            "Passes(x,y) ::: x passes course y",
            "Takes(x, y) ::: x takes course y",
            "Gradable(y) ::: Course y is gradable"
        ]
    },
    {
        "premises-NL": [
            "Anyone enrolled in a course either studies hard or the passing is guaranteed.",
            "If a course is difficult, then passing is not guaranteed.",
            "If someone studies hard and is enrolled in a course, then they pass the exam.",
            "There exists someone who is enrolled in a course that studies hard.",
            "There exists someone enrolled in a difficult course."
        ],
        "premises-FOL": [
            "∀x (Enrolled(x) → (StudiesHard(x) ∨ GuaranteedPass(x))) ::: Anyone enrolled in a course either studies hard or the passing is guaranteed.",
            "∀x (DifficultCourse(x) → ¬GuaranteedPass(x)) ::: If a course is difficult, then passing is not guaranteed.",
            "∀x (Enrolled(x) ∧ StudiesHard(x) → PassedExam(x)) ::: If someone studies hard and is enrolled in a course, then they pass the exam.",
            "∃x (Enrolled(x) ∧ StudiesHard(x)) ::: There exists someone who is enrolled in a course that studies hard.",
            "∃x (Enrolled(x) ∧ DifficultCourse(x)) ::: There exists someone enrolled in a difficult course."
        ],
        "predicates": [
            "Enrolled(x) ::: x is enrolled in a course",
            "DifficultCourse(x) ::: x is a difficult course",
            "PassedExam(x) ::: x has passed the exam for a course",
            "StudiesHard(x) ::: x studies hard",
            "GuaranteedPass(x) ::: Passing is guaranteed in course x"
        ]
    },
    {
        "premises-NL": [
            "All rich students own a car.",
            "If someone is intelligent and owns a car, then they like mechanics.",
            "All rich people are intelligent.",
            "If someone is a student, then they are hardworking or rich.",
            "All hardworking people are not rich.",
            "There exists a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ Rich(x) → OwnsCar(x)) ::: All rich students own a car.",
            "∀x (Intelligent(x) ∧ OwnsCar(x) → LikesMechanics(x)) ::: If someone is intelligent and owns a car, then they like mechanics.",
            "∀x (Rich(x) → Intelligent(x)) ::: All rich people are intelligent.",
            "∀x (Student(x) → (Hardworking(x) ∨ Rich(x))) ::: If someone is a student, then they are hardworking or rich.",
            "∀x (Hardworking(x) → ¬Rich(x)) ::: All hardworking people are not rich.",
            "∃x (Student(x)) ::: There exists a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "OwnsCar(x) ::: x owns a car",
            "LikesMechanics(x) ::: x likes mechanics",
            "Rich(x) ::: x is rich",
            "Intelligent(x) ::: x is intelligent",
            "Hardworking(x) ::: x is hardworking"
        ]
    },
    {
        "premises-NL": [
            "All professors who teach logic are experienced.",
            "If someone is experienced, then they like math.",
            "If someone likes math, then they enjoy programming.",
            "No young professors teach logic.",
            "All successful professors are not young.",
            "All professors are either successful or not experienced.",
            "There exists a professor."
        ],
        "premises-FOL": [
            "∀x (Professor(x) ∧ TeachesLogic(x) → Experienced(x)) ::: All professors who teach logic are experienced.",
            "∀x (Experienced(x) → LikesMath(x)) ::: If someone is experienced, then they like math.",
            "∀x (LikesMath(x) → EnjoysProgramming(x)) ::: If someone likes math, then they enjoy programming.",
            "∀x (Young(x) ∧ Professor(x) → ¬TeachesLogic(x)) ::: No young professors teach logic.",
            "∀x (Successful(x) → ¬Young(x)) ::: All successful professors are not young.",
            "∀x (Professor(x) → (Successful(x) ∨ ¬Experienced(x))) ::: All professors are either successful or not experienced.",
            "∃x (Professor(x)) ::: There exists a professor."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "TeachesLogic(x) ::: x teaches logic",
            "EnjoysProgramming(x) ::: x enjoys programming",
            "Experienced(x) ::: x is experienced",
            "LikesMath(x) ::: x likes math",
            "Young(x) ::: x is young",
            "Successful(x) ::: x is successful"
        ]
    },
    {
        "premises-NL": [
            "All students who like AI are intelligent.",
            "If someone is intelligent and does not procrastinate, then they study for long hours.",
            "All students who study for long hours pass exams.",
            "No one who passes exams procrastinates.",
            "All students who like AI enjoy learning.",
            "If someone enjoys learning, they do not procrastinate",
            "All students work hard.",
            "There exists a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ LikesAI(x) → Intelligent(x)) ::: All students who like AI are intelligent.",
            "∀x (Intelligent(x) ∧ ¬Procrastinates(x) → StudiesLongHours(x)) ::: If someone is intelligent and does not procrastinate, then they study for long hours.",
            "∀x (Student(x) ∧ StudiesLongHours(x) → PassesExams(x)) ::: All students who study for long hours pass exams.",
            "∀x (PassesExams(x) → ¬Procrastinates(x)) ::: No one who passes exams procrastinates.",
            "∀x (Student(x) ∧ LikesAI(x) → EnjoysLearning(x)) ::: All students who like AI enjoy learning.",
            "∀x (EnjoysLearning(x) → ¬Procrastinates(x)) ::: If someone enjoys learning, they do not procrastinate",
            "∀x (Student(x) → WorksHard(x)) ::: All students work hard.",
            "∃x (Student(x)) ::: There exists a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "LikesAI(x) ::: x likes AI",
            "StudiesLongHours(x) ::: x studies for long hours",
            "PassesExams(x) ::: x passes exams",
            "Intelligent(x) ::: x is intelligent",
            "Procrastinates(x) ::: x procrastinates",
            "EnjoysLearning(x) ::: x enjoys learning",
            "WorksHard(x) ::: x works hard"
        ]
    },
    {
        "premises-NL": [
            "All professors who write books are experienced.",
            "If someone is experienced, then they are respected.",
            "All professors who are respected enjoy teaching.",
            "All professors who enjoy teaching are dedicated.",
            "All tenured professors are dedicated.",
            "All professors who write books are researchers.",
            "All researchers publish papers.",
            "If someone publishes papers, they are tenured.",
            "There exists a professor who writes books."
        ],
        "premises-FOL": [
            "∀x (Professor(x) ∧ WritesBooks(x) → Experienced(x)) ::: All professors who write books are experienced.",
            "∀x (Experienced(x) → Respected(x)) ::: If someone is experienced, then they are respected.",
            "∀x (Professor(x) ∧ Respected(x) → EnjoysTeaching(x)) ::: All professors who are respected enjoy teaching.",
            "∀x (Professor(x) ∧ EnjoysTeaching(x) → Dedicated(x)) ::: All professors who enjoy teaching are dedicated.",
            "∀x (Professor(x) ∧ Tenured(x) → Dedicated(x)) ::: All tenured professors are dedicated.",
            "∀x (Professor(x) ∧ WritesBooks(x) → Researcher(x)) ::: All professors who write books are researchers.",
            "∀x (Researcher(x) → PublishesPapers(x)) ::: All researchers publish papers.",
            "∀x (PublishesPapers(x) → Tenured(x)) ::: If someone publishes papers, they are tenured.",
            "∃x (Professor(x) ∧ WritesBooks(x)) ::: There exists a professor who writes books."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "WritesBooks(x) ::: x writes books",
            "EnjoysTeaching(x) ::: x enjoys teaching",
            "Tenured(x) ::: x is tenured",
            "Experienced(x) ::: x is experienced",
            "Respected(x) ::: x is respected",
            "PublishesPapers(x) ::: x publishes papers",
            "Dedicated(x) ::: x is dedicated",
            "Researcher(x) ::: x is a researcher"
        ]
    },
    {
        "premises-NL": [
            "All students either have a low GPA or meet all requirements.",
            "If a student meets all requirements, then they have completed all required courses.",
            "If a student has completed all required courses and does not have a low GPA, then they will graduate.",
            "No student can both have a low GPA and graduate.",
            "Some students have a low GPA.",
            "Not all students meet all requirements.",
            "Some students have not completed all required courses."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (LowGPA(x) ∨ MeetsRequirements(x))) ::: All students either have a low GPA or meet all requirements.",
            "∀x (MeetsRequirements(x) → CompletedAllCourses(x)) ::: If a student meets all requirements, then they have completed all required courses.",
            "∀x ((CompletedAllCourses(x) ∧ ¬LowGPA(x)) → Graduates(x)) ::: If a student has completed all required courses and does not have a low GPA, then they will graduate.",
            "∀x ¬(LowGPA(x) ∧ Graduates(x)) ::: No student can both have a low GPA and graduate.",
            "∃x Student(x) ∧ LowGPA(x) ::: Some students have a low GPA.",
            "¬∀x (Student(x) → MeetsRequirements(x)) ::: Not all students meet all requirements.",
            "∃x (Student(x) ∧ ¬CompletedAllCourses(x)) ::: Some students have not completed all required courses."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "LowGPA(x) ::: x has a low GPA",
            "CompletedAllCourses(x) ::: x has completed all required courses",
            "MeetsRequirements(x) ::: x meets all graduation requirements",
            "Graduates(x) ::: x graduates"
        ]
    },
    {
        "premises-NL": [
            "All students who apply for financial aid are expected to take only allowed credits.",
            "If a student is taking more than the maximum allowed credits, then they will be penalized.",
            "If a student is penalized and has applied for financial aid, then they will not graduate on time.",
            "All students who do not graduate on time, do not meet all the graduation requirements.",
            "Some students applied for financial aid.",
            "Some students are taking more than the maximum allowed credits.",
            "Some students who apply for financial aid are taking more than the maximum allowed credits.",
            "There is a maximum credit limit."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ AppliedFinancialAid(x) → TakesAllowedCredits(x)) ::: All students who apply for financial aid are expected to take only allowed credits.",
            "∀x (Student(x) ∧ TakingTooManyCredits(x) → Penalized(x)) ::: If a student is taking more than the maximum allowed credits, then they will be penalized.",
            "∀x ((Student(x) ∧ Penalized(x) ∧ AppliedFinancialAid(x)) → ¬GraduatesOnTime(x)) ::: If a student is penalized and has applied for financial aid, then they will not graduate on time.",
            "∀x (¬GraduatesOnTime(x) → ¬MeetsAllRequirements(x)) ::: All students who do not graduate on time, do not meet all the graduation requirements.",
            "∃x (Student(x) ∧ AppliedFinancialAid(x)) ::: Some students applied for financial aid.",
            "∃x (Student(x) ∧ TakingTooManyCredits(x)) ::: Some students are taking more than the maximum allowed credits.",
            "∃x (Student(x) ∧ AppliedFinancialAid(x) ∧ TakingTooManyCredits(x)) ::: Some students who apply for financial aid are taking more than the maximum allowed credits.",
            "∃y MaxCreditLimit(y) ::: There is a maximum credit limit."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AppliedFinancialAid(x) ::: x applied for financial aid",
            "TakingTooManyCredits(x) ::: x is taking more than the maximum allowed credits",
            "Penalized(x) ::: x is penalized",
            "GraduatesOnTime(x) ::: x graduates on time",
            "MeetsAllRequirements(x) ::: x meets all the graduation requirements",
            "TakesAllowedCredits(x) ::: x takes only allowed credits"
        ]
    },
    {
        "premises-NL": [
            "All students with scholarships must meet certain scholarship requirements.",
            "Withdrawing from a required course can cause a student to no longer meet scholarship requirements.",
            "If a student no longer meets scholarship requirements, they lose their scholarship.",
            "If a student loses their scholarship and is not financially stable, they have to pay back tuition.",
            "If a student has to pay back tuition, then they will be delayed in graduating.",
            "Some students have scholarships.",
            "Some students withdraw from required courses.",
            "Some students are not financially stable.",
            "Some students who have scholarships withdraw from required courses.",
            "Some courses are required courses."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ HasScholarship(x) → MeetsScholarshipRequirements(x)) ::: All students with scholarships must meet certain scholarship requirements.",
            "∀x ∀y ((Student(x) ∧ WithdrawsFrom(x, y) ∧ RequiredCourse(y)) → ¬MeetsScholarshipRequirements(x)) ::: Withdrawing from a required course can cause a student to no longer meet scholarship requirements.",
            "∀x (¬MeetsScholarshipRequirements(x) → LosesScholarship(x)) ::: If a student no longer meets scholarship requirements, they lose their scholarship.",
            "∀x ((LosesScholarship(x) ∧ ¬FinanciallyStable(x)) → PayBackTuition(x)) ::: If a student loses their scholarship and is not financially stable, they have to pay back tuition.",
            "∀x (PayBackTuition(x) → DelayedGraduation(x)) ::: If a student has to pay back tuition, then they will be delayed in graduating.",
            "∃x (Student(x) ∧ HasScholarship(x)) ::: Some students have scholarships.",
            "∃x ∃y (Student(x) ∧ WithdrawsFrom(x, y) ∧ RequiredCourse(y)) ::: Some students withdraw from required courses.",
            "∃x Student(x) ∧ ¬FinanciallyStable(x) ::: Some students are not financially stable.",
            "∃x ∃y (Student(x) ∧ HasScholarship(x) ∧ WithdrawsFrom(x, y) ∧ RequiredCourse(y)) ::: Some students who have scholarships withdraw from required courses.",
            "∃y RequiredCourse(y) ::: Some courses are required courses."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "HasScholarship(x) ::: x has a scholarship",
            "WithdrawsFrom(x, y) ::: x withdraws from course y",
            "RequiredCourse(y) ::: y is a required course",
            "LosesScholarship(x) ::: x loses their scholarship",
            "PayBackTuition(x) ::: x has to pay back tuition",
            "DelayedGraduation(x) ::: x is delayed in graduating",
            "MeetsScholarshipRequirements(x) ::: x meets all scholarship requirements",
            "FinanciallyStable(x) ::: x is financially stable"
        ]
    },
    {
        "premises-NL": [
            "If a student fails an exam, then either the professor is inexperienced or the course is hard.",
            "All professors are either new or experienced.",
            "No experienced professors are lazy.",
            "If the professor is lazy, then the course is easy.",
            "All courses are either genuinely hard or easy.",
            "If a course is easy, then it is not genuinely hard.",
            "If someone is a professor, they are an instructor."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ FailsExam(x) → (InexperiencedProfessor(y) ∨ HardCourse(z))) ::: If a student fails an exam, then either the professor is inexperienced or the course is hard.",
            "∀y (Professor(y) → (NewProfessor(y) ∨ ExperiencedProfessor(y))) ::: All professors are either new or experienced.",
            "∀y (ExperiencedProfessor(y) → ¬LazyProfessor(y)) ::: No experienced professors are lazy.",
            "∀y (LazyProfessor(y) → EasyCourse(z)) ::: If the professor is lazy, then the course is easy.",
            "∀z (Course(z) → (GenuinelyHard(z) ∨ EasyCourse(z))) ::: All courses are either genuinely hard or easy.",
            "∀z (EasyCourse(z) → ¬GenuinelyHard(z)) ::: If a course is easy, then it is not genuinely hard.",
            "∀y (Professor(y) → Instructor(y)) ::: If someone is a professor, they are an instructor."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "FailsExam(x) ::: x fails an exam",
            "NewProfessor(y) ::: y is a new professor",
            "GenuinelyHard(z) ::: z is a genuinely hard course",
            "ExperiencedProfessor(y) ::: y is an experienced professor",
            "LazyProfessor(y) ::: y is a lazy professor",
            "Course(z) ::: z is a course"
        ]
    },
    {
        "premises-NL": [
            "If a student misses all classes, they are lazy.",
            "If a professor is strict, the grading is not easy.",
            "If the grading is not easy and a student is lazy, then they will fail the course.",
            "All courses have a professor.",
            "If a student fails a course, they did not attend class.",
            "All students are either hardworking or lazy.",
            "If a student is hardworking, they attend class.",
            "If someone is a student, they are a person."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ MissesAllClasses(x) → LazyStudent(x)) ::: If a student misses all classes, they are lazy.",
            "∀y (StrictProfessor(y) → ¬EasyGrading(y)) ::: If a professor is strict, the grading is not easy.",
            "∀x ∀y (¬EasyGrading(y) ∧ LazyStudent(x) → FailsCourse(x, z)) ::: If the grading is not easy and a student is lazy, then they will fail the course.",
            "∀z ∃y Professor(y) ∧ Course(z) ::: All courses have a professor.",
            "∀x ∀z (FailsCourse(x, z) → ¬AttendsClass(x, z)) ::: If a student fails a course, they did not attend class.",
            "∀x (Student(x) → (HardworkingStudent(x) ∨ LazyStudent(x))) ::: All students are either hardworking or lazy.",
            "∀x (HardworkingStudent(x) → AttendsClass(x, z)) ::: If a student is hardworking, they attend class.",
            "∀x (Student(x) → Person(x)) ::: If someone is a student, they are a person."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "MissesAllClasses(x) ::: x misses all classes",
            "StrictProfessor(y) ::: y is a strict professor",
            "FailsCourse(x, z) ::: x fails course z",
            "EasyGrading(y) ::: y has easy grading",
            "Course(z) ::: z is a course",
            "AttendsClass(x, z) ::: x attends class z",
            "LazyStudent(x) ::: x is a lazy student"
        ]
    },
    {
        "premises-NL": [
            "If a student is taking a course online, the lecture is boring.",
            "If a course requires a textbook, then the textbook is expensive.",
            "If the textbook is expensive, then the student is sad.",
            "If the student is sad, then they either buy the textbook or drop the course.",
            "All courses are either online or in person.",
            "Students taking online courses are sometimes lazy.",
            "If someone is lazy, they find the lecture boring.",
            "All textbooks are expensive.",
            "Students are people."
        ],
        "premises-FOL": [
            "∀x ∀y (Student(x) ∧ TakingOnline(x, y) → BoringLecture(x)) ::: If a student is taking a course online, the lecture is boring.",
            "∀y (Course(y) ∧ RequiresTextbook(y) → Expensive(z)) ::: If a course requires a textbook, then the textbook is expensive.",
            "∀z (Expensive(z) → Sad(x)) ::: If the textbook is expensive, then the student is sad.",
            "∀x (Sad(x) → (Purchases(x, z) ∨ Drops(x, y))) ::: If the student is sad, then they either buy the textbook or drop the course.",
            "∀y (Course(y) → (Online(y) ∨ InPerson(y))) ::: All courses are either online or in person.",
            "∃x (Student(x) ∧ TakingOnline(x,y) → LazyStudent(x)) ::: Students taking online courses are sometimes lazy.",
            "∀x (LazyStudent(x) → BoringLecture(x)) ::: If someone is lazy, they find the lecture boring.",
            "∀z (Textbook(z) → Expensive(z)) ::: All textbooks are expensive.",
            "∀x (Student(x) → Person(x)) ::: Students are people."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "TakingOnline(x, y) ::: x is taking y online",
            "RequiresTextbook(y) ::: y requires a textbook",
            "Purchases(x, z) ::: x purchases z",
            "Drops(x, y) ::: x drops y",
            "Course(y) ::: y is a course",
            "Expensive(z) ::: z is expensive",
            "Textbook(z) ::: z is a textbook",
            "BoringLecture(x) ::: x has a boring lecture"
        ]
    },
    {
        "premises-NL": [
            "All students must take Math101.",
            "If a student takes Math101 and fails, they failed Math101.",
            "Math101 is a prerequisite for Math201.",
            "Anyone who fails a course must retake it if it's a prerequisite for another course.",
            "There exists a student who takes Math101."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Takes(x, Math101)) ::: For all students x, x takes Math101.",
            "∀x (Student(x) ∧ Takes(x, Math101) ∧ ¬Passed(x, Math101) → Failed(x, Math101)) ::: For all students x, if x takes Math101 and does not pass, then x failed Math101.",
            "Prerequisite(Math101, Math201) ::: Math101 is a prerequisite for Math201.",
            "∀x ∀y (Failed(x, y) ∧ Prerequisite(y, z) → MustRetake(x, y)) ::: For all x and y, if x fails y and y is a prerequisite for z, then x must retake y.",
            "∃x (Student(x) ∧ Takes(x, Math101)) ::: There exists a student x who takes Math101."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Takes(x, y) ::: x takes course y",
            "Failed(x, y) ::: x failed course y",
            "Prerequisite(y, z) ::: y is a prerequisite for z",
            "MustRetake(x, y) ::: x must retake course y"
        ]
    },
    {
        "premises-NL": [
            "John is a student.",
            "If someone is intelligent, then they like studying.",
            "If someone likes studying, they pass the exam.",
            "If someone is a student and attends lectures, then they like studying or they are forced to attend the lectures.",
            "If a student passes the exam, then they are intelligent.",
            "Attending lectures is necessary for passing exams.",
            "If someone is forced to attend and is a student, they will get a better grade.",
            "Students who attend lectures are either intelligent or trying hard.",
            "Trying hard implies attending lectures.",
            "John attends lectures.",
            "If you are trying hard, you are not intelligent."
        ],
        "premises-FOL": [
            "Student(john) ::: John is a student.",
            "∀x (Intelligent(x) → LikesStudying(x)) ::: If someone is intelligent, then they like studying.",
            "∀x (LikesStudying(x) → PassesExam(x)) ::: If someone likes studying, they pass the exam.",
            "∀x (Student(x) ∧ AttendsLectures(x) → LikesStudying(x) ∨ ForcedToAttend(x)) ::: If someone is a student and attends lectures, then they like studying or they are forced to attend the lectures.",
            "∀x (Student(x) ∧ PassesExam(x) → Intelligent(x)) ::: If a student passes the exam, then they are intelligent.",
            "∀x (PassesExam(x) → AttendsLectures(x)) ::: Attending lectures is necessary for passing exams.",
            "∀x (ForcedToAttend(x) ∧ Student(x) → BetterGrade(x)) ::: If someone is forced to attend and is a student, they will get a better grade.",
            "∀x (Student(x) ∧ AttendsLectures(x) → Intelligent(x) ∨ TryingHard(x)) ::: Students who attend lectures are either intelligent or trying hard.",
            "∀x (TryingHard(x) → AttendsLectures(x)) ::: Trying hard implies attending lectures.",
            "AttendsLectures(john) ::: John attends lectures.",
            "∀x (TryingHard(x) → ¬Intelligent(x)) ::: If you are trying hard, you are not intelligent."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsLectures(x) ::: x attends lectures",
            "LikesStudying(x) ::: x likes studying",
            "ForcedToAttend(x) ::: x is forced to attend",
            "Intelligent(x) ::: x is intelligent",
            "PassesExam(x) ::: x passes the exam"
        ]
    },
    {
        "premises-NL": [
            "All students enrolled in courses.",
            "To remain enrolled, they have to pay tuition.",
            "If someone is enrolled and pays tuition, then they receive access or can appeal the charge.",
            "Anyone who fails a course can appeal.",
            "If someone takes a course, they either pass or fail.",
            "If someone fails a course, they are not passing the course.",
            "If someone passes the course, they are not failing the course.",
            "For everyone, it is not possible for them to pass and fail a course at the same time."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x)) ::: If someone is a student then they are enrolled.",
            "∀x (Enrolled(x) → PaysTuition(x)) ::: If someone is enrolled, then they pay tuition.",
            "∀x (Enrolled(x) ∧ PaysTuition(x) → (ReceivesAccess(x) ∨ Appeal(x))) ::: If someone is enrolled and pays tuition, then they receive access or can appeal.",
            "∀x (FailsCourse(x) → Appeal(x)) ::: Anyone who fails a course can appeal.",
            "∀x (TakesCourse(x) → (PassesCourse(x) ∨ FailsCourse(x))) ::: If someone takes a course, they either pass or fail.",
            "∀x (FailsCourse(x) → ¬PassesCourse(x)) ::: If someone fails a course, they are not passing the course.",
            "∀x (PassesCourse(x) → ¬FailsCourse(x)) ::: If someone passes the course, they are not failing the course.",
            "¬∃x (PassesCourse(x) ∧ FailsCourse(x)) ::: For everyone, it is not possible for them to pass and fail a course at the same time."
        ],
        "predicates": [
            "Enrolled(x) ::: x is enrolled",
            "PaysTuition(x) ::: x pays tuition",
            "ReceivesAccess(x) ::: x receives access",
            "Appeal(x) ::: x can appeal",
            "FailsCourse(x) ::: x fails the course",
            "TakesCourse(x) ::: x takes the course",
            "PassesCourse(x) ::: x passes the course"
        ]
    },
    {
        "premises-NL": [
            "Every student either likes math or physics.",
            "There exists a student who likes math.",
            "There exists a student who likes physics.",
            "Not every student likes chemistry.",
            "If a student likes math then they know about arithmetic.",
            "If a student likes physics then they know about mechanics.",
            "If a student knows about arithmetic and mechanics then they are smart.",
            "There is a student who is smart.",
            "There is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (LikesMath(x) ∨ LikesPhysics(x))) ::: Every student likes math or physics",
            "∃x (Student(x) ∧ LikesMath(x)) ::: Some student likes math",
            "∃x (Student(x) ∧ LikesPhysics(x)) ::: Some student likes physics",
            "¬∀x (Student(x) → LikesChemistry(x)) ::: Not all students like chemistry",
            "∀x (Student(x) ∧ LikesMath(x) → Knows(x, \"arithmetic\")) ::: If a student likes math then they know about arithmetic",
            "∀x (Student(x) ∧ LikesPhysics(x) → Knows(x, \"mechanics\")) ::: If a student likes physics then they know about mechanics",
            "∀x (Knows(x, \"arithmetic\") ∧ Knows(x, \"mechanics\") → Smart(x)) ::: If a student knows arithmetic and mechanics then they are smart",
            "∃x (Student(x) ∧ Smart(x)) ::: There is a smart student",
            "∃x Student(x) ::: There is a student"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "LikesMath(x) ::: x likes mathematics",
            "LikesPhysics(x) ::: x likes physics",
            "LikesChemistry(x) ::: x likes chemistry",
            "Knows(x, y) ::: x knows y"
        ]
    },
    {
        "premises-NL": [
            "All professors are experienced.",
            "Some experienced professors teach advanced courses.",
            "Not all experienced professors advise undergraduate students.",
            "If someone is a professor then they work at a university.",
            "There exists a professor.",
            "There exists an experienced person.",
            "Some professors teach.",
            "All who teach are experienced.",
            "Some experienced professors work at a University",
            "All professors who work at a university are paid."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Experienced(x)) ::: All professors are experienced",
            "∃x (Experienced(x) ∧ TeachesAdvancedCourse(x)) ::: Some experienced professors teach advanced courses",
            "∃x (Experienced(x) ∧ ¬AdvisesUndergraduates(x)) ::: Some experienced professors do not advise undergraduate students",
            "∀x (Professor(x) → WorksAt(x,\"University\")) ::: If someone is a professor then they work at a university.",
            "∃x (Professor(x)) ::: There exists a professor.",
            "∃x (Experienced(x)) ::: There exists an experienced person",
            "∃x (Professor(x) ∧ TeachesAdvancedCourse(x)) ::: Some professors teach",
            "∀x (TeachesAdvancedCourse(x) → Experienced(x)) ::: All who teach are experienced",
            "∃x (Experienced(x) ∧ WorksAt(x,\"University\")) ::: Some experienced professors work at a university",
            "∀x (Professor(x) ∧ WorksAt(x, \"University\") → Paid(x)) ::: All professors who work at a university are paid"
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "TeachesAdvancedCourse(x) ::: x teaches an advanced course",
            "AdvisesUndergraduates(x) ::: x advises undergraduate students",
            "Experienced(x) ::: x is an experienced professor",
            "WorksAt(x,y) ::: x works at y"
        ]
    },
    {
        "premises-NL": [
            "Every course either has prerequisites or is easy.",
            "Not all courses are easy.",
            "Some courses with prerequisites are interesting.",
            "All interesting courses require a textbook.",
            "There exists a course.",
            "If a course requires a textbook then it is expensive.",
            "Some courses are expensive.",
            "All easy courses are popular.",
            "Some popular courses are not interesting.",
            "All courses are taught by professors.",
            "All courses require time commitment."
        ],
        "premises-FOL": [
            "∀x (Course(x) → (HasPrerequisites(x) ∨ Easy(x))) ::: Every course either has prerequisites or is easy",
            "¬∀x (Course(x) → Easy(x)) ::: Not all courses are easy",
            "∃x (Course(x) ∧ HasPrerequisites(x) ∧ Interesting(x)) ::: Some courses with prerequisites are interesting",
            "∀x (Course(x) ∧ Interesting(x) → RequiresTextbook(x)) ::: All interesting courses require a textbook",
            "∃x Course(x) ::: There exists a course",
            "∀x (Course(x) ∧ RequiresTextbook(x) → Expensive(x)) ::: If a course requires a textbook then it is expensive",
            "∃x (Course(x) ∧ Expensive(x)) ::: Some courses are expensive",
            "∀x (Course(x) ∧ Easy(x) → Popular(x)) ::: All easy courses are popular",
            "∃x (Course(x) ∧ Popular(x) ∧ ¬Interesting(x)) ::: Some popular courses are not interesting",
            "∀x ∃y (Course(x) → IsTaughtBy(x,y)) ::: All courses are taught by professors",
            "∀x (Course(x) → RequiresTimeCommitment(x)) ::: All courses require time commitment"
        ],
        "predicates": [
            "Course(x) ::: x is a course",
            "HasPrerequisites(x) ::: x has prerequisites",
            "Easy(x) ::: x is an easy course",
            "RequiresTextbook(x) ::: x requires a textbook",
            "Interesting(x) ::: x is interesting",
            "IsTaughtBy(x, y) ::: x is taught by y"
        ]
    },
    {
        "premises-NL": [
            "All math courses are science courses.",
            "If someone is a student and enrolled in a math course, then they are enrolled in a course.",
            "If someone is enrolled in a course, then they are taking a science course or a humanities course.",
            "Math101 is a math course.",
            "If someone is enrolled in Math101, they are enrolled in a course."
        ],
        "premises-FOL": [
            "∀y (MathCourse(y) → ScienceCourse(y)) ::: All math courses are science courses.",
            "∀x ∀y (Student(x) ∧ Enrolled(x, y) ∧ MathCourse(y) → Enrolled(x, y)) ::: If someone is a student and enrolled in a math course, then they are enrolled in a course.",
            "∀x ∀y (Enrolled(x, y) → (TakesScience(x) ∨ ¬TakesScience(x))) ::: If someone is enrolled in a course, then they are either taking a science course or not.",
            "MathCourse(Math101) ::: Math101 is a math course.",
            "∀x (Enrolled(x, Math101) → Enrolled(x, Math101)) ::: If someone is enrolled in Math101, they are enrolled in a course."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "MathCourse(y) ::: y is a math course",
            "ScienceCourse(y) ::: y is a science course",
            "TakesScience(x) ::: x takes a science course"
        ]
    },
    {
        "premises-NL": [
            "All students are either intelligent or motivated.",
            "If a student is motivated, they study hard.",
            "If a student is intelligent, they attend all lectures.",
            "If a student studies hard, they understand the material.",
            "If a student attends all lectures, they understand the material.",
            "If a student understands the material, they are studying.",
            "If a student studies hard and attends all lectures, then the student studies hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Intelligent(x) ∨ Motivated(x))) ::: All students are either intelligent or motivated.",
            "∀x (Student(x) ∧ Motivated(x) → StudiesHard(x)) ::: If a student is motivated, they study hard.",
            "∀x (Student(x) ∧ Intelligent(x) → AttendsAllLectures(x)) ::: If a student is intelligent, they attend all lectures.",
            "∀x (Student(x) ∧ StudiesHard(x) → UnderstandsMaterial(x)) ::: If a student studies hard, they understand the material.",
            "∀x (Student(x) ∧ AttendsAllLectures(x) → UnderstandsMaterial(x)) ::: If a student attends all lectures, they understand the material.",
            "∀x (Student(x) ∧ UnderstandsMaterial(x) → StudiesHard(x)) ::: If a student understands the material, they are studying.",
            "∀x (Student(x) ∧ StudiesHard(x) ∧ AttendsAllLectures(x) → StudiesHard(x)) ::: If a student studies hard and attends all lectures, then the student studies hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "AttendsAllLectures(x) ::: x attends all lectures",
            "PassesExam(x) ::: x passes the exam",
            "Intelligent(x) ::: x is intelligent",
            "Motivated(x) ::: x is motivated",
            "UnderstandsMaterial(x) ::: x understands material"
        ]
    },
    {
        "premises-NL": [
            "All students either pay tuition or receive a waiver.",
            "If a student pays tuition, they have good standing.",
            "If a student is enrolled in a course, they take the course.",
            "If a student takes all courses, they have completed all requirements.",
            "If a student has completed all requirements and has good standing, they are eligible to graduate.",
            "If a student is enrolled in a course, they are taking a course.",
            "If a student takes a required course, the course is required.",
            "If a student is enrolled and pays tuition, then the student is enrolled"
        ],
        "premises-FOL": [
            "∀x (Student(x) → (PaysTuition(x) ∨ ¬PaysTuition(x))) ::: All students either pay tuition or receive a waiver.",
            "∀x (Student(x) ∧ PaysTuition(x) → HasGoodStanding(x)) ::: If a student pays tuition, they have good standing.",
            "∀x ∀y (Student(x) ∧ Enrolled(x, y) → TakesCourse(x, y)) ::: If a student is enrolled in a course, they take the course.",
            "∀x (Student(x) ∧ TakesCourse(x, Math101) → CompletedAllRequirements(x)) ::: If a student takes all courses, they have completed all requirements.",
            "∀x (Student(x) ∧ CompletedAllRequirements(x) ∧ HasGoodStanding(x) → EligibleToGraduate(x)) ::: If a student has completed all requirements and has good standing, they are eligible to graduate.",
            "∀x ∀y (Student(x) ∧ Enrolled(x, y) → TakesCourse(x, y)) ::: If a student is enrolled in a course, they are taking a course.",
            "∀y (TakesCourse(x, y) ∧ RequiredCourse(y) → RequiredCourse(y)) ::: If a student takes a required course, the course is required.",
            "∀x ∀y (Student(x) ∧ Enrolled(x, y) ∧ PaysTuition(x) → Enrolled(x, y)) ::: If a student is enrolled and pays tuition, then the student is enrolled."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "PaysTuition(x) ::: x pays tuition",
            "RequiredCourse(y) ::: y is a required course",
            "EligibleToGraduate(x) ::: x is eligible to graduate",
            "TakesCourse(x, y) ::: x takes course y",
            "HasGoodStanding(x) ::: x has good standing",
            "CompletedAllRequirements(x) ::: x completed all requirements"
        ]
    },
    {
        "premises-NL": [
            "Students who fail a mandatory course twice will be academically dismissed.",
            "Academic dismissal leads to expulsion from the program.",
            "Students on probation are not allowed to take more than 12 credits.",
            "If a student has an appeal in process, they may be allowed to retake the course.",
            "A student has failed a mandatory course.",
            "The student is not meeting the minimum grade requirement.",
            "The student failed the mandatory course again.",
            "The course is allowed to be retaken one time.",
            "The student is not on probation.",
            "The student does not have an appeal in process.",
            "The student attends tutorials.",
            "The student has low attendance"
        ],
        "premises-FOL": [
            "∀x ∀y (Student(x) ∧ Fails(x, y) ∧ MandatoryCourse(y) ∧ FailsAgain(x,y) → AcademicallyDismissed(x)) ::: Students who fail a mandatory course twice will be academically dismissed.",
            "∀x (AcademicallyDismissed(x) → Expelled(x)) ::: Academic dismissal leads to expulsion.",
            "∀x (Probation(x) → MaxCredits(x, 12)) ::: Students on probation are limited to 12 credits.",
            "∀x ∀y (HasAppeal(x) → AllowedRetake(y)) ::: If a student appeals, they can retake.",
            "∃x ∃y (Student(x) ∧ Fails(x, y) ∧ MandatoryCourse(y)) ::: A student failed a mandatory course.",
            "∃x ¬MeetsMinimumGrade(x) ::: The student is not meeting the minimum grade.",
            "∃x ∃y Student(x) ∧ FailsAgain(x,y) ∧ MandatoryCourse(y) ::: The student failed the mandatory course again",
            "∃y AllowedRetake(y) ::: The course is allowed to be retaken.",
            "∀x ¬Probation(x) ::: The student is not on probation.",
            "∀x ¬HasAppeal(x) ::: The student does not have an appeal",
            "∃x ∃y AttendsTutorial(x,y) ::: The student attends tutorials.",
            "∃x ∃y LowAttendance(x,y) ::: The student has low attendance"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Fails(x, y) ::: x fails course y",
            "MandatoryCourse(y) ::: y is a mandatory course",
            "AcademicallyDismissed(x) ::: x is academically dismissed",
            "MeetsMinimumGrade(x) ::: x meets minimum grade",
            "AllowedRetake(y) ::: y is allowed to be retaken",
            "FailsAgain(x,y) ::: x fails course y a second time",
            "Probation(x) ::: x is on probation",
            "HasAppeal(x) ::: x has an appeal in process",
            "AttendsTutorial(x,y) ::: x attends tutorial y",
            "LowAttendance(x,y) ::: x has low attendance in y",
            "ProfessorConcern(x,y) ::: A professor is concerned about x in y"
        ]
    },
    {
        "premises-NL": [
            "If a professor teaches advanced courses and publishes research, they participate in committees.",
            "The university's reputation increases if it supports research.",
            "The university supports research if professors obtain grants.",
            "A professor who obtains grants submits proposals.",
            "A professor who mentors graduate students attracts high-achieving students.",
            "The university supports research if professors collaborate with industry.",
            "If a professor attracts high-achieving students, the university's reputation increases.",
            "If a professor develops new curriculum, then the university reputation increases.",
            "If a professor teaches advanced courses, then they must develop new curriculum.",
            "Professors who submit proposals must obtain grants.",
            "If a professor participates in committees then they must develop new curriculum.",
            "If a professor obtains grants, they collaborate with industry."
        ],
        "premises-FOL": [
            "∀x (Professor(x) ∧ TeachesAdvancedCourses(x) ∧ PublishesResearch(x) → ParticipatesInCommittees(x)) ::: If a professor teaches advanced courses and publishes research, they participate in committees.",
            "IncreasesUniversityReputation(u) ↔ UniversitySupportsResearch(u) ::: The university's reputation increases if and only if it supports research.",
            "∀x (ObtainsGrants(x) → UniversitySupportsResearch(u)) ::: The university supports research if professors obtain grants.",
            "∀x (ObtainsGrants(x) → SubmitsProposals(x)) ::: A professor who obtains grants submits proposals.",
            "∀x (MentorsGraduateStudents(x) → AttractsHighAchievingStudents(x)) ::: A professor who mentors graduate students attracts high-achieving students.",
            "∀x (CollaboratesWithIndustry(x) → UniversitySupportsResearch(u)) ::: The university supports research if professors collaborate with industry.",
            "∀x (AttractsHighAchievingStudents(x) → IncreasesUniversityReputation(u)) ::: If a professor attracts high-achieving students, the university's reputation increases.",
            "∀x (DevelopsNewCurriculum(x) → IncreasesUniversityReputation(u)) ::: If a professor develops new curriculum, then the university reputation increases.",
            "∀x (TeachesAdvancedCourses(x) → DevelopsNewCurriculum(x)) ::: If a professor teaches advanced courses, then they must develop new curriculum.",
            "∀x (SubmitsProposals(x) → ObtainsGrants(x)) ::: Professors who submit proposals must obtain grants.",
            "∀x (ParticipatesInCommittees(x) → DevelopsNewCurriculum(x)) ::: If a professor participates in committees then they must develop new curriculum.",
            "∀x (ObtainsGrants(x) → CollaboratesWithIndustry(x)) ::: If a professor obtains grants, they collaborate with industry."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "TeachesAdvancedCourses(x) ::: x teaches advanced courses",
            "PublishesResearch(x) ::: x publishes research",
            "IncreasesUniversityReputation(u) ::: the university's reputation increases",
            "MentorsGraduateStudents(x) ::: x mentors graduate students",
            "ObtainsGrants(x) ::: x obtains grants",
            "ParticipatesInCommittees(x) ::: x participates in committees",
            "AttractsHighAchievingStudents(x) ::: x attracts high achieving students",
            "CollaboratesWithIndustry(x) ::: x collaborates with industry",
            "DevelopsNewCurriculum(x) ::: x develops new curriculum",
            "UniversitySupportsResearch(u) ::: the university supports research",
            "SubmitsProposals(x) ::: x submits proposals"
        ]
    },
    {
        "premises-NL": [
            "All students are registered.",
            "To graduate, a student must meet all requirements and pay tuition.",
            "Meeting all requirements means completing all courses.",
            "If a student graduates, there is no administrative delay.",
            "Students cannot graduate if there is an administrative delay.",
            "If a student doesn't pay tuition, they cannot graduate.",
            "A student who does not meet the requirements will not graduate."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Registered(x)) ::: All students are registered.",
            "∀x (Graduates(x) → (MeetsRequirements(x) ∧ PaysTuition(x))) ::: To graduate, a student must meet all requirements and pay tuition.",
            "∀x (MeetsRequirements(x) → CompletesAllCourses(x)) ::: Meeting all requirements means completing all courses.",
            "∀x (Graduates(x) → ¬AdministrativeDelay(x)) ::: If a student graduates, there is no administrative delay.",
            "∀x (AdministrativeDelay(x) → ¬Graduates(x)) ::: Students cannot graduate if there is an administrative delay.",
            "∀x (¬PaysTuition(x) → ¬Graduates(x)) ::: If a student doesn't pay tuition, they cannot graduate.",
            "∀x (¬MeetsRequirements(x) → ¬Graduates(x)) ::: A student who does not meet the requirements will not graduate."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Registered(x) ::: x is registered",
            "CompletesAllCourses(x) ::: x completes all courses",
            "Graduates(x) ::: x graduates",
            "PaysTuition(x) ::: x pays tuition",
            "AdministrativeDelay(x) ::: there is an administrative delay for x",
            "MeetsRequirements(x) ::: x meets requirements"
        ]
    },
    {
        "premises-NL": [
            "All students must complete the prerequisite before enrolling.",
            "If a student is enrolled in a graded course, they must attend lectures.",
            "If a student attends lectures and pays fees, they will either pass or receive an incomplete.",
            "If a student doesn't attend lectures and the course is graded, they will drop the course.",
            "All students pay fees for the courses they take.",
            "To be enrolled, students must pay fees for the course.",
            "If a student does not pay fees for a course they are not enrolled.",
            "Anyone who is enrolled and takes a course is a student.",
            "A course must be graded or pass-fail."
        ],
        "premises-FOL": [
            "∀x ∀y (EnrolledIn(x, y) → CompletesPrerequisite(x, y)) ::: All students must complete the prerequisite before enrolling.",
            "∀x ∀y ((EnrolledIn(x, y) ∧ Graded(y)) → AttendsLectures(x, y)) ::: If a student is enrolled in a graded course, they must attend lectures.",
            "∀x ∀y ((AttendsLectures(x, y) ∧ PaysFees(x, y)) → (PassesCourse(x, y) ∨ ReceivesIncomplete(x, y))) ::: If a student attends lectures and pays fees, they will either pass or receive an incomplete.",
            "∀x ∀y ((¬AttendsLectures(x, y) ∧ Graded(y)) → DropsCourse(x, y)) ::: If a student doesn't attend lectures and the course is graded, they will drop the course.",
            "∀x ∀y (EnrolledIn(x,y) → PaysFees(x, y)) ::: All students pay fees for the courses they take.",
            "∀x ∀y (EnrolledIn(x, y) → PaysFees(x,y)) ::: To be enrolled, students must pay fees for the course.",
            "∀x ∀y (¬PaysFees(x, y) → ¬EnrolledIn(x, y)) ::: If a student does not pay fees for a course they are not enrolled.",
            "∀x ∀y (EnrolledIn(x, y) ∧ TakesCourse(x,y) → Student(x)) ::: Anyone who is enrolled and takes a course is a student.",
            "∀y (Graded(y) ∨ PassFail(y)) ::: A course must be graded or pass-fail."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "CompletesPrerequisite(x, y) ::: x completes the prerequisite for y",
            "EnrolledIn(x, y) ::: x is enrolled in y",
            "PassesCourse(x, y) ::: x passes y",
            "ReceivesIncomplete(x, y) ::: x receives an incomplete in y",
            "Graded(y) ::: y is graded",
            "DropsCourse(x, y) ::: x drops y",
            "AttendsLectures(x,y) ::: x attends lectures for y",
            "PaysFees(x,y) ::: x pays fees for y"
        ]
    },
    {
        "premises-NL": [
            "Every important project is useful.",
            "Every interesting project is fun.",
            "Every project that requires effort is time-consuming.",
            "Every useful project is practical.",
            "Every practical project benefits the team.",
            "Every project that promotes learning is interesting.",
            "If a project is important, then it requires effort.",
            "If a project is well-designed, it promotes learning.",
            "Some projects are important.",
            "Some projects are well-designed.",
            "Every challenging project requires effort.",
            "If a project is interesting then it is challenging.",
            "There exists a project."
        ],
        "premises-FOL": [
            "∀x (Project(x) ∧ Important(x) → Useful(x)) ::: Every important project is useful.",
            "∀x (Project(x) ∧ Interesting(x) → Fun(x)) ::: Every interesting project is fun.",
            "∀x (Project(x) ∧ RequiresEffort(x) → TimeConsuming(x)) ::: Every project that requires effort is time-consuming.",
            "∀x (Project(x) ∧ Useful(x) → Practical(x)) ::: Every useful project is practical.",
            "∀x (Project(x) ∧ Practical(x) → BenefitsTeam(x)) ::: Every practical project benefits the team.",
            "∀x (Project(x) ∧ PromotesLearning(x) → Interesting(x)) ::: Every project that promotes learning is interesting.",
            "∀x (Project(x) ∧ Important(x) → RequiresEffort(x)) ::: If a project is important, then it requires effort.",
            "∀x (Project(x) ∧ WellDesigned(x) → PromotesLearning(x)) ::: If a project is well-designed, it promotes learning.",
            "∃x (Project(x) ∧ Important(x)) ::: Some projects are important.",
            "∃x (Project(x) ∧ WellDesigned(x)) ::: Some projects are well-designed.",
            "∀x (Project(x) ∧ Challenging(x) → RequiresEffort(x)) ::: Every challenging project requires effort.",
            "∀x (Project(x) ∧ Interesting(x) → Challenging(x)) ::: If a project is interesting then it is challenging.",
            "∃x Project(x) ::: There exists a project."
        ],
        "predicates": [
            "Project(x) ::: x is a project",
            "Challenging(x) ::: x is challenging",
            "TimeConsuming(x) ::: x is time-consuming",
            "Important(x) ::: x is important",
            "Interesting(x) ::: x is interesting",
            "RequiresEffort(x) ::: x requires effort",
            "BenefitsTeam(x) ::: x benefits the team",
            "WellDesigned(x) ::: x is well-designed",
            "PromotesLearning(x) ::: x promotes learning",
            "Practical(x) ::: x is practical",
            "Useful(x) ::: x is useful",
            "Fun(x) ::: x is fun"
        ]
    },
    {
        "premises-NL": [
            "All invited people are on the guest list.",
            "If a person is on the guest list and has a valid ID, then they will be admitted.",
            "If a person knows the host, they are invited.",
            "Carol is a person.",
            "If Carol knows the host, then she is on the guest list",
            "Carol has a valid ID.",
            "Carol is on the guest list.",
            "Carol knows the host."
        ],
        "premises-FOL": [
            "∀x (Invited(x) → OnGuestList(x)) ::: All invited people are on the guest list.",
            "∀x ((OnGuestList(x) ∧ HasID(x)) → Admitted(x)) ::: If a person is on the guest list and has a valid ID, they will be admitted.",
            "∀x (KnowsHost(x) → Invited(x)) ::: If a person knows the host, they are invited.",
            "Person(carol) ::: Carol is a person.",
            "KnowsHost(carol) → OnGuestList(carol) ::: If Carol knows the host then she is on the guest list.",
            "HasID(carol) ::: Carol has a valid ID.",
            "OnGuestList(carol) ::: Carol is on the guest list.",
            "KnowsHost(carol) ::: Carol knows the host."
        ],
        "predicates": [
            "Person(x)",
            "HasID(x)",
            "OnGuestList(x)",
            "Admitted(x)",
            "Invited(x)",
            "KnowsHost(x)",
            "PaysFee(x)"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard understand the material.",
            "All students who attend lectures understand the material.",
            "If a student understands the material, they will pass the exam.",
            "If a student asks questions they will receive help.",
            "If a student receives help, they will understand the material.",
            "David is a student.",
            "David studies hard.",
            "David attends lectures.",
            "David is intelligent."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) → UnderstandsMaterial(x)) ::: All students who study hard understand the material.",
            "∀x (Student(x) ∧ AttendsLectures(x) → UnderstandsMaterial(x)) ::: All students who attend lectures understand the material.",
            "∀x (UnderstandsMaterial(x) → PassesExam(x)) ::: If a student understands the material, they will pass the exam.",
            "∀x (AsksQuestions(x) → ReceivesHelp(x)) ::: If a student asks questions, they will receive help.",
            "∀x (ReceivesHelp(x) → UnderstandsMaterial(x)) ::: If a student receives help, they will understand the material.",
            "Student(david) ::: David is a student.",
            "StudiesHard(david) ::: David studies hard.",
            "AttendsLectures(david) ::: David attends lectures.",
            "Intelligent(david) ::: David is intelligent."
        ],
        "predicates": [
            "Student(x)",
            "StudiesHard(x)",
            "AttendsLectures(x)",
            "PassesExam(x)",
            "UnderstandsMaterial(x)",
            "AsksQuestions(x)",
            "ReceivesHelp(x)",
            "Intelligent(x)"
        ]
    },
    {
        "premises-NL": [
            "All students who have good attendance understand the concepts.",
            "All students who complete the project understand the concepts.",
            "If a student understands the concepts, they will meet all requirements.",
            "If a student meets all requirements, they will pass the course.",
            "If a student reads the textbook, they understand the concepts.",
            "If a student participates, then they meet all requirements.",
            "Emily is a student.",
            "Emily has good attendance.",
            "Emily completes the project.",
            "Emily is enrolled."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ GoodAttendance(x) → UnderstandsConcepts(x)) ::: All students who have good attendance understand the concepts.",
            "∀x (Student(x) ∧ CompletesProject(x) → UnderstandsConcepts(x)) ::: All students who complete the project understand the concepts.",
            "∀x (UnderstandsConcepts(x) → MeetsRequirements(x)) ::: If a student understands the concepts, they meet all requirements.",
            "∀x (MeetsRequirements(x) → PassesCourse(x)) ::: If a student meets all requirements, they will pass the course.",
            "∀x (ReadsTextbook(x) → UnderstandsConcepts(x)) ::: If a student reads the textbook, they understand the concepts.",
            "∀x (Participates(x) → MeetsRequirements(x)) ::: If a student participates they will meet the requirements.",
            "Student(emily) ::: Emily is a student.",
            "GoodAttendance(emily) ::: Emily has good attendance.",
            "CompletesProject(emily) ::: Emily completes the project.",
            "Enrolled(emily) ::: Emily is enrolled."
        ],
        "predicates": [
            "Student(x)",
            "GoodAttendance(x)",
            "CompletesProject(x)",
            "PassesCourse(x)",
            "UnderstandsConcepts(x)",
            "Participates(x)",
            "ReadsTextbook(x)",
            "AsksQuestions(x)",
            "MeetsRequirements(x)",
            "Enrolled(x)"
        ]
    },
    {
        "premises-NL": [
            "All who study diligently pass the exam.",
            "All who attend lectures understand the material.",
            "If someone understands the material, they pass the exam.",
            "Passing the exam is necessary for not failing the course.",
            "Alice studies diligently.",
            "Alice is registered."
        ],
        "premises-FOL": [
            "∀x (StudiesDiligently(x) → PassesExam(x)) ::: All who study diligently pass the exam.",
            "∀x (AttendsLectures(x) → UnderstandsMaterial(x)) ::: All who attend lectures understand the material.",
            "∀x (UnderstandsMaterial(x) → PassesExam(x)) ::: If someone understands the material, they pass the exam.",
            "∀x (¬PassesExam(x) → FailsCourse(x)) ::: Passing the exam is necessary for not failing the course.",
            "StudiesDiligently(Alice) ::: Alice studies diligently.",
            "Registered(Alice) ::: Alice is registered."
        ],
        "predicates": [
            "StudiesDiligently(x) ::: x studies diligently",
            "Registered(x) ::: x is registered for the course",
            "FailsCourse(x) ::: x fails the course",
            "PassesExam(x) ::: x passes the exam",
            "AttendsLectures(x) ::: x attends lectures",
            "UnderstandsMaterial(x) ::: x understands the material"
        ]
    },
    {
        "premises-NL": [
            "All students are expected to fulfill certain course requirements.",
            "Fulfilling course requirements means taking required courses, passing all courses, and maintaining minimum credits.",
            "To take required courses, students must be enrolled.",
            "If a student takes required courses, they pass them.",
            "Maintaining minimum credits is essential for a good GPA.",
            "Passing all courses is a condition for maintaining minimum credits.",
            "All enrolled students have a GPA.",
            "A student who is enrolled passes the course"
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x)) ::: All students are expected to fulfill certain course requirements.",
            "∀x (FulfillsRequirements(x) ↔ (TakesRequiredCourses(x) ∧ PassesAllCourses(x) ∧ MaintainsMinimumCredits(x))) ::: Fulfilling course requirements means taking required courses, passing all courses, and maintaining minimum credits.",
            "∀x (TakesRequiredCourses(x) → Enrolled(x)) ::: To take required courses, students must be enrolled.",
            "∀x (TakesRequiredCourses(x) → PassesAllCourses(x)) ::: If a student takes required courses, they pass them.",
            "∀x (MaintainsMinimumCredits(x) → GoodGPA(x)) ::: Maintaining minimum credits is essential for a good GPA.",
            "∀x (PassesAllCourses(x) → MaintainsMinimumCredits(x)) ::: Passing all courses is a condition for maintaining minimum credits.",
            "∀x (Enrolled(x) → GoodGPA(x)) ::: All enrolled students have a GPA.",
            "∀x (Enrolled(x) → PassesAllCourses(x)) ::: A student who is enrolled passes the course."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "FulfillsRequirements(x) ::: x fulfills all course requirements",
            "GoodGPA(x) ::: x maintains a good GPA",
            "EligibleForGraduation(x) ::: x is eligible for graduation",
            "TakesRequiredCourses(x) ::: x takes all required courses",
            "PassesAllCourses(x) ::: x passes all courses",
            "MaintainsMinimumCredits(x) ::: x maintains minimum required credits",
            "Enrolled(x) ::: x is enrolled"
        ]
    },
    {
        "premises-NL": [
            "All students are either diligent or struggling.",
            "If a student is diligent and takes a difficult course, then they will study hard.",
            "If a student studies hard, then they will succeed.",
            "Some courses are difficult.",
            "If a student succeeds, they graduate.",
            "Graduation is a prerequisite for employment.",
            "If a student is not struggling, then they are a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Diligent(x) ∨ Struggling(x)) ::: All students are either diligent or struggling.",
            "∀x ∀y (Student(x) ∧ Diligent(x) ∧ Takes(x, y) ∧ DifficultCourse(y) → StudiesHard(x)) ::: If a student is diligent and takes a difficult course, then they will study hard.",
            "∀x (StudiesHard(x) → Succeeds(x)) ::: If a student studies hard, then they will succeed.",
            "∃y DifficultCourse(y) ::: Some courses are difficult.",
            "∀x (Succeeds(x) → Graduates(x)) ::: If a student succeeds, they graduate.",
            "∀x (Graduates(x) → Employed(x)) ::: Graduation is a prerequisite for employment.",
            "∀x (¬Struggling(x) → Student(x)) ::: If a student is not struggling, then they are a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Takes(x, y) ::: x takes course y",
            "DifficultCourse(y) ::: y is a difficult course",
            "StudiesHard(x) ::: x studies hard",
            "Succeeds(x) ::: x succeeds"
        ]
    },
    {
        "premises-NL": [
            "All students must pay tuition.",
            "A student can register for a course if they paid tuition and meet the prerequsites.",
            "If a student failed a course and the course allows retakes, then the student can retake the course if they took it before.",
            "If a student is retaking, they are also registered.",
            "There is a policy that allows a student to retake a course if they failed the course.",
            "There is a student who failed a course.",
            "If a student has paid tuition and met prerequsites for a course, they are allowed to register.",
            "There exists a course that allows retakes.",
            "If a student takes a course, they meet the prerequisites."
        ],
        "premises-FOL": [
            "∀x (Student(x) → PaidTuition(x)) ::: All students must pay tuition.",
            "∀x ∀y ((PaidTuition(x) ∧ PrerequisiteMet(x,y)) → Registered(x, y)) ::: If a student paid tuition and meet the prerequsites, then they are registered.",
            "∀x ∀y ((Failed(x, y) ∧ AllowedRetake(y) ∧ TookBefore(x,y)) → Retaking(x, y)) ::: If a student failed a course and the course allows retakes, the student is retaking.",
            "∀x ∀y (Retaking(x, y) → Registered(x, y)) ::: If a student is retaking a course, then they are registered.",
            "∃x ∃y (PolicyAllows(x,y) ∧ Failed(x,y)) ::: There is a policy that allows a student to retake a course if they failed the course.",
            "∃x ∃y Failed(x, y) ::: There is a student who failed a course.",
            "∀x ∀y ((PaidTuition(x) ∧ PrerequisiteMet(x,y)) → PolicyAllows(x,y)) ::: If a student has paid tuition and met prerequsites for a course, they are allowed to register.",
            "∃y AllowedRetake(y) ::: There exists a course that allows retakes.",
            "∀x ∀y TookBefore(x,y) → PrerequisiteMet(x,y) ::: If a student took a course, they meet the prerequisites."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Registered(x, y) ::: x is registered for course y",
            "Failed(x, y) ::: x failed course y",
            "Retaking(x, y) ::: x is retaking course y",
            "AllowedRetake(y) ::: Course y is allowed to be retaken",
            "PolicyAllows(x,y) ::: Policy allows student x for course y",
            "PaidTuition(x) ::: Student x has paid the tuition",
            "PrerequisiteMet(x,y) ::: Student x has met the prerequisite for course y",
            "TookBefore(x,y) ::: Student x took course y before"
        ]
    },
    {
        "premises-NL": [
            "All students have an ID.",
            "If a student is registered, then they are enrolled.",
            "If a student is enrolled, they can attend class if they pay tuition.",
            "If a student pays tuition and has a valid ID then they have access to the class.",
            "If a student has access to the class then they can attend the class.",
            "If a student can attend class then they meet the requirements.",
            "If a student is valid registration then they meet the requirements for the class.",
            "If a student attends a class, they have a valid registration.",
            "There is a student that attends a class.",
            "If a student attends class then they are registered.",
            "If a student is registered then they have a valid registration."
        ],
        "premises-FOL": [
            "∀x (Student(x) → HasId(x)) ::: All students have an ID.",
            "∀x ∀y (Registered(x, y) → Enrolled(x, y)) ::: If a student is registered, then they are enrolled.",
            "∀x ∀y ((Enrolled(x, y) ∧ PaysTuition(x)) → CanAttend(x, y)) ::: If a student is enrolled, they can attend if they pay tuition.",
            "∀x ∀y ((PaysTuition(x) ∧ HasId(x)) → HasAccess(x, y)) ::: If a student pays tuition and has a valid ID then they have access.",
            "∀x ∀y (HasAccess(x, y) → CanAttend(x, y)) ::: If a student has access, then they can attend.",
            "∀x ∀y (CanAttend(x, y) → MeetsRequirements(x, y)) ::: If a student can attend class then they meet the requirements.",
            "∀x ∀y (ValidRegistration(x, y) → MeetsRequirements(x, y)) ::: If a student is valid registration then they meet the requirements for the class.",
            "∀x ∀y (Attends(x, y) → ValidRegistration(x, y)) ::: If a student attends a class, they have a valid registration.",
            "∃x ∃y Attends(x, y) ::: There is a student that attends a class.",
            "∀x ∀y (Attends(x, y) → Registered(x, y)) ::: If a student attends class then they are registered.",
            "∀x ∀y (Registered(x, y) → ValidRegistration(x, y)) ::: If a student is registered then they have a valid registration."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PaysTuition(x) ::: x pays tuition",
            "Registered(x, y) ::: x is registered for course y",
            "Attends(x, y) ::: x attends class y",
            "CanAttend(x, y) ::: x can attend class y",
            "HasAccess(x, y) ::: x has access to class y",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "MeetsRequirements(x, y) ::: x meets the requirements for y",
            "HasId(x) ::: x has a valid ID",
            "ValidRegistration(x,y) ::: x has valid registration for y"
        ]
    },
    {
        "premises-NL": [
            "All professors must conduct research.",
            "If a professor is tenured, they are dedicated.",
            "If a professor conducts research, they publish papers.",
            "If a professor publishes papers, their work is visible.",
            "If a professor's work is visible, it impacts the field.",
            "If a professor impacts the field, their influence grows.",
            "If a professor's influence grows, they gain recognition.",
            "If a professor is dedicated and teaches diligently, their students succeed.",
            "If a professor's students succeed and they gain recognition, their research output is high."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → ConductsResearch(x)) ::: All professors must conduct research.",
            "∀x (Tenured(x) → Dedicated(x)) ::: If a professor is tenured, they are dedicated.",
            "∀x (ConductsResearch(x) → PublishesPapers(x)) ::: If a professor conducts research, they publish papers.",
            "∀x (PublishesPapers(x) → VisibleWork(x)) ::: If a professor publishes papers, their work is visible.",
            "∀x (VisibleWork(x) → ImpactsField(x)) ::: If a professor's work is visible, it impacts the field.",
            "∀x (ImpactsField(x) → InfluenceGrows(x)) ::: If a professor impacts the field, their influence grows.",
            "∀x (InfluenceGrows(x) → GainsRecognition(x)) ::: If a professor's influence grows, they gain recognition.",
            "∀x ((Dedicated(x) ∧ TeachesDiligently(x)) → StudentsSucceed(x)) ::: If a professor is dedicated and teaches diligently, their students succeed.",
            "∀x ((StudentsSucceed(x) ∧ GainsRecognition(x)) → HighResearchOutput(x)) ::: If a professor's students succeed and they gain recognition, their research output is high."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "Tenured(x) ::: x is tenured",
            "TeachesDiligently(x) ::: x teaches diligently",
            "ConductsResearch(x) ::: x conducts research",
            "PublishesPapers(x) ::: x publishes papers",
            "HighResearchOutput(x) ::: x has high research output",
            "Dedicated(x) ::: x is dedicated"
        ]
    },
    {
        "premises-NL": [
            "All professors are expected to contribute to their field.",
            "If a professor is passionate, they inspire students.",
            "If a professor dedicates time to research, they publish research.",
            "If a professor publishes research, they advance knowledge.",
            "If a professor mentors effectively, their students succeed.",
            "If a professor's students succeed, they attract funding.",
            "If a professor is open to new ideas, they collaborate with peers.",
            "If a professor collaborates with peers, their impact widens.",
            "If a professor advances knowledge and attracts funding, they have resources.",
            "If a professor inspires students and has resources, they have a greater impact.",
            "If a professor has a greater impact and their impact widens, they positively impact their field.",
            "Collaboration fosters greater impact."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → ContributesToField(x)) ::: All professors are expected to contribute to their field.",
            "∀x (Passionate(x) → InspiresStudents(x)) ::: If a professor is passionate, they inspire students.",
            "∀x (DedicatesTimeToResearch(x) → PublishesResearch(x)) ::: If a professor dedicates time to research, they publish research.",
            "∀x (PublishesResearch(x) → AdvancesKnowledge(x)) ::: If a professor publishes research, they advance knowledge.",
            "∀x (MentorsEffectively(x) → StudentsSucceed(x)) ::: If a professor mentors effectively, their students succeed.",
            "∀x (StudentsSucceed(x) → AttractsFunding(x)) ::: If a professor's students succeed, they attract funding.",
            "∀x (OpenToNewIdeas(x) → CollaboratesWithPeers(x)) ::: If a professor is open to new ideas, they collaborate with peers.",
            "∀x (CollaboratesWithPeers(x) → ImpactWidens(x)) ::: If a professor collaborates with peers, their impact widens.",
            "∀x ((AdvancesKnowledge(x) ∧ AttractsFunding(x)) → HasResources(x)) ::: If a professor advances knowledge and attracts funding, they have resources.",
            "∀x ((InspiresStudents(x) ∧ HasResources(x)) → GreaterImpact(x)) ::: If a professor inspires students and has resources, they have a greater impact.",
            "∀x ((GreaterImpact(x) ∧ ImpactWidens(x)) → PositivelyImpactsField(x)) ::: If a professor has a greater impact and their impact widens, they positively impact their field.",
            "∀x (CollaboratesWithPeers(x) → GreaterImpact(x)) ::: Collaboration fosters greater impact."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "Passionate(x) ::: x is passionate about their subject",
            "DedicatesTimeToResearch(x) ::: x dedicates time to research",
            "MentorsEffectively(x) ::: x mentors students effectively",
            "OpenToNewIdeas(x) ::: x is open to new ideas",
            "PositivelyImpactsField(x) ::: x positively impacts their field",
            "PublishesResearch(x) ::: x publishes research",
            "AttractsFunding(x) ::: x attracts funding",
            "InspiresStudents(x) ::: x inspires students",
            "AdvancesKnowledge(x) ::: x advances knowledge",
            "CollaboratesWithPeers(x) ::: x collaborates with peers"
        ]
    },
    {
        "premises-NL": [
            "All students must complete all requirements to graduate.",
            "To graduate with honors, a student must maintain good standing.",
            "Maintaining good standing requires having a high GPA.",
            "Having a high GPA necessitates passing all exams.",
            "Passing all exams depends on submitting all assignments.",
            "Submitting all assignments is facilitated by attending all classes.",
            "If a student studies hard, they attend all classes.",
            "If a student attends all classes, they submit all assignments.",
            "If a student submits all assignments, they pass all exams.",
            "If a student passes all exams, they have a high GPA.",
            "If a student has a high GPA, they maintain good standing."
        ],
        "premises-FOL": [
            "∀x (Student(x) → CompletesAllRequirements(x)) ::: All students must complete all requirements to graduate.",
            "∀x (GraduatesWithHonors(x) → MaintainsGoodStanding(x)) ::: To graduate with honors, a student must maintain good standing.",
            "∀x (MaintainsGoodStanding(x) → HasHighGPA(x)) ::: Maintaining good standing requires having a high GPA.",
            "∀x (HasHighGPA(x) → PassesAllExams(x)) ::: Having a high GPA necessitates passing all exams.",
            "∀x (PassesAllExams(x) → SubmitsAllAssignments(x)) ::: Passing all exams depends on submitting all assignments.",
            "∀x (SubmitsAllAssignments(x) → AttendsAllClasses(x)) ::: Submitting all assignments is facilitated by attending all classes.",
            "∀x (StudiesHard(x) → AttendsAllClasses(x)) ::: If a student studies hard, they attend all classes.",
            "∀x (AttendsAllClasses(x) → SubmitsAllAssignments(x)) ::: If a student attends all classes, they submit all assignments.",
            "∀x (SubmitsAllAssignments(x) → PassesAllExams(x)) ::: If a student submits all assignments, they pass all exams.",
            "∀x (PassesAllExams(x) → HasHighGPA(x)) ::: If a student passes all exams, they have a high GPA.",
            "∀x (HasHighGPA(x) → MaintainsGoodStanding(x)) ::: If a student has a high GPA, they maintain good standing."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "IsDedicated(x) ::: x is dedicated",
            "GraduatesWithHonors(x) ::: x graduates with honors",
            "CompletesAllRequirements(x) ::: x completes all requirements",
            "MaintainsGoodStanding(x) ::: x maintains good standing",
            "HasHighGPA(x) ::: x has a high GPA",
            "AttendsAllClasses(x) ::: x attends all classes",
            "PassesAllExams(x) ::: x passes all exams",
            "SubmitsAllAssignments(x) ::: x submits all assignments",
            "SeeksHelp(x) ::: x seeks help when needed"
        ]
    },
    {
        "premises-NL": [
            "Diligent students attend lectures and complete assignments.",
            "Completing assignments and attending lectures leads to asking questions.",
            "Helpful professors provide guidance and offer feedback.",
            "Professors who offer feedback clarify concepts.",
            "If a student receives feedback, they understand concepts.",
            "If a professor clarifies concepts, they provide guidance.",
            "If a student asks questions, they will understand concepts.",
            "Students who understand concepts will succeed.",
            "If a student attends the lectures, then the student will complete assignments.",
            "If a student completes the assignment, then the student attends lectures.",
            "If a professor teaches a student and provides guidance, the student understands concepts.",
            "If a student understands concepts and receives feedback, the student will succeed.",
            "If a professor teaches a student and offers feedback, then the student receives feedback."
        ],
        "premises-FOL": [
            "∀x (Diligent(x) → AttendsLectures(x) ∧ CompletesAssignments(x)) ::: Diligent students attend lectures and complete assignments.",
            "∀x (CompletesAssignments(x) ∧ AttendsLectures(x) → AsksQuestions(x)) ::: Completing assignments and attending lectures leads to asking questions.",
            "∀y (ProfessorHelpful(y) → ProvidesGuidance(y) ∧ OffersFeedback(y)) ::: Helpful professors provide guidance and offer feedback.",
            "∀y (OffersFeedback(y) → ClarifiesConcepts(y)) ::: Professors who offer feedback clarify concepts.",
            "∀x ∀y (ReceivesFeedback(x, y) → UnderstandsConcepts(x)) ::: If a student receives feedback, they understand concepts.",
            "∀y (ClarifiesConcepts(y) → ProvidesGuidance(y)) ::: If a professor clarifies concepts, they provide guidance.",
            "∀x (AsksQuestions(x) → UnderstandsConcepts(x)) ::: If a student asks questions, they will understand concepts.",
            "∀x (UnderstandsConcepts(x) → Succeeds(x)) ::: Students who understand concepts will succeed.",
            "∀x (AttendsLectures(x) → CompletesAssignments(x)) ::: If a student attends the lectures, then the student will complete assignments.",
            "∀x (CompletesAssignments(x) → AttendsLectures(x)) ::: If a student completes the assignment, then the student attends lectures.",
            "∀x ∀y (Teaches(y, x) ∧ ProvidesGuidance(y) → UnderstandsConcepts(x)) ::: If a professor teaches a student and provides guidance, the student understands concepts.",
            "∀x ∀y (UnderstandsConcepts(x) ∧ ReceivesFeedback(x, y) → Succeeds(x)) ::: If a student understands concepts and receives feedback, the student will succeed.",
            "∀x ∀y (Teaches(y, x) ∧ OffersFeedback(y) → ReceivesFeedback(x, y)) ::: If a professor teaches a student and offers feedback, then the student receives feedback."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Diligent(x) ::: x is diligent",
            "ProfessorHelpful(y) ::: y is a helpful professor",
            "Teaches(y, x) ::: professor y teaches student x",
            "Succeeds(x) ::: x succeeds in the course",
            "AttendsLectures(x) ::: x attends lectures",
            "CompletesAssignments(x) ::: x completes assignments",
            "AsksQuestions(x) ::: x asks questions",
            "ProvidesGuidance(y) ::: y provides guidance",
            "OffersFeedback(y) ::: y offers feedback",
            "ClarifiesConcepts(y) ::: y clarifies concepts",
            "UnderstandsConcepts(x) ::: x understands concepts",
            "ReceivesFeedback(x, y) ::: x receives feedback from y"
        ]
    },
    {
        "premises-NL": [
            "All students must comply with rules.",
            "To meet prerequisites, a student must have the required GPA and complete required courses.",
            "To have required GPA, a student must registers on time.",
            "Paying tuition on time means having no outstanding fees.",
            "Having no outstanding fees implies following instructions.",
            "Following instructions necessitates understanding the requirements.",
            "Understanding the requirements enables students to complete required courses.",
            "Students who comply with rules attend advising.",
            "Attending advising means understanding the course requirements.",
            "If a student doesn't understand the course requirements they seek clarification.",
            "Seeking clarification allows them to meets the prereqs.",
            "To have the requires GPA, a student follows instructions.",
            "If a student follows instructions, then they comply with the rules.",
            "If a student seeks clarification, then they meet the prereqs."
        ],
        "premises-FOL": [
            "∀x (Student(x) → CompliesWithRules(x)) ::: All students must comply with rules.",
            "∀x ∀y (MeetsPrerequisites(x, y) → HasRequiredGPA(x) ∧ CompletedRequiredCourses(x, y)) ::: To meet prerequisites, a student must have the required GPA and complete required courses.",
            "∀x (HasRequiredGPA(x) → RegistersOnTime(x)) ::: To have required GPA, a student must registers on time.",
            "∀x (PaysTuitionOnTime(x) → NoOutstandingFees(x)) ::: Paying tuition on time means having no outstanding fees.",
            "∀x (NoOutstandingFees(x) → FollowsInstructions(x)) ::: Having no outstanding fees implies following instructions.",
            "∀x (FollowsInstructions(x) → UnderstandsRequirements(x, y)) ::: Following instructions necessitates understanding the requirements.",
            "∀x ∀y (UnderstandsRequirements(x, y) → CompletedRequiredCourses(x, y)) ::: Understanding the requirements enables students to complete required courses.",
            "∀x (CompliesWithRules(x) → AttendsAdvising(x)) ::: Students who comply with rules attend advising.",
            "∀x (AttendsAdvising(x) → UnderstandsRequirements(x, y)) ::: Attending advising means understanding the course requirements.",
            "∀x ∀y (¬UnderstandsRequirements(x, y) → SeeksClarification(x, y)) ::: If a student doesn't understand the course requirements they seek clarification.",
            "∀x ∀y (SeeksClarification(x, y) → MeetsPrerequisites(x, y)) ::: Seeking clarification allows them to meets the prereqs.",
            "∀x (HasRequiredGPA(x) → FollowsInstructions(x)) ::: To have the requires GPA, a student follows instructions.",
            "∀x (FollowsInstructions(x) → CompliesWithRules(x)) ::: If a student follows instructions, then they comply with the rules.",
            "∀x ∀y (SeeksClarification(x, y) → MeetsPrerequisites(x, y)) ::: If a student seeks clarification, then they meet the prereqs."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "MeetsPrerequisites(x, y) ::: x meets all prerequisites for course y",
            "PaysTuitionOnTime(x) ::: x pays tuition on time",
            "EligibleToEnroll(x, y) ::: x is eligible to enroll in course y",
            "HasRequiredGPA(x) ::: x has the required GPA",
            "CompletedRequiredCourses(x, y) ::: x completed the required courses for y",
            "NoOutstandingFees(x) ::: x has no outstanding fees",
            "RegistersOnTime(x) ::: x registers on time",
            "AttendsAdvising(x) ::: x attends advising",
            "UnderstandsRequirements(x, y) ::: x understands the requirements for course y",
            "SeeksClarification(x, y) ::: x seeks clarification for course y",
            "FollowsInstructions(x) ::: x follows instructions",
            "CompliesWithRules(x) ::: x complies with all rules"
        ]
    },
    {
        "premises-NL": [
            "All professors are intelligent.",
            "Some students study.",
            "If a student is enrolled in a course, then that student is a student.",
            "If a professor teaches a course, then that professor is a professor.",
            "Professor Smith teaches Quantum Physics.",
            "Alice is enrolled in Quantum Physics.",
            "Alice is a student."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Intelligent(x)) ::: All professors are intelligent.",
            "∃x (Student(x) ∧ Studies(x)) ::: Some students study.",
            "∀x ∀y (EnrolledIn(x, y) → Student(x)) ::: If a student is enrolled in a course, then that student is a student.",
            "∀x ∀y (Teaches(x, y) → Professor(x)) ::: If a professor teaches a course, then that professor is a professor.",
            "Teaches(ProfessorSmith, QuantumPhysics) ::: Professor Smith teaches Quantum Physics.",
            "EnrolledIn(Alice, QuantumPhysics) ::: Alice is enrolled in Quantum Physics.",
            "Student(Alice) ::: Alice is a student."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches course y",
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in course y",
            "Responsible(x, y, z) ::: x is responsible for y's success in z",
            "Intelligent(x) ::: x is intelligent",
            "Studies(x) ::: x studies hard"
        ]
    },
    {
        "premises-NL": [
            "All students enrolled in a course are considered registered.",
            "To be considered registered, a student must have paid tuition.",
            "If a student has paid tuition and has no holds, they are cleared to attend.",
            "A student is cleared to attend if they have passed the prerequisites.",
            "If a student is cleared to attend, they can attend lectures."
        ],
        "premises-FOL": [
            "∀x (Enrolled(x) → Registered(x)) ::: All students enrolled in a course are considered registered.",
            "∀x (Registered(x) → PaidTuition(x)) ::: To be considered registered, a student must have paid tuition.",
            "∀x (PaidTuition(x) ∧ ¬HasHolds(x) → ClearedToAttend(x)) ::: If a student has paid tuition and has no holds, they are cleared to attend.",
            "∀x (ClearedToAttend(x) ↔ PassedPrerequisites(x)) ::: A student is cleared to attend if and only if they have passed the prerequisites.",
            "∀x (ClearedToAttend(x) → CanAttend(x)) ::: If a student is cleared to attend, they can attend lectures."
        ],
        "predicates": [
            "Enrolled(x)",
            "PassedPrerequisites(x)",
            "CanAttend(x)"
        ]
    },
    {
        "premises-NL": [
            "All graduate students are pursuing advanced degrees.",
            "If someone is pursuing an advanced degree and is enrolled in a course, then they are considered a student.",
            "If a course is research-oriented, then it is assigned a project.",
            "If a student takes a course that is assigned a project, then they must present results.",
            "If a student takes a course, then they are considered enrolled",
            "If a student presents results, they must write a paper."
        ],
        "premises-FOL": [
            "∀x (GraduateStudent(x) → PursuingAdvancedDegree(x)) ::: All graduate students are pursuing advanced degrees.",
            "∀x (PursuingAdvancedDegree(x) ∧ Enrolled(x) → Student(x)) ::: If someone is pursuing an advanced degree and is enrolled in a course, then they are considered a student.",
            "∀y (ResearchOriented(y) → AssignedProject(y)) ::: If a course is research-oriented, then it is assigned a project.",
            "∀x ∀y (Student(x) ∧ TakesCourse(x, y) ∧ AssignedProject(y) → PresentsResults(x)) ::: If a student takes a course that is assigned a project, then they must present results.",
            "∀x ∀y (TakesCourse(x, y) → Enrolled(x)) ::: If a student takes a course, then they are considered enrolled",
            "∀x (PresentsResults(x) → WritesPaper(x)) ::: If a student presents results, they must write a paper."
        ],
        "predicates": [
            "GraduateStudent(x)",
            "TakesCourse(x, y)",
            "ResearchOriented(y)",
            "WritesPaper(x)",
            "AssignedProject(y)"
        ]
    },
    {
        "premises-NL": [
            "Every course taught by a faculty member is graded.",
            "If a course is graded and requires software, then it assigns programming assignments.",
            "If a course is difficult and assigns programming assignments, then students need help.",
            "If a course is difficult, then it is time-consuming.",
            "If a faculty member teaches a course, then the course is considered difficult.",
            "If a course is graded and assigns programming assignments, then it requires software.",
            "If any student is enrolled in a course that requires help, then the course needs support."
        ],
        "premises-FOL": [
            "∀x ∀y (FacultyMember(x) ∧ Teaches(x, y) → Graded(y)) ::: Every course taught by a faculty member is graded.",
            "∀y (Graded(y) ∧ RequiresSoftware(y) → AssignsProgramming(y)) ::: If a course is graded and requires software, then it assigns programming assignments.",
            "∀y (Difficult(y) ∧ AssignsProgramming(y) → NeedsHelp(y)) ::: If a course is difficult and assigns programming assignments, then students need help.",
            "∀y (Difficult(y) → TimeConsuming(y)) ::: If a course is difficult, then it is time-consuming.",
            "∀x ∀y (FacultyMember(x) ∧ Teaches(x, y) → Difficult(y)) ::: If a faculty member teaches a course, then the course is considered difficult.",
            "∀y (Graded(y) ∧ AssignsProgramming(y) → RequiresSoftware(y)) ::: If a course is graded and assigns programming assignments, then it requires software.",
            "∀z ∀y (Enrolled(z,y) ∧ NeedsHelp(y) → NeedsSupport(y)) ::: If any student is enrolled in a course that requires help, then the course needs support."
        ],
        "predicates": [
            "FacultyMember(x)",
            "Teaches(x, y)",
            "Difficult(y)",
            "RequiresSoftware(y)",
            "NeedsSupport(y)",
            "Enrolled(z,y)"
        ]
    },
    {
        "premises-NL": [
            "If a course has prerequisites, then students must have completed prior coursework.",
            "If a course requires a textbook, then students must read.",
            "If students must read and have completed prior coursework, then they need assistance.",
            "If a course has an assigned professor, then the course is considered a course.",
            "If a course is assigned a professor and has prerequisites, then the course is difficult.",
            "If a course is difficult and requires a textbook, then it's challenging.",
            "If any student is enrolled in a course and needs assistance, then the course needs assistance.",
            "If a course has prerequisites, then it has an assigned professor."
        ],
        "premises-FOL": [
            "∀x (HasPrerequisites(x) → CompletedPriorWork(x)) ::: If a course has prerequisites, then students must have completed prior coursework.",
            "∀x (RequiresTextbook(x) → MustRead(x)) ::: If a course requires a textbook, then students must read.",
            "∀x (MustRead(x) ∧ CompletedPriorWork(x) → NeedsAssistance(x)) ::: If students must read and have completed prior coursework, then they need assistance.",
            "∀x (AssignedProfessor(x) → Course(x)) ::: If a course has an assigned professor, then the course is considered a course.",
            "∀x (Course(x) ∧ HasPrerequisites(x) → Difficult(x)) ::: If a course is assigned a professor and has prerequisites, then the course is difficult.",
            "∀x (Difficult(x) ∧ RequiresTextbook(x) → ChallengingCourse(x)) ::: If a course is difficult and requires a textbook, then it's challenging.",
            "∀y ∀x (Enrolled(y, x) ∧ NeedsAssistance(x) → NeedsAssistance(x)) ::: If any student is enrolled in a course and needs assistance, then the course needs assistance.",
            "∀x (HasPrerequisites(x) → AssignedProfessor(x)) ::: If a course has prerequisites, then it has an assigned professor."
        ],
        "predicates": [
            "HasPrerequisites(x)",
            "RequiresTextbook(x)",
            "NeedsAssistance(x)",
            "ChallengingCourse(x)",
            "AssignedProfessor(x)",
            "Enrolled(y, x)"
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled.",
            "There exists someone who is a student.",
            "If someone takes a course, then the course is difficult.",
            "There exists a course.",
            "If someone is enrolled, that someone is a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x)) ::: All students are enrolled.",
            "∃x Student(x) ::: There exists someone who is a student.",
            "∀x ∀y (Takes(x, y) → Difficult(y)) ::: If someone takes a course, then the course is difficult.",
            "∃y Course(y) ::: There exists a course.",
            "∀x (Enrolled(x) → Student(x)) ::: If someone is enrolled, that someone is a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Takes(x, y) ::: x takes y",
            "Course(y) ::: y is a course",
            "Difficult(y) ::: y is difficult",
            "Enrolled(x) ::: x is enrolled"
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled in an exam.",
            "Everyone who is enrolled in an exam is a student.",
            "If someone is a student and studies hard, then they are intelligent.",
            "If someone is intelligent, they will pass the exam.",
            "Someone studies hard.",
            "There exist some exams."
        ],
        "premises-FOL": [
            "∀x ∃y (Student(x) → Enrolled(x, y) ∧ Exam(y)) ::: All students are enrolled in an exam.",
            "∀x ∀y (Enrolled(x, y) ∧ Exam(y) → Student(x)) ::: Everyone who is enrolled in an exam is a student.",
            "∀x (Student(x) ∧ StudiesHard(x) → Intelligent(x)) ::: If someone is a student and studies hard, then they are intelligent.",
            "∀x (Intelligent(x) → PassExam(x)) ::: If someone is intelligent, they will pass the exam.",
            "∃x StudiesHard(x) ::: Someone studies hard.",
            "∃y Exam(y) ::: There exist some exams."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "Intelligent(x) ::: x is intelligent",
            "PassExam(x) ::: x passes the exam",
            "Enrolled(x, y) ::: x is enrolled in y",
            "Exam(y) ::: y is an exam"
        ]
    },
    {
        "premises-NL": [
            "All students are people.",
            "If someone is a student and enrolled in a course, then they must study for it.",
            "Every course requires some effort to pass.",
            "If someone studies for a course then they are enrolled in that course.",
            "If someone passes a course, they receive credit for it."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Person(x)) ::: All students are people.",
            "∀x ∀y (Student(x) ∧ EnrolledIn(x, y) → StudiesFor(x, y)) ::: If someone is a student and enrolled in a course, then they must study for it.",
            "∀y (Course(y) → RequiresEffort(y)) ::: Every course requires some effort to pass.",
            "∀x ∀y (StudiesFor(x, y) → EnrolledIn(x, y)) ::: If someone studies for a course then they are enrolled in that course.",
            "∀x ∀y (Passes(x, y) → ReceivesCredit(x, y)) ::: If someone passes a course, they receive credit for it."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in course y",
            "Passes(x, y) ::: x passes course y",
            "RequiresEffort(y) ::: course y requires effort",
            "ReceivesCredit(x, y) ::: x receives credit for course y"
        ]
    },
    {
        "premises-NL": [
            "All students are either registered or not registered.",
            "If a student is not registered, then they are not on academic probation.",
            "Students who are registered might need help.",
            "If a student does not meet the GPA requirement, they may need help.",
            "A student can be registered if they meet GPA requirement.",
            "Students who do not meet the GPA requirement and don't have a waiver are put on probation."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Registered(x) ∨ ¬Registered(x))) ::: All students are either registered or not registered.",
            "∀x (Student(x) ∧ ¬Registered(x) → ¬AcademicProbation(x)) ::: If a student is not registered, then they are not on academic probation.",
            "∃x (Student(x) ∧ Registered(x) → NeedsHelp(x)) ::: Students who are registered might need help.",
            "∀x (Student(x) ∧ ¬MeetsGpaRequirement(x) → NeedsHelp(x)) ::: If a student does not meet the GPA requirement, they may need help.",
            "∀x (Student(x) ∧ MeetsGpaRequirement(x) → Registered(x)) ::: A student can be registered if they meet GPA requirement.",
            "∀x (Student(x) ∧ ¬MeetsGpaRequirement(x) ∧ ¬HasWaiver(x) → AcademicProbation(x)) ::: Students who do not meet the GPA requirement and don't have a waiver are put on probation."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "MeetsGpaRequirement(x) ::: x meets the GPA requirement",
            "HasWaiver(x) ::: x has a waiver",
            "AcademicProbation(x) ::: x is on academic probation",
            "IsRegistered(x) ::: x is registered",
            "NeedsHelp(x) ::: x needs help"
        ]
    },
    {
        "premises-NL": [
            "All students have advisors.",
            "If a student fails a course, it is included in their GPA.",
            "A student must get advisor approval before retaking a course.",
            "A student who retakes a course must be a student.",
            "If a student passes a course, they get credit for it.",
            "If a student fails a course and retakes it and passes it, then the failing grade is removed.",
            "If a student gets advisor approval, they are a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → HasAdvisor(x)) ::: All students have advisors.",
            "∀x ∀y (Student(x) ∧ Fails(x, y) → IncludedInGpa(x, y)) ::: If a student fails a course, it is included in their GPA.",
            "∀x ∀y (Student(x) ∧ Retakes(x, y) → AdvisorApproval(x)) ::: A student must get advisor approval before retaking a course.",
            "∀x ∀y (Retakes(x, y) → Student(x)) ::: A student who retakes a course must be a student.",
            "∀x ∀y (Passes(x, y) → ReceivesCredit(x, y)) ::: If a student passes a course, they get credit for it.",
            "∀x ∀y (Student(x) ∧ Fails(x, y) ∧ Retakes(x, y) ∧ Passes(x, y) → RemovedFromGpa(x, y)) ::: If a student fails a course and retakes it and passes it, then the failing grade is removed.",
            "∀x (AdvisorApproval(x) → Student(x)) ::: If a student gets advisor approval, they are a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Fails(x, y) ::: x fails course y",
            "Retakes(x, y) ::: x retakes course y",
            "Passes(x, y) ::: x passes course y",
            "IncludedInGpa(x, y) ::: course y is included in x's GPA",
            "RemovedFromGpa(x, y) ::: course y is removed from x's GPA",
            "AdvisorApproval(x) ::: x gets advisor approval"
        ]
    },
    {
        "premises-NL": [
            "All students must either be in good standing or owe money.",
            "Students who owe money cannot attend classes.",
            "If a student is registered, they must have met the prerequisites for their courses.",
            "To attend classes, a student must be registered.",
            "A student must pay tuition to be considered registered.",
            "A student who is registered must be a student.",
            "If a student is not in good standing, they are not registered.",
            "If a student is in good standing, is registered, and has paid tuition, then they can attend classes."
        ],
        "premises-FOL": [
            "∀x (Student(x) → InGoodStanding(x) ∨ OwesMoney(x)) ::: All students must either be in good standing or owe money.",
            "∀x (Student(x) ∧ OwesMoney(x) → ¬CanAttendClasses(x)) ::: Students who owe money cannot attend classes.",
            "∀x ∀y (Registered(x) ∧ EnrolledIn(x, y) → MeetsPrerequisites(x, y)) ::: If a student is registered, they must have met the prerequisites for their courses.",
            "∀x (CanAttendClasses(x) → Registered(x)) ::: To attend classes, a student must be registered.",
            "∀x (Registered(x) → PaidTuition(x)) ::: A student must pay tuition to be considered registered.",
            "∀x (Registered(x) → Student(x)) ::: A student who is registered must be a student.",
            "∀x (¬InGoodStanding(x) → ¬Registered(x)) ::: If a student is not in good standing, they are not registered.",
            "∀x (Student(x) ∧ InGoodStanding(x) ∧ Registered(x) ∧ PaidTuition(x) → CanAttendClasses(x)) ::: If a student is in good standing, is registered, and has paid tuition, then they can attend classes."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "InGoodStanding(x) ::: x is in good standing",
            "Registered(x) ::: x is registered",
            "PaidTuition(x) ::: x has paid tuition",
            "CanAttendClasses(x) ::: x can attend classes",
            "OwesMoney(x) ::: x owes money",
            "MeetsPrerequisites(x, y) ::: x meets prerequisites for y",
            "EnrolledIn(x, y) ::: x is enrolled in y"
        ]
    },
    {
        "premises-NL": [
            "All students must meet a residency requirement.",
            "A student cannot graduate if they haven't applied for graduation.",
            "A student must have completed all courses to apply for graduation.",
            "A student who is eligible to graduate must be a student.",
            "To be eligible to graduate, a student must have paid all fees.",
            "A student who has applied for graduation must have at least minimum GPA.",
            "Students who are eligible to graduate will eventually receive their degree.",
            "A student must have all required credits to apply for graduation.",
            "If a student has completed all required courses, has the required credits, their GPA is above the minimum, and has paid all fees, then they are eligible to graduate."
        ],
        "premises-FOL": [
            "∀x (Student(x) → MeetsResidencyRequirement(x)) ::: All students must meet a residency requirement.",
            "∀x (¬AppliedForGraduation(x) → ¬EligibleToGraduate(x)) ::: A student cannot graduate if they haven't applied for graduation.",
            "∀x (AppliedForGraduation(x) → CompletedAllCourses(x)) ::: A student must have completed all courses to apply for graduation.",
            "∀x (EligibleToGraduate(x) → Student(x)) ::: A student who is eligible to graduate must be a student.",
            "∀x (EligibleToGraduate(x) → PaidAllFees(x)) ::: To be eligible to graduate, a student must have paid all fees.",
            "∀x (AppliedForGraduation(x) → GpaAboveMinimum(x)) ::: A student who has applied for graduation must have at least minimum GPA.",
            "∀x (EligibleToGraduate(x) → ReceivedDegree(x)) ::: Students who are eligible to graduate will eventually receive their degree.",
            "∀x (AppliedForGraduation(x) → HasRequiredCredits(x)) ::: A student must have all required credits to apply for graduation.",
            "∀x (Student(x) ∧ CompletedAllCourses(x) ∧ HasRequiredCredits(x) ∧ GpaAboveMinimum(x) ∧ PaidAllFees(x) → EligibleToGraduate(x)) ::: If a student has completed all required courses, and has the required credits, and their GPA is above the minimum, and has paid all fees, then they are eligible to graduate."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "CompletedAllCourses(x) ::: x has completed all required courses",
            "HasRequiredCredits(x) ::: x has the required credits",
            "GpaAboveMinimum(x) ::: x's GPA is above the minimum",
            "PaidAllFees(x) ::: x has paid all fees",
            "EligibleToGraduate(x) ::: x is eligible to graduate",
            "MeetsResidencyRequirement(x) ::: x meets the residency requirement",
            "AppliedForGraduation(x) ::: x has applied for graduation",
            "ReceivedDegree(x) ::: x has received the degree"
        ]
    },
    {
        "premises-NL": [
            "All students who pay tuition on time are in good standing.",
            "Students who receive financial aid are required to maintain good standing.",
            "A student graduates if and only if they are in good standing and complete all required courses.",
            "Only students can graduate.",
            "Good standing implies no outstanding fees."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ PaysTuitionOnTime(x) → GoodStanding(x)) ::: All students who pay tuition on time are in good standing.",
            "∀x (Student(x) ∧ ReceivesFinancialAid(x) → GoodStanding(x)) ::: Students who receive financial aid are required to maintain good standing.",
            "∀x (Student(x) ∧ Graduates(x) ↔ (GoodStanding(x) ∧ CompletesAllCourses(x))) ::: A student graduates if and only if they are in good standing and complete all required courses.",
            "∀x (Graduates(x) → Student(x)) ::: Only students can graduate.",
            "∀x (GoodStanding(x) → ¬OutstandingFees(x)) ::: Good standing implies no outstanding fees.",
            "∀x (PaysTuitionOnTime(x) → ¬OutstandingFees(x)) ::: Paying tuition on time means no outstanding fees.",
            "∀x (ReceivesFinancialAid(x) → Enrolled(x,x)) ::: Receiving financial aid implies being enrolled.",
            "∀x (CompletesAllCourses(x) → TakesCourse(x,x)) ::: Completing all courses implies taking a course.",
            "∀x (Graduates(x) → TakesCourse(x,x)) ::: Graduating requires taking a course",
            "∀x (Student(x) → (Graduates(x) ∨ ¬Graduates(x))) ::: A student either graduates or does not.",
            "∀x (PaysTuitionOnTime(x) ∨ ¬PaysTuitionOnTime(x)) ::: Someone either pays tuition on time or does not.",
            "∀x (CompletesAllCourses(x) ∨ ¬CompletesAllCourses(x)) ::: Someone either completes all courses or does not.",
            "∀x (Graduates(x) → Diligent(x)) ::: Graduating requires being diligent."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PaysTuitionOnTime(x) ::: x pays tuition on time",
            "ReceivesFinancialAid(x) ::: x receives financial aid",
            "Graduates(x) ::: x graduates",
            "CompletesAllCourses(x) ::: x completes all required courses",
            "RequiresEffort(y) ::: y requires effort",
            "TakesCourse(x,y) ::: x takes course y",
            "Fails(x,y) ::: x fails y"
        ]
    },
    {
        "premises-NL": [
            "All graduate students funded by a grant are expected to publish a paper.",
            "Working diligently in the lab usually leads to publishing a paper.",
            "Administrative delays and equipment malfunctions can hinder progress in research.",
            "Students who publish papers graduate.",
            "Only graduate students are funded by a grant."
        ],
        "premises-FOL": [
            "∀x (GraduateStudent(x) ∧ FundedByGrant(x) → ExpectedToPublish(x)) ::: All graduate students funded by a grant are expected to publish a paper.",
            "∀x (WorksDiligentlyInLab(x) → (PublishesPaper(x) ∨ FacesChallenges(x))) ::: Working diligently in the lab usually leads to publishing a paper, or facing challenges",
            "∀x ((AdministrativeDelays(x) ∧ EquipmentMalfunctions(x)) → HindersProgress(x)) ::: Administrative delays and equipment malfunctions can hinder progress in research.",
            "∀x (PublishesPaper(x) → Graduates(x)) ::: Students who publish papers graduate.",
            "∀x (FundedByGrant(x) → GraduateStudent(x)) ::: Only graduate students are funded by a grant.",
            "∀x (GraduateStudent(x) ∨ ¬GraduateStudent(x)) ::: Someone is either a graduate student or not.",
            "∀x (WorksDiligentlyInLab(x) → Diligent(x)) ::: Working diligently in the lab implies being diligent.",
            "∀x (Diligent(x) → AttendsRegularly(x,x)) ::: Being diligent implies attending regularly.",
            "∀x (PublishesPaper(x) ∨ ¬PublishesPaper(x)) ::: Someone either publishes a paper or does not.",
            "∀x (Graduates(x) → Diligent(x)) ::: Graduating implies being diligent.",
            "∀x (FundedByGrant(x) ∨ ¬FundedByGrant(x)) ::: Someone either has funding by grant or does not.",
            "∀x (GraduateStudent(x) → Enrolled(x,x)) ::: A graduate student must be enrolled.",
            "∀x (ExpectedToPublish(x) → PublishesPaper(x) ∨ ¬PublishesPaper(x)) ::: Someone expected to publish will either publish or not."
        ],
        "predicates": [
            "GraduateStudent(x) ::: x is a graduate student",
            "FundedByGrant(x) ::: x is funded by a grant",
            "WorksDiligentlyInLab(x) ::: x works diligently in the lab",
            "PublishesPaper(x) ::: x publishes a paper",
            "AdministrativeDelays(x) ::: x faces administrative delays",
            "EquipmentMalfunctions(x) ::: x's equipment malfunctions",
            "Enrolled(x,y) ::: x is enrolled in y",
            "TakesCourse(x,y) ::: x takes course y",
            "Diligent(x) ::: x is diligent",
            "AttendsRegularly(x,y) ::: x attends y regularly"
        ]
    },
    {
        "premises-NL": [
            "All scholarship recipients meet certain criteria.",
            "If a student meets certain criteria and excels academically, then that student is an international student.",
            "All students who study hard and are enrolled in a difficult course excel academically.",
            "If a student is a scholarship recipient, then that student studies hard.",
            "There exists a student enrolled in Quantum Physics, and Quantum Physics is a difficult course.",
            "All students who are enrolled in quantum physics, take quantum physics.",
            "If a student meets certain criteria, then they are a student.",
            "There exists a scholarship recipient who meets certain criteria."
        ],
        "premises-FOL": [
            "∀x (ScholarshipRecipient(x) → MeetsCriteria(x)) ::: All scholarship recipients meet certain criteria.",
            "∀x ((MeetsCriteria(x) ∧ Excels(x)) → InternationalStudent(x)) ::: If a student meets certain criteria and excels academically, then that student is an international student.",
            "∀x ∀y ((Student(x) ∧ StudiesHard(x) ∧ Enrolled(x, y) ∧ DifficultCourse(y)) → Excels(x)) ::: All students who study hard and are enrolled in a difficult course excel academically.",
            "∀x (ScholarshipRecipient(x) → StudiesHard(x)) ::: If a student is a scholarship recipient, then that student studies hard.",
            "∃x (Student(x) ∧ Enrolled(x, quant) ∧ DifficultCourse(quant)) ::: There exists a student enrolled in Quantum Physics, and Quantum Physics is a difficult course.",
            "∀x ((Student(x) ∧ Enrolled(x, quant)) → Takes(x, quant)) ::: All students who are enrolled in quantum physics, take quantum physics.",
            "∀x (MeetsCriteria(x) → Student(x)) ::: If a student meets certain criteria, then they are a student.",
            "∃x (ScholarshipRecipient(x) ∧ MeetsCriteria(x)) ::: There exists a scholarship recipient who meets certain criteria."
        ],
        "predicates": [
            "ScholarshipRecipient(x) ::: x is a scholarship recipient",
            "InternationalStudent(x) ::: x is an international student",
            "Takes(x, y) ::: x takes course y",
            "DifficultCourse(y) ::: y is a difficult course",
            "Excels(x) ::: x excels academically",
            "StudiesHard(x) ::: x studies hard",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "MeetsCriteria(x) ::: x meets certain criteria"
        ]
    },
    {
        "premises-NL": [
            "All students are eligible to enroll.",
            "If a student is eligible, they can enroll.",
            "To attend a course, a student must enroll.",
            "To enroll, a student must be registered.",
            "If a student pays tuition, they are registered.",
            "If a student is registered, they are considered enrolled.",
            "Scheduling conflicts prevent enrollment.",
            "All persons are people."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Eligible(x)) ::: All students are eligible to enroll.",
            "∀x (Eligible(x) → Enrolls(x)) ::: If a student is eligible, they can enroll.",
            "∀x (CanAttend(x) → Enrolls(x)) ::: To attend a course, a student must enroll.",
            "∀x (Enrolls(x) → Registered(x)) ::: To enroll, a student must be registered.",
            "∀x (PaysTuition(x) → Registered(x)) ::: If a student pays tuition, they are registered.",
            "∀x (Registered(x) → Enrolls(x)) ::: If a student is registered, they are considered enrolled.",
            "∀x (SchedulingConflict(x) → ¬Enrolls(x)) ::: Scheduling conflicts prevent enrollment.",
            "∀x (Person(x) → People(x)) ::: All persons are people."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolls(x) ::: x enrolls in a course",
            "PaysTuition(x) ::: x pays tuition",
            "SchedulingConflict(x) ::: x has a scheduling conflict",
            "CanAttend(x) ::: x can attend the course",
            "Registered(x) ::: x is registered",
            "Eligible(x) ::: x is eligible to enroll"
        ]
    },
    {
        "premises-NL": [
            "All students must meet certain academic requirements.",
            "If a student meets all academic requirements, they are in good academic standing.",
            "If a student is in good academic standing, they are not on academic probation.",
            "Graduate students are students.",
            "If a student registers in a course then attends the course.",
            "If a student is enrolled in a graduate course, they must pay tuition unless they have a scholarship.",
            "Students with scholarships do not have tuition due.",
            "If tuition is not due, the student pays tuition.",
            "Graduate students register to graduate courses.",
            "There exists a student.",
            "There exists a graduate course."
        ],
        "premises-FOL": [
            "∀x (Student(x) → MeetsRequirements(x)) ::: All students must meet certain academic requirements.",
            "∀x (MeetsRequirements(x) → GoodStanding(x)) ::: If a student meets all academic requirements, they are in good academic standing.",
            "∀x (GoodStanding(x) → ¬AcademicProbation(x)) ::: If a student is in good academic standing, they are not on academic probation.",
            "∀x (GraduateStudent(x) → Student(x)) ::: Graduate students are students.",
            "∀x ∀y (Registers(x, y) → Attends(x, y)) ::: If a student registers in a course then attends the course.",
            "∀x ∀y ((Student(x) ∧ Enrolled(x, y) ∧ GraduateCourse(y)) → (PaysTuition(x) ∨ HasScholarship(x))) ::: If a student is enrolled in a graduate course, they must pay tuition unless they have a scholarship.",
            "∀x (HasScholarship(x) → ¬TuitionDue(x)) ::: Students with scholarships do not have tuition due.",
            "∀x (¬TuitionDue(x) → PaysTuition(x)) ::: If tuition is not due, the student pays tuition.",
            "∀x ∀y ((Student(x) ∧ GraduateCourse(y)) → Registers(x, y)) ::: Graduate students register to graduate courses.",
            "∃x Student(x) ::: There exists a student.",
            "∃y GraduateCourse(y) ::: There exists a graduate course."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "GraduateCourse(y) ::: y is a graduate course",
            "PaysTuition(x) ::: x pays tuition",
            "AcademicProbation(x) ::: x is on academic probation",
            "HasScholarship(x) ::: x has a scholarship",
            "MeetsRequirements(x) ::: x meets all requirements",
            "GoodStanding(x) ::: x is in good standing",
            "TuitionDue(x) ::: Tuition is due for x",
            "Registers(x,y) ::: x registers to y",
            "Attends(x,y) ::: x attends y"
        ]
    },
    {
        "premises-NL": [
            "EnrolledIn(x, CS101)::: x is enrolled in CS101",
            "Passes(x, CS101)::: x passes CS101",
            "PrerequisiteFor(CS101, CS201)::: CS101 is a prerequisite for CS201",
            "Professor(ProfA)::: ProfA is a professor",
            "Teaches(ProfA, CS101)::: ProfA teaches CS101",
            "Course(CS101)::: CS101 is a course",
            "Difficult(CS201)::: CS201 is a difficult course",
            "Studies(x, Math)::: x studies Math",
            "∀x (EnrolledIn(x, CS101) ∧ Passes(x, CS101) ∧ PrerequisiteFor(CS101, CS201) → EligibleToEnroll(x, CS201)) ::: If someone is enrolled in CS101 and passes, and CS101 is a prerequisite for CS201, then they are eligible to enroll in CS201."
        ],
        "premises-FOL": [
            "EnrolledIn(x, CS101) ::: x is enrolled in CS101",
            "Passes(x, CS101) ::: x passes CS101",
            "PrerequisiteFor(CS101, CS201) ::: CS101 is a prerequisite for CS201",
            "Professor(ProfA) ::: ProfA is a professor",
            "Teaches(ProfA, CS101) ::: ProfA teaches CS101",
            "Course(CS101) ::: CS101 is a course",
            "Difficult(CS201) ::: CS201 is a difficult course",
            "Studies(x, Math) ::: x studies Math",
            "∀x (EnrolledIn(x, CS101) ∧ Passes(x, CS101) ∧ PrerequisiteFor(CS101, CS201) → EligibleToEnroll(x, CS201)) ::: If someone is enrolled in CS101 and passes, and CS101 is a prerequisite for CS201, then they are eligible to enroll in CS201."
        ],
        "predicates": [
            "EnrolledIn(x, y) ::: x is enrolled in y",
            "Passes(x, y) ::: x passes y",
            "PrerequisiteFor(x, y) ::: x is a prerequisite for y",
            "EligibleToEnroll(x, y) ::: x is eligible to enroll in y",
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches y",
            "Course(x) ::: x is a course",
            "Difficult(x) ::: x is a difficult course",
            "Studies(x, y) ::: x studies y"
        ]
    },
    {
        "premises-NL": [
            "Takes(x, CS101) ::: x takes CS101",
            "Takes(x, CS201) ::: x takes CS201",
            "Passes(x, CS101) ::: x passes CS101",
            "Requires(CS201, CS101) ::: CS201 requires CS101",
            "Professor(ProfA) ::: ProfA is a professor",
            "Teaches(ProfA, CS201) ::: ProfA teaches CS201",
            "Course(CS201) ::: CS201 is a course",
            "Difficult(CS301) ::: CS301 is a difficult course",
            "Student(x) ::: x is a student",
            "AdvancedCourse(CS301) ::: CS301 is an advanced course",
            "∀x (Takes(x, CS101) ∧ Takes(x, CS201) ∧ Passes(x, CS101) ∧ Requires(CS201, CS101) → EligibleForAdvancedCS(x)) ::: If all students who take CS101 and CS201 pass CS101, and CS201 requires CS101, then all students who take CS201 are eligible to take advanced CS courses."
        ],
        "premises-FOL": [
            "Takes(x, CS101) ::: x takes CS101",
            "Takes(x, CS201) ::: x takes CS201",
            "Passes(x, CS101) ::: x passes CS101",
            "Requires(CS201, CS101) ::: CS201 requires CS101",
            "Professor(ProfA) ::: ProfA is a professor",
            "Teaches(ProfA, CS201) ::: ProfA teaches CS201",
            "Course(CS201) ::: CS201 is a course",
            "Difficult(CS301) ::: CS301 is a difficult course",
            "Student(x) ::: x is a student",
            "AdvancedCourse(CS301) ::: CS301 is an advanced course",
            "∀x (Takes(x, CS101) ∧ Takes(x, CS201) ∧ Passes(x, CS101) ∧ Requires(CS201, CS101) → EligibleForAdvancedCS(x)) ::: If all students who take CS101 and CS201 pass CS101, and CS201 requires CS101, then all students who take CS201 are eligible to take advanced CS courses."
        ],
        "predicates": [
            "Takes(x, y) ::: x takes y",
            "Passes(x, y) ::: x passes y",
            "Requires(x, y) ::: x requires y",
            "EligibleForAdvancedCS(x) ::: x is eligible for advanced CS courses",
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches y",
            "Course(x) ::: x is a course",
            "Difficult(x) ::: x is a difficult course",
            "Student(x) ::: x is a student",
            "AdvancedCourse(x) ::: x is an advanced course"
        ]
    },
    {
        "premises-NL": [
            "EnrolledIn(x, CS101) ::: x is enrolled in CS101",
            "RequiresTextbook(CS101, TextbookA) ::: CS101 requires TextbookA",
            "Student(x) ::: x is a student",
            "Course(CS101) ::: CS101 is a course",
            "Textbook(TextbookA) ::: TextbookA is a textbook",
            "Professor(ProfA) ::: ProfA is a professor",
            "Teaches(ProfA, CS101) ::: ProfA teaches CS101",
            "Expensive(TextbookA) ::: TextbookA is expensive",
            "Buys(x, TextbookA) ::: x buys TextbookA",
            "Takes(x, CS201) ::: x takes CS201",
            "∀x ∀y (EnrolledIn(x, y) ∧ RequiresTextbook(y, z) → (NeedsToAcquire(x, z) ∨ Possesses(x, z))) ::: If a student is enrolled in a course and the course requires a textbook, then the student needs to acquire the textbook unless they already possess it."
        ],
        "premises-FOL": [
            "EnrolledIn(x, CS101) ::: x is enrolled in CS101",
            "RequiresTextbook(CS101, TextbookA) ::: CS101 requires TextbookA",
            "Student(x) ::: x is a student",
            "Course(CS101) ::: CS101 is a course",
            "Textbook(TextbookA) ::: TextbookA is a textbook",
            "Professor(ProfA) ::: ProfA is a professor",
            "Teaches(ProfA, CS101) ::: ProfA teaches CS101",
            "Expensive(TextbookA) ::: TextbookA is expensive",
            "Buys(x, TextbookA) ::: x buys TextbookA",
            "Takes(x, CS201) ::: x takes CS201",
            "∀x ∀y (EnrolledIn(x, y) ∧ RequiresTextbook(y, z) → (NeedsToAcquire(x, z) ∨ Possesses(x, z))) ::: If a student is enrolled in a course and the course requires a textbook, then the student needs to acquire the textbook unless they already possess it."
        ],
        "predicates": [
            "EnrolledIn(x, y) ::: x is enrolled in y",
            "RequiresTextbook(y, z) ::: Course y requires textbook z",
            "NeedsToAcquire(x, z) ::: x needs to acquire z",
            "Possesses(x, z) ::: x possesses z",
            "Student(x) ::: x is a student",
            "Course(y) ::: y is a course",
            "Textbook(z) ::: z is a textbook",
            "Professor(w) ::: w is a professor",
            "Teaches(w, y) ::: w teaches y",
            "Expensive(z) ::: z is expensive",
            "Buys(x, z) ::: x buys z"
        ]
    },
    {
        "premises-NL": [
            "All enrolled students attend lectures or study hard.",
            "If someone attends lectures and studies hard, they pass the final exam.",
            "If someone passes the final exam, then they pass the course.",
            "Difficult courses are courses that are difficult.",
            "If someone is enrolled in a difficult course and does not study hard, they must attend lectures to pass the final.",
            "If someone is enrolled, then they study or attend lecture."
        ],
        "premises-FOL": [
            "∀x (Enrolled(x) → (AttendsLecture(x) ∨ StudiesHard(x))) ::: All enrolled students attend lectures or study hard.",
            "∀x ((AttendsLecture(x) ∧ StudiesHard(x)) → PassesFinal(x)) ::: If someone attends lectures and studies hard, they pass the final exam.",
            "∀x (PassesFinal(x) → PassesCourse(x)) ::: If someone passes the final exam, then they pass the course.",
            "∀x (DifficultCourse(x) → DifficultCourse(x)) ::: Difficult courses are courses that are difficult.",
            "∀x ((Enrolled(x) ∧ DifficultCourse(x) ∧ ¬StudiesHard(x)) → AttendsLecture(x)) ::: If someone is enrolled in a difficult course and does not study hard, they must attend lectures to pass the final.",
            "∀x (Enrolled(x) → (StudiesHard(x) ∨ AttendsLecture(x))) ::: If someone is enrolled, then they study or attend lecture."
        ],
        "predicates": [
            "Enrolled(x) ::: x is enrolled in a course",
            "DifficultCourse(x) ::: x is a difficult course",
            "PassesFinal(x) ::: x passes the final exam",
            "AttendsLecture(x) ::: x attends lectures",
            "StudiesHard(x) ::: x studies hard",
            "PassesCourse(x) ::: x passes the course"
        ]
    },
    {
        "premises-NL": [
            "All students either take a prerequisite or are interested in a subject.",
            "If a student takes a prerequisite and does well, they are interested in the subject.",
            "Advanced courses are hard courses.",
            "If a course requires a lab, then students taking it take a prerequisite.",
            "If someone does well, then they study or go to lab.",
            "If someone is interested and does well, they enroll in the next course.",
            "If a course is not advanced, then it is not a hard course."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (TakesPrerequisite(x) ∨ Interested(x))) ::: All students either take a prerequisite or are interested in a subject.",
            "∀x ((TakesPrerequisite(x) ∧ DoesWell(x)) → Interested(x)) ::: If a student takes a prerequisite and does well, they are interested in the subject.",
            "∀x (AdvancedCourse(x) → HardCourse(x)) ::: Advanced courses are hard courses.",
            "∀x (RequiresLab(x) → TakesPrerequisite(x)) ::: If a course requires a lab, then students taking it take a prerequisite.",
            "∀x (DoesWell(x) → (Studies(x) ∨ GoesToLab(x))) ::: If someone does well, then they study or go to lab.",
            "∀x ((Interested(x) ∧ DoesWell(x)) → LikelyEnrolls(x)) ::: If someone is interested and does well, they enroll in the next course.",
            "∀x (¬AdvancedCourse(x) → ¬HardCourse(x)) ::: If a course is not advanced, then it is not a hard course."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "TakesPrerequisite(x) ::: x takes a prerequisite course",
            "DoesWell(x) ::: x does well in a course",
            "Interested(x) ::: x is interested in a subject",
            "AdvancedCourse(x) ::: x is an advanced course",
            "RequiresLab(x) ::: x requires a lab component",
            "LikelyEnrolls(x) ::: x is likely to enroll in the next course",
            "HardCourse(x) ::: x is a hard course"
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled in at least one course.",
            "If a student studies hard and asks questions, then they understand the material.",
            "If someone understands the material, then they attend lectures.",
            "If a student attends lectures, the professor notices.",
            "If the professor notices a student, and the professor cares, the student passes the course.",
            "If a student asks questions, then they understand the material.",
            "The professor cares about students or is not teaching.",
            "The professor is teaching."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x)) ::: All students are enrolled in at least one course.",
            "∀x ((StudiesHard(x) ∧ AsksQuestions(x)) → UnderstandsMaterial(x)) ::: If a student studies hard and asks questions, then they understand the material.",
            "∀x (UnderstandsMaterial(x) → AttendsLecture(x)) ::: If someone understands the material, then they attend lectures.",
            "∀x (AttendsLecture(x) → Notices(professor, x)) ::: If a student attends lectures, the professor notices.",
            "∀x ((Notices(professor, x) ∧ Cares(professor)) → PassesCourse(x)) ::: If the professor notices a student, and the professor cares, the student passes the course.",
            "∀x (AsksQuestions(x) → UnderstandsMaterial(x)) ::: If a student asks questions, then they understand the material.",
            "Cares(professor) ∨ ¬Teaches(professor) ::: The professor cares about students or is not teaching.",
            "Teaches(professor) ::: The professor is teaching."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x) ::: x is enrolled in a course",
            "StudiesHard(x) ::: x studies hard",
            "AsksQuestions(x) ::: x asks questions in class",
            "PassesCourse(x) ::: x passes the course",
            "Cares(x) ::: x cares about students",
            "UnderstandsMaterial(x) ::: x understands the material",
            "AttendsLecture(x) ::: x attends lectures"
        ]
    },
    {
        "premises-NL": [
            "All students either have a GPA below 2.0 or above 2.0.",
            "Students who have a GPA below 2.0 are warned.",
            "Full time students take course or fail.",
            "To be eligible for graduation, a student must complete the required credits.",
            "To graduate student must apply for graduation.",
            "If a student seeks help they meet with advisor.",
            "If a student has not completed the required credits, they must meet with an advisor.",
            "If a student does not meet with an advisor, they do not seek help.",
            "A student seeks help or does not."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (GPA_Below_2_0(x) ∨ ¬GPA_Below_2_0(x))) ::: All students either have a GPA below 2.0 or above 2.0.",
            "∀x (GPA_Below_2_0(x) → Warned(x)) ::: Students who have a GPA below 2.0 are warned.",
            "∀x (FullTime(x) → (TakesCourse(x) ∨ FailsCourse(x))) ::: Full time students take course or fail.",
            "∀x (EligibleForGraduation(x) → CompletedRequiredCredits(x)) ::: To be eligible for graduation, a student must complete the required credits.",
            "∀x (Graduates(x) → AppliesForGraduation(x)) ::: To graduate student must apply for graduation.",
            "∀x (SeeksHelp(x) → MeetsWithAdvisor(x)) ::: If a student seeks help they meet with advisor.",
            "∀x (¬CompletedRequiredCredits(x) → MeetsWithAdvisor(x)) ::: If a student has not completed the required credits, they must meet with an advisor.",
            "∀x (¬MeetsWithAdvisor(x) → ¬SeeksHelp(x)) ::: If a student does not meet with an advisor, they do not seek help.",
            "∀x (SeeksHelp(x) ∨ ¬SeeksHelp(x)) ::: A student seeks help or does not."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "GPA_Below_2_0(x) ::: x has a GPA below 2.0",
            "CompletedRequiredCredits(x) ::: x has completed the required credits",
            "MeetsWithAdvisor(x) ::: x meets with an academic advisor",
            "EligibleForGraduation(x) ::: x is eligible for graduation",
            "TakesCourse(x) ::: x takes a course",
            "PassesCourse(x) ::: x passes the course",
            "SeeksHelp(x) ::: x seeks academic help",
            "FullTime(x) ::: x is full time",
            "AppliesForGraduation(x) ::: x applies for graduation"
        ]
    },
    {
        "premises-NL": [
            "If someone studies hard, they understand the material.",
            "If someone understands the material and attends all the lectures, they will pass the exam.",
            "If someone is a good student, they attend all the lectures.",
            "Alice is a good student.",
            "Alice studies hard.",
            "Understanding the material is required to pass the exam."
        ],
        "premises-FOL": [
            "∀x (StudiesHard(x) → UnderstandsMaterial(x)) ::: If someone studies hard, they understand the material.",
            "∀x ((UnderstandsMaterial(x) ∧ AttendsLectures(x)) → PassExam(x)) ::: If someone understands the material and attends all the lectures, they will pass the exam.",
            "∀x (GoodStudent(x) → AttendsLectures(x)) ::: If someone is a good student, they attend all the lectures.",
            "GoodStudent(Alice) ::: Alice is a good student.",
            "StudiesHard(Alice) ::: Alice studies hard.",
            "∀x (PassExam(x) → UnderstandsMaterial(x)) ::: Understanding the material is required to pass the exam."
        ],
        "predicates": [
            "StudiesHard(x) ::: x studies hard",
            "PassExam(x) ::: x will pass the exam",
            "UnderstandsMaterial(x) ::: x understands the material",
            "AttendsLectures(x) ::: x attends all the lectures",
            "GoodStudent(x) ::: x is a good student"
        ]
    },
    {
        "premises-NL": [
            "All students take courses.",
            "Some courses require prerequisites.",
            "If a student is enrolled in a course, then the student takes the course.",
            "If a course requires a prerequisite and a student does not meet it, then the student is not allowed to enroll in that course.",
            "There exists a student.",
            "There exists a course that requires a prerequisite.",
            "If a student takes a course and satisfies the prerequisite, then the student meets the prerequisite.",
            "If a student is enrolled in a course and is allowed to enroll, then they are smart."
        ],
        "premises-FOL": [
            "∀x ∃y (Student(x) → TakesCourse(x, y)) ::: All students take courses.",
            "∃y ∃z RequiresPrerequisite(y, z) ::: Some courses require prerequisites.",
            "∀x ∀y (EnrolledIn(x, y) → TakesCourse(x, y)) ::: If a student is enrolled in a course, then the student takes the course.",
            "∀x ∀y ∀z (RequiresPrerequisite(y, z) ∧ ¬MeetsPrerequisite(x, z) → ¬AllowedToEnroll(x, y)) ::: If a course requires a prerequisite and a student does not meet it, then the student is not allowed to enroll in that course.",
            "∃x Student(x) ::: There exists a student.",
            "∃y ∃z RequiresPrerequisite(y, z) ::: There exists a course that requires a prerequisite.",
            "∀x ∀y (TakesCourse(x, y) ∧ PrereqSatisfied(x, y) → MeetsPrerequisite(x, y)) ::: If a student takes a course and satisfies the prerequisite, then the student meets the prerequisite.",
            "∀x ∀y (EnrolledIn(x, y) ∧ AllowedToEnroll(x,y) → Smart(x)) ::: If a student is enrolled in a course and is allowed to enroll, then they are smart."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in course y",
            "RequiresPrerequisite(y, z) ::: Course y requires course z as a prerequisite",
            "MeetsPrerequisite(x, z) ::: x meets the prerequisite z",
            "TakesCourse(x, y) ::: x takes course y",
            "PrereqSatisfied(x, y) ::: Student x satisfied prerequisite y",
            "Smart(x) ::: x is a smart student",
            "AllowedToEnroll(x,y) ::: x is allowed to enroll in y"
        ]
    },
    {
        "premises-NL": [
            "Every student either works hard or does not.",
            "If a student attends class, they study.",
            "If a student studies and asks questions, they understand the material.",
            "If a student understands the material, they will not fail.",
            "Only diligent students attend class.",
            "Diligent students also ask questions.",
            "Asking questions is necessary to understand material.",
            "Attending class and studying implies working hard.",
            "Working hard means studying diligently.",
            "If a student does not understand the material, they might fail.",
            "Failing is the opposite of succeeding.",
            "To succeed, a student must study diligently.",
            "If a student attends class and studies, they work hard.",
            "If someone attends class, they are diligent."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (WorksHard(x) ∨ ¬WorksHard(x))) ::: Every student either works hard or does not.",
            "∀x (Student(x) ∧ AttendsClass(x) → Studies(x)) ::: If a student attends class, they study.",
            "∀x (Student(x) ∧ Studies(x) ∧ AsksQuestions(x) → UnderstandsMaterial(x)) ::: If a student studies and asks questions, they understand the material.",
            "∀x (Student(x) ∧ UnderstandsMaterial(x) → ¬Fails(x)) ::: If a student understands the material, they will not fail.",
            "∀x (AttendsClass(x) → Diligent(x)) ::: Only diligent students attend class.",
            "∀x (Diligent(x) → AsksQuestions(x)) ::: Diligent students also ask questions.",
            "∀x (AsksQuestions(x) → UnderstandsMaterial(x)) ::: Asking questions is necessary to understand material.",
            "∀x (Student(x) ∧ AttendsClass(x) ∧ Studies(x) → WorksHard(x)) ::: Attending class and studying implies working hard.",
            "∀x (WorksHard(x) → StudiesDiligently(x)) ::: Working hard means studying diligently.",
            "∀x (¬UnderstandsMaterial(x) → MayFail(x)) ::: If a student does not understand the material, they might fail.",
            "∀x (Fails(x) ↔ ¬Succeeds(x)) ::: Failing is the opposite of succeeding.",
            "∀x (Succeeds(x) → StudiesDiligently(x)) ::: To succeed, a student must study diligently.",
            "∀x (Student(x) ∧ AttendsClass(x) ∧ Studies(x) → WorksHard(x)) ::: If a student attends class and studies, they work hard.",
            "∀x (AttendsClass(x) → Diligent(x)) ::: If someone attends class, they are diligent."
        ],
        "predicates": [
            "WorksHard(x) ::: x works hard",
            "Fails(x) ::: x fails",
            "AttendsClass(x) ::: x attends class",
            "AsksQuestions(x) ::: x asks questions",
            "Studies(x) ::: x studies",
            "UnderstandsMaterial(x) ::: x understands material"
        ]
    },
    {
        "premises-NL": [
            "All students who take an advanced course are dedicated.",
            "If a student is dedicated and submits assignments, then they pass the course.",
            "If a student passes a course, then they do not fail.",
            "If a student takes a course, they are a student.",
            "If a student does not submit assignments and does not pass, then they fail the course.",
            "If a student fails, they will eventually fail.",
            "All students are students.",
            "All courses are courses."
        ],
        "premises-FOL": [
            "∀x ∀y (Student(x) ∧ Takes(x, y) ∧ AdvancedCourse(y) → Dedicated(x)) ::: All students who take an advanced course are dedicated.",
            "∀x ∀y (Dedicated(x) ∧ SubmitsAssignments(x) → Passes(x, y)) ::: If a student is dedicated and submits assignments, then they pass the course.",
            "∀x ∀y (Passes(x, y) → ¬Fails(x, y)) ::: If a student passes a course, then they do not fail.",
            "∀x ∀y (Takes(x, y) → Student(x)) ::: If a student takes a course, they are a student.",
            "∀x ∀y (¬SubmitsAssignments(x) ∧ ¬Passes(x, y) → Fails(x, y)) ::: If a student does not submit assignments and does not pass, then they fail the course.",
            "∀x ∀y (Fails(x, y) → EventuallyFails(x)) ::: If a student fails, they will eventually fail.",
            "∀x (Student(x) → Student(x)) ::: All students are students.",
            "∀y (AdvancedCourse(y) → AdvancedCourse(y)) ::: All courses are courses."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Takes(x, y) ::: x takes course y",
            "AdvancedCourse(y) ::: y is an advanced course",
            "SubmitsAssignments(x) ::: x submits assignments",
            "Passes(x, y) ::: x passes course y",
            "Fails(x, y) ::: x fails course y",
            "EventuallyFails(x) ::: x will eventually fail"
        ]
    },
    {
        "premises-NL": [
            "All professors are dedicated.",
            "If a professor is dedicated, they either provide sufficient resources or are teaching an easy course.",
            "If a course is difficult, it is not easy.",
            "If a professor teaches a difficult course and provides resources, students will succeed in that course.",
            "If students succeed in a course, then the course is good.",
            "If a course is not good, then students do not succeed in that course.",
            "All students are students.",
            "All courses are courses.",
            "All professors are professors."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Dedicated(x)) ::: All professors are dedicated.",
            "∀x (Dedicated(x) → (ProvidesResources(x) ∨ TeachesEasyCourse(x))) ::: If a professor is dedicated, they either provide sufficient resources or teach an easy course.",
            "∀y (DifficultCourse(y) → ¬TeachesEasyCourse(y)) ::: If a course is difficult, it is not easy.",
            "∀x ∀y (Professor(x) ∧ Teaches(x, y) ∧ DifficultCourse(y) ∧ ProvidesResources(x) → StudentSucceeds(y)) ::: If a professor teaches a difficult course and provides resources, students will succeed in that course.",
            "∀y (StudentSucceeds(y) → GoodCourse(y)) ::: If students succeed in a course, then the course is good.",
            "∀y (¬GoodCourse(y) → ¬StudentSucceeds(y)) ::: If a course is not good, then students do not succeed in that course.",
            "∀x (Student(x) → Student(x)) ::: All students are students.",
            "∀y (DifficultCourse(y) → DifficultCourse(y)) ::: All courses are courses.",
            "∀x (Professor(x) → Professor(x)) ::: All professors are professors."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches course y",
            "DifficultCourse(y) ::: y is a difficult course",
            "ProvidesResources(x) ::: x provides sufficient resources",
            "StudentSucceeds(y) ::: students succeed in course y",
            "Studies(x) ::: x studies",
            "Enrolled(x,y) ::: x is enrolled in y",
            "Student(x) ::: x is a student"
        ]
    },
    {
        "premises-NL": [
            "All students take courses.",
            "If a student does not attend class, then they skip class.",
            "If a student studies and is smart, then they will pass the course.",
            "If a course is not difficult, then skipping does not automatically cause failure.",
            "A student is either smart or not smart.",
            "If a student takes a course and passes, the course is not too hard.",
            "All students are students.",
            "All classes are classes.",
            "If a student skips class they do not attend.",
            "A student who attends class is not skipping class."
        ],
        "premises-FOL": [
            "∀x ∃y Takes(x, y) ::: All students take courses.",
            "∀x (¬AttendsClass(x) → SkipsClass(x)) ::: If a student does not attend class, then they skip class.",
            "∀x ∀y (Studies(x) ∧ Smart(x) → Passes(x, y)) ::: If a student studies and is smart, then they will pass the course.",
            "∀y (¬DifficultCourse(y) → ¬(SkipsClass(x) ∧ Fails(x, y))) ::: If a course is not difficult, then skipping does not automatically cause failure.",
            "∀x (Student(x) → (Smart(x) ∨ ¬Smart(x))) ::: A student is either smart or not smart.",
            "∀x ∀y (Takes(x, y) ∧ Passes(x, y) → ¬DifficultCourse(y)) ::: If a student takes a course and passes, the course is not too hard.",
            "∀x (Student(x) → Student(x)) ::: All students are students.",
            "∀y (DifficultCourse(y) → DifficultCourse(y)) ::: All classes are classes.",
            "∀x (SkipsClass(x) → ¬AttendsClass(x)) ::: If a student skips class they do not attend.",
            "∀x (AttendsClass(x) → ¬SkipsClass(x)) ::: A student who attends class is not skipping class."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Takes(x, y) ::: x takes course y",
            "DifficultCourse(y) ::: y is a difficult course",
            "Passes(x, y) ::: x passes course y",
            "Studies(x) ::: x studies",
            "SkipsClass(x) ::: x skips class",
            "Smart(x) ::: x is smart",
            "AttendsClass(x) ::: x attends class"
        ]
    },
    {
        "premises-NL": [
            "All professors teach courses.",
            "If a professor provides adequate feedback, then students will pass if they study.",
            "If a student is enrolled in a course and does not study, then they are at risk of failing.",
            "If a student fails, then they do not pass.",
            "If a professor gives difficult exams, then the course is difficult.",
            "If a student does not study, then they will not be prepared for difficult exams.",
            "All students are students.",
            "All professors are professors.",
            "If someone is prepared then they study.",
            "If someone takes a course they are a student.",
            "If a student does not pass they fail."
        ],
        "premises-FOL": [
            "∀x ∃y Teaches(x, y) ::: All professors teach courses.",
            "∀x ∀y (Professor(x) ∧ ProvidesFeedback(x) ∧ Student(y) ∧ Studies(y) → Passes(y)) ::: If a professor provides adequate feedback, then students will pass if they study.",
            "∀y ∀z (Student(y) ∧ Enrolled(y, z) ∧ ¬Studies(y) → AtRiskOfFailing(y)) ::: If a student is enrolled in a course and does not study, then they are at risk of failing.",
            "∀y (Fails(y) → ¬Passes(y)) ::: If a student fails, then they do not pass.",
            "∀x ∀y (Professor(x) ∧ GivesDifficultExams(x) → DifficultCourse(y)) ::: If a professor gives difficult exams, then the course is difficult.",
            "∀y (¬Studies(y) → ¬PreparedForExams(y)) ::: If a student does not study, then they will not be prepared for difficult exams.",
            "∀y (Student(y) → Student(y)) ::: All students are students.",
            "∀x (Professor(x) → Professor(x)) ::: All professors are professors.",
            "∀x (PreparedForExams(x) → Studies(x)) ::: If someone is prepared then they study.",
            "∀x ∀y (Teaches(x, y) → Student(y)) ::: If someone takes a course they are a student.",
            "∀x (¬Passes(x) → Fails(x)) ::: If a student does not pass they fail."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "GivesDifficultExams(x) ::: x gives difficult exams",
            "ProvidesFeedback(x) ::: x provides adequate feedback",
            "Student(y) ::: y is a student",
            "Studies(y) ::: y studies",
            "Passes(y) ::: y passes",
            "Fails(y) ::: y fails",
            "Teaches(x, y) ::: x teaches y",
            "Enrolled(y, z) ::: y is enrolled in course z"
        ]
    },
    {
        "premises-NL": [
            "All students must pay their tuition to enroll in courses.",
            "If a student applies for aid and meets requirements, they receive aid.",
            "To enroll in courses, a student must meet all enrollment requirements, unless there is a delay.",
            "If a student receives aid, they are considered to have paid their tuition.",
            "A student must pay tuition or have a waiver or get student aid to enroll in classes",
            "Unless given an extension, one must pay tuition before taking a course",
            "To meet enrollment requirements, a student must have paid their tuition.",
            "Some courses have prerequisites",
            "To take a course, one must meet its prerequisites",
            "Students with prerequisites can request an extension if they have not completed a course.",
            "If the course has no prerequisites, you do not need to meet them.",
            "Students with no prerequisites can enroll in the course if they have not passed prerequistes."
        ],
        "premises-FOL": [
            "∀x ∀y (Student(x) ∧ EnrollsIn(x, y) → PaysTuition(x)) ::: All students must pay their tuition to enroll in courses.",
            "∀x (AppliesForAid(x) ∧ MeetsRequirements(x) → ReceivesAid(x)) ::: If a student applies for aid and meets requirements, they receive aid.",
            "∀x ∀y ((Student(x) ∧ EnrollsIn(x, y)) → (MeetsRequirements(x) ∨ GetsExtension(x))) ::: To enroll in courses, a student must meet all enrollment requirements, unless there is a delay.",
            "∀x (ReceivesAid(x) → PaysTuition(x)) ::: If a student receives aid, they are considered to have paid their tuition.",
            "∀x ∀y (Student(x) ∧ EnrollsIn(x, y) → (PaysTuition(x) ∨ HasWaiver(x) ∨ ReceivesAid(x))) ::: A student must pay tuition or have a waiver or get student aid to enroll in classes",
            "∀x ∀y ((TakesCourse(x,y) ∧ ¬GetsExtension(x)) → PaysTuition(x)) ::: Unless given an extension, one must pay tuition before taking a course",
            "∀x (MeetsRequirements(x) → PaysTuition(x)) ::: To meet enrollment requirements, a student must have paid their tuition.",
            "∃y HasPrerequisites(y) ::: Some courses have prerequisites",
            "∀x ∀y ((TakesCourse(x,y) ∧ HasPrerequisites(y)) → PassedPrerequisites(x,y)) ::: To take a course, one must meet its prerequisites",
            "∀x ∀y ((Student(x) ∧ HasPrerequisites(y)) → GetsExtension(x)) ::: Students with prerequisites can request an extension if they have not completed a course.",
            "∀y (¬HasPrerequisites(y) → ¬MeetsRequirements(y)) ::: If the course has no prerequisites, you do not need to meet them.",
            "∀x ∀y ((¬PassedPrerequisites(x, y) ∧ ¬HasPrerequisites(y)) → EnrollsIn(x,y)) ::: Students with no prerequisites can enroll in the course if they have not passed prerequistes."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PaysTuition(x) ::: x pays tuition",
            "EnrollsIn(x, y) ::: x enrolls in course y",
            "HasWaiver(x) ::: x has a tuition waiver",
            "AppliesForAid(x) ::: x applies for student aid",
            "ReceivesAid(x) ::: x receives student aid",
            "MeetsRequirements(x) ::: x meets the enrollment requirements",
            "TakesCourse(x,y) ::: x takes course y",
            "HasPrerequisites(y) ::: Course y has prerequisites.",
            "PassedPrerequisites(x, y) ::: Student x has passed all prerequisites for course y",
            "GetsExtension(x) ::: Student x has been given an extension"
        ]
    },
    {
        "premises-NL": [
            "All students must be enrolled in a course to pass it.",
            "CS101 is a course.",
            "If a student is enrolled in a course and passes it, they satisfy the requirements for that course.",
            "Receiving credit for a course satisfies its requirements.",
            "CS101 requires satisfying its requirements for a student to receive credit."
        ],
        "premises-FOL": [
            "∀x ∀y (Student(x) ∧ Passes(x, y) → EnrolledIn(x, y)) ::: All students must be enrolled in a course to pass it.",
            "Course(CS101) ::: CS101 is a course.",
            "∀x ∀y (EnrolledIn(x, y) ∧ Passes(x, y) → Satisfies(x, y)) ::: If a student is enrolled in a course and passes it, they satisfy the requirements for that course.",
            "∀x ∀y (ReceivesCredit(x, y) → Satisfies(x, y)) ::: Receiving credit for a course satisfies its requirements.",
            "∀x (Student(x) ∧ EnrolledIn(x, CS101) ∧ Passes(x, CS101) → ReceivesCredit(x, CS101)) ::: CS101 requires satisfying its requirements for a student to receive credit."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in course y",
            "Passes(x, y) ::: x passes course y",
            "Requires(x, y) ::: Course x requires course y as a pre-requisite",
            "ReceivesCredit(x, y) ::: x receives credit for course y"
        ]
    },
    {
        "premises-NL": [
            "All students are people.",
            "If someone takes Calculus101, they are a student.",
            "Professor David teaches Calculus101.",
            "If a professor teaches a course, that course is in mathematics.",
            "If a student takes a course in mathematics, they will find mathematics interesting."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Person(x)) ::: All students are people.",
            "∀x (Takes(x, Calculus101) → Student(x)) ::: If someone takes Calculus101, they are a student.",
            "Teaches(David, Calculus101) ::: Professor David teaches Calculus101.",
            "∀x ∀y (Teaches(x, y) → In(y, Mathematics)) ::: If a professor teaches a course, that course is in mathematics.",
            "∀x ∀y ((Student(x) ∧ In(y, Mathematics) ∧ Takes(x, y)) → FindsInteresting(x, Mathematics)) ::: If a student takes a course in mathematics, they will find mathematics interesting."
        ],
        "predicates": [
            "Takes(x, y) ::: x takes y",
            "Student(x) ::: x is a student",
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches y",
            "FindsInteresting(x, y) ::: x finds y interesting"
        ]
    },
    {
        "premises-NL": [
            "All students are learners.",
            "If a course requires reading, then it requires textbooks.",
            "Textbooks are expensive.",
            "If something is expensive, a student enrolled in the course must have books.",
            "If someone is a learner and enrolled in a course, they are a student.",
            "If a student must have books, then they own books."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Learner(x)) ::: All students are learners.",
            "∀x (RequiresReading(x) → RequiresTextbooks(x)) ::: If a course requires reading, then it requires textbooks.",
            "∀x (RequiresTextbooks(x) → Textbook(x)) ::: If a course requires textbooks, then it requires textbooks",
            "∀x (Textbook(x) → Expensive(x)) ::: Textbooks are expensive",
            "∀x ∀y ((Expensive(x) ∧ EnrolledIn(y, x)) → MustHaveBooks(y)) ::: If something is expensive, a student enrolled in the course must have books.",
            "∀x ∀y ((Learner(x) ∧ EnrolledIn(x, y)) → Student(x)) ::: If someone is a learner and enrolled in a course, they are a student.",
            "∀x (MustHaveBooks(x) → OwnsBooks(x)) ::: If a student must have books, then they own books."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "EnrolledIn(x, y) ::: x is enrolled in y",
            "RequiresReading(x) ::: x requires reading",
            "OwnsBooks(x) ::: x owns books",
            "Expensive(x) ::: x is expensive",
            "Textbook(x) ::: x is a textbook"
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled.",
            "If a student is enrolled and completes all degree requirements, they are in good standing.",
            "If a student is in good standing and pays their tuition, they will graduate.",
            "If a student fails a course, they may be placed on academic probation.",
            "If a student is on academic probation, their graduation may be delayed.",
            "If a student's graduation is delayed, they will not receive their diploma immediately.",
            "If someone is enrolled, they are a student.",
            "If a student graduates, they have completed requirements.",
            "If a student has completed requirements and graduates then it means they complete all degree requirements."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x)) ::: All students are enrolled.",
            "∀x ((Enrolled(x) ∧ CompletesRequirements(x)) → GoodStanding(x)) ::: If a student is enrolled and completes all degree requirements, they are in good standing.",
            "∀x ((GoodStanding(x) ∧ PaysTuition(x)) → Graduates(x)) ::: If a student is in good standing and pays their tuition, they will graduate.",
            "∀x (FailsCourse(x) → AcademicProbation(x)) ::: If a student fails a course, they may be placed on academic probation.",
            "∀x (AcademicProbation(x) → DelayedGraduation(x)) ::: If a student is on academic probation, their graduation may be delayed.",
            "∀x (DelayedGraduation(x) → ¬ReceivesDiplomaImmediately(x)) ::: If a student's graduation is delayed, they will not receive their diploma immediately.",
            "∀x (Enrolled(x) → Student(x)) ::: If someone is enrolled, they are a student.",
            "∀x (Graduates(x) → CompletesRequirements(x)) ::: If a student graduates, they have completed requirements.",
            "∀x ((CompletesRequirements(x) ∧ Graduates(x)) → CompletesRequirements(x)) ::: If a student has completed requirements and graduates then it means they complete all degree requirements."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "CompletesRequirements(x) ::: x completes all degree requirements",
            "PaysTuition(x) ::: x pays their tuition",
            "Graduates(x) ::: x graduates",
            "DelayedGraduation(x) ::: x's graduation is delayed",
            "ReceivesDiplomaImmediately(x) ::: x receives their diploma immediately",
            "Enrolled(x) ::: x is enrolled",
            "GoodStanding(x) ::: x is in good standing",
            "FailsCourse(x) ::: x fails a course",
            "AcademicProbation(x) ::: x is on academic probation"
        ]
    },
    {
        "premises-NL": [
            "All students must enroll in courses before the deadline to receive credit.",
            "A student cannot enroll in a course if they have not met the prerequisites.",
            "If a course is full, no student can enroll in that course.",
            "If a student enrolls in a course after the deadline, they will not receive credit for that course."
        ],
        "premises-FOL": [
            "∀x ∀y (Student(x) ∧ Course(y) ∧ ¬EnrollsAfterDeadline(x, y) → Credit(x, y)) ::: Students must enroll before the deadline to receive credit.",
            "∀x ∀y (Student(x) ∧ Course(y) ∧ ¬MeetsPrerequisites(x, y) → ¬Enrolls(x, y)) ::: A student cannot enroll if they haven't met prerequisites.",
            "∀y (Course(y) ∧ Full(y) → ¬Enrolls(x, y)) ::: If a course is full, no student can enroll.",
            "∀x ∀y (Student(x) ∧ Course(y) ∧ EnrollsAfterDeadline(x, y) → ¬Credit(x, y)) ::: A student enrolling after the deadline will not receive credit."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Course(y) ::: y is a course",
            "EnrollsAfterDeadline(x, y) ::: x enrolls in y after the deadline",
            "Credit(x, y) ::: x receives credit for y",
            "Prerequisite(y, z) ::: Course y is a prerequisite for course z"
        ]
    },
    {
        "premises-NL": [
            "All students must pay tuition to remain enrolled.",
            "If a student has outstanding fees, they cannot register for the next semester.",
            "The university sends a reminder to students before the tuition due date.",
            "If a student does not pay tuition by the due date, they will be dropped from their courses."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ ¬PaysTuition(x) → ¬Enrolled(x)) ::: Students must pay tuition to remain enrolled.",
            "∀x (Student(x) ∧ OutstandingFees(x) → ¬CanRegister(x)) ::: Students with outstanding fees cannot register.",
            "∀x (Student(x) → SendsReminder(x)) ::: The university sends a reminder before the due date.",
            "∀x (Student(x) ∧ ¬PaysTuition(x) ∧ AfterDueDate(x) → DroppedFromCourses(x)) ::: If a student doesn't pay tuition by the due date, they are dropped."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PaysTuition(x) ::: x pays tuition",
            "AfterDueDate(x) ::: It is after the tuition due date for student x",
            "DroppedFromCourses(x) ::: x is dropped from their courses",
            "Enrolled(x, y) ::: x is enrolled in course y"
        ]
    },
    {
        "premises-NL": [
            "A student can repeat a course to improve their grade.",
            "If a student repeats a course they previously passed, then no change is done to the GPA.",
            "If a student repeats a course they previously failed, the new grade will replace the old grade.",
            "If a student withdraws from a course, there is no grade and no replacement of the former grade",
            "If a student repeats a course they previously failed and does not withdraw from it, the new grade replaces the old grade in their GPA calculation."
        ],
        "premises-FOL": [
            "∀x ∀y (Student(x) ∧ Course(y) → CanRepeat(x, y)) ::: A student can repeat a course.",
            "∀x ∀y (Student(x) ∧ Course(y) ∧ Repeats(x, y) ∧ PreviouslyPassed(x, y) → ¬ReplacesGrade(x, y)) ::: Repeating a passed course doesn't replace the grade.",
            "∀x ∀y (Student(x) ∧ Course(y) ∧ Repeats(x, y) ∧ PreviouslyFailed(x, y) → ReplacesGrade(x, y)) ::: Repeating a failed course replaces the grade.",
            "∀x ∀y (Student(x) ∧ Course(y) ∧ Withdrawn(x, y) → ¬HasGrade(x, y)) ::: If a student withdraws, they have no grade.",
            "∀x ∀y (Student(x) ∧ Course(y) ∧ Repeats(x, y) ∧ PreviouslyFailed(x, y) ∧ ¬Withdrawn(x, y) → ReplacesGrade(x, y)) ::: Repeating a failed course (without withdrawing) replaces the old grade."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Course(y) ::: y is a course",
            "Repeats(x, y) ::: x repeats course y",
            "PreviouslyFailed(x, y) ::: x previously failed course y",
            "Withdrawn(x, y) ::: x has withdrawn from course y",
            "ReplacesGrade(x, y) ::: The new grade replaces the old grade for x in y",
            "GPA(x, z) ::: The GPA of x is z"
        ]
    },
    {
        "premises-NL": [
            "John is a student.",
            "CS101 is a course.",
            "John is enrolled in CS101.",
            "CS101 requires the textbook 'Introduction to Programming'.",
            "John owns the textbook 'Introduction to Programming'.",
            "If a student studies a course using the required textbook and attends lectures for that course, they will likely score well.",
            "If a student completes assignments for a course then the student studies the course using textbook for that course.",
            "If a student is enrolled in a course and the student completes assignments for that course then the student attends lectures for that course.",
            "Students who own textbook and are enrolled study the course using the textbook for that course."
        ],
        "premises-FOL": [
            "Student(john) ::: John is a student.",
            "Course(CS101) ::: CS101 is a course.",
            "Enrolled(john, CS101) ::: John is enrolled in CS101.",
            "RequiresTextbook(CS101, introToProg) ::: CS101 requires the textbook 'Introduction to Programming'.",
            "Owns(john, introToProg) ::: John owns the textbook 'Introduction to Programming'.",
            "∀x ∀y ∀z (Studies(x, y, z) ∧ AttendsLectures(x, y) → LikelyScoreWell(x, y)) ::: If a student studies a course using the required textbook and attends lectures for that course, they will likely score well.",
            "∀x ∀y(CompletesAssignments(x, y) → Studies(x, y, z)) ::: If a student completes assignments for a course then the student studies the course using textbook for that course.",
            "∀x ∀y(Enrolled(x, y) ∧ CompletesAssignments(x, y) → AttendsLectures(x, y)) ::: If a student is enrolled in a course and the student completes assignments for that course then the student attends lectures for that course.",
            "∀x ∀y(Enrolled(x, y) ∧ Owns(x, z) → Studies(x, y, z)) ::: Students who own textbook and are enrolled study the course using the textbook for that course."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Course(y) ::: y is a course",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "RequiresTextbook(y, z) ::: course y requires textbook z",
            "Owns(x, z) ::: x owns z",
            "Studies(x, y, z) ::: x studies course y using textbook z",
            "AttendsLectures(x, y) ::: x attends lectures for course y",
            "CompletesAssignments(x, y) ::: x completes assignments for course y",
            "LikelyScoreWell(x, y) ::: x will likely score well in course y"
        ]
    },
    {
        "premises-NL": [
            "For all courses, if a student is registered, they are a student.",
            "If a course is difficult, students who take it must study hard.",
            "Students who study hard attend most lectures.",
            "Students who attend most lectures and complete most assignments have a good chance of passing the course.",
            "If a student attends all lectures, then they attend most lectures.",
            "If a student completes all assignments, then they complete most assignments."
        ],
        "premises-FOL": [
            "∀x ∀y (Course(y) ∧ Registered(x, y) → Student(x)) ::: For all courses, if a student is registered, they are a student.",
            "∀x ∀y ((Student(x) ∧ Course(y) ∧ Difficult(y) ∧ Registered(x, y)) → StudiesHard(x, y)) ::: If a course is difficult, students who take it must study hard.",
            "∀x ∀y ((Student(x) ∧ Course(y) ∧ StudiesHard(x, y)) → AttendsMost(x, y)) ::: Students who study hard attend most lectures.",
            "∀x ∀y ((Student(x) ∧ AttendsMost(x, y) ∧ CompletesMost(x, y)) → HighChance(x, y)) ::: Students who attend most lectures and complete most assignments have a good chance of passing the course.",
            "∀x ∀y (AttendsAll(x, y) → AttendsMost(x, y)) ::: If a student attends all lectures, then they attend most lectures.",
            "∀x ∀y (CompletesAll(x, y) → CompletesMost(x, y)) ::: If a student completes all assignments, then they complete most assignments."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Course(y) ::: y is a course",
            "AttendsAll(x, y) ::: x attends all lectures for course y",
            "CompletesAll(x, y) ::: x completes all assignments for course y",
            "Passes(x, y) ::: x passes course y",
            "Credit(x, y) ::: x receives credit for course y",
            "Difficult(y) ::: Course y is difficult"
        ]
    },
    {
        "premises-NL": [
            "A student must either pass or fail a course.",
            "If a student fails a course, they are allowed to retake it.",
            "If a student retakes a course, the new grade replaces the old grade in GPA calculation.",
            "If a student achieves a higher grade in a retaken course, their GPA will likely increase.",
            "A student is only considered for graduation if they have passed all required courses.",
            "If a student has not passed all required courses, they are not graduating.",
            "If a student has completed all required courses and their GPA has not improved, then they should consider graduating."
        ],
        "premises-FOL": [
            "∀x ∀y (Student(x) ∧ Course(y) → (Passes(x, y) ∨ Fails(x, y))) ::: A student must either pass or fail a course.",
            "∀x ∀y ((Student(x) ∧ Fails(x, y)) → AllowedToRetake(x, y)) ::: If a student fails a course, they are allowed to retake it.",
            "∀x ∀y (Retakes(x, y) → ReplacesGrade(x, y)) ::: If a student retakes a course, the new grade replaces the old grade in GPA calculation.",
            "∀x ∀y ((Retakes(x, y) ∧ HigherGrade(x, y)) → LikelyIncrease(x)) ::: If a student achieves a higher grade in a retaken course, their GPA will likely increase.",
            "∀x (Graduating(x) → PassedAll(x)) ::: A student is only considered for graduation if they have passed all required courses.",
            "∀x (¬PassedAll(x) → ¬Graduating(x)) ::: If a student has not passed all required courses, they are not graduating.",
            "∀x ((CompletedAll(x) ∧ ¬ImprovesGPA(x)) → ConsiderGraduating(x)) ::: If a student has completed all required courses and their GPA has not improved, then they should consider graduating."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Retakes(x, y) ::: x retakes course y",
            "HigherGrade(x, y) ::: x achieves a higher grade in course y",
            "ImprovesGPA(x) ::: x's GPA improves",
            "Graduating(x) ::: x is graduating this semester",
            "Passes(x, y) ::: x passes course y",
            "Fails(x, y) ::: x fails course y"
        ]
    },
    {
        "premises-NL": [
            "All graduate students are students.",
            "To be eligible for graduation, a student must complete their thesis and pass their defense.",
            "A student must fulfill all course requirements and maintain a minimum GPA to be considered for graduation.",
            "The university awards degrees to students who are eligible for graduation and do not have outstanding tuition fees.",
            "Thesis completion requires advisor approval.",
            "Passing a thesis defense requires committee approval.",
            "If a student has an advisor that is a professor and that advisor has approved the student's thesis then the student has completed their thesis.",
            "A student only pass their defense if the committee approves the defense",
            "The university cannot award degree to someone who has outstanding fees."
        ],
        "premises-FOL": [
            "∀x (GraduateStudent(x) → Student(x)) ::: All graduate students are students.",
            "∀x (EligibleGraduation(x) → (CompletesThesis(x) ∧ PassesDefense(x))) ::: To be eligible for graduation, a student must complete their thesis and pass their defense.",
            "∀x (EligibleGraduation(x) → (FulfillsRequirements(x) ∧ MaintainsGPA(x))) ::: A student must fulfill all course requirements and maintain a minimum GPA to be considered for graduation.",
            "∀x ((EligibleGraduation(x) ∧ ¬OutstandingFees(x)) → AwardsDegree(x)) ::: The university awards degrees to students who are eligible for graduation and do not have outstanding tuition fees.",
            "∀x (CompletesThesis(x) → RequiresApproval(x)) ::: Thesis completion requires advisor approval.",
            "∀x (PassesDefense(x) → RequiresCommitteeApproval(x)) ::: Passing a thesis defense requires committee approval.",
            "∀x ∀y ((GraduateStudent(x) ∧ Professor(y) ∧ Advisor(x,y) ∧ ApprovesThesis(y, x)) → CompletesThesis(x)) ::: If a student has an advisor that is a professor and that advisor has approved the student's thesis then the student has completed their thesis.",
            "∀x (CommitteeApproves(x) → PassesDefense(x)) ::: A student only pass their defense if the committee approves the defense",
            "∀x (OutstandingFees(x) → ¬AwardsDegree(x)) ::: The university cannot award degree to someone who has outstanding fees."
        ],
        "predicates": [
            "GraduateStudent(x) ::: x is a graduate student",
            "CompletesThesis(x) ::: x completes their thesis",
            "PassesDefense(x) ::: x passes their thesis defense",
            "FulfillsRequirements(x) ::: x fulfills all course requirements",
            "MaintainsGPA(x) ::: x maintains a minimum GPA",
            "AwardsDegree(x) ::: x is awarded their degree",
            "OutstandingFees(x) ::: x has outstanding tuition fees",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches course y"
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled in a course.",
            "If a student studies hard, then they pass the course.",
            "If a student is enrolled in a difficult course and studies hard, then they pass the course.",
            "If a student does not study hard, then they sometimes struggle.",
            "If a student passes a difficult course, then they studied hard.",
            "There exists a student who is enrolled in a difficult course.",
            "For all students, if they study hard, then they are students.",
            "If a student is enrolled in a course then the student is a student.",
            "There exists a student who does not study hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x)) ::: All students are enrolled in a course.",
            "∀x (Studies(x) → Passes(x)) ::: If a student studies hard, then they pass the course.",
            "∀x ((DifficultCourse(x) ∧ Studies(x)) → Passes(x)) ::: If a student is enrolled in a difficult course and studies hard, then they pass the course.",
            "∀x (¬Studies(x) → SometimesStruggles(x)) ::: If a student does not study hard, then they sometimes struggle.",
            "∀x ((DifficultCourse(x) ∧ Passes(x)) → Studies(x)) ::: If a student passes a difficult course, then they studied hard.",
            "∃x (Student(x) ∧ DifficultCourse(x)) ::: There exists a student who is enrolled in a difficult course.",
            "∀x (Studies(x) → Student(x)) ::: For all students, if they study hard, then they are students.",
            "∀x (Enrolled(x) → Student(x)) ::: If a student is enrolled in a course then the student is a student.",
            "∃x (Student(x) ∧ ¬Studies(x)) ::: There exists a student who does not study hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x) ::: x is enrolled in a course",
            "DifficultCourse(x) ::: x is enrolled in a difficult course",
            "Passes(x) ::: x passes the course",
            "Studies(x) ::: x studies hard",
            "SometimesStruggles(x) ::: x sometimes struggles"
        ]
    },
    {
        "premises-NL": [
            "All students either attend lectures or do not study hard.",
            "If a student attends lectures and studies hard, then they will pass exams.",
            "If a student passes exams, then they are motivated.",
            "If a student is motivated and dedicated, then they will graduate.",
            "All students are dedicated.",
            "There exists a student who attends lectures.",
            "If someone attends lectures then they are a student.",
            "If someone is dedicated then they are a student.",
            "If someone studies hard then they are a student.",
            "If someone passes exams then they are a student."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (AttendsLectures(x) ∨ ¬StudiesHard(x))) ::: All students either attend lectures or do not study hard.",
            "∀x ((AttendsLectures(x) ∧ StudiesHard(x)) → PassesExams(x)) ::: If a student attends lectures and studies hard, then they will pass exams.",
            "∀x (PassesExams(x) → Motivated(x)) ::: If a student passes exams, then they are motivated.",
            "∀x ((Motivated(x) ∧ Dedicated(x)) → WillGraduate(x)) ::: If a student is motivated and dedicated, then they will graduate.",
            "∀x (Student(x) → Dedicated(x)) ::: All students are dedicated.",
            "∃x (Student(x) ∧ AttendsLectures(x)) ::: There exists a student who attends lectures.",
            "∀x (AttendsLectures(x) → Student(x)) ::: If someone attends lectures then they are a student.",
            "∀x (Dedicated(x) → Student(x)) ::: If someone is dedicated then they are a student.",
            "∀x (StudiesHard(x) → Student(x)) ::: If someone studies hard then they are a student.",
            "∀x (PassesExams(x) → Student(x)) ::: If someone passes exams then they are a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsLectures(x) ::: x attends lectures",
            "StudiesHard(x) ::: x studies hard",
            "PassesExams(x) ::: x passes exams",
            "WillGraduate(x) ::: x will graduate",
            "Motivated(x) ::: x is motivated",
            "Dedicated(x) ::: x is dedicated"
        ]
    },
    {
        "premises-NL": [
            "All students who meet the requirements are eligible to graduate.",
            "If a student has a scholarship, then they have a good GPA.",
            "If a student is eligible to graduate, then they passed the exams.",
            "If a student studies then they pass exams.",
            "If a student passes exams then they meet the requirements.",
            "There exists a student who studies.",
            "If someone is a student then they study.",
            "If someone meets requirements then they are a student.",
            "If someone has a scholarship then they are a student.",
            "If someone passes exams then they are a student.",
            "If someone is eligible to graduate then they are a student.",
            "There exists someone who has a scholarship."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ MeetsRequirements(x) → EligibleToGraduate(x)) ::: All students who meet the requirements are eligible to graduate.",
            "∀x (HasScholarship(x) → GoodGPA(x)) ::: If a student has a scholarship, then they have a good GPA.",
            "∀x (EligibleToGraduate(x) → Passes(x)) ::: If a student is eligible to graduate, then they passed the exams.",
            "∀x (Studies(x) → Passes(x)) ::: If a student studies then they pass exams.",
            "∀x (Passes(x) → MeetsRequirements(x)) ::: If a student passes exams then they meet the requirements.",
            "∃x (Student(x) ∧ Studies(x)) ::: There exists a student who studies.",
            "∀x (Student(x) → Studies(x)) ::: If someone is a student then they study.",
            "∀x (MeetsRequirements(x) → Student(x)) ::: If someone meets requirements then they are a student.",
            "∀x (HasScholarship(x) → Student(x)) ::: If someone has a scholarship then they are a student.",
            "∀x (Passes(x) → Student(x)) ::: If someone passes exams then they are a student.",
            "∀x (EligibleToGraduate(x) → Student(x)) ::: If someone is eligible to graduate then they are a student.",
            "∃x HasScholarship(x) ::: There exists someone who has a scholarship."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "MeetsRequirements(x) ::: x meets the requirements",
            "HasScholarship(x) ::: x has a scholarship",
            "GoodGPA(x) ::: x has a good GPA",
            "EligibleToGraduate(x) ::: x is eligible to graduate",
            "Studies(x) ::: x studies hard",
            "Passes(x) ::: x passes exams"
        ]
    },
    {
        "premises-NL": [
            "Every student is either hardworking or not.",
            "There exists a student who is enrolled in a difficult course.",
            "Not all hardworking students pass every course they are enrolled in.",
            "If a student always passes a course, they have passed the final exam.",
            "Hardworking students are students.",
            "Only students can be enrolled in courses."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Hardworking(x) ∨ ¬Hardworking(x))) ::: Every student is either hardworking or not.",
            "∃x ∃y (Student(x) ∧ Enrolled(x, y) ∧ DifficultCourse(y)) ::: There exists a student x and a course y, such that the student is enrolled in the course, and the course is difficult.",
            "∃x ∃y (Hardworking(x) ∧ Enrolled(x, y) ∧ ¬PassedFinalExam(x, y)) ::: There exists a hardworking student x and a course y, such that the student is enrolled in the course, but has not passed the final exam.",
            "∀x ∀y (AlwaysPasses(x,y) → PassedFinalExam(x,y)) ::: If a student always passes a course, then they have passed the final exam.",
            "∀x (Hardworking(x) → Student(x)) ::: If someone is hardworking then they are a student.",
            "∀x ∀y (Enrolled(x,y) → Student(x)) ::: Only students can be enrolled in courses."
        ],
        "predicates": [
            "Student(x) ::: x is a student.",
            "Enrolled(x, y) ::: x is enrolled in course y.",
            "DifficultCourse(y) ::: Course y is a difficult course.",
            "PassedFinalExam(x, y) ::: x passed the final exam in course y.",
            "Hardworking(x) ::: x is a hardworking student.",
            "AlwaysPasses(x, y) ::: x always passes course y."
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled in a course.",
            "If a student is enrolled in a difficult course and not stressed, then they pass the course.",
            "If a student passes the course, then they do not fail the course.",
            "All who fail the course are students.",
            "If a student passes the course, then they are not stressed.",
            "All students are either stressed or pass the course."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x)) ::: All students are enrolled in a course.",
            "∀x ((Student(x) ∧ Enrolled(x) ∧ DifficultCourse(x) ∧ ¬Stressed(x)) → Passes(x)) ::: If a student is enrolled in a difficult course and not stressed, then they pass the course.",
            "∀x (Passes(x) → ¬Fails(x)) ::: If a student passes the course, then they do not fail the course.",
            "∀x (Fails(x) → Student(x)) ::: All who fail the course are students.",
            "∀x (Passes(x) → ¬Stressed(x)) ::: If a student passes the course, then they are not stressed.",
            "∀x (Student(x) → (Stressed(x) ∨ Passes(x))) ::: All students are either stressed or pass the course."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x) ::: x is enrolled in a course",
            "DifficultCourse(x) ::: x is a difficult course",
            "Passes(x) ::: x passes the course",
            "Stressed(x) ::: x is stressed",
            "Fails(x) ::: x fails the course"
        ]
    },
    {
        "premises-NL": [
            "All students attend the lecture if they are not lazy.",
            "If a student attends the lecture and is not struggling, then they understood the lecture.",
            "If a student does not understand the lecture, then they are struggling.",
            "All struggling students require tutoring.",
            "Students are either lazy or require tutoring.",
            "Students who are struggling are not taking an advanced course.",
            "All advanced courses require tutoring."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ ¬Lazy(x) → AttendsLecture(x)) ::: All students attend the lecture if they are not lazy.",
            "∀x (Student(x) ∧ AttendsLecture(x) ∧ ¬Struggling(x) → UnderstoodLecture(x)) ::: If a student attends the lecture and is not struggling, then they understood the lecture.",
            "∀x (Student(x) ∧ ¬UnderstoodLecture(x) → Struggling(x)) ::: If a student does not understand the lecture, then they are struggling.",
            "∀x (Struggling(x) → RequiresTutoring(x)) ::: All struggling students require tutoring.",
            "∀x (Student(x) → (Lazy(x) ∨ RequiresTutoring(x))) ::: Students are either lazy or require tutoring.",
            "∀x (Struggling(x) → ¬AdvancedCourse(x)) ::: Students who are struggling are not taking an advanced course.",
            "∀x (AdvancedCourse(x) → RequiresTutoring(x)) ::: All advanced courses require tutoring."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "AttendsLecture(x) ::: x attends the lecture",
            "UnderstoodLecture(x) ::: x understood the lecture",
            "RequiresTutoring(x) ::: x requires tutoring",
            "Lazy(x) ::: x is lazy",
            "AdvancedCourse(x) ::: x is taking an advanced course",
            "Struggling(x) ::: x is struggling"
        ]
    },
    {
        "premises-NL": [
            "All students must pay tuition to be registered.",
            "If a student is registered, they are eligible to graduate.",
            "If a student has not paid tuition, they will not be registered.",
            "If a student has paid tuition and is not registered, they will complain.",
            "If a student complains, they will be delayed in graduation or refunded.",
            "All students are eligible to graduate if and only if they attend classes.",
            "Only registered students are eligible to graduate.",
            "All those who are not eligible to graduate are not registered."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (PaidTuition(x) ↔ Registered(x))) ::: All students must pay tuition to be registered.",
            "∀x (Registered(x) → EligibleToGraduate(x)) ::: If a student is registered, they are eligible to graduate.",
            "∀x (Student(x) ∧ ¬PaidTuition(x) → ¬Registered(x)) ::: If a student has not paid tuition, they will not be registered.",
            "∀x (Student(x) ∧ PaidTuition(x) ∧ ¬Registered(x) → Complains(x)) ::: If a student has paid tuition and is not registered, they will complain.",
            "∀x (Complains(x) → (DelayedGraduation(x) ∨ Refunded(x))) ::: If a student complains, they will be delayed in graduation or refunded.",
            "∀x (Student(x) → (EligibleToGraduate(x) ↔ AttendsClasses(x))) ::: All students are eligible to graduate if and only if they attend classes.",
            "∀x (Registered(x) → EligibleToGraduate(x)) ::: Only registered students are eligible to graduate.",
            "∀x (¬EligibleToGraduate(x) → ¬Registered(x)) ::: All those who are not eligible to graduate are not registered."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PaidTuition(x) ::: x has paid tuition",
            "Registered(x) ::: x is registered for courses",
            "AttendsClasses(x) ::: x attends classes",
            "EligibleToGraduate(x) ::: x is eligible to graduate",
            "DelayedGraduation(x) ::: x will be delayed in graduation",
            "Refunded(x) ::: x will be refunded their tuition",
            "Complains(x) ::: x complains"
        ]
    },
    {
        "premises-NL": [
            "All students who study hard and understand the material pass the exam.",
            "If a student does not understand the material, they will be confused.",
            "If a student is confused, they ask questions.",
            "All students who ask questions are participating in class.",
            "Students who take good notes are either participating in class or study hard.",
            "If a student fails the exam, they did not study hard.",
            "Students either pass the exam or fail the exam.",
            "If a student takes good notes and does not participate, then they fail the exam.",
            "All students participate if they study hard."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ StudiesHard(x) ∧ UnderstandsMaterial(x) → PassesExam(x)) ::: All students who study hard and understand the material pass the exam.",
            "∀x (Student(x) ∧ ¬UnderstandsMaterial(x) → Confused(x)) ::: If a student does not understand the material, they will be confused.",
            "∀x (Student(x) ∧ Confused(x) → AsksQuestions(x)) ::: If a student is confused, they ask questions.",
            "∀x (Student(x) ∧ AsksQuestions(x) → Participates(x)) ::: All students who ask questions are participating in class.",
            "∀x (Student(x) ∧ TakesGoodNotes(x) → (Participates(x) ∨ StudiesHard(x))) ::: Students who take good notes are either participating in class or study hard.",
            "∀x (Student(x) ∧ FailsExam(x) → ¬StudiesHard(x)) ::: If a student fails the exam, they did not study hard.",
            "∀x (Student(x) → (PassesExam(x) ∨ FailsExam(x))) ::: Students either pass the exam or fail the exam.",
            "∀x (Student(x) ∧ TakesGoodNotes(x) ∧ ¬Participates(x) → FailsExam(x)) ::: If a student takes good notes and does not participate, then they fail the exam.",
            "∀x (Student(x) ∧ StudiesHard(x) → Participates(x)) ::: All students participate if they study hard."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "TakesGoodNotes(x) ::: x takes good notes",
            "UnderstandsMaterial(x) ::: x understands the material",
            "PassesExam(x) ::: x passes the exam",
            "FailsExam(x) ::: x fails the exam",
            "AsksQuestions(x) ::: x asks questions",
            "Confused(x) ::: x is confused",
            "Participates(x) ::: x participates in class"
        ]
    },
    {
        "premises-NL": [
            "All students who are late to class and have a valid excuse will improve their attendance.",
            "If a student is disruptive, they will be late to class.",
            "If a student receives a warning, then they will not be disruptive.",
            "All students are respectful if they are not disruptive.",
            "If a student attends all classes, they will learn the material.",
            "Students who improve their attendance and are respectful will attend all classes.",
            "If a student is late to class and is respectful, then they have a valid excuse.",
            "If a student has points deducted, they will not learn the material.",
            "All students who learn the material improve their attendance.",
            "If a student attends all classes, then they are not late to class."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ LateToClass(x) ∧ ValidExcuse(x) → ImproveAttendance(x)) ::: All students who are late to class and have a valid excuse will improve their attendance.",
            "∀x (Student(x) ∧ Disruptive(x) → LateToClass(x)) ::: If a student is disruptive, they will be late to class.",
            "∀x (Student(x) ∧ ReceiveWarning(x) → ¬Disruptive(x)) ::: If a student receives a warning, then they will not be disruptive.",
            "∀x (Student(x) ∧ ¬Disruptive(x) → Respectful(x)) ::: All students are respectful if they are not disruptive.",
            "∀x (Student(x) ∧ AttendsAllClasses(x) → LearnsMaterial(x)) ::: If a student attends all classes, they will learn the material.",
            "∀x (Student(x) ∧ ImproveAttendance(x) ∧ Respectful(x) → AttendsAllClasses(x)) ::: Students who improve their attendance and are respectful will attend all classes.",
            "∀x (Student(x) ∧ LateToClass(x) ∧ Respectful(x) → ValidExcuse(x)) ::: If a student is late to class and is respectful, then they have a valid excuse.",
            "∀x (Student(x) ∧ PointsDeducted(x) → ¬LearnsMaterial(x)) ::: If a student has points deducted, they will not learn the material.",
            "∀x (Student(x) ∧ LearnsMaterial(x) → ImproveAttendance(x)) ::: All students who learn the material improve their attendance.",
            "∀x (Student(x) ∧ AttendsAllClasses(x) → ¬LateToClass(x)) ::: If a student attends all classes, then they are not late to class."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "LateToClass(x) ::: x is late to class",
            "ValidExcuse(x) ::: x has a valid excuse",
            "ReceiveWarning(x) ::: x receives a warning",
            "PointsDeducted(x) ::: x has points deducted",
            "ImproveAttendance(x) ::: x improves their attendance",
            "Disruptive(x) ::: x is disruptive",
            "Respectful(x) ::: x is respectful",
            "LearnsMaterial(x) ::: x learns the material",
            "AttendsAllClasses(x) ::: x attends all classes"
        ]
    },
    {
        "premises-NL": [
            "All international students require a visa to study.",
            "Full-time students are enrolled in a certain amount of courses.",
            "To remain enrolled, international students must demonstrate English proficiency or enroll in an ESL program.",
            "Students who do not demonstrate English proficiency and do not enroll in an ESL program will be unenrolled.",
            "International students require to live on campus.",
            "International students need to attend campus tours",
            "Any international student who needs to live on campus will be enrolled.",
            "All enrolled students need to purchase parking permits.",
            "All visa students must be registered."
        ],
        "premises-FOL": [
            "∀x (InternationalStudent(x) → RequiresVisa(x)) ::: International students require a visa.",
            "∀x (FullTimeProgram(x) → Enrolled(x)) ::: Full-time students are enrolled.",
            "∀x (InternationalStudent(x) → (EnglishProficiency(x) ∨ EnrollsESL(x))) ::: Int'l students need English proficiency or ESL.",
            "∀x ((InternationalStudent(x) ∧ ¬EnglishProficiency(x) ∧ ¬EnrollsESL(x)) → Unenrolled(x)) ::: Int'l student no proficiency, no ESL, unenrolled.",
            "∀x InternationalStudent(x) → LivesOnCampus(x) ::: international students need to live on campus.",
            "∀x InternationalStudent(x) → AttendsTour(x) ::: international students needs to attend campus tours.",
            "∀x LivesOnCampus(x) → Enrolled(x) ::: Any student who lives on campus is enrolled.",
            "∀x Enrolled(x) → ParkingPermit(x) ::: all enrolled students purchase parking permits.",
            "∀x RequiresVisa(x) → Registered(x) ::: all students with Visas must be registered."
        ],
        "predicates": [
            "InternationalStudent(x) ::: x is an international student",
            "RequiresVisa(x) ::: x requires a visa",
            "FullTimeProgram(x) ::: x is in a full-time program",
            "EnglishProficiency(x) ::: x demonstrates English proficiency",
            "EnrollsESL(x) ::: x enrolls in an ESL program",
            "Unenrolled(x) ::: x is unenrolled",
            "LivesOnCampus(x) ::: x lives on campus",
            "Enrolled(x) ::: x is enrolled"
        ]
    },
    {
        "premises-NL": [
            "All engineering students must complete all required coursework.",
            "To be eligible for graduation, an engineering student must pass the FE exam and complete an internship.",
            "Engineers that have a license, must get a degree.",
            "If an engineering student wishes to work after graduation, they must complete an internship or not be eligible for working after graduation.",
            "Engineering students get a degree.",
            "All engineering students need to complete all requirements.",
            "Internship gives work experience.",
            "All students must pay tuition to study.",
            "Engineers pay tuition.",
            "Students take loans."
        ],
        "premises-FOL": [
            "∀x (EngineeringStudent(x) → CompletedCoursework(x)) ::: All engineering students complete coursework.",
            "∀x (EngineeringStudent(x) ∧ PassedFE(x) ∧ CompletedInternship(x) → EligibleGraduation(x)) ::: Engineers passing FE and internship are eligible for graduation.",
            "∀x HasLicense(x) → Degree(x) ::: Engineers with a license need a degree.",
            "∀x ((EngineeringStudent(x) ∧ WorkingAfterUniversity(x)) → CompletedInternship(x)) ::: Engineers working after graduation need to complete internship.",
            "∀x EngineeringStudent(x) → Degree(x) ::: Engineers get a degree.",
            "∀x EngineeringStudent(x) → AllRequirements(x) ::: all engineers needs to complete all the requirements.",
            "∀x Internship(x) → WorkExperience(x) ::: all internships give work experience.",
            "∀x Student(x) → PayTuition(x) ::: students need to pay tuition to study.",
            "∀x EngineeringStudent(x) → PayTuition(x) ::: engineers need to pay tuition.",
            "∀x Student(x) → Loan(x) ::: students take loans"
        ],
        "predicates": [
            "EngineeringStudent(x) ::: x is an engineering student",
            "CompletedCoursework(x) ::: x has completed all required coursework",
            "PassedFE(x) ::: x has passed the FE exam",
            "CompletedInternship(x) ::: x has completed an internship",
            "EligibleGraduation(x) ::: x is eligible for graduation",
            "CompleteInternship(x) ::: x completes an internship",
            "WorkingAfterUniversity(x) ::: x is working after university",
            "HasLicense(x) ::: x has a license",
            "Degree(x) ::: x is earning a degree"
        ]
    },
    {
        "premises-NL": [
            "∀x (Student(x) → Enrolled(x)) ::: All students are enrolled.",
            "∀x (Enrolled(x) → (Passed(x) ∨ Failed(x))) ::: If someone is enrolled, they either passed or failed.",
            "∀x (Passed(x) → ¬Failed(x)) ::: If someone passed, then they have not failed.",
            "∀x (Student(x) → Smart(x) ∨ ¬Failed(x)) ::: Students are either smart or they didn't fail.",
            "∀x (Smart(x) → Passed(x)) ::: Smart individuals pass.",
            "∀x (Failed(x) → ¬Passed(x)) ::: If someone has failed, then they did not pass.",
            "∀x (Passed(x) ∨ ¬Passed(x)) ::: Either someone passed or they didn't pass."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Enrolled(x)) ::: All students are enrolled.",
            "∀x (Enrolled(x) → (Passed(x) ∨ Failed(x))) ::: If someone is enrolled, they either passed or failed.",
            "∀x (Passed(x) → ¬Failed(x)) ::: If someone passed, then they have not failed.",
            "∀x (Student(x) → (Smart(x) ∨ ¬Failed(x))) ::: Students are either smart or they didn't fail.",
            "∀x (Smart(x) → Passed(x)) ::: Smart individuals pass.",
            "∀x (Failed(x) → ¬Passed(x)) ::: If someone has failed, then they did not pass.",
            "∀x (Passed(x) ∨ ¬Passed(x)) ::: Either someone passed or they didn't pass."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Takes(x, y) ::: x takes course y",
            "Enrolled(x) ::: x is enrolled",
            "Passed(x) ::: x has passed",
            "Failed(x) ::: x has failed",
            "Prerequisite(x, y) ::: x is a prerequisite of y",
            "Smart(x) ::: x is smart"
        ]
    },
    {
        "premises-NL": [
            "All students must enroll in at least one course.",
            "If a student enrolls in CS101, they are considered a beginner.",
            "If a student enrolls in Math201, they are considered mathematically inclined.",
            "CS101 is a prerequisite for CS201.",
            "If a student passes a course, they receive credit for it.",
            "A student must pass all prerequisites before enrolling in a course.",
            "John enrolls in CS101.",
            "John enrolls in Math201.",
            "John passes CS101."
        ],
        "premises-FOL": [
            "∀x ∃y Enrolls(x, y) ::: All students must enroll in at least one course.",
            "∀x (Enrolls(x, CS101) → Beginner(x)) ::: If a student enrolls in CS101, they are considered a beginner.",
            "∀x (Enrolls(x, Math201) → MathInclined(x)) ::: If a student enrolls in Math201, they are considered mathematically inclined.",
            "Prerequisite(CS101, CS201) ::: CS101 is a prerequisite for CS201.",
            "∀x ∀y (Passes(x, y) → Credit(x, y)) ::: If a student passes a course, they receive credit for it.",
            "∀x ∀y ∀z (Enrolls(x, z) ∧ Prerequisite(y, z) → Passes(x, y)) ::: A student must pass all prerequisites before enrolling in a course.",
            "Enrolls(john, CS101) ::: John enrolls in CS101.",
            "Enrolls(john, Math201) ::: John enrolls in Math201.",
            "Passes(john, CS101) ::: John passes CS101."
        ],
        "predicates": [
            "Enrolls(x, y) ::: Student x enrolls in course y",
            "Prerequisite(x, y) ::: Course x is a prerequisite for course y",
            "Passes(x, y) ::: Student x passes course y",
            "CanEnroll(x, y) ::: Student x can enroll in course y"
        ]
    },
    {
        "premises-NL": [
            "All courses have a course code.",
            "If a course has a lab, the lab is usually optional.",
            "Professors teach courses.",
            "The Dean manages professors.",
            "If a student enrolls in a course, they can drop it before the deadline.",
            "CS101 has a lab.",
            "The CS101 lab is graded.",
            "Alice is a student.",
            "Alice is enrolled in CS101.",
            "Alice does not attend the CS101 lab.",
            "If a student fails to submit assignments, their grade will be affected."
        ],
        "premises-FOL": [
            "∀x (Course(x) → HasCode(x)) ::: All courses have a course code.",
            "∀x ∀y (HasLab(x, y) → Optional(y)) ::: If a course has a lab, the lab is usually optional.",
            "∀z (Professor(z) → Teaches(z, x)) ::: Professors teach courses.",
            "∀z (Professor(z) → ManagedBy(z, Dean)) ::: The Dean manages professors.",
            "∀w ∀x (Enrolls(w, x) → CanDrop(w, x)) ::: If a student enrolls in a course, they can drop it before the deadline.",
            "HasLab(CS101, lab1) ::: CS101 has a lab.",
            "Graded(lab1) ::: The CS101 lab is graded.",
            "Student(alice) ::: Alice is a student.",
            "Enrolls(alice, CS101) ::: Alice is enrolled in CS101.",
            "¬Attends(alice, lab1) ::: Alice does not attend the CS101 lab.",
            "∀x (FailsToSubmit(x, assignment) → GradeAffected(x, CS101)) ::: If a student fails to submit assignments, their grade will be affected."
        ],
        "predicates": [
            "Course(x) ::: x is a course",
            "HasLab(x, y) ::: Course x has lab y",
            "Lab(y) ::: y is a lab",
            "Graded(y) ::: Lab y is graded",
            "Attends(x, y) ::: Student x attends lab y",
            "GradeAffected(x, y) ::: Student x's grade is affected negatively in course y",
            "Student(w) ::: w is a student",
            "Professor(z) ::: z is a professor"
        ]
    },
    {
        "premises-NL": [
            "All professors assign either easy or challenging homework.",
            "If a course is demanding, diligent students study hard for it.",
            "If a student takes a course, then the student is enrolled.",
            "If a professor assigns challenging homework and a student studies hard, they either understand or struggle.",
            "If a student is enrolled and struggles, the material is difficult.",
            "All students are students."
        ],
        "premises-FOL": [
            "∀x (Professor(x) → (AssignsEasyHomework(x) ∨ AssignsChallengingHomework(x))) ::: All professors assign either easy or challenging homework.",
            "∀y ∀z (DemandingCourse(z) ∧ Student(y) ∧ Diligent(y) → StudiesHard(y)) ::: If a course is demanding, diligent students study hard for it.",
            "∀y ∀z (TakesCourse(y, z) → Enrolled(y)) ::: If a student takes a course, then the student is enrolled.",
            "∀x ∀y (AssignsChallengingHomework(x) ∧ Student(y) ∧ StudiesHard(y) → (UnderstandsMaterial(y) ∨ Struggles(y))) ::: If a professor assigns challenging homework and a student studies hard, they either understand or struggle.",
            "∀y (Enrolled(y) ∧ Struggles(y) → DifficultMaterial(y)) ::: If a student is enrolled and struggles, the material is difficult.",
            "∀x (Student(x) → Student(x)) ::: All students are students."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "AssignsChallengingHomework(x) ::: x assigns challenging homework",
            "Student(y) ::: y is a student",
            "Diligent(y) ::: y is diligent",
            "StudiesHard(y) ::: y studies hard",
            "UnderstandsMaterial(y) ::: y understands the material",
            "TakesCourse(y, z) ::: y takes course z",
            "DemandingCourse(z) ::: z is a demanding course"
        ]
    },
    {
        "premises-NL": [
            "Courses are academic endeavors.",
            "Every student is a person.",
            "If a course has prerequisites, that course exists.",
            "For someone to enroll in something they need to be enrolled as a student.",
            "Academic endeavors are difficult.",
            "If a course has a prerequisite, that prerequisite exists.",
            "Students are persons.",
            "Students need to meet the course requirements.",
            "If a course has prerequisites, and a student has not taken the prerequisites, then that student cannot enroll in the course."
        ],
        "premises-FOL": [
            "∀x (Course(x) → AcademicEndeavor(x)) ::: Courses are academic endeavors.",
            "∀z (Student(z) → Person(z)) ::: Every student is a person.",
            "∀x ∀y (Course(x) ∧ Prereq(x, y) → Exists(x)) ::: If a course has prerequisites, that course exists.",
            "∀z ∀x (Enrolls(z, x) → Enrolled(z)) ::: For someone to enroll in something they need to be enrolled as a student.",
            "∀x (AcademicEndeavor(x) → Difficult(x)) ::: Academic endeavors are difficult.",
            "∀x ∀y (Course(x) ∧ Prereq(x, y) → Exists(y)) ::: If a course has a prerequisite, that prerequisite exists.",
            "∀z (Student(z) → Person(z)) ::: Students are persons.",
            "∀z ∀x (Student(z) ∧ Course(x) → Requires(z, x)) ::: Students need to meet the course requirements.",
            "∀x ∀y ∀z ((Course(x) ∧ Prereq(x, y) ∧ Student(z) ∧ ¬Taken(z, y)) → ¬Enrolls(z, x)) ::: If a course has prerequisites, and a student has not taken the prerequisites, then that student cannot enroll in the course."
        ],
        "predicates": [
            "Course(x) ::: x is a course",
            "Prereq(x, y) ::: x has prerequisite y",
            "Student(z) ::: z is a student",
            "Taken(z, y) ::: z has taken y",
            "Enrolls(z, x) ::: z enrolls in x",
            "Exists(x) ::: x exists",
            "Person(z) ::: z is a person"
        ]
    },
    {
        "premises-NL": [
            "All students are persons.",
            "Every student who exists is enrolled in something.",
            "Enrollment requires payment of tuition.",
            "Attending a class requires enrollment.",
            "If one attends a class, one is a student.",
            "If a student exists, that student is attending courses.",
            "Students take courses.",
            "Every person has requirements.",
            "If tuition is not paid, and a student is enrolled, and enrollment requires payment of tuition, the student's enrollment is cancelled."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Person(x)) ::: All students are persons.",
            "∀x (Student(x) ∧ Exists(x) → Enrolled(x)) ::: Every student who exists is enrolled in something.",
            "Requires(enrollment, payment) ::: Enrollment requires payment of tuition.",
            "∀x (Attends(x) → Enrolled(x)) ::: Attending a class requires enrollment.",
            "∀x (Attends(x) → Student(x)) ::: If one attends a class, one is a student.",
            "∀x (Student(x) ∧ Exists(x) → Attends(x)) ::: If a student exists, that student is attending courses.",
            "∀x ∀y (Student(x) ∧ Course(y) → Takes(x, y)) ::: Students take courses.",
            "∀x (Person(x) → Requires(x, payment)) ::: Every person has requirements.",
            "∀x ((Student(x) ∧ Enrolled(x) ∧ ¬Paid(x) ∧ Requires(enrollment, payment)) → Cancelled(x)) ::: If tuition is not paid, and a student is enrolled, and enrollment requires payment of tuition, the student's enrollment is cancelled."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x) ::: x is enrolled",
            "Paid(x) ::: x has paid tuition",
            "Requires(x, y) ::: x requires y",
            "Cancelled(x) ::: x's enrollment is cancelled",
            "Attends(x) ::: x attends classes",
            "Course(y) ::: y is a course",
            "Takes(x, y) ::: x takes y",
            "Exists(x) ::: x exists",
            "Person(x) ::: x is a person"
        ]
    },
    {
        "premises-NL": [
            "If someone studies hard, they are a hard worker.",
            "If someone attends every class, they attend all classes.",
            "If someone studies a subject, and that subject is difficult, and they are a hard worker, then they pass.",
            "Alice studies the exam.",
            "The exam is difficult.",
            "Attending all classes helps to pass exam"
        ],
        "premises-FOL": [
            "∀x (StudiesHard(x) → HardWorker(x)) ::: If someone studies hard, they are a hard worker.",
            "∀x (AttendsEveryClass(x) → AttendsAllClasses(x)) ::: If someone attends every class, they attend all classes.",
            "∀x ∀y (Studies(x, y) ∧ Difficult(y) ∧ HardWorker(x) → Pass(x)) ::: If someone studies a subject, and that subject is difficult, and they are a hard worker, then they pass.",
            "Studies(alice, exam) ::: Alice studies the exam.",
            "Difficult(exam) ::: The exam is difficult.",
            "AttendsAllClasses(alice) → HardWorker(alice) ::: Attending all classes helps to pass exam"
        ],
        "predicates": [
            "HardWorker(x) ::: x studies hard",
            "AttendsAllClasses(x) ::: x attends every class",
            "Pass(x) ::: x passes the exam",
            "Studies(x, y) ::: x studies y",
            "Difficult(y) ::: y is difficult",
            "HelpsPass(x,y) ::: x helps to pass y"
        ]
    },
    {
        "premises-NL": [
            "Alice is a student.",
            "If Alice is enrolled in a course, she will either pass or fail that course.",
            "If Alice passes a course, then she does not fail it.",
            "If Alice is enrolled in a difficult course and does not spend a lot of time studying, then she will fail the course.",
            "Alice is enrolled in some course."
        ],
        "premises-FOL": [
            "Student(alice) ::: Alice is a student.",
            "∀x ∀y (Enrolled(x, y) → (Passes(x, y) ∨ Fails(x, y))) ::: If a student is enrolled in a course, they will either pass or fail that course.",
            "∀x ∀y (Passes(x, y) → ¬Fails(x, y)) ::: If a student passes a course, then they do not fail it.",
            "∀x (Enrolled(alice, x) ∧ Difficult(x) ∧ ¬SpendsALotOfTimeStudying(alice) → Fails(alice, x)) ::: If Alice is enrolled in a difficult course and does not spend a lot of time studying, then she will fail the course.",
            "∃x Enrolled(alice, x) ::: Alice is enrolled in some course."
        ],
        "predicates": [
            "Enrolled(x, y) ::: x is enrolled in course y",
            "Difficult(x) ::: x is a difficult course",
            "SpendsALotOfTimeStudying(x) ::: x spends a lot of time studying",
            "Fails(x, y) ::: x fails course y",
            "Passes(x, y) ::: x passes course y"
        ]
    },
    {
        "premises-NL": [
            "All students are people.",
            "If someone takes a course, they are registered in it.",
            "If someone is registered in a course, they are a student.",
            "For every course, there exists a professor who teaches it.",
            "Some courses are hard.",
            "No hard courses are easy.",
            "If someone takes an easy course and their grade is less than 50, that course is hard.",
            "Some students take hard courses.",
            "If someone takes a course and gets a grade above 70, the course is not hard.",
            "There exists a course that some student takes."
        ],
        "premises-FOL": [
            "∀x (Student(x) → Person(x)) ::: All students are people.",
            "∀x ∀y (Takes(x, y) → Registered(x, y)) ::: If someone takes a course, they are registered in it.",
            "∀x ∀y (Registered(x, y) → Student(x)) ::: If someone is registered in a course, they are a student.",
            "∀x ∃y (Course(x) → Teaches(y, x) ∧ Professor(y)) ::: For every course, there exists a professor who teaches it.",
            "∃x HardCourse(x) ::: Some courses are hard.",
            "∀x (HardCourse(x) → ¬EasyCourse(x)) ::: No hard courses are easy.",
            "∀x ∀y ∀z (Takes(x, y) ∧ EasyCourse(y) ∧ Grade(x, y, z) ∧ LessThan(z, 50) → HardCourse(y)) ::: If someone takes an easy course and their grade is less than 50, that course is hard.",
            "∃x ∃y (Student(x) ∧ Takes(x, y) ∧ HardCourse(y)) ::: Some students take hard courses.",
            "∀x ∀y ∀z (Takes(x, y) ∧ Grade(x, y, z) ∧ GreaterThan(z, 70) → ¬HardCourse(y)) ::: If someone takes a course and gets a grade above 70, the course is not hard.",
            "∃x ∃y (Student(x) ∧ Takes(x, y)) ::: There exists a course that some student takes."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Takes(x, y) ::: x takes course y",
            "Professor(y) ::: y is a professor",
            "Teaches(y, x) ::: y teaches course x",
            "Grade(x, y, z) ::: The grade of student x in course y is z",
            "GreaterThan(x, y) ::: x is greater than y",
            "LessThan(x, y) ::: x is less than y",
            "Registered(x, y) ::: x is registered in course y",
            "HardCourse(x) ::: x is a hard course",
            "EasyCourse(x) ::: x is an easy course"
        ]
    },
    {
        "premises-NL": [
            "∀x ∀y (Enrolled(x, y) → Student(x)) ::: If someone is enrolled in a course, then they are a student.",
            "∀x ∀y (Prerequisite(x, y) → Course(x) ∧ Course(y)) ::: If a course is a prerequisite for another, both are valid courses.",
            "∀x ∀y ∀z (Enrolled(x, y) ∧ Prerequisite(y, z) ∧ Student(x) → Eligible(x, z)) ::: If a student is enrolled in a prerequisite course, they are eligible for the course.",
            "Enrolled(alice, cs101) ::: Alice is enrolled in CS101.",
            "Enrolled(alice, cs201) ::: Alice is enrolled in CS201.",
            "Prerequisite(cs101, cs301) ::: CS101 is a prerequisite for CS301.",
            "Student(alice) ::: Alice is a student."
        ],
        "premises-FOL": [
            "∀x ∀y (Enrolled(x, y) → Student(x)) ::: If someone is enrolled in a course, then they are a student.",
            "∀x ∀y (Prerequisite(x, y) → Course(x) ∧ Course(y)) ::: If a course is a prerequisite for another, both are valid courses.",
            "∀x ∀y ∀z (Enrolled(x, y) ∧ Prerequisite(y, z) ∧ Student(x) → Eligible(x, z)) ::: If a student is enrolled in a prerequisite course, they are eligible for the course.",
            "Enrolled(alice, cs101) ::: Alice is enrolled in CS101.",
            "Enrolled(alice, cs201) ::: Alice is enrolled in CS201.",
            "Prerequisite(cs101, cs301) ::: CS101 is a prerequisite for CS301.",
            "Student(alice) ::: Alice is a student."
        ],
        "predicates": [
            "Enrolled(x, y) ::: Student x is enrolled in course y",
            "Prerequisite(x, y) ::: Course x is a prerequisite for course y",
            "Eligible(x, y) ::: Student x is eligible to enroll in course y"
        ]
    },
    {
        "premises-NL": [
            "To be eligible to graduate, a student must meet all requirements.",
            "Meeting all requirements includes attending all classes.",
            "Graduating students must be eligible to graduate.",
            "A student who has not paid tuition has outstanding fees.",
            "A student with outstanding fees is not eligible to graduate.",
            "If a student has not paid their tuition, they will have outstanding fees.",
            "A student can only be considered graduating if they meet all requirements.",
            "Receiving a diploma is dependent on graduation."
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ EligibleToGraduate(x) → MeetsAllRequirements(x)) ::: To be eligible to graduate, a student must meet all requirements.",
            "∀x (Student(x) ∧ MeetsAllRequirements(x) → AttendedAllClasses(x)) ::: Meeting all requirements includes attending all classes.",
            "∀x (Student(x) ∧ Graduating(x) → EligibleToGraduate(x)) ::: Graduating students must be eligible to graduate.",
            "∀x (Student(x) ∧ ¬PaidTuition(x) → HasOutstandingFees(x)) ::: A student who has not paid tuition has outstanding fees.",
            "∀x (Student(x) ∧ HasOutstandingFees(x) → ¬EligibleToGraduate(x)) ::: A student with outstanding fees is not eligible to graduate.",
            "∀x (Student(x) ∧ ¬PaidTuition(x) → HasOutstandingFees(x)) ::: If a student has not paid their tuition, they will have outstanding fees.",
            "∀x (Student(x) ∧ Graduating(x) → MeetsAllRequirements(x)) ::: A student can only be considered graduating if they meet all requirements.",
            "∀x (Student(x) ∧ Graduating(x) → ReceiveDiploma(x)) ::: Receiving a diploma is dependent on graduation."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Graduating(x) ::: x is graduating",
            "PaidTuition(x) ::: x has paid tuition",
            "ReceiveDiploma(x) ::: x receives a diploma",
            "HasOutstandingFees(x) ::: x has outstanding fees",
            "EligibleToGraduate(x) ::: x is eligible to graduate",
            "MeetsAllRequirements(x) ::: x meets all requirements",
            "AttendedAllClasses(x) ::: x has attended all classes"
        ]
    },
    {
        "premises-NL": [
            "All students must maintain a minimum GPA.",
            "If a student's GPA is low, they are placed on academic probation.",
            "Students on academic probation must improve their grades.",
            "If a student on probation does not improve their grades, they fail to meet academic standards.",
            "If a student fails to meet academic standards, they will be suspended.",
            "Students can appeal suspension decisions.",
            "If a student appeals successfully, they will not be suspended.",
            "Students who are not suspended continue their studies.",
            "Students with a high GPA are not on academic probation.",
            "Students on probation are closely monitored.",
            "Students who are suspended cannot enroll in courses.",
            "All students must adhere to academic standards."
        ],
        "premises-FOL": [
            "∀x (Student(x) → MustMaintainMinimumGPA(x)) ::: All students must maintain a minimum GPA.",
            "∀x (Student(x) ∧ LowGPA(x) → OnAcademicProbation(x)) ::: If a student's GPA is low, they are placed on academic probation.",
            "∀x (OnAcademicProbation(x) → MustImproveGrades(x)) ::: Students on academic probation must improve their grades.",
            "∀x (OnAcademicProbation(x) ∧ ¬ImprovesGrades(x) → FailsToMeetStandards(x)) ::: If a student on probation does not improve their grades, they fail to meet academic standards.",
            "∀x (FailsToMeetStandards(x) → Suspended(x)) ::: If a student fails to meet academic standards, they will be suspended.",
            "∀x (Student(x) → CanAppealSuspension(x)) ::: Students can appeal suspension decisions.",
            "∀x (AppealsSuccessfully(x) → ¬Suspended(x)) ::: If a student appeals successfully, they will not be suspended.",
            "∀x (¬Suspended(x) → ContinuesStudies(x)) ::: Students who are not suspended continue their studies.",
            "∀x (HighGPA(x) → ¬OnAcademicProbation(x)) ::: Students with a high GPA are not on academic probation.",
            "∀x (OnAcademicProbation(x) → CloselyMonitored(x)) ::: Students on probation are closely monitored.",
            "∀x (Suspended(x) → ¬CanEnrollInCourses(x)) ::: Students who are suspended cannot enroll in courses.",
            "∀x (Student(x) → AdheresToAcademicStandards(x)) ::: All students must adhere to academic standards."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "LowGPA(x) ::: x has a low GPA",
            "OnAcademicProbation(x) ::: x is on academic probation",
            "ImprovesGrades(x) ::: x improves their grades",
            "Suspended(x) ::: x is suspended",
            "AppealsSuccessfully(x) ::: x appeals successfully",
            "FailsToMeetStandards(x) ::: x fails to meet academic standards",
            "MeetsMinimumRequirements(x) ::: x meets minimum academic requirements"
        ]
    },
    {
        "premises-NL": [
            "All students must meet their financial obligations to remain enrolled.",
            "Paying tuition or being eligible for financial aid meets financial obligations.",
            "Setting up a payment plan meets financial obligations.",
            "If a student does not meet financial obligations, they have an outstanding balance.",
            "Students with an outstanding balance may be dropped from their courses.",
            "Students dropped from courses do not receive credit.",
            "Students are expected to pay tuition before the semester starts.",
            "Students can apply for financial aid to help with tuition costs.",
            "The university offers payment plans to students who cannot pay tuition in full.",
            "If a student is dropped from courses, they must re-enroll.",
            "Students cannot graduate without receiving credit for required courses.",
            "Students who pay their tuition don't get dropped from the courses.",
            "Those on financial aid also don't get dropped from the courses."
        ],
        "premises-FOL": [
            "∀x (Student(x) → MeetsFinancialObligations(x) ∨ ¬EnrolledInCourses(x)) ::: All students must meet their financial obligations to remain enrolled.",
            "∀x (PaysTuition(x) ∨ EligibleForFinancialAid(x) → MeetsFinancialObligations(x)) ::: Paying tuition or being eligible for financial aid meets financial obligations.",
            "∀x (SetsUpPaymentPlan(x) → MeetsFinancialObligations(x)) ::: Setting up a payment plan meets financial obligations.",
            "∀x (¬MeetsFinancialObligations(x) → HasOutstandingBalance(x)) ::: If a student does not meet financial obligations, they have an outstanding balance.",
            "∀x (HasOutstandingBalance(x) → DroppedFromCourses(x)) ::: Students with an outstanding balance may be dropped from their courses.",
            "∀x (DroppedFromCourses(x) → ¬ReceivesCredit(x)) ::: Students dropped from courses do not receive credit.",
            "∀x (Student(x) → ExpectsToPayTuition(x)) ::: Students are expected to pay tuition before the semester starts.",
            "∀x (Student(x) → CanApplyForFinancialAid(x)) ::: Students can apply for financial aid to help with tuition costs.",
            "∀x (Student(x) → OffersPaymentPlans(x)) ::: The university offers payment plans to students who cannot pay tuition in full.",
            "∀x (DroppedFromCourses(x) → MustReEnroll(x)) ::: If a student is dropped from courses, they must re-enroll.",
            "∀x (Student(x) → RequiresCreditToGraduate(x)) ::: Students cannot graduate without receiving credit for required courses.",
            "∀x (PaysTuition(x) → ¬DroppedFromCourses(x)) ::: Students who pay their tuition don't get dropped from the courses.",
            "∀x (EligibleForFinancialAid(x) → ¬DroppedFromCourses(x)) ::: Those on financial aid also don't get dropped from the courses."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "PaysTuition(x) ::: x pays tuition",
            "EligibleForFinancialAid(x) ::: x is eligible for financial aid",
            "SetsUpPaymentPlan(x) ::: x sets up a payment plan",
            "DroppedFromCourses(x) ::: x is dropped from courses",
            "ReceivesCredit(x) ::: x receives credit",
            "MeetsFinancialObligations(x) ::: x meets financial obligations",
            "EnrolledInCourses(x) ::: x is enrolled in courses",
            "HasOutstandingBalance(x) ::: x has an outstanding balance"
        ]
    },
    {
        "premises-NL": [
            "Calculus is a prerequisite for Advanced Engineering.",
            "Anyone enrolled in Advanced Engineering must have passed Calculus.",
            "If someone is enrolled in Calculus and a freshman, then they are taking Introductory Physics.",
            "No one can be enrolled in both Advanced Engineering and Introductory Physics.",
            "All freshmen are taking an introductory course."
        ],
        "premises-FOL": [
            "Prerequisite(Calculus, AdvancedEngineering) ::: Calculus is a prerequisite for Advanced Engineering.",
            "∀x (Enrolled(x, AdvancedEngineering) → Passed(x, Calculus)) ::: Anyone enrolled in Advanced Engineering must have passed Calculus.",
            "∀x ((Enrolled(x, Calculus) ∧ Freshman(x)) → Takes(x, IntroductoryPhysics)) ::: If someone is enrolled in Calculus and a freshman, then they are taking Introductory Physics.",
            "¬∃x (Enrolled(x, AdvancedEngineering) ∧ Takes(x, IntroductoryPhysics)) ::: No one can be enrolled in both Advanced Engineering and Introductory Physics.",
            "∀x (Freshman(x) → Takes(x, IntroductoryCourse)) ::: All freshmen are taking an introductory course.",
            "∀x (Takes(x, IntroductoryCourse) → Takes(x, IntroductoryPhysics) ∨ Takes(x, IntroductoryChemistry)) ::: Everyone taking an introductory course takes either Introductory Physics or Introductory Chemistry",
            "¬∃x (Takes(x, IntroductoryPhysics) ∧ Takes(x, IntroductoryChemistry)) ::: No one can take Introductory Physics and Introductory Chemistry simultaneously",
            "∀x (Enrolled(x, Calculus) → Takes(x, Calculus)) ::: If someone is enrolled in Calculus they take Calculus"
        ],
        "predicates": [
            "Enrolled(x, y) ::: Student x is enrolled in course y",
            "Freshman(x) ::: Student x is a freshman",
            "Takes(x, y) ::: Student x takes course y",
            "Prerequisite(x, y) ::: Course x is a prerequisite for course y"
        ]
    },
    {
        "premises-NL": [
            "All students are either dedicated or not.",
            "If a student is dedicated, they ask for help if they struggle.",
            "If a student asks for help, they receive extra credit.",
            "If a student receives extra credit, they pass the course.",
            "There exists a student who is enrolled in a course.",
            "There exists a difficult course.",
            "If a student is enrolled in a difficult course they struggle.",
            "Every student enrolled in a course is a student.",
            "There exists a student who is not dedicated."
        ],
        "premises-FOL": [
            "∀x (Student(x) → (Dedicated(x) ∨ ¬Dedicated(x))) ::: All students are either dedicated or not.",
            "∀x ∀y (Student(x) ∧ Dedicated(x) ∧ Enrolled(x, y) ∧ Struggles(x, y) → AsksForHelp(x, y)) ::: If a student is dedicated, they ask for help if they struggle.",
            "∀x ∀y (Student(x) ∧ Enrolled(x, y) ∧ AsksForHelp(x, y) → ExtraCredit(x, y)) ::: If a student asks for help, they receive extra credit.",
            "∀x ∀y (Student(x) ∧ Enrolled(x, y) ∧ ExtraCredit(x, y) → Passes(x, y)) ::: If a student receives extra credit, they pass the course.",
            "∃x ∃y (Student(x) ∧ Enrolled(x, y)) ::: There exists a student who is enrolled in a course.",
            "∃y DifficultCourse(y) ::: There exists a difficult course.",
            "∀x ∀y (Student(x) ∧ Enrolled(x, y) ∧ DifficultCourse(y) → Struggles(x, y)) ::: If a student is enrolled in a difficult course they struggle.",
            "∀x ∀y (Enrolled(x, y) → Student(x)) ::: Every student enrolled in a course is a student.",
            "∃x (Student(x) ∧ ¬Dedicated(x)) ::: There exists a student who is not dedicated."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Enrolled(x, y) ::: x is enrolled in course y",
            "Struggles(x, y) ::: x struggles in course y",
            "ExtraCredit(x, y) ::: x receives extra credit in course y",
            "AsksForHelp(x, y) ::: x asks for help in course y",
            "Passes(x, y) ::: x passes course y",
            "DifficultCourse(y) ::: y is a difficult course",
            "Dedicated(x) ::: x is dedicated"
        ]
    },
    {
        "premises-NL": [
            "All people who regularly drink coffee are dependent on caffeine.",
            "People either regularly drink coffee or joke about being addicted to caffeine.",
            "No one who jokes about being addicted to caffeine is unaware that caffeine is a drug.",
            "Rina is either a student and unaware that caffeine is a drug, or neither a student nor unaware that caffeine is a drug.",
            "If Rina is not a person dependent on caffeine and a student, then Rina is either a person dependent on caffeine and a student, or neither a person dependent on caffeine nor a student. "
        ],
        "predicates": [
            "Drinks(x) ::: x regularly drinks coffee",
            "Dependent(x) ::: x is dependent on caffeine",
            "Jokes(x) ::: x jokes about being addicted to caffeine",
            "Unaware(x) ::: x is unaware that caffeine is a drug",
            "Student(x) ::: x is a student"
        ],
        "premises-FOL": [
            "∀x (Drinks(x) → Dependent(x)) ::: All people who regularly drink coffee are dependent on caffeine.",
            "∀x (Drinks(x) ⊕ Jokes(x)) ::: People either regularly drink coffee or joke about being addicted to caffeine.",
            "∀x (Jokes(x) → ¬Unaware(x)) ::: No one who jokes about being addicted to caffeine is unaware that caffeine is a drug.",
            "(Student(rina) ∧ Unaware(rina)) ⊕ ¬(Student(rina) ∨ Unaware(rina)) ::: Rina is either a student and unaware that caffeine is a drug, or neither a student nor unaware that caffeine is a drug.",
            "¬(Dependent(rina) ∧ Student(rina)) → ((Dependent(rina) ∧ Student(rina)) ⊕ ¬(Dependent(rina) ∨ Student(rina))) ::: If Rina is not a person dependent on caffeine and a student, then Rina is either a person dependent on caffeine and a student, or neither a person dependent on caffeine nor a student."
        ]
    },
    {
        "premises-NL": [
            "Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music.",
            "Any choral conductor is a musician.",
            "Some musicians love music.",
            "Miroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant."
        ],
        "predicates": [
            "Czech(x) ::: x is Czech",
            "ChoralConductor(x) ::: x is a choral conductor",
            "Specialize(x, y) ::: x specializes in y",
            "Musician(x) ::: x is a musician",
            "Love(x, y) ::: x loves y",
            "Book(x) ::: x is a book",
            "Author(x, y) ::: x is the author of y",
            "Publish(x, y) ::: x was published in year y"
        ],
        "premises-FOL": [
            "Czech(miroslav) ∧ ChoralConductor(miroslav) ∧ Specialize(miroslav, renaissance) ∧ Specialize(miroslav, baroque) ::: Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music.",
            "∀x (ChoralConductor(x) → Musician(x)) ::: Any choral conductor is a musician.",
            "∃x (Musician(x) ∧ Love(x, music)) ::: Some musicians love music.",
            "Book(methodofstudyinggregorianchant) ∧ Author(miroslav, methodofstudyinggregorianchant) ∧ Publish(methodofstudyinggregorianchant, 1946) ::: Miroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant."
        ]
    },
    {
        "premises-NL": [
            "All eels are fish. ",
            "No fish are plants. ",
            "A thing is either a plant or animal.",
            "Nothing that breathes is paper. ",
            "All animals breathe.",
            "If a sea eel is either an eel or a plant, then a sea eel is an eel or an animal."
        ],
        "predicates": [
            "Eel(x) ::: x is an eel",
            "Fish(x) ::: x is a fish",
            "Plant(x) ::: x is a plant",
            "Animal(x) ::: x is an animal",
            "Breathe(x) ::: x breathes",
            "Paper(x) ::: x is paper",
            "SeaEel(x) ::: x is a sea eel"
        ],
        "premises-FOL": [
            "∀x (Eel(x) → Fish(x)) ::: All eels are fish.",
            "∀x (Fish(x) → ¬Plant(x)) ::: No fish are plants.",
            "∀x (Plant(x) ∨ Animal(x)) ::: A thing is either a plant or animal.",
            "∀x (Breathe(x) → ¬Paper(x)) ::: Nothing that breathes is paper.",
            "∀x (Animal(x) → Breathe(x)) ::: All animals breathe.",
            "∀x ((SeaEel(x) ∧ (Eel(x) ∨ Plant(x))) → (Eel(x) ∨ Animal(x))) ::: If a sea eel is either an eel or a plant, then a sea eel is an eel or an animal."
        ]
    },
    {
        "premises-NL": [
            "The Blake McFall Company Building is a commercial warehouse listed on the National Register of Historic Places.",
            "The Blake McFall Company Building was added to the National Register of Historic Places in 1990.",
            "The Emmet Building is a five-story building in Portland, Oregon.",
            "The Emmet Building was built in 1915.",
            "The Emmet Building is another name for the Blake McFall Company Building.",
            "John works at the Emmet Building."
        ],
        "predicates": [
            "Blake(x) ::: x is the Blake McFall Company Building",
            "Building(x) ::: x is a building",
            "CommercialWarehouse(x) ::: x is a commercial warehouse",
            "ListedOn(x, y) ::: x is listed on y",
            "NationalRegisterOfHistoricPlaces(x) ::: x is the National Register of Historic Places",
            "AddedTo(x, y, z) ::: x was added to y in year z",
            "Emmet(x) ::: x is the Emmet Building",
            "FiveStory(x) ::: x is a five-story building",
            "Locate(x, y) ::: x is located in y",
            "Construct(x, y) ::: x was constructed in year y",
            "Work(x, y) ::: x works at y"
        ],
        "premises-FOL": [
            "∀x (Blake(x) → CommercialWarehouse(x) ∧ Building(x) ∧ ListedOn(x, NationalRegisterOfHistoricPlaces)) ::: The Blake McFall Company Building is a commercial warehouse listed on the National Register of Historic Places.",
            "∀x (Blake(x) → AddedTo(x, NationalRegisterOfHistoricPlaces, 1990)) ::: The Blake McFall Company Building was added to the National Register of Historic Places in 1990.",
            "∀x (Emmet(x) → Building(x) ∧ FiveStory(x) ∧ Locate(x, portland)) ::: The Emmet Building is a five-story building in Portland, Oregon.",
            "∀x (Emmet(x) → Construct(x, 1915)) ::: The Emmet Building was built in 1915.",
            "∀x (Emmet(x) ↔ Blake(x)) ::: The Emmet Building is another name for the Blake McFall Company Building.",
            "∃x (Emmet(x) ∧ Work(john, x)) ::: John works at the Emmet Building."
        ]
    },
    {
        "premises-NL": [
            "William Dickinson was a British politician who sat in the House of Commons",
            "William Dickinson attended Westminster school for high school and then the University of Edinburgh.",
            "The University of Edinburgh is a university located in the United Kingdom.",
            "William Dickinson supported the Portland Whigs.",
            "People who supported the Portland Whigs did not get a seat in the Parliament."
        ],
        "predicates": [
            "BritishPolitician(x) ::: x is a British politician",
            "SatInHouseOfCommons(x) ::: x sat in the House of Commons",
            "Attended(x, y) ::: x attended y",
            "Highschool(x) ::: x is a high school",
            "University(x) ::: x is a university",
            "LocatedIn(x, y) ::: x is located in y",
            "Supported(x, y) ::: x supported y",
            "SeatInParliament(x) ::: x got a seat in the Parliament"
        ],
        "premises-FOL": [
            "BritishPolitician(williamdickinson) ∧ SatInHouseOfCommons(williamdickinson) ::: William Dickinson was a British politician who sat in the House of Commons",
            "Attended(williamdickinson, westminster) ∧ Highschool(westminster) ∧ Attended(williamdickinson, universityofedinburgh) ::: William Dickinson attended Westminster school for high school and then the University of Edinburgh.",
            "LocatedIn(universityofedinburgh, unitedkingdom) ∧ University(universityofedinburgh) ::: The University of Edinburgh is a university located in the United Kingdom.",
            "Supported(williamdickinson, portlandwhigs) ::: William Dickinson supported the Portland Whigs.",
            "∀x (Supported(x, portlandwhigs) → ¬SeatInParliament(x)) ::: People who supported the Portland Whigs did not get a seat in the Parliament."
        ]
    },
    {
        "premises-NL": [
            "LanguageA is a universal language",
            "If a universal language exists, then for every two people if they both know the same universal language they can communicate.",
            "Katya cannot communicate with Danil.",
            "Katya knows LanguageA. "
        ],
        "predicates": [
            "UniversalLanguage(x) ::: x is a universal language",
            "Know(x, y) ::: x knows language y",
            "Communicate(x, y) ::: x can communicate with y"
        ],
        "premises-FOL": [
            "UniversalLanguage(languageA) ::: LanguageA is a universal language",
            "∀x ∀y (∃z (Know(x, z) ∧ Know(y, z) ∧ UniversalLanguage(z)) → Communicate(x, y)) ::: If a universal language exists, then for every two people if they both know the same universal language they can communicate.",
            "¬Communicate(katya, danil) ::: Katya cannot communicate with Danil.",
            "Know(katya, languageA) ::: Katya knows LanguageA."
        ]
    },
    {
        "premises-NL": [
            "All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees. ",
            "Some customers go to cinemas every week",
            "Customers either subscribe to AMC service or HBO service. ",
            "Customers who prefer TV series more and will not watch TV series in cinemas.",
            "All customers who subscribe to HBO services prefer TV series to movies. ",
            "James watches TV series in cinemas. "
        ],
        "predicates": [
            "AMC(x) ::: x is a customer subscribed to AMC List",
            "ThreeMovies(x) ::: x is available to watch 3 movies every week without any additional fees",
            "CinemaEveryWeek(x) ::: x goes to cinemas every week",
            "HBO(x) ::: x is a customer subscribed to HBO service",
            "PreferTVSeries(x) ::: x prefers TV series more",
            "WatchTVInCinema(x) ::: x watches TV series in cinemas"
        ],
        "premises-FOL": [
            "∀x (AMC(x) → ThreeMovies(x)) ::: All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees.",
            "∃x (CinemaEveryWeek(x)) ::: Some customers go to cinemas every week",
            "∀x (AMC(x) ∨ HBO(x)) ::: Customers either subscribe to AMC service or HBO service.",
            "∀x (PreferTVSeries(x) → ¬WatchTVInCinema(x)) ::: Customers who prefer TV series more and will not watch TV series in cinemas.",
            "∀x (HBO(x) → PreferTVSeries(x)) ::: All customers who subscribe to HBO services prefer TV series to movies.",
            "WatchTVInCinema(james) ::: James watches TV series in cinemas."
        ]
    },
    {
        "premises-NL": [
            "A La Liga soccer team ranks higher than another if it receives more points.",
            "If two La Liga soccer teams recieve the same points, the team which recieves more points from the games between the two teams ranks higher.",
            "Real Madrid and Barcelona are both La Liga soccer teams.",
            "In La Liga 2021-2022, Real Madrid recieves 86 points and Barcelon recieves 73 points.",
            "In La Liga 2021-2022, Real Madrid and Barcelona both recieve 3 points from the games between them."
        ],
        "predicates": [
            "LaLiga(x) ::: x is a La Liga soccer team",
            "MorePoints(x, y) ::: team x receives more points than team y",
            "HigherRank(x, y) ::: team x ranks higher than team y",
            "MorePointsInGameBetween(x, y) ::: team x receives more points in the games between team x and team y"
        ],
        "premises-FOL": [
            "∀x ∀y (LaLiga(x) ∧ LaLiga(y) ∧ MorePoints(x, y) → HigherRank(x, y)) ::: If a La Liga soccer team x receives more points than another La Liga soccer team y, then team x ranks higher than team y.",
            "∀x ∀y (LaLiga(x) ∧ LaLiga(y) ∧ ¬MorePoints(x, y) ∧ ¬MorePoints(y, x) ∧ MorePointsInGameBetween(x, y) → HigherRank(x, y)) ::: If two La Liga soccer teams x and y receive the same points, and team x receives more points from the games between the two teams than team y, then team x ranks higher than team y.",
            "LaLiga(realMadrid) ∧ LaLiga(barcelona) ::: Real Madrid and Barcelona are both La Liga soccer teams.",
            "MorePoints(realMadrid, barcelona) ::: Real Madrid receives more points than Barcelona",
            "MorePointsInGameBetween(realMadrid, barcelona) ∧ MorePointsInGameBetween(barcelona, realMadrid) ::: Real Madrid receives 3 points and Barcelona receives 3 points from the games between them."
        ]
    },
    {
        "premises-NL": [
            "Lawton Park is a neighbourhood in Seattle. ",
            "All citizens of Lawton Park use the zip code 98199. ",
            "Tom is a citizen of Lawton Park.",
            "Daniel uses the zip code 98199. "
        ],
        "predicates": [
            "Neighbourhoodin(x, y) ::: x is a neighbourhood in y",
            "Citizenof(x, y) ::: x is a citizen of y",
            "Usezipcode(x, y) ::: x uses the zip code y"
        ],
        "premises-FOL": [
            "Neighbourhoodin(lawtonPark, seattle) ::: Lawton Park is a neighbourhood in Seattle",
            "∀x (Citizenof(x, lawtonPark) → Usezipcode(x, number98199)) ::: All citizens of Lawton Park use the zip code 98199",
            "Citizenof(tom, lawtonPark) ::: Tom is a citizen of Lawton Park",
            "Usezipcode(daniel, number98199) ::: Daniel uses the zip code 98199"
        ]
    },
    {
        "premises-NL": [
            "If a legislator is found guilty of stealing government funds, they will be suspended from office.",
            "Tiffany T. Alston was a legislator in Maryland's House of Delegates from 2011 to 2013.",
            "Tiffany T. Alston was found guilty of stealing government funds in 2012."
        ],
        "predicates": [
            "IsLegislator(x) ::: x is a legislator",
            "StealsFunds(x) ::: x steals government funds",
            "Suspended(x) ::: x is suspended from office"
        ],
        "premises-FOL": [
            "∀x (IsLegislator(x) ∧ StealsFunds(x) → Suspended(x)) ::: If a legislator is found guilty of stealing government funds, they will be suspended from office",
            "IsLegislator(tiffanyTAlston) ::: Tiffany T. Alston was a legislator in Maryland's House of Delegates from 2011 to 2013",
            "StealsFunds(tiffanyTAlston) ::: Tiffany T. Alston was found guilty of stealing government funds in 2012"
        ]
    },
    {
        "premises-NL": [
            "Some fish may sting.",
            "Stonefish is a fish.",
            "It stings to step on a stonefish.",
            "Stonefish stings cause death if not treated.",
            "To treat stonefish stings, apply heat to the affected area or use an antivenom."
        ],
        "predicates": [
            "Fish(x) ::: x is a fish",
            "Sting(x, y) ::: x stings y",
            "StepOn(x, y) ::: x steps on y",
            "Treated(x) ::: x is treated",
            "CauseDeath(x) ::: x causes death",
            "ApplyHeat(x) ::: apply heat to x",
            "UseAntivenom(x) ::: use antivenom for x"
        ],
        "premises-FOL": [
            "∃x ∃y (Fish(x) → Sting(x, y)) ::: Some fish may sting.",
            "Fish(stonefish) ::: Stonefish is a fish.",
            "∀x (StepOn(stonefish, x) → Sting(stonefish, x)) ::: It stings to step on a stonefish.",
            "∀x (Sting(stonefish, x) ∧ ¬Treated(x) → CauseDeath(x)) ::: Stonefish stings cause death if not treated.",
            "∀x (Sting(stonefish, x) ∧ (ApplyHeat(x) ∨ UseAntivenom(x)) → Treated(x)) ::: To treat stonefish stings, apply heat to the affected area or use an antivenom."
        ]
    },
    {
        "premises-NL": [
            "Some monitors produced by LG have a type-c port.",
            "If the monitor has a type-c port, then it is not produced by AOC.",
            "All monitors in the library are produced by AOC. ",
            "L-2021 is either in the library or has a type-c port.",
            "L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG."
        ],
        "predicates": [
            "LG(x) ::: x is produced by LG",
            "TypeC(x) ::: x has a type-c port",
            "AOC(x) ::: x is produced by AOC",
            "Library(x) ::: x is in the library"
        ],
        "premises-FOL": [
            "∃x (LG(x) ∧ TypeC(x)) ::: Some monitors produced by LG have a type-c port",
            "∀x (TypeC(x) → ¬AOC(x)) ::: If the monitor has a type-c port, then it is not produced by AOC",
            "∀x (Library(x) → AOC(x)) ::: All monitors in the library are produced by AOC",
            "Library(l-2021) ∨ TypeC(l-2021) ::: L-2021 is either in the library or has a type-c port",
            "(AOC(l-2021) ∧ LG(l-2021)) ∨ (¬AOC(l-2021) ∧ ¬LG(l-2021)) ::: L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG"
        ]
    },
    {
        "premises-NL": [
            "All rabbits have fur",
            "Some pets are rabbits."
        ],
        "predicates": [
            "Rabbit(x) ::: x is a rabbit",
            "HasFur(x) ::: x has fur",
            "Pet(x) ::: x is a pet",
            "Reptile(x) ::: x is a reptile"
        ],
        "premises-FOL": [
            "∀x (Rabbit(x) → HasFur(x)) ::: All rabbits have fur",
            "∃x (Pet(x) ∧ Reptile(x)) ::: Some pets are rabbits"
        ]
    },
    {
        "premises-NL": [
            "All video applications are software.",
            "All YouTube-related applications are video applications. ",
            "An APP is either related to YouTube or Instagram.",
            "All Instagram is entertainment. ",
            "All software is programmed. ",
            "All entertainments are interesting.",
            "If something is interesting, then it is good.",
            "TikTok is not good."
        ],
        "predicates": [
            "App(x) ::: x is a video application",
            "Software(x) ::: x is software",
            "Youtube(x) ::: x is a YouTube-related application",
            "Related(x, y) ::: x is related to y",
            "Instagram(x) ::: x is Instagram",
            "Entertainment(x) ::: x is entertainment",
            "Program(x) ::: x is programmed",
            "Interesting(x) ::: x is interesting",
            "Good(x) ::: x is good"
        ],
        "premises-FOL": [
            "∀x (App(x) → Software(x)) ::: All video applications are software.",
            "∀x (Youtube(x) → App(x)) ::: All YouTube-related applications are video applications.",
            "∀x (Related(x, Youtube) ∨ Related(x, Instagram)) ::: An APP is either related to YouTube or Instagram.",
            "∀x (Instagram(x) → Entertainment(x)) ::: All Instagram is entertainment.",
            "∀x (Software(x) → Program(x)) ::: All software is programmed.",
            "∀x (Entertainment(x) → Interesting(x)) ::: All entertainments are interesting.",
            "∀x (Interesting(x) → Good(x)) ::: If something is interesting, then it is good.",
            "¬Good(tiktok) ::: TikTok is not good."
        ]
    },
    {
        "premises-NL": [
            "Ordinary is an unincorporated community.",
            "Located within Elliot County, Ordinary is on Kentucky Route 32.",
            "Ordinary is located northwest of Sandy Hook."
        ],
        "predicates": [
            "UnincorporatedCommunity(x) ::: x is an unincorporated community",
            "In(x, y) ::: x is located within y",
            "On(x, y) ::: x is on y",
            "NorthwestOf(x, y) ::: x is located northwest of y"
        ],
        "premises-FOL": [
            "UnincorporatedCommunity(ordinary) ::: Ordinary is an unincorporated community.",
            "In(ordinary, elliotcounty) ∧ On(ordinary, kentuckyroute32) ::: Ordinary is located within Elliot County and Ordinary is on Kentucky Route 32.",
            "NorthwestOf(ordinary, sandyhook) ::: Ordinary is located northwest of Sandy Hook."
        ]
    },
    {
        "premises-NL": [
            "All young adults go on a diet.",
            "All college students are young adults.",
            "All Yale students are college students.",
            "Someone is either a Yale student or a Harvard student.",
            "All Harvard students are diligent.",
            "If Susan is a Harvard student, then she is a young adult.",
            "If Susan is a Yale student, then she does not go on a diet."
        ],
        "predicates": [
            "YoungAdult(x) ::: x is a young adult",
            "GoOnDiet(x) ::: x goes on a diet",
            "CollegeStudent(x) ::: x is a college student",
            "YaleStudent(x) ::: x is a Yale student",
            "HarvardStudent(x) ::: x is a Harvard student",
            "Diligent(x) ::: x is diligent"
        ],
        "premises-FOL": [
            "∀x (YoungAdult(x) → GoOnDiet(x)) ::: All young adults go on a diet.",
            "∀x (CollegeStudent(x) → YoungAdult(x)) ::: All college students are young adults.",
            "∀x (YaleStudent(x) → CollegeStudent(x)) ::: All Yale students are college students.",
            "∃x (YaleStudent(x) ∨ HarvardStudent(x)) ::: Someone is either a Yale student or a Harvard student.",
            "∀x (HarvardStudent(x) → Diligent(x)) ::: All Harvard students are diligent.",
            "HarvardStudent(susan) → YoungAdult(susan) ::: If Susan is a Harvard student, then she is a young adult.",
            "YaleStudent(susan) → ¬GoOnDiet(susan) ::: If Susan is a Yale student, then she does not go on a diet."
        ]
    },
    {
        "premises-NL": [
            "Vic DiCara plays guitar and bass.",
            "The only style of music Vic DiCara plays is punk music.",
            "Vic DiCara played in the band Inside Out."
        ],
        "predicates": [
            "Play(x, y) ::: x plays y",
            "Music(x, y) ::: x plays music of style y",
            "Band(x, y) ::: x played in band y"
        ],
        "premises-FOL": [
            "Play(vicdicara, guitar) ∧ Play(vicdicara, bass) ::: Vic DiCara plays guitar and bass.",
            "∀x (Music(vicdicara, x) → Equal(x, punk)) ::: The only style of music Vic DiCara plays is punk music.",
            "Band(vicdicara, insideout) ::: Vic DiCara played in the band Inside Out."
        ]
    },
    {
        "premises-NL": [
            "All athletes are good at sports.",
            "All Olympic gold medal winners are good athletes.",
            "No scientists are good at sports.",
            "All Nobel laureates are scientists.",
            "Amy is good at sports or Amy is an Olympic gold medal winner.",
            "If Amy is not a Nobel laureate, then Amy is not an Olympic gold medal winner."
        ],
        "predicates": [
            "Athlete(x) ::: x is an athlete",
            "GoodAtSports(x) ::: x is good at sports",
            "OlympicGoldMedalWinner(x) ::: x is an Olympic gold medal winner",
            "Scientist(x) ::: x is a scientist",
            "NobelLaureate(x) ::: x is a Nobel laureate"
        ],
        "premises-FOL": [
            "∀x (Athlete(x) → GoodAtSports(x)) ::: All athletes are good at sports",
            "∀x (OlympicGoldMedalWinner(x) → Athlete(x)) ::: All Olympic gold medal winners are good athletes",
            "∀x (Scientist(x) → ¬GoodAtSports(x)) ::: No scientists are good at sports",
            "∀x (NobelLaureate(x) → Scientist(x)) ::: All Nobel laureates are scientists",
            "GoodAtSports(amy) ∨ OlympicGoldMedalWinner(amy) ::: Amy is good at sports or Amy is an Olympic gold medal winner",
            "¬NobelLaureate(amy) → ¬OlympicGoldMedalWinner(amy) ::: If Amy is not a Nobel laureate, then Amy is not an Olympic gold medal winner"
        ]
    },
    {
        "premises-NL": [
            "All fruits with the color red contain a large amount of vitamin C.",
            "All apples are fruits with the color red.",
            "All fruits containing a large amount of vitamin C are beneficial to people. ",
            "No fruits that are beneficial to people are on a warning list.",
            "If K is not beneficial to people and also not an apple, then it is a fruit with the color red."
        ],
        "predicates": [
            "RedFruit(x) ::: x is a fruit with the color red",
            "VC(x) ::: x contains a large amount of vitamin C",
            "Apple(x) ::: x is an apple",
            "Benefit(x) ::: x is beneficial to people",
            "WarningList(x) ::: x is on a warning list"
        ],
        "premises-FOL": [
            "∀x (RedFruit(x) → VC(x)) ::: All fruits with the color red contain a large amount of vitamin C.",
            "∀x (Apple(x) → RedFruit(x)) ::: All apples are fruits with the color red.",
            "∀x (VC(x) → Benefit(x)) ::: All fruits containing a large amount of vitamin C are beneficial to people.",
            "∀x (Benefit(x) → ¬WarningList(x)) ::: No fruits that are beneficial to people are on a warning list.",
            "¬(Benefit(k) ∧ Apple(k)) → RedFruit(k) ::: If K is not beneficial to people and also not an apple, then it is a fruit with the color red."
        ]
    },
    {
        "premises-NL": [
            "Everyone working at Meta has a high income. ",
            "If a person has a high income, then he/she will not take a bus to their destination.",
            "People will either take a bus or drive to their destination. ",
            "Everyone who has a car will choose to drive to their destination. ",
            "No students drive to their destination. ",
            "James has a car or works at Meta."
        ],
        "predicates": [
            "Meta(x) ::: x works at Meta",
            "HighIncome(x) ::: x has a high income",
            "Bus(x) ::: x takes a bus to their destination",
            "Drive(x) ::: x drives to their destination",
            "HaveCars(x) ::: x has a car",
            "Student(x) ::: x is a student"
        ],
        "premises-FOL": [
            "∀x (Meta(x) → HighIncome(x)) ::: Everyone working at Meta has a high income.",
            "∀x (HighIncome(x) → ¬Bus(x)) ::: If a person has a high income, then he/she will not take a bus to their destination.",
            "∀x (Bus(x) ∨ Drive(x)) ::: People will either take a bus or drive to their destination.",
            "∀x (HaveCars(x) → Drive(x)) ::: Everyone who has a car will choose to drive to their destination.",
            "∀x (Student(x) → ¬Drive(x)) ::: No students drive to their destination.",
            "HaveCars(james) ∨ Meta(james) ::: James has a car or works at Meta."
        ]
    },
    {
        "premises-NL": [
            "Students either go to the park or go to the movies. ",
            "No student who enjoys nature has free time during the weekend. ",
            "All students who go to the movies enjoy nature. ",
            "All students who do not have class during the weekend have free time during the weekend. ",
            "All students not in summer camp do not have class during the weekend. ",
            "James does not have class during the weekend."
        ],
        "predicates": [
            "Park(x) ::: Student x goes to the park",
            "Movies(x) ::: Student x goes to the movies",
            "Nature(x) ::: Student x enjoys nature",
            "FreeTime(x) ::: Student x has free time during the weekend",
            "NoClass(x) ::: Student x does not have class during the weekend",
            "SummerCamp(x) ::: Student x is not in summer camp"
        ],
        "premises-FOL": [
            "∀x (Park(x) ⊕ Movies(x)) ::: Students either go to the park or go to the movies.",
            "∀x (Nature(x) → ¬FreeTime(x)) ::: No student who enjoys nature has free time during the weekend.",
            "∀x (Movies(x) → Nature(x)) ::: All students who go to the movies enjoy nature.",
            "∀x (NoClass(x) → FreeTime(x)) ::: All students who do not have class during the weekend have free time during the weekend.",
            "∀x (SummerCamp(x) → NoClass(x)) ::: All students not in summer camp do not have class during the weekend.",
            "NoClass(james) ::: James does not have class during the weekend."
        ]
    },
    {
        "premises-NL": [
            "No television stars are certified public accountants.",
            "All certified public accountants have good business sense."
        ],
        "predicates": [
            "TelevisionStar(x) ::: x is a television star",
            "CertifiedPublicAccoutant(x) ::: x is a certified public accountant",
            "GoodBusinessSense(x) ::: x has good business sense"
        ],
        "premises-FOL": [
            "∀x (TelevisionStar(x) → ¬CertifiedPublicAccoutant(x)) ::: No television stars are certified public accountants.",
            "∀x (CertifiedPublicAccoutant(x) → GoodBusinessSense(x)) ::: All certified public accountants have good business sense."
        ]
    },
    {
        "premises-NL": [
            "If a Leetcode problem is at the easy level, then its AC rate is lower than 20 percent. ",
            "All Leetcode problems that are recommended to novices are easy. ",
            "A Leetode problem is either easy or hard.",
            "Leetcode problems that are starred by more than 1 thousand users are hard.",
            "2Sum is recommended to novices. ",
            "4Sum is starred by more than 1 thousand users."
        ],
        "predicates": [
            "Easy(x) ::: Leetcode problem x is at the easy level",
            "LowerAC(x) ::: AC rate of Leetcode problem x is lower than 20 percent",
            "Recommended(x) ::: Leetcode problem x is recommended to novices",
            "Hard(x) ::: Leetcode problem x is hard",
            "Starred(x) ::: Leetcode problem x is starred by more than 1 thousand users"
        ],
        "premises-FOL": [
            "∀x (Easy(x) → LowerAC(x)) ::: If a Leetcode problem x is at the easy level, then its AC rate is lower than 20 percent.",
            "∀x (Recommended(x) → Easy(x)) ::: All Leetcode problems x that are recommended to novices are easy.",
            "∀x (Easy(x) ⊕ Hard(x)) ::: A Leetode problem x is either easy or hard.",
            "∀x (Starred(x) → Hard(x)) ::: Leetcode problems x that are starred by more than 1 thousand users are hard.",
            "Recommended(twosum) ::: 2Sum is recommended to novices.",
            "Starred(foursum) ::: 4Sum is starred by more than 1 thousand users."
        ]
    },
    {
        "premises-NL": [
            "All rental cars cost the renter money.",
            "Whenever Sarah goes to Vermont, Sarah drives there.",
            "For someone who does not own a car to drive somewhere, they must either borrow a car or rent a car.",
            "Sarah doesn’t own a car.",
            "Sarah never borrows a car to go camping.",
            "Sarah is going to go camping in Vermont this weekend.",
            "To go camping somewhere, you must go to that place."
        ],
        "predicates": [
            "Rent(x, car) ::: x rents a car",
            "Spend(x, money) ::: x spends money",
            "GoesTo(x, y) ::: x goes to y",
            "DriveTo(x, y) ::: x drives to y",
            "Own(x, car) ::: x owns a car",
            "Borrow(x, car) ::: x borrows a car",
            "Camping(x, y) ::: x goes camping in y"
        ],
        "premises-FOL": [
            "∀x (Rent(x, car) → Spend(x, money)) ::: All rental cars cost the renter money.",
            "GoesTo(sarah, vermont) → DriveTo(sarah, vermont) ::: Whenever Sarah goes to Vermont, Sarah drives there.",
            "∀x ∀y (¬Own(x, car) ∧ DriveTo(x, y) → Borrow(x, car) ∨ Rent(x, car)) ::: For someone who does not own a car to drive somewhere, they must either borrow a car or rent a car.",
            "¬Own(sarah, car) ::: Sarah doesn’t own a car.",
            "∀x (Camping(sarah, x) → ¬(Borrow(sarah, car))) ::: Sarah never borrows a car to go camping.",
            "Camping(sarah, vermont) ::: Sarah is going to go camping in Vermont this weekend.",
            "∀x ∀y (Camping(x, y) → GoesTo(x, y)) ::: To go camping somewhere, you must go to that place."
        ]
    },
    {
        "premises-NL": [
            "All Republicans are anti-abortion.",
            "Either Republicans or Democrats. ",
            "No Democrats are conservative.",
            "Either conservative or liberal. ",
            "A U.S government official is either conservative or a Republican."
        ],
        "predicates": [
            "Republicans(x) ::: x is a Republican",
            "Anti-abortion(x) ::: x is anti-abortion",
            "Democrats(x) ::: x is a Democrat",
            "Conservative(x) ::: x is conservative",
            "Liberal(x) ::: x is liberal",
            "USGovernmentOfficial(x) ::: x is a U.S. government official"
        ],
        "premises-FOL": [
            "∀x (Republicans(x) → Anti-abortion(x)) ::: All Republicans are anti-abortion.",
            "∀x (Republicans(x) ∨ Democrats(x)) ::: Everyone is either a Republican or a Democrat.",
            "∀x (Democrats(x) → ¬Conservative(x)) ::: No Democrats are conservative.",
            "∀x (Conservative(x) ∨ Liberal(x)) ::: Everyone is either conservative or liberal.",
            "∃x (USGovernmentOfficial(x) ∧ (Conservative(x) ∨ Republicans(x))) ::: A U.S government official is either conservative or a Republican."
        ]
    },
    {
        "premises-NL": [
            "All advocates of high tariff rates are Republicans.",
            "Some Republicans are not conservatives."
        ],
        "predicates": [
            "AdvocateOfHighTariff(x) ::: x is an advocate of high tariff",
            "Republican(x) ::: x is a republican",
            "Conservative(x) ::: x is a conservative"
        ],
        "premises-FOL": [
            "∀x (AdvocateOfHighTariff(x) → Republican(x)) ::: All advocates of high tariff rates are republicans.",
            "∃x (Republican(x) ∧ ¬Conservative(x)) ::: Some republicans are not conservatives."
        ]
    },
    {
        "premises-NL": [
            "No athletes are slow runners. ",
            "All professional basketball players are athletes. ",
            "All NBA players are professional basketball players. ",
            "All Knicks players are NBA players. ",
            "Jim is either not a professional basketball player or not a slow runner. "
        ],
        "predicates": [
            "Athlete(x) ::: x is an athlete",
            "SlowRunner(x) ::: x is a slow runner",
            "ProfessionalBasketballPlayer(x) ::: x is a professional basketball player",
            "NBAPlayer(x) ::: x is an NBA player",
            "KnicksPlayer(x) ::: x is a Knicks player"
        ],
        "premises-FOL": [
            "∀x (Athlete(x) → ¬SlowRunner(x)) ::: No athletes are slow runners.",
            "∀x (ProfessionalBasketballPlayer(x) → Athlete(x)) ::: All professional basketball players are athletes.",
            "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x)) ::: All NBA players are professional basketball players.",
            "∀x (KnicksPlayer(x) → NBAPlayer(x)) ::: All Knicks players are NBA players.",
            "¬ProfessionalBasketballPlayer(jim) ∨ ¬SlowRunner(jim) ::: Jim is either not a professional basketball player or not a slow runner."
        ]
    },
    {
        "premises-NL": [
            "All kids love animals.",
            "All toddlers are kids.",
            "If someone loves animals, then they are not bad.",
            "All pirates are bad.",
            "If Nancy is not a pirate, then Nancy loves animals.",
            "If Nancy is not a toddler, then Nancy is bad."
        ],
        "predicates": [
            "Kid(x) ::: x is a kid",
            "LoveAnimals(x) ::: x loves animals",
            "Toddler(x) ::: x is a toddler",
            "Bad(x) ::: x is bad",
            "Pirate(x) ::: x is a pirate"
        ],
        "premises-FOL": [
            "∀x (Kid(x) → LoveAnimals(x)) ::: All kids love animals.",
            "∀x (Toddler(x) → Kid(x)) ::: All toddlers are kids.",
            "∀x (LoveAnimals(x) → ¬Bad(x)) ::: If someone loves animals, then they are not bad.",
            "∀x (Pirate(x) → Bad(x)) ::: All pirates are bad.",
            "¬Pirate(nancy) → LoveAnimals(nancy) ::: If Nancy is not a pirate, then Nancy loves animals.",
            "¬Toddler(nancy) → Bad(nancy) ::: If Nancy is not a toddler, then Nancy is bad."
        ]
    },
    {
        "premises-NL": [
            "All bears in zoos are not wild. ",
            "Some bears are in zoos. "
        ],
        "predicates": [
            "Bear(x) ::: x is a bear",
            "InZoo(x) ::: x is in a zoo",
            "Wild(x) ::: x is wild"
        ],
        "premises-FOL": [
            "∀x ((Bear(x) ∧ InZoo(x)) → ¬Wild(x)) ::: All bears in zoos are not wild.",
            "∃x (Bear(x) ∧ InZoo(x)) ::: Some bears are in zoos."
        ]
    },
    {
        "premises-NL": [
            "If a person is the leader of a country for life, that person is in a monarchy. ",
            "Leaders are either a king or a queen.",
            "Queens are female.",
            "Kings are male. ",
            "Elizabeth is a queen.",
            "Elizabeth is a leader"
        ],
        "predicates": [
            "Leader(x) ::: x is a leader",
            "InMonarchy(x) ::: x is in a monarchy",
            "King(x) ::: x is a king",
            "Queen(x) ::: x is a queen",
            "Female(x) ::: x is female",
            "Male(x) ::: x is male"
        ],
        "premises-FOL": [
            "∀x (Leader(x) → InMonarchy(x)) ::: If x is a leader, then x is in a monarchy.",
            "∀x (Leader(x) → (King(x) ∨ Queen(x))) ::: If x is a leader, then x is a king or x is a queen.",
            "∀x (Queen(x) → Female(x)) ::: If x is a queen, then x is female.",
            "∀x (King(x) → Male(x)) ::: If x is a king, then x is male.",
            "Queen(elizabeth) ::: Elizabeth is a queen.",
            "Leader(elizabeth) ::: Elizabeth is a leader."
        ]
    },
    {
        "premises-NL": [
            "If people make their own matcha teas every morning with ceremonial-grade matcha powder, then they do not wake up late and start their schedules past noon regularly.",
            "If people live in California and attend yoga classes regularly, then they make their own matcha teas every morning with ceremonial-grade matcha powder.",
            "If people work in the entertainment industry as high-profile celebrities, then they wake up late and start their schedules past noon regularly.",
            "If people do not have regular 9-5 jobs, then they work in the entertainment industry as high-profile celebrities.",
            "All people who prefer working at home over going to the office every day do not have regular 9-5 jobs.",
            "Clay either both prefers to work at home over going to the office every day and makes his own matcha teas every morning with ceremonial-grade matcha powder, or he neither prefers to work at home over going to the office every day nor makes his own matcha teas every morning with ceremonial-grade matcha powder."
        ],
        "predicates": [
            "Matcha(x) ::: x makes their own matcha teas every morning with ceremonial-grade matcha powder",
            "Late(x) ::: x wakes up late and starts their schedules past noon regularly",
            "California(x) ::: x lives in California and attends yoga classes regularly",
            "Celebrities(x) ::: x works in the entertainment industry as high-profile celebrities",
            "Jobs(x) ::: x does not have regular 9-5 jobs",
            "WorkHome(x) ::: x prefers working at home over going to the office every day"
        ],
        "premises-FOL": [
            "∀x (Matcha(x) → ¬Late(x)) ::: If people make their own matcha teas every morning with ceremonial-grade matcha powder, then they do not wake up late and start their schedules past noon regularly.",
            "∀x (California(x) → Matcha(x)) ::: If people live in California and attend yoga classes regularly, then they make their own matcha teas every morning with ceremonial-grade matcha powder.",
            "∀x (Celebrities(x) → Late(x)) ::: If people work in the entertainment industry as high-profile celebrities, then they wake up late and start their schedules past noon regularly.",
            "∀x (Jobs(x) → Celebrities(x)) ::: If people do not have regular 9-5 jobs, then they work in the entertainment industry as high-profile celebrities.",
            "∀x (WorkHome(x) → Jobs(x)) ::: All people who prefer working at home over going to the office every day do not have regular 9-5 jobs.",
            "(WorkHome(clay) ∧ Matcha(clay)) ⊕ (¬WorkHome(clay) ∧ ¬Matcha(clay)) ::: Clay either both prefers to work at home over going to the office every day and makes his own matcha teas every morning with ceremonial-grade matcha powder, or he neither prefers to work at home over going to the office every day nor makes his own matcha teas every morning with ceremonial-grade matcha powder."
        ]
    },
    {
        "premises-NL": [
            "Thomas Barber was an English professional footballer.",
            "Thomas Barber played in the Football League for Aston Villa.",
            "Thomas Barber played as a half back and inside left.",
            "Thomas Barber scored the winning goal in the 1913 FA Cup Final."
        ],
        "predicates": [
            "English(x) ::: x is English",
            "ProfessionalFootballer(x) ::: x is a professional footballer",
            "PlayedInTheFootballLeagueFor(x, y) ::: x played in the Football League for y",
            "PlayedAs(x, y) ::: x played as y",
            "ScoredTheWinningGoalIn(x, y) ::: x scored the winning goal in y"
        ],
        "premises-FOL": [
            "English(thomasBarber) ∧ ProfessionalFootballer(thomasBarber) ::: Thomas Barber was an English professional footballer.",
            "PlayedInTheFootballLeagueFor(thomasBarber, astonVilla) ::: Thomas Barber played in the Football League for Aston Villa.",
            "PlayedAs(thomasBarber, aHalfBack) ∧ PlayedAs(thomasBarber, anInsideLeft) ::: Thomas Barber played as a half back and inside left.",
            "ScoredTheWinningGoalIn(thomasBarber, facupfinal1913) ::: Thomas Barber scored the winning goal in the 1913 FA Cup Final."
        ]
    },
    {
        "premises-NL": [
            "If people play the instrument in the concert, then he is good at playing this kind of instrument.",
            "Peter plays piano, violin, and saxophone.",
            "Peter was invited to play piano at the concert hall.",
            "Oliver and Peter were both invited to perform in the concert.",
            "Oliver plays a different musical instrument from Peter in the concert."
        ],
        "predicates": [
            "PlayInConcert(x, y) ::: x plays y in the concert",
            "GoodAt(x, y) ::: x is good at playing y",
            "Play(x, y) ::: x plays y",
            "PlayerInConcert(x) ::: x is a player in the concert"
        ],
        "premises-FOL": [
            "∀x (∀y (PlayInConcert(x, y) → GoodAt(x, y))) ::: If x plays y in the concert, then x is good at playing y",
            "Play(peter, piano) ∧ Play(peter, violin) ∧ Play(peter, saxophone) ::: Peter plays piano, violin, and saxophone",
            "PlayInConcert(peter, piano) ::: Peter plays piano in the concert",
            "PlayerInConcert(oliver) ∧ PlayerInConcert(peter) ::: Oliver and Peter were both invited to perform in the concert",
            "∃x (Play(oliver, x) ∧ ¬Play(peter, x) ∧ PlayInConcert(oliver, x) ∧ PlayInConcert(peter, y)) ::: Oliver plays a different musical instrument from Peter in the concert"
        ]
    },
    {
        "premises-NL": [
            "If something can go underwater, then it enjoys water.",
            "All animals that can swim can go underwater.",
            "Either an animal can swim or it can walk.",
            "Animals that can walk travel on land.",
            "Animals that enjoy water splash water around.",
            "Every animal that travels on land enjoys basking in the sun.",
            "George splashes water around and can swim.",
            "Liam is either an animal that can walk and enjoys water, or is neither an animal that can walk nor enjoys water."
        ],
        "predicates": [
            "GoesUnderwater(x) ::: x can go underwater",
            "EnjoysWater(x) ::: x enjoys water",
            "CanSwim(x) ::: x can swim",
            "CanWalk(x) ::: x can walk",
            "TravelsOnLand(x) ::: x travels on land",
            "Splashes(x) ::: x splashes water around",
            "EnjoysBasking(x) ::: x enjoys basking in the sun"
        ],
        "premises-FOL": [
            "∀x (GoesUnderwater(x) → EnjoysWater(x)) ::: If something can go underwater, then it enjoys water.",
            "∀x (CanSwim(x) → GoesUnderwater(x)) ::: All animals that can swim can go underwater.",
            "∀x (CanSwim(x) ∨ CanWalk(x)) ::: Either an animal can swim or it can walk.",
            "∀x (CanWalk(x) → TravelsOnLand(x)) ::: Animals that can walk travel on land.",
            "∀x (EnjoysWater(x) → Splashes(x)) ::: Animals that enjoy water splash water around.",
            "∀x (TravelsOnLand(x) → EnjoysBasking(x)) ::: Every animal that travels on land enjoys basking in the sun.",
            "Splashes(george) ∧ CanSwim(george) ::: George splashes water around and can swim.",
            "(CanWalk(liam) ∧ EnjoysWater(liam)) ∨ (¬CanWalk(liam) ∧ ¬EnjoysWater(liam)) ::: Liam is either an animal that can walk and enjoys water, or is neither an animal that can walk nor enjoys water."
        ]
    },
    {
        "premises-NL": [
            "Cancer biology is finding genetic alterations that confer selective advantage to cancer cells. ",
            "Cancer researchers have frequently ranked the importance of substitutions to cancer growth by P value.",
            "P values are thresholds for belief, not metrics of effect. "
        ],
        "predicates": [
            "FindingGeneticAlterationsConferSelectiveAdvantageTo(x, y) ::: x finds genetic alterations that confer selective advantage to y",
            "RankedTheImportanceOfSubstitutionsToGrowthBy(x, y, z) ::: x ranked the importance of substitutions to growth by y using z",
            "PValue(x) ::: x is a P value",
            "ThresholdsForBelief(x) ::: x is a threshold for belief",
            "MetricsOfEffect(x) ::: x is a metric of effect"
        ],
        "premises-FOL": [
            "FindingGeneticAlterationsConferSelectiveAdvantageTo(cancerBiology, cancerCells) ::: Cancer biology is finding genetic alterations that confer selective advantage to cancer cells.",
            "RankedTheImportanceOfSubstitutionsToGrowthBy(cancerResearchers, theImportanceOfSubstitutionsToCancerGrowth, PValue) ::: Cancer researchers have frequently ranked the importance of substitutions to cancer growth by P value.",
            "∀x (PValue(x) → ThresholdsForBelief(x) ∧ ¬MetricsOfEffect(x)) ::: P values are thresholds for belief, not metrics of effect."
        ]
    },
    {
        "premises-NL": [
            "All dispensable things are environment-friendly. ",
            "All woodware is dispensable.",
            "All paper is woodware. ",
            "No good things are bad. ",
            "All environment-friendly things are good.",
            "A worksheet is either paper or is environment-friendly."
        ],
        "predicates": [
            "Dispensable(x) ::: x is dispensable",
            "EnvironmentFriendly(x) ::: x is environment-friendly",
            "Woodware(x) ::: x is woodware",
            "Paper(x) ::: x is paper",
            "Good(x) ::: x is good",
            "Bad(x) ::: x is bad"
        ],
        "premises-FOL": [
            "∀x (Dispensable(x) → EnvironmentFriendly(x)) ::: All dispensable things are environment-friendly.",
            "∀x (Woodware(x) → Dispensable(x)) ::: All woodware is dispensable.",
            "∀x (Paper(x) → Woodware(x)) ::: All paper is woodware.",
            "∀x (Good(x) → ¬Bad(x)) ::: No good things are bad.",
            "∀x (EnvironmentFriendly(x) → Good(x)) ::: All environment-friendly things are good.",
            "Paper(worksheet) ⊕ EnvironmentFriendly(worksheet) ::: A worksheet is either paper or is environment-friendly."
        ]
    },
    {
        "premises-NL": [
            "No reptile has fur.",
            "All snakes are reptiles."
        ],
        "predicates": [
            "Reptile(x) ::: x is a reptile",
            "HasFur(x) ::: x has fur",
            "Snake(x) ::: x is a snake"
        ],
        "premises-FOL": [
            "∀x (Reptile(x) → ¬HasFur(x)) ::: No reptile has fur.",
            "∀x (Snake(x) → Reptile(x)) ::: All snakes are reptiles."
        ]
    },
    {
        "premises-NL": [
            "All buildings in New Haven are low. ",
            "All buildings managed by the Yale Housing are located in New Haven. ",
            "All buildings in Manhattans are high. ",
            "All buildings owned by Bloomberg are located in Manhattans. ",
            "All buildings with the Bloomberg logo are owned by Bloomberg. ",
            "Tower A is managed by the Yale Housing.",
            "Tower B is with the Bloomberg logo."
        ],
        "predicates": [
            "Located(x, y) ::: x is located in y",
            "High(x) ::: x is high",
            "YaleHousing(x) ::: x is managed by the Yale Housing",
            "Bloomberg(x) ::: x is owned by Bloomberg",
            "BloombergLogo(x) ::: x has the Bloomberg logo"
        ],
        "premises-FOL": [
            "∀x (Located(x, newhaven) → ¬High(x)) ::: All buildings in New Haven are low.",
            "∀x (YaleHousing(x) → Located(x, newhaven)) ::: All buildings managed by the Yale Housing are located in New Haven.",
            "∀x (Located(x, manhattans) → High(x)) ::: All buildings in Manhattans are high.",
            "∀x (Bloomberg(x) → Located(x, manhattans)) ::: All buildings owned by Bloomberg are located in Manhattans.",
            "∀x (BloombergLogo(x) → Bloomberg(x)) ::: All buildings with the Bloomberg logo are owned by Bloomberg.",
            "YaleHousing(tower-a) ::: Tower A is managed by the Yale Housing.",
            "BloombergLogo(tower-b) ::: Tower B is with the Bloomberg logo."
        ]
    },
    {
        "premises-NL": [
            "No cold-blooded animals are birds.",
            "All reptiles are cold-blooded.",
            "Either an animal is a bird or it eats other animals.",
            "If an animal eats other animals, then it is a carnivore.",
            "Ron is neither a cold-blooded animal nor a carnivore.",
            "Henry is neither a carnivore nor a lizard."
        ],
        "predicates": [
            "ColdBlooded(x) ::: x is cold-blooded",
            "Bird(x) ::: x is a bird",
            "Reptile(x) ::: x is a reptile",
            "EatOtherAnimals(x) ::: x eats other animals",
            "Carnivore(x) ::: x is a carnivore",
            "Lizard(x) ::: x is a lizard"
        ],
        "premises-FOL": [
            "∀x (ColdBlooded(x) → ¬Bird(x)) ::: No cold-blooded animals are birds.",
            "∀x (Reptile(x) → ColdBlooded(x)) ::: All reptiles are cold-blooded.",
            "∀x (Bird(x) ∨ EatOtherAnimals(x)) ::: Either an animal is a bird or it eats other animals.",
            "∀x (EatOtherAnimals(x) → Carnivore(x)) ::: If an animal eats other animals, then it is a carnivore.",
            "¬ColdBlooded(ron) ∧ ¬Carnivore(ron) ::: Ron is neither a cold-blooded animal nor a carnivore.",
            "¬Carnivore(henry) ∧ ¬Lizard(henry) ::: Henry is neither a carnivore nor a lizard."
        ]
    },
    {
        "premises-NL": [
            "Ambiortus is a prehistoric bird genus.",
            "Ambiorus Dementjevi is the only known species of Ambiortus.",
            "The Mongol region was where Ambiorus Dementjevi lived.",
            "Yevgeny Kurochkin was the discoverer of Ambiortus."
        ],
        "predicates": [
            "Prehistoric(x) ::: x is prehistoric",
            "BirdGenus(x) ::: x is a bird genus",
            "Species(x, y) ::: x is a species of y",
            "AmbiortusDementjevi(x) ::: x is Ambiorus Dementjevi",
            "Lived(x, y) ::: x lived in y",
            "Discovered(x, y) ::: x discovered y"
        ],
        "premises-FOL": [
            "Prehistoric(ambiortus) ∧ BirdGenus(ambiortus) ::: Ambiortus is prehistoric and a bird genus.",
            "∀x (Species(x, ambiortus) → AmbiortusDementjevi(x)) ::: For all x, if x is a species of Ambiortus, then x is Ambiorus Dementjevi.",
            "∀x (AmbiortusDementjevi(x) → Lived(x, mongolregion)) ::: For all x, if x is Ambiorus Dementjevi, then x lived in the Mongol region.",
            "Discovered(yevgenykurochkin, ambiortus) ::: Yevgeny Kurochkin discovered Ambiortus."
        ]
    },
    {
        "premises-NL": [
            "Everyone that uses a football can throw a football.",
            "If someone plays football, then they use a football.",
            "Either someone is a football player or a basketball player.",
            "Every basketball player is tall.",
            "Everyone that can throw a football can throw a football with a spiral.",
            "If someone is tall, then they are in shape.",
            "If Jack is neither tall nor a basketball player,  then Jack is neither tall nor can throw a football."
        ],
        "predicates": [
            "UseFootball(x) ::: x uses a football",
            "ThrowFootball(x) ::: x can throw a football",
            "PlayFootball(x) ::: x plays football",
            "BasketballPlayer(x) ::: x is a basketball player",
            "Tall(x) ::: x is tall",
            "ThrowFootballSpiral(x) ::: x can throw a football with a spiral",
            "InShape(x) ::: x is in shape"
        ],
        "premises-FOL": [
            "∀x (UseFootball(x) → ThrowFootball(x)) ::: Everyone that uses a football can throw a football.",
            "∀x (PlayFootball(x) → UseFootball(x)) ::: If someone plays football, then they use a football.",
            "∀x (PlayFootball(x) ∨ BasketballPlayer(x)) ::: Either someone is a football player or a basketball player.",
            "∀x (BasketballPlayer(x) → Tall(x)) ::: Every basketball player is tall.",
            "∀x (ThrowFootball(x) → ThrowFootballSpiral(x)) ::: Everyone that can throw a football can throw a football with a spiral.",
            "∀x (Tall(x) → InShape(x)) ::: If someone is tall, then they are in shape.",
            "¬Tall(jack) ∧ ¬BasketballPlayer(jack) → ¬Tall(jack) ∧ ¬ThrowFootball(jack) ::: If Jack is neither tall nor a basketball player, then Jack is neither tall nor can throw a football."
        ]
    },
    {
        "premises-NL": [
            "Fort Ticonderoga is the current name for Fort Carillon.",
            "Pierre de Rigaud de Vaudreuil built Fort Carillon.",
            "Fort Carillon was located in New France.",
            "New France is not in Europe."
        ],
        "predicates": [
            "CurrentName(x, y) ::: x is the current name for y",
            "Built(x, y) ::: x built y",
            "LocatedIn(x, y) ::: x is located in y"
        ],
        "premises-FOL": [
            "CurrentName(fortticonderoga, fortcarillon) ::: Fort Ticonderoga is the current name for Fort Carillon",
            "Built(pierrederigauddevaudreuil, fortcarillon) ::: Pierre de Rigaud de Vaudreuil built Fort Carillon",
            "LocatedIn(fortcarillon, newfrance) ::: Fort Carillon was located in New France",
            "¬LocatedIn(newfrance, europe) ::: New France is not in Europe"
        ]
    },
    {
        "premises-NL": [
            "No soccer players are professional basketball players.",
            "All NBA players are professional basketball players.",
            "All defenders are soccer players.",
            "All centerback players are defenders.",
            "If Stephen Curry is an NBA player or a soccer player, then he is a professional basketball player."
        ],
        "predicates": [
            "SoccerPlayer(x) ::: x is a soccer player",
            "ProfessionalBasketballPlayer(x) ::: x is a professional basketball player",
            "NBAPlayer(x) ::: x is an NBA player",
            "Defender(x) ::: x is a defender",
            "Centerback(x) ::: x is a centerback"
        ],
        "premises-FOL": [
            "¬(∃x (SoccerPlayer(x) ∧ ProfessionalBasketballPlayer(x))) ::: No soccer players are professional basketball players.",
            "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x)) ::: All NBA players are professional basketball players.",
            "∀x (Defender(x) → SoccerPlayer(x)) ::: All defenders are soccer players.",
            "∀x (Centerback(x) → Defender(x)) ::: All centerback players are defenders.",
            "(NBAPlayer(stephencurry) ∨ SoccerPlayer(stephencurry)) → ProfessionalBasketballPlayer(stephencurry) ::: If Stephen Curry is an NBA player or a soccer player, then he is a professional basketball player."
        ]
    },
    {
        "premises-NL": [
            "No songs are visual. ",
            "All folk songs are songs. ",
            "All videos are visual. ",
            "All movies are videos.",
            "All sci-fi movies are movies.",
            "Inception is a sci-fi movie.",
            "Mac is neither a folk song nor a sci-fi movie."
        ],
        "predicates": [
            "Song(x) ::: x is a song",
            "Visual(x) ::: x is visual",
            "FolkSong(x) ::: x is a folk song",
            "Video(x) ::: x is a video",
            "Movie(x) ::: x is a movie",
            "ScifiMovie(x) ::: x is a sci-fi movie",
            "Name(x, y) ::: the name of x is y"
        ],
        "premises-FOL": [
            "∀x (Song(x) → ¬Visual(x)) ::: No songs are visual.",
            "∀x (FolkSong(x) → Song(x)) ::: All folk songs are songs.",
            "∀x (Video(x) → Visual(x)) ::: All videos are visual.",
            "∀x (Movie(x) → Video(x)) ::: All movies are videos.",
            "∀x (ScifiMovie(x) → Movie(x)) ::: All sci-fi movies are movies.",
            "ScifiMovie(inception) ::: Inception is a sci-fi movie.",
            "¬FolkSong(mac) ∧ ¬ScifiMovie(mac) ::: Mac is neither a folk song nor a sci-fi movie."
        ]
    },
    {
        "premises-NL": [
            "All extroverts are overtly expressive.",
            "People are either extroverts or introverts.",
            "If someone is an introvert, then they are shy and reticent. ",
            "No shy and reticent person likes to talk to strangers.",
            "Jeff is not an extrovert and someone who likes to talk to strangers."
        ],
        "predicates": [
            "Extroverts(x) ::: x is an extrovert",
            "OvertlyExpressive(x) ::: x is overtly expressive",
            "Introverts(x) ::: x is an introvert",
            "ShyAndReticentPerson(x) ::: x is a shy and reticent person",
            "LikeToTalkToStrangers(x) ::: x likes to talk to strangers"
        ],
        "premises-FOL": [
            "∀x (Extroverts(x) → OvertlyExpressive(x)) ::: All extroverts are overtly expressive.",
            "∀x (Extroverts(x) ∨ Introverts(x)) ::: People are either extroverts or introverts.",
            "∀x (Introverts(x) → ShyAndReticentPerson(x)) ::: If someone is an introvert, then they are shy and reticent.",
            "∀x (ShyAndReticentPerson(x) → ¬LikeToTalkToStrangers(x)) ::: No shy and reticent person likes to talk to strangers.",
            "¬Extroverts(jeff) ∧ LikeToTalkToStrangers(jeff) ::: Jeff is not an extrovert and likes to talk to strangers."
        ]
    },
    {
        "premises-NL": [
            "No low-scoring players are top players in the league.",
            "Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
            "All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
            "No players who are solid at shooting 2-pointers are bad at mid-range shots.",
            "Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers."
        ],
        "predicates": [
            "LowScore(x) ::: x is a low-scoring player",
            "TopPlayer(x) ::: x is a top player in the league",
            "ThreePointer(x) ::: x successfully shoots a high percentage of 3-pointers",
            "TwoPointer(x) ::: x is solid at shooting 2-pointers",
            "BadMid(x) ::: x is bad at mid-range shots"
        ],
        "premises-FOL": [
            "∀x (LowScore(x) → ¬TopPlayer(x)) ::: No low-scoring players are top players in the league.",
            "∀x (BasketballPlayer(x) → (TopPlayer(x) ∨ ThreePointer(x))) ::: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
            "∀x (ThreePointer(x) → TwoPointer(x)) ::: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
            "∀x (TwoPointer(x) → ¬BadMid(x)) ::: No players who are solid at shooting 2-pointers are bad at mid-range shots.",
            "LowScore(candace) ∨ ThreePointer(candace) ::: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers."
        ]
    },
    {
        "premises-NL": [
            "No plants are fungi.",
            "Mushrooms are fungi."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "Fungi(x) ::: x is a fungus",
            "Mushroom(x) ::: x is a mushroom"
        ],
        "premises-FOL": [
            "∀x (Plant(x) → ¬Fungi(x)) ::: No plants are fungi",
            "∀x (Mushroom(x) → Fungi(x)) ::: Mushrooms are fungi"
        ]
    },
    {
        "premises-NL": [
            "No road is clean.",
            "And some streets are roads."
        ],
        "predicates": [
            "Road(x) ::: x is a road",
            "Clean(x) ::: x is clean",
            "Street(x) ::: x is a street"
        ],
        "premises-FOL": [
            "∀x (Road(x) → ¬Clean(x)) ::: No road is clean.",
            "∃x (Street(x) ∧ Road(x)) ::: And some streets are roads."
        ]
    },
    {
        "premises-NL": [
            "New York City is on the East Coast. ",
            "Seattle is on the West Coast. ",
            "If a person from a city on the East coast is traveling to a city on the west coast, they will be on a long flight.",
            "Most passengers on flights to Seattle from New York City are not in first class.",
            "People on long flights are uncomfortable unless they're in first class"
        ],
        "predicates": [
            "On(x, y) ::: x is on y",
            "TravelingFrom(x, y) ::: x is traveling from y",
            "TravelingTo(x, y) ::: x is traveling to y",
            "OnLongFlight(x) ::: x is on a long flight",
            "InFirstClass(x) ::: x is in first class",
            "Uncomfortable(x) ::: x is uncomfortable"
        ],
        "premises-FOL": [
            "On(newyorkcity, eastcoast) ::: New York City is on the East Coast.",
            "On(seattle, westcoast) ::: Seattle is on the West Coast.",
            "∀x ∀y ∀z ((TravelingFrom(x, y) ∧ On(y, eastcoast) ∧ TravelingTo(x, z) ∧ On(z, westcoast)) → OnLongFlight(x)) ::: If a person from a city on the East coast is traveling to a city on the west coast, they will be on a long flight.",
            "∃x (¬InFirstClass(x) ∧ TravelingFrom(x, newyorkcity) ∧ TravelingTo(x, seattle)) ::: Most passengers on flights to Seattle from New York City are not in first class.",
            "∀x (OnLongFlight(x) ∧ ¬InFirstClass(x) → Uncomfortable(x)) ::: People on long flights are uncomfortable unless they're in first class"
        ]
    },
    {
        "premises-NL": [
            "Musicians have very busy lives.",
            "Singh Kaur is a musician and famous.",
            "If a musician is not famous, that musician will not make a lot of money.",
            "A musician can be a singer or a writer."
        ],
        "predicates": [
            "Musician(x) ::: x is a musician",
            "Busy(x) ::: x has a very busy life",
            "Famous(x) ::: x is famous",
            "MakeMoney(x) ::: x makes a lot of money",
            "Singer(x) ::: x is a singer",
            "Writer(x) ::: x is a writer"
        ],
        "premises-FOL": [
            "∀x (Musician(x) → Busy(x)) ::: All musicians have very busy lives.",
            "Musician(singhKaur) ∧ Famous(singhKaur) ::: Singh Kaur is a musician and famous.",
            "∀x (Musician(x) ∧ ¬Famous(x) → ¬MakeMoney(x)) ::: If a musician is not famous, that musician will not make a lot of money.",
            "∀x (Musician(x) → Singer(x) ∨ Writer(x)) ::: A musician can be a singer or a writer."
        ]
    },
    {
        "premises-NL": [
            "Each building is tall. ",
            "Everything tall has  height."
        ],
        "predicates": [
            "Building(x) ::: x is a building",
            "Tall(x) ::: x is tall",
            "HasHeight(x) ::: x has height"
        ],
        "premises-FOL": [
            "∀x (Building(x) → Tall(x)) ::: Each building is tall.",
            "∀x (Tall(x) → HasHeight(x)) ::: Everything tall has height."
        ]
    },
    {
        "premises-NL": [
            "All humans eat.",
            "If something eats, then it is not a plant.",
            "A thing is either plant or animal.",
            "All goats are animals.",
            "No dirt is an animal.",
            "Hulu is a goat or a human."
        ],
        "predicates": [
            "Human(x) ::: x is a human",
            "Eat(x) ::: x eats",
            "Plant(x) ::: x is a plant",
            "Animal(x) ::: x is an animal",
            "Goat(x) ::: x is a goat",
            "Dirt(x) ::: x is dirt"
        ],
        "premises-FOL": [
            "∀x (Human(x) → Eat(x)) ::: All humans eat.",
            "∀x (Eat(x) → ¬Plant(x)) ::: If something eats, then it is not a plant.",
            "∀x (Plant(x) ∨ Animal(x)) ::: A thing is either plant or animal.",
            "∀x (Goat(x) → Animal(x)) ::: All goats are animals.",
            "∀x (Dirt(x) → ¬Animal(x)) ::: No dirt is an animal.",
            "Goat(hulu) ∨ Human(hulu) ::: Hulu is a goat or a human."
        ]
    },
    {
        "premises-NL": [
            "A controlled substance is a drug.",
            "There exist both harmful and beneficial controlled substances.",
            "If a child is exposed to a controlled substance, he or she is in chemical endangerment.",
            "Chemical Endangerment is harmful. ",
            "The Controlled Substances Act was an act passed in 1971.",
            "Some Acts prevent harmful things."
        ],
        "predicates": [
            "ControlledSubstances(x) ::: x is a controlled substance",
            "Drugs(x) ::: x is a drug",
            "Beneficial(x) ::: x is beneficial",
            "Harmful(x) ::: x is harmful",
            "ExposedToControlledSubstance(x, y) ::: x is exposed to the controlled substance y",
            "ChemicalEndangerment(x) ::: x is in chemical endangerment",
            "PassedIn(x, y) ::: x was passed in year y",
            "Act(x) ::: x is an act",
            "PreventsHarm(x) ::: x prevents harmful things"
        ],
        "premises-FOL": [
            "∀x (ControlledSubstances(x) → Drugs(x)) ::: A controlled substance is a drug",
            "∃x ∃y (ControlledSubstances(x) ∧ ControlledSubstances(y) ∧ Beneficial(x) ∧ Harmful(y)) ::: There exist both harmful and beneficial controlled substances.",
            "∀x ∀y (ExposedToControlledSubstance(x, y) → ChemicalEndangerment(x)) ::: If a child is exposed to a controlled substance, he or she is in chemical endangerment",
            "∀x (ChemicalEndangerment(x) → Harmful(x)) ::: Chemical Endangerment is harmful",
            "PassedIn(controlledSubstancesAct, year1971) ∧ Act(controlledSubstancesAct) ::: The Controlled Substances Act was an act passed in 1971",
            "∃x (Act(x) ∧ PreventsHarm(x)) ::: Some Acts prevent harmful things"
        ]
    },
    {
        "premises-NL": [
            "No people who work at corporate jobs are starting a new company.",
            "All entrepreneurs are starting a new company.",
            "All risk-averse people are people who work at corporate jobs.",
            "All people who hate working for others are entrepreneurs.",
            "If Mark Zuckerberg is neither an entrepreneur nor a person who hates working for others, then Mark Zuckerberg is not a risk-averse person."
        ],
        "predicates": [
            "WorkAtCorporateJobs(x) ::: x works at corporate jobs",
            "StartingANewCompany(x) ::: x is starting a new company",
            "Entrepreneurs(x) ::: x is an entrepreneur",
            "Risk-averse(x) ::: x is risk-averse",
            "HateWorkingForOthers(x) ::: x hates working for others"
        ],
        "premises-FOL": [
            "∀x (WorkAtCorporateJobs(x) → ¬StartingANewCompany(x)) ::: No people who work at corporate jobs are starting a new company.",
            "∀x (Entrepreneurs(x) → StartingANewCompany(x)) ::: All entrepreneurs are starting a new company.",
            "∀x (Risk-averse(x) → WorkAtCorporateJobs(x)) ::: All risk-averse people are people who work at corporate jobs.",
            "∀x (HateWorkingForOthers(x) → Entrepreneurs(x)) ::: All people who hate working for others are entrepreneurs.",
            "¬Entrepreneurs(markZuckerberg) ∨ ¬HateWorkingForOthers(markZuckerberg) → ¬Risk-averse(markZuckerberg) ::: If Mark Zuckerberg is neither an entrepreneur nor a person who hates working for others, then Mark Zuckerberg is not a risk-averse person."
        ]
    },
    {
        "premises-NL": [
            "There are two kitchens in the house: the upstairs kitchen and the downstairs kitchen.",
            "When someone is cooking in the downstairs kitchen, the first floor becomes smokey unless the air conditioner is running.",
            "If the air conditioner is running and someone is cooking in the downstairs kitchen, all the smoke travels to the second floor."
        ],
        "predicates": [
            "Kitchen(x) ::: x is a kitchen",
            "Up(x) ::: x is the upstairs kitchen",
            "Down(x) ::: x is the downstairs kitchen",
            "Cook(x) ::: someone is cooking in kitchen x",
            "Run(x) ::: x is running",
            "Smokey(x) ::: x becomes smokey"
        ],
        "premises-FOL": [
            "∀x (Kitchen(x) → Up(x) ⊕ Down(x)) ::: All kitchens are either upstairs or downstairs",
            "(Cook(downstairs) ∧ ¬Run(ac)) → Smokey(firstFloor) ::: if someone is cooking in the downstairs kitchen and the air conditioner is not running, then the first floor becomes smokey",
            "(Cook(downstairs) ∧ Run(ac)) → Smokey(secondFloor) ::: if someone is cooking in the downstairs kitchen and the air conditioner is running, then the second floor becomes smokey"
        ]
    },
    {
        "premises-NL": [
            "New York City is Located in the United States of America.",
            "United States of America is part of North America.",
            "North America is in the western hemisphere of the earth.",
            "New York City is a highly developed city.",
            "If place A is located in place B and place B is located in place C, then place A is located in place C."
        ],
        "predicates": [
            "Located(x, y) ::: x is located in y",
            "PartOf(x, y) ::: x is part of y",
            "In(x, y) ::: x is in y",
            "HighlyDeveloped(x) ::: x is a highly developed city"
        ],
        "premises-FOL": [
            "Located(nyc, usa) ::: New York City is located in the United States of America",
            "PartOf(usa, northAmerica) ::: United States of America is part of North America",
            "In(northAmerica, westernHemisphere) ::: North America is in the western hemisphere",
            "HighlyDeveloped(nyc) ::: New York City is a highly developed city",
            "∀x ∀y ∀z ((Located(x, y) ∧ Located(y, z)) → Located(x, z)) ::: If place A is located in place B and place B is located in place C, then place A is located in place C"
        ]
    },
    {
        "premises-NL": [
            "Callus 4 is a poem that was written by the ancient Roman writer Catullus.",
            "Callus 4 is a story about the retirement of a well-traveled ship.",
            "There is a strong analogy of human aging in the poem Callus 4.",
            "Callus 4 is written in an unusual iambic trimeter to convey a sense of speed over the waves."
        ],
        "predicates": [
            "Poem(x) ::: x is a poem",
            "WrittenBy(x, y) ::: x was written by y",
            "Roman(x) ::: x is Roman",
            "RetirementShip(x) ::: x is a story about the retirement of a ship",
            "AgingAnalogy(x) ::: there is an analogy of aging in x",
            "Lambic(x) ::: x is written in iambic trimeter",
            "Waves(x) ::: x conveys a sense of speed over the waves"
        ],
        "premises-FOL": [
            "Poem(callus4) ∧ WrittenBy(callus4, catullus) ∧ Roman(catullus) ::: Callus 4 is a poem written by the ancient Roman writer Catullus.",
            "RetirementShip(callus4) ::: Callus 4 is a story about the retirement of a well-traveled ship.",
            "Poem(callus4) → AgingAnalogy(callus4) ::: If Callus 4 is a poem, then there is a strong analogy of human aging in it.",
            "Poem(callus4) → Lambic(callus4) ∧ Waves(callus4) ::: If Callus 4 is a poem, then it is written in an unusual iambic trimeter to convey a sense of speed over the waves."
        ]
    },
    {
        "premises-NL": [
            "Xiufeng, Xiangshan, Diecai, Qixing are districts in the city of Guilin.",
            "Yangshuo is not a district in Guilin. "
        ],
        "predicates": [
            "DistrictIn(x, y) ::: x is a district in y",
            "City(x) ::: x is a city"
        ],
        "premises-FOL": [
            "DistrictIn(xiufeng, guilin) ∧ DistrictIn(xiangshan, guilin) ∧ DistrictIn(diecai, guilin) ∧ DistrictIn(qixing, guilin) ∧ City(guilin) ::: Xiufeng, Xiangshan, Diecai, Qixing are districts in the city of Guilin.",
            "¬DistrictIn(yangshuo, guilin) ::: Yangshuo is not a district in Guilin."
        ]
    },
    {
        "premises-NL": [
            "All people who grow their own fresh vegetables in their home garden also have ample space.",
            "If people are young working professionals who live in large cities, then they do not have ample space.",
            "If people order takeout from delivery services often, then they grow their own fresh vegetables in their home garden.",
            "If people enjoy going out often to restaurants with friends, then they order takeout from delivery services often.",
            "If people regularly tout the benefits of homegrown and homecooked meals over fast food, then they enjoy going out often to restaurants with friends. ",
            "Michael grows his own fresh vegetables in his home garden or regularly touts the benefits of homegrown and homecooked meals over fast food."
        ],
        "predicates": [
            "Garden(x) ::: x grows their own fresh vegetables in their home garden",
            "Space(x) ::: x has ample space",
            "Professional(x) ::: x is a young working professional who lives in large cities",
            "Takeout(x) ::: x orders takeout from delivery services often",
            "GoingOut(x) ::: x enjoys going out often to restaurants with friends",
            "Homecooked(x) ::: x regularly touts the benefits of homegrown and homecooked meals over fast food"
        ],
        "premises-FOL": [
            "∀x (Garden(x) → Space(x)) ::: All people who grow their own fresh vegetables in their home garden also have ample space.",
            "∀x (Professional(x) → ¬Space(x)) ::: If people are young working professionals who live in large cities, then they do not have ample space.",
            "∀x (Takeout(x) → Garden(x)) ::: If people order takeout from delivery services often, then they grow their own fresh vegetables in their home garden.",
            "∀x (GoingOut(x) → Takeout(x)) ::: If people enjoy going out often to restaurants with friends, then they order takeout from delivery services often.",
            "∀x (Homecooked(x) → GoingOut(x)) ::: If people regularly tout the benefits of homegrown and homecooked meals over fast food, then they enjoy going out often to restaurants with friends.",
            "Garden(michael) ∨ Homecooked(michael) ::: Michael grows his own fresh vegetables in his home garden or regularly touts the benefits of homegrown and homecooked meals over fast food."
        ]
    },
    {
        "premises-NL": [
            "All devices belonging to the company are connected to Google Home. ",
            "All devices belonging to employees are connected to the company's wifi. ",
            "All devices connected to Google Home are controlled by the managers. ",
            "All devices that connect to the company's wifi are easy to operate. ",
            "IPod1 belongs to employees. "
        ],
        "predicates": [
            "BelongTo(x, y) ::: device x belongs to y",
            "ConnectedTo(x, y) ::: device x is connected to y",
            "ControlledBy(x, y) ::: device x is controlled by y",
            "EasyToOperate(x) ::: device x is easy to operate",
            "Device(x) ::: x is a device",
            "Company(x) ::: x is a company",
            "GoogleHome(x) ::: x is Google Home",
            "Employee(x) ::: x is an employee",
            "Wifi(x) ::: x is the company's wifi",
            "Manager(x) ::: x is a manager"
        ],
        "premises-FOL": [
            "∀x (BelongTo(x, company) → ConnectedTo(x, googleHome)) ::: All devices belonging to the company are connected to Google Home.",
            "∀x (BelongTo(x, employee) → ConnectedTo(x, wifi)) ::: All devices belonging to employees are connected to the company's wifi.",
            "∀x (ConnectedTo(x, googleHome) → ControlledBy(x, managers)) ::: All devices connected to Google Home are controlled by the managers.",
            "∀x (ConnectedTo(x, wifi) → EasyToOperate(x)) ::: All devices that connect to the company's wifi are easy to operate.",
            "BelongTo(iPod1, employees) ::: IPod1 belongs to employees."
        ]
    },
    {
        "premises-NL": [
            "If someone yells, then they are not cool.",
            "If someone is angry, then they yell.",
            "If someone flies, then they are cool.",
            "Every person that knows magic can fly.",
            "All wizards know magic.",
            "Harry either yells and flies, or neither yells nor flies.",
            "Potter is a wizard and flies."
        ],
        "predicates": [
            "Yell(x) ::: x yells",
            "Cool(x) ::: x is cool",
            "Angry(x) ::: x is angry",
            "Fly(x) ::: x flies",
            "KnowMagic(x) ::: x knows magic",
            "Wizard(x) ::: x is a wizard"
        ],
        "premises-FOL": [
            "∀x (Yell(x) → ¬Cool(x)) ::: If someone yells, then they are not cool.",
            "∀x (Angry(x) → Yell(x)) ::: If someone is angry, then they yell.",
            "∀x (Fly(x) → Cool(x)) ::: If someone flies, then they are cool.",
            "∀x (KnowMagic(x) → Fly(x)) ::: Every person that knows magic can fly.",
            "∀x (Wizard(x) → KnowMagic(x)) ::: All wizards know magic.",
            "(Yell(harry) ∧ Fly(harry)) ⊕ (¬Yell(harry) ∧ ¬Fly(harry)) ::: Harry either yells and flies, or neither yells nor flies.",
            "Wizard(potter) ∧ Fly(potter) ::: Potter is a wizard and flies."
        ]
    },
    {
        "premises-NL": [
            "Products are either produced in China or the US. ",
            "All produced in China are labeled. ",
            "All produced in the US are sold in the US. ",
            "If labeled, then the product is cheaper. ",
            "All sold in the US are sold in Walmart. ",
            "All displayed on the homepage are sold in Walmart. ",
            "No products returned by customers are sold in Walmart. ",
            "G-910 is either displayed on the homepage or cheaper."
        ],
        "predicates": [
            "Product(x) ::: x is a product",
            "ProducedIn(x, y) ::: product x is produced in country y",
            "China(x) ::: x is produced in China",
            "US(x) ::: x is produced in the US",
            "Labeled(x) ::: x is labeled",
            "SoldIn(x, y) ::: x is sold in y",
            "SoldInUS(x) ::: x is sold in the US",
            "SoldInWalmart(x) ::: x is sold in Walmart",
            "Cheaper(x) ::: x is cheaper",
            "DisplayedInHomepage(x) ::: x is displayed on the homepage",
            "ReturnedByCustomer(x) ::: x is returned by customer"
        ],
        "premises-FOL": [
            "∀x (Product(x) → (ProducedIn(x, China) ∨ ProducedIn(x, US))) ::: All products are produced in China or US.",
            "∀x (ProducedIn(x, China) → Labeled(x)) ::: All products produced in China are labeled.",
            "∀x (ProducedIn(x, US) → SoldInUS(x)) ::: All products produced in the US are sold in the US.",
            "∀x (Labeled(x) → Cheaper(x)) ::: All labeled products are cheaper.",
            "∀x (SoldInUS(x) → SoldInWalmart(x)) ::: All products sold in the US are sold in Walmart.",
            "∀x (DisplayedInHomepage(x) → SoldInWalmart(x)) ::: All products displayed on the homepage are sold in Walmart.",
            "∀x (ReturnedByCustomer(x) → ¬SoldInWalmart(x)) ::: No products returned by customers are sold in Walmart.",
            "DisplayedInHomepage(g910) ∨ Cheaper(g910) ::: G-910 is displayed on the homepage or is cheaper."
        ]
    },
    {
        "premises-NL": [
            "People either order a lot of Amazon packages or are environmentally conscious.",
            "If people order a lot of Amazon packages, then they get a lot of daily mail delivered.",
            "If people are environmentally conscious, then they have solar panels in their homes.",
            "If people get a lot of daily mail delivered, then they are very involved with their neighborhood.",
            "If people have solar panels in their homes, then they save a lot of money.",
            "If Marcy either gets a lot of mail and is very involved with her neighborhood or if she does not order a lot of Amazon packages nor is very involved with her neighborhood, then Marcy does not both get a lot of daily mail and order a lot of Amazon packages. "
        ],
        "predicates": [
            "OrderAmazon(x) ::: x orders a lot of Amazon packages",
            "EnvironmentallyConscious(x) ::: x is environmentally conscious",
            "GetDailyMail(x) ::: x gets a lot of daily mail delivered",
            "HaveSolarPanels(x) ::: x has solar panels in their home",
            "InvolvedNeighborhood(x) ::: x is very involved with their neighborhood",
            "SaveMoney(x) ::: x saves a lot of money"
        ],
        "premises-FOL": [
            "∀x (OrderAmazon(x) ∨ EnvironmentallyConscious(x)) ::: Everyone either orders a lot of Amazon packages or is environmentally conscious",
            "∀x (OrderAmazon(x) → GetDailyMail(x)) ::: If people order a lot of Amazon packages, then they get a lot of daily mail delivered",
            "∀x (EnvironmentallyConscious(x) → HaveSolarPanels(x)) ::: If people are environmentally conscious, then they have solar panels in their homes",
            "∀x (GetDailyMail(x) → InvolvedNeighborhood(x)) ::: If people get a lot of daily mail delivered, then they are very involved with their neighborhood",
            "∀x (HaveSolarPanels(x) → SaveMoney(x)) ::: If people have solar panels in their homes, then they save a lot of money",
            "((GetDailyMail(marcy) ∧ InvolvedNeighborhood(marcy)) ∨ (¬OrderAmazon(marcy) ∧ ¬InvolvedNeighborhood(marcy))) → ¬(GetDailyMail(marcy) ∧ OrderAmazon(marcy)) ::: If Marcy either gets a lot of mail and is very involved with her neighborhood or if she does not order a lot of Amazon packages nor is very involved with her neighborhood, then Marcy does not both get a lot of daily mail and order a lot of Amazon packages"
        ]
    },
    {
        "premises-NL": [
            "No watch that is battery-powered is automatic.",
            "All digital watches are battery-powered.",
            "Some mechanical watches are automatic.",
            "All smart watches are digital.",
            "Moonwatch is not a digital watch or an automatic."
        ],
        "predicates": [
            "BatteryPoweredWatch(x) ::: x is a battery-powered watch",
            "AutomaticWatch(x) ::: x is an automatic watch",
            "DigitalWatch(x) ::: x is a digital watch",
            "MechanicalWatch(x) ::: x is a mechanical watch",
            "SmartWatch(x) ::: x is a smart watch"
        ],
        "premises-FOL": [
            "∀x (BatteryPoweredWatch(x) → ¬AutomaticWatch(x)) ::: No watch that is battery-powered is automatic.",
            "∀x (DigitalWatch(x) → BatteryPoweredWatch(x)) ::: All digital watches are battery-powered.",
            "∃x (MechanicalWatch(x) ∧ AutomaticWatch(x)) ::: Some mechanical watches are automatic.",
            "∀x (SmartWatch(x) → DigitalWatch(x)) ::: All smart watches are digital.",
            "¬DigitalWatch(moonwatch) ∧ ¬AutomaticWatch(moonwatch) ::: Moonwatch is not a digital watch or an automatic."
        ]
    },
    {
        "premises-NL": [
            "If a person can distinguish the taste of different condiments, then he/she can also use different condiments to cook.",
            "People who have the talent of cooking can distinguish the taste of different condiments.",
            "Only people with the talent of cooking can make delicious meals.",
            "If the meal is popular at the party, then it is delicious.",
            "John can make meals which are popular at the party."
        ],
        "predicates": [
            "People(x) ::: x is a person",
            "DistinguishCondiments(x) ::: x can distinguish the taste of different condiments",
            "UseDiffCondiments(x) ::: x can use different condiments to cook",
            "TalentCooking(x) ::: x has the talent of cooking",
            "MakeMeal(x, y) ::: x makes meal y",
            "Delicious(y) ::: meal y is delicious",
            "Popular(y) ::: meal y is popular at the party"
        ],
        "premises-FOL": [
            "∀x (People(x) ∧ DistinguishCondiments(x) → UseDiffCondiments(x)) ::: If a person can distinguish the taste of different condiments, then he/she can also use different condiments to cook.",
            "∀x (People(x) ∧ TalentCooking(x) → DistinguishCondiments(x)) ::: People who have the talent of cooking can distinguish the taste of different condiments.",
            "∀x (People(x) ∧ TalentCooking(x) → Delicious(x)) ::: Only people with the talent of cooking can make delicious meals.",
            "∀x (Meal(x) ∧ Popular(x) → Delicious(x)) ::: If the meal is popular at the party, then it is delicious.",
            "∃x (Meal(x) ∧ MakeMeal(John, x) ∧ Popular(x)) ::: John can make meals which are popular at the party."
        ]
    },
    {
        "premises-NL": [
            "Effective monetary policy is possible with successful inflation control and a strong national currency.",
            "A country cannot simultaneously regulate the exchange rate and successfully control inflation.",
            "The introduction of an embargo on foreign trade goods in a country leads to a sharp decrease in exports.",
            "If exports fall sharply, the national currency cannot be in this country.",
            "Regulation of the exchange rate is required to have a strong national currency. ",
            "There is an embargo on Russian foreign trade goods."
        ],
        "predicates": [
            "EffMonPolicy(x) ::: x is an effective monetary policy",
            "InfControl(x) ::: x is a successful inflation control",
            "StongCurr(x) ::: x is a strong national currency",
            "ExRate(x) ::: x regulates the exchange rate",
            "Embargo(x) ::: there is an embargo on x",
            "ExportFall(x) ::: x leads to a sharp decrease in exports"
        ],
        "premises-FOL": [
            "∀x (EffMonPolicy(x) → InfControl(x) ∧ StongCurr(x)) ::: If x is an effective monetary policy, then x is a successful inflation control and x is a strong national currency.",
            "¬(∀x (ExRate(x) ∧ InfControl(x))) ::: It is not the case that for all x, x regulates the exchange rate and x is a successful inflation control.",
            "∀x (Embargo(x) → ExportFall(x)) ::: If there is an embargo on x, then x leads to a sharp decrease in exports.",
            "∀x (ExportFall(x) → ¬StongCurr(x)) ::: If x leads to a sharp decrease in exports, then x is not a strong national currency.",
            "∀x (ExRate(x) → StongCurr(x)) ::: If x regulates the exchange rate, then x is a strong national currency.",
            "Embargo(russianForeignTradeGoods) ::: There is an embargo on russian foreign trade goods."
        ]
    },
    {
        "premises-NL": [
            "Video Gag is a French television series that airs weekly.",
            "Video Gag airs on the French broadcast channel TF1. ",
            "If viewers send in funny videos to the French broadcast channel, then Video Gag airs them on television.",
            "All videos aired on Video Gag are in French."
        ],
        "predicates": [
            "VideoGag(x) ::: x is a video gag",
            "FrenchTelevisionSeries(x) ::: x is a French television series",
            "AirsWeekly(x) ::: x airs weekly",
            "Airs(x,y) ::: x airs on y",
            "FrenchBroadcastChannel(x) ::: x is a French broadcast channel",
            "ChannelTF1(x) ::: x is channel TF1",
            "ViewersSendVideos(x, y, z) ::: viewers send videos x to channel y",
            "FunnyVideos(x) ::: x is a funny video",
            "AirsThem(x, y, z) ::: x airs y on z",
            "AiredOn(x, y) ::: x is aired on y",
            "InFrench(x) ::: x is in French"
        ],
        "premises-FOL": [
            "∀x (VideoGag(x) → FrenchTelevisionSeries(x) ∧ AirsWeekly(x)) ::: All video gags are French television series that air weekly.",
            "∀x (VideoGag(x) → Airs(x, FrenchBroadcastChannel)) ::: All video gags air on the French broadcast channel.",
            "∀x (FunnyVideos(x) ∧ ViewersSendVideos(x, FrenchBroadcastChannel) → AirsThem(VideoGag, x, Television)) ::: If viewers send in funny videos to the French broadcast channel, then Video Gag airs them on television.",
            "∀x (AiredOn(x, VideoGag) → InFrench(x)) ::: All videos aired on Video Gag are in French."
        ]
    },
    {
        "premises-NL": [
            "All phones are things.",
            "All cellphones are phones. ",
            "All iPhones are cellphones. ",
            "All engineers are workers.",
            "All workers are human. ",
            "Jack is either an engineer or a worker.",
            "Jack is is either a human or a phone."
        ],
        "predicates": [
            "Phone(x) ::: x is a phone",
            "Thing(x) ::: x is a thing",
            "Cellphone(x) ::: x is a cellphone",
            "Iphone(x) ::: x is an iPhone",
            "Engineer(x) ::: x is an engineer",
            "Worker(x) ::: x is a worker",
            "Human(x) ::: x is human"
        ],
        "premises-FOL": [
            "∀x (Phone(x) → Thing(x)) ::: All phones are things",
            "∀x (Cellphone(x) → Phone(x)) ::: All cellphones are phones",
            "∀x (Iphone(x) → Cellphone(x)) ::: All iPhones are cellphones",
            "∀x (Engineer(x) → Worker(x)) ::: All engineers are workers",
            "∀x (Worker(x) → Human(x)) ::: All workers are human",
            "Engineer(jack) ∨ Worker(jack) ::: Jack is either an engineer or a worker",
            "Human(jack) ∨ Phone(jack) ::: Jack is either a human or a phone"
        ]
    },
    {
        "premises-NL": [
            "All iPhones are electronic.",
            "Some phones are iPhones."
        ],
        "predicates": [
            "IPhone(x) ::: x is an iPhone",
            "Electronic(x) ::: x is electronic",
            "Phone(x) ::: x is a phone"
        ],
        "premises-FOL": [
            "∀x (IPhone(x) → Electronic(x)) ::: All iPhones are electronic",
            "∃x (Phone(x) ∧ IPhone(x)) ::: Some phones are iPhones"
        ]
    },
    {
        "premises-NL": [
            "Metropolitan Museum of Art is a museum in NYC.",
            "Whitney Museum of American Art is a museum in NYC.",
            "Museum of Modern Art (MoMA) is a museum if NYC. ",
            "Metropolitan Museum of Art includes Bytantine and Islamic Art. ",
            "Whitney Museum of American Art includes American art."
        ],
        "predicates": [
            "Museum(x) ::: x is a museum",
            "InNYC(x) ::: x is in NYC",
            "Include(x, y) ::: x includes y"
        ],
        "premises-FOL": [
            "Museum(metropolitanMuseumofArt) ∧ InNYC(metropolitanMuseumofArt) ::: Metropolitan Museum of Art is a museum in NYC",
            "Museum(whitneyMuseumofAmericanArt) ∧ InNYC(whitneyMuseumofAmericanArt) ::: Whitney Museum of American Art is a museum in NYC",
            "Museum(museumofModernArt) ∧ InNYC(museumofModernArt) ::: Museum of Modern Art (MoMA) is a museum if NYC",
            "Include(metropolitanMuseumofArt, byzantineArt) ∧ Include(metropolitanMuseumofArt, islamicArt) ::: Metropolitan Museum of Art includes Bytantine and Islamic Art",
            "Include(whitneyMuseumofAmericanArt, americanArt) ::: Whitney Museum of American Art includes American art"
        ]
    },
    {
        "premises-NL": [
            "A person either likes eating cheese or is a francophile.",
            "No francophiles are people who like Spain as their favorite country.",
            "A person likes Spain as their favorite country or likes eating cheese.",
            "Benji is not a person who likes eating cheese and a person who studies Spanish.",
            "If Benji is neither a person who studies Spanish nor a person that studies French, then Benji is a person who studies Spanish or a person that studies French."
        ],
        "predicates": [
            "LikesEatingCheese(x) ::: x likes eating cheese",
            "IsFrancophile(x) ::: x is a francophile",
            "LikesSpainAsFavoriteCountry(x) ::: x likes Spain as their favorite country",
            "StudiesSpanish(x) ::: x studies Spanish",
            "StudiesFrench(x) ::: x studies French"
        ],
        "premises-FOL": [
            "LikesEatingCheese(x) ∨ IsFrancophile(x) ::: A person either likes eating cheese or is a francophile.",
            "IsFrancophile(x) → ¬LikesSpainAsFavoriteCountry(x) ::: No francophiles are people who like Spain as their favorite country.",
            "LikesSpainAsFavoriteCountry(x) ∨ LikesEatingCheese(x) ::: A person likes Spain as their favorite country or likes eating cheese.",
            "¬(LikesEatingCheese(benji) ∧ StudiesSpanish(benji)) ::: Benji is not a person who likes eating cheese and a person who studies Spanish.",
            "¬(StudiesSpanish(benji) ∨ StudiesFrench(benji)) → (StudiesSpanish(benji) ∨ StudiesFrench(benji)) ::: If Benji is neither a person who studies Spanish nor a person that studies French, then Benji is a person who studies Spanish or a person that studies French."
        ]
    },
    {
        "premises-NL": [
            "Gasteren is village located in the province of Drenthe.",
            "Drenthe is a Dutch province. ",
            "No cities are villages.",
            "The population of a village in Drenthe was 155 people."
        ],
        "predicates": [
            "Village(x) ::: x is a village",
            "Province(x) ::: x is a province",
            "LocatedIn(x, y) ::: x is located in y",
            "Dutch(x) ::: x is Dutch",
            "City(x) ::: x is a city",
            "Population155(x) ::: The population of x was 155 people"
        ],
        "premises-FOL": [
            "Village(gasteren) ∧ Province(drenthe) ∧ LocatedIn(gasteren, drenthe) ::: Gasteren is a village located in the province of Drenthe.",
            "Province(drenthe) ∧ Dutch(drenthe) ::: Drenthe is a Dutch province.",
            "∀x (City(x) → ¬Village(x)) ::: No cities are villages.",
            "∃x (Population155(x) ∧ Village(x) ∧ LocatedIn(x, drenthe)) ::: The population of a village in Drenthe was 155 people."
        ]
    },
    {
        "premises-NL": [
            "Bobby Flynn is a singer-songwriter. ",
            "Bobby Flynn finished 7th while competing on Australian Idol.",
            "Australian Idol competitors are Australian citizens.",
            "The Omega Three band made a nationwide tour in 2007.",
            "Bobby Flynn is a member of The Omega Three band.",
            "Bobby Flynn was born in Queensland."
        ],
        "predicates": [
            "Singer(x) ::: x is a singer",
            "SongWriter(x) ::: x is a song writer",
            "Finished7th(x) ::: x finished 7th",
            "CompetedOnAustralianIdol(x) ::: x competed on Australian Idol",
            "AustralianCitizen(x) ::: x is an Australian citizen",
            "MadeNationWideTour2007(x) ::: x made a nationwide tour in 2007",
            "IsMember(x, y) ::: x is a member of y",
            "BornIn(x, y) ::: x was born in y"
        ],
        "premises-FOL": [
            "Singer(bobbyFlynn) ∧ SongWriter(bobbyFlynn) ::: Bobby Flynn is a singer and a songwriter",
            "Finished7th(bobbyFlynn) ∧ CompetedOnAustralianIdol(bobbyFlynn) ::: Bobby Flynn finished 7th and competed on Australian Idol",
            "∀x (CompetedOnAustralianIdol(x) → AustralianCitizen(x)) ::: All competitors on Australian Idol are Australian citizens",
            "MadeNationWideTour2007(theOmegaThreeBand) ::: The Omega Three band made a nationwide tour in 2007",
            "IsMember(bobbyFlynn, theOmegaThreeBand) ::: Bobby Flynn is a member of The Omega Three band",
            "BornIn(bobbyFlynn, queensland) ::: Bobby Flynn was born in Queensland"
        ]
    },
    {
        "premises-NL": [
            "One American screenwriter and producer is Maggie Friedman.",
            "Maggie Friedman was the showrunner and executive producer of the lifetime television series Witches of East End.",
            "Witches of East End is a fantasy-drama series.",
            "Maggie Friedman produced and developed Eastwick.",
            "Eastwick is a series by ABC."
        ],
        "predicates": [
            "American(x) ::: x is American",
            "Screenwriter(x) ::: x is a screenwriter",
            "Producer(x) ::: x is a producer",
            "ShowRunnerOf(x, y) ::: x is the showrunner of y",
            "ExecutiveProducerOf(x, y) ::: x is the executive producer of y",
            "LifetimeTelevisionSeries(x) ::: x is a lifetime television series",
            "Fantasy-Drama(x) ::: x is a fantasy-drama",
            "Series(x) ::: x is a series",
            "Produced(x, y) ::: x produced y",
            "Developed(x, y) ::: x developed y",
            "By(x, y) ::: x is by y"
        ],
        "premises-FOL": [
            "American(maggiefriedman) ∧ Screenwriter(maggiefriedman) ∧ Producer(maggiefriedman) ::: Maggie Friedman is an American screenwriter and producer",
            "ShowRunnerOf(maggiefriedman, witchesofeastend) ∧ ExecutiveProducerOf(maggiefriedman, witchesofeastend) ∧ LifetimeTelevisionSeries(witchesofeastend) ::: Maggie Friedman was the showrunner and executive producer of the lifetime television series Witches of East End",
            "Fantasy-Drama(witchesofeastend) ∧ Series(witchesofeastend) ::: Witches of East End is a fantasy-drama series",
            "Produced(maggiefriedman, eastwick) ∧ Developed(maggiefriedman, eastwick) ::: Maggie Friedman produced and developed Eastwick",
            "Series(eastwick) ∧ By(eastwick, abc) ::: Eastwick is a series by ABC"
        ]
    },
    {
        "premises-NL": [
            "Before releasing their single, Hooray! Hooray! It's a Holi-Holiday!, Boney M. had had seven consecutive German #1 singles.",
            "Hooray! Hooray! It's a Holi-Holiday! was a big hit all over Europe.",
            "Nevertheless, Hooray! Hooray! It's a Holi-Holiday! broke Boney M's streak of consecutive German #1 singles.",
            "A song that peaks below #1 on the german charts is also a song that is not the #1 single"
        ],
        "predicates": [
            "Release(x, y) ::: x releases y",
            "Single(x) ::: x is a single",
            "Had(x, y) ::: x had y",
            "Consecutive(x) ::: x is consecutive",
            "GermanN1(x) ::: x is German number 1",
            "Hit(x, y) ::: x is a hit in y",
            "Song(x) ::: x is a song",
            "Broke(x, y, z) ::: x broke y's z",
            "Streak(x) ::: x is a streak",
            "PeaksBelowN1(x) ::: x peaks below number 1"
        ],
        "premises-FOL": [
            "Release(boneym, hooray) ∧ Had(boneym, sevenConsecutiveGermanN1Singles) ::: Before releasing their single, Hooray! Hooray! It's a Holi-Holiday!, Boney M. had had seven consecutive German #1 singles.",
            "Hit(hooray, europe) ::: Hooray! Hooray! It's a Holi-Holiday! was a big hit all over Europe.",
            "Broke(hooray, boneym, streak) ::: Nevertheless, Hooray! Hooray! It's a Holi-Holiday! broke Boney M's streak of consecutive German #1 singles.",
            "∀x (PeaksBelowN1(x) → ¬N1GermanSingle(x)) ::: A song that peaks below #1 on the german charts is also a song that is not the #1 single"
        ]
    },
    {
        "premises-NL": [
            "Every chef can cook.",
            "Some people who aren’t chefs can cook.",
            "People who cook can make scrambled eggs and pasta.",
            "If someone can make cookies and muffins, they are a baker.",
            "Bakers who can also make scrambled eggs can make a good breakfast.",
            "Luke can make cookies, scrambled eggs, and muffins, but not pasta."
        ],
        "predicates": [
            "Chef(x) ::: x is a chef",
            "Cook(x) ::: x can cook",
            "MakeScrambledEggs(x) ::: x can make scrambled eggs",
            "MakePasta(x) ::: x can make pasta",
            "MakeCookies(x) ::: x can make cookies",
            "MakeMuffins(x) ::: x can make muffins",
            "Baker(x) ::: x is a baker",
            "MakeGoodBreakfast(x) ::: x can make a good breakfast"
        ],
        "premises-FOL": [
            "∀x (Chef(x) → Cook(x)) ::: Every chef can cook.",
            "∃x (¬Chef(x) ∧ Cook(x)) ::: Some people who aren’t chefs can cook.",
            "∀x (Cook(x) → (MakeScrambledEggs(x) ∧ MakePasta(x))) ::: People who cook can make scrambled eggs and pasta.",
            "∀x (MakeCookies(x) ∧ MakeMuffins(x) → Baker(x)) ::: If someone can make cookies and muffins, they are a baker.",
            "∀x ((Baker(x) ∧ MakeScrambledEggs(x)) → MakeGoodBreakfast(x)) ::: Bakers who can also make scrambled eggs can make a good breakfast.",
            "MakeCookies(luke) ∧ MakeScrambledEggs(luke) ∧ MakeMuffins(luke) ∧ ¬MakePasta(luke) ::: Luke can make cookies, scrambled eggs, and muffins, but not pasta."
        ]
    },
    {
        "premises-NL": [
            "ETS develops various standardized tests primarily in the United States for K-12 and higher education. ",
            "ETS administers international tests including the TOEFL, TOEIC, GRE and subject tests in more than 180 countries.",
            "Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions. ",
            "ETS also develops K-12 statewide assessments used for accountability testing in many states."
        ],
        "predicates": [
            "Develops(x, y) ::: x develops y",
            "StandardizedTest(x) ::: x is a standardized test",
            "In(x, y) ::: x is in y",
            "For(x, y) ::: x is for y",
            "Administers(x, y) ::: x administers y",
            "InternationalTest(x) ::: x is an international test",
            "TOEFL(x) ::: x is TOEFL",
            "TOEIC(x) ::: x is TOEIC",
            "GRE(x) ::: x is GRE",
            "SubjectTests(x) ::: x is subject tests",
            "AssociatedWith(x, y) ::: x is associated with y",
            "StateWideAssesment(x) ::: x is a state wide assessment",
            "UsedFor(x, y) ::: x is used for y"
        ],
        "premises-FOL": [
            "∃x (Develops(ets, x) ∧ StandardizedTest(x) ∧ In(x, unitedstates) ∧ For(x, k-12andhighereducation)) ::: ETS develops various standardized tests primarily in the United States for K-12 and higher education.",
            "∃x (Administers(ets, x) ∧ InternationalTest(x) ∧ (TOEFL(x) ∨ TOEIC(x) ∨ GRE(x) ∨ SubjectTests(x))) ::: ETS administers international tests including the TOEFL, TOEIC, GRE and subject tests in more than 180 countries.",
            "∃x (Develops(ets, x) ∧ AssociatedWith(x, entrytouseducationinstitutions)) ::: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.",
            "∃x (Develops(ets, x) ∧ StateWideAssesment(x) ∧ UsedFor(x, accountabilitytesting)) ::: ETS also develops K-12 statewide assessments used for accountability testing in many states."
        ]
    },
    {
        "premises-NL": [
            "All people who enjoy eating gelato ice cream would enjoy a vacation to Italy.",
            "There are no people who can resist the hallmark delectable drinks and desserts that are famed in Italy.",
            "People either enjoy eating gelato ice cream or love to travel and vacation often.",
            "If people often take study abroad semesters to Europe, then they do not regret their college experiences.",
            "If people love to travel and vacation often, then they often take study abroad semesters to Europe.",
            "Robert either enjoys eating gelato ice cream and loves to travel and vacation often, or he neither enjoys eating gelato ice cream nor loves to travel and vacation often."
        ],
        "predicates": [
            "Gelato(x) ::: x enjoys eating gelato ice cream",
            "Italy(x) ::: x would enjoy a vacation to Italy",
            "Resist(x) ::: x can resist the hallmark delectable drinks and desserts that are famed in Italy",
            "Travel(x) ::: x loves to travel and vacation often",
            "Europe(x) ::: x often take study abroad semesters to Europe",
            "Regret(x) ::: x regret their college experiences"
        ],
        "premises-FOL": [
            "∀x (Gelato(x) → Italy(x)) ::: All people who enjoy eating gelato ice cream would enjoy a vacation to Italy.",
            "∀x (¬Resist(x)) ::: There are no people who can resist the hallmark delectable drinks and desserts that are famed in Italy.",
            "∀x (Gelato(x) ∨ Travel(x)) ::: People either enjoy eating gelato ice cream or love to travel and vacation often.",
            "∀x (Europe(x) → ¬Regret(x)) ::: If people often take study abroad semesters to Europe, then they do not regret their college experiences.",
            "∀x (Travel(x) → Europe(x)) ::: If people love to travel and vacation often, then they often take study abroad semesters to Europe.",
            "(Gelato(robert) ∧ Travel(robert)) ∨ (¬Gelato(robert) ∧ ¬Travel(robert)) ::: Robert either enjoys eating gelato ice cream and loves to travel and vacation often, or he neither enjoys eating gelato ice cream nor loves to travel and vacation often."
        ]
    },
    {
        "premises-NL": [
            "To get a student visa, you must be full-time enrolled in an academic program.",
            "Those who are full-time enrolled in an academic program can not work full-time.",
            "Everyone who wants to study abroad needs to have a student visa.",
            "All PhD graduates can work full time. ",
            "If Tom does not want to study abroad, he is full-time enrolled in an educational program."
        ],
        "predicates": [
            "StudentVisa(x) ::: x has a student visa",
            "FullTimeAcademic(x) ::: x is full-time enrolled in an academic program",
            "WorkFullTime(x) ::: x can work full-time",
            "StudyAbroad(x) ::: x wants to study abroad",
            "PhdGraduate(x) ::: x is a PhD graduate"
        ],
        "premises-FOL": [
            "∀x (StudentVisa(x) → FullTimeAcademic(x)) ::: To get a student visa, you must be full-time enrolled in an academic program.",
            "∀x (FullTimeAcademic(x) → ¬WorkFullTime(x)) ::: Those who are full-time enrolled in an academic program can not work full-time.",
            "∀x (StudyAbroad(x) → StudentVisa(x)) ::: Everyone who wants to study abroad needs to have a student visa.",
            "∀x (PhdGraduate(x) → WorkFullTime(x)) ::: All PhD graduates can work full time.",
            "¬StudyAbroad(tom) → FullTimeAcademic(tom) ::: If Tom does not want to study abroad, he is full-time enrolled in an educational program."
        ]
    },
    {
        "premises-NL": [
            "All people who are respected by others are people who contribute to the country. ",
            "If a person is respected by others, then he/she contributes to the country. ",
            "All people available to have a visit without any fees are those respected by others. ",
            "All Customers who once served in the army are available to have a visit without any fees. ",
            "All people who once were sentenced for thief stayed in prison for some time. ",
            "All people who once stayed in prison for some time have a bad record in the local state. ",
            "James was either once sentenced for thief or stayed in prison for some time. ",
            "James is either with a bad record in the local state or respected by others. "
        ],
        "predicates": [
            "Respected(x) ::: x is respected by others",
            "ContributeToCountry(x) ::: x contributes to the country",
            "HaveVisitWithoutAnyFees(x) ::: x is available to have a visit without any fees",
            "Army(x) ::: x once served in the army",
            "Thief(x) ::: x was once sentenced for thief",
            "Prison(x) ::: x stayed in prison for some time",
            "BadRecord(x) ::: x has a bad record in the local state"
        ],
        "premises-FOL": [
            "∀x (Respected(x) → ContributeToCountry(x)) ::: All people who are respected by others are people who contribute to the country.",
            "∀x (Respected(x) → ContributeToCountry(x)) ::: If a person is respected by others, then he/she contributes to the country.",
            "∀x (HaveVisitWithoutAnyFees(x) → Respected(x)) ::: All people available to have a visit without any fees are those respected by others.",
            "∀x (Army(x) → HaveVisitWithoutAnyFees(x)) ::: All Customers who once served in the army are available to have a visit without any fees.",
            "∀x (Thief(x) → Prison(x)) ::: All people who once were sentenced for thief stayed in prison for some time.",
            "∀x (Prison(x) → BadRecord(x)) ::: All people who once stayed in prison for some time have a bad record in the local state.",
            "Thief(james) ⊕ Prison(james) ::: James was either once sentenced for thief or stayed in prison for some time.",
            "BadRecord(james) ⊕ Respected(james) ::: James is either with a bad record in the local state or respected by others."
        ]
    },
    {
        "premises-NL": [
            "The Croton River watershed is the drainage basin of the Croton River.",
            "The Croton River is in southwestern New York.",
            "Water from the Croton River watershed flows to the Bronx.",
            "The Bronx is in New York."
        ],
        "predicates": [
            "DrainageBasinOf(x, y) ::: x is the drainage basin of y",
            "In(x, y) ::: x is in y",
            "Water(x) ::: x is water",
            "From(x, y) ::: x is from y",
            "FlowsTo(x, y) ::: x flows to y"
        ],
        "premises-FOL": [
            "DrainageBasinOf(crotonriverwatershed, crotonriver) ::: The Croton River watershed is the drainage basin of the Croton River.",
            "In(crotonriver, southwesternnewyork) ::: The Croton River is in southwestern New York.",
            "∃x (Water(x) ∧ From(x, crotonriverwatershed) ∧ FlowsTo(x, bronx)) ::: Water from the Croton River watershed flows to the Bronx.",
            "In(bronx, newyork) ::: The Bronx is in New York."
        ]
    },
    {
        "premises-NL": [
            "All nuclear-powered submarines are warships.",
            "No nuclear-powered submarines are commercial vessels."
        ],
        "predicates": [
            "NuclearPoweredSubmarine(x) ::: x is a nuclear-powered submarine",
            "Warship(x) ::: x is a warship",
            "CommercialVessel(x) ::: x is a commercial vessel"
        ],
        "premises-FOL": [
            "∀x (NuclearPoweredSubmarine(x) → Warship(x)) ::: All nuclear-powered submarines are warships.",
            "∀x (NuclearPoweredSubmarine(x) → ¬CommercialVessel(x)) ::: No nuclear-powered submarines are commercial vessels."
        ]
    },
    {
        "premises-NL": [
            "Daniel is a software engineer and he works at Palantir Technologies.",
            "Daniel studied bioengineering during his undergraduate at Rice University.",
            "Daniel’s older sister works at Meta as a technical sourcer. ",
            "Daniel’s dad and older sister both graduated from Stanford University.",
            "Daniel’s dad is a doctor practicing internal medicine at a veteran’s hospital in Minneapolis"
        ],
        "predicates": [
            "SoftwareEngineer(x) ::: x is a software engineer",
            "WorksAt(x, y) ::: x works at y",
            "StudiedBioengineering(x, y) ::: x studied bioengineering at y",
            "WorksAtMeta(x) ::: x works at Meta",
            "TechnicalSourcer(x) ::: x is a technical sourcer",
            "GraduatedFromStanfordUniversity(x) ::: x graduated from Stanford University",
            "DoctorPracticingInternalMedicine(x, y) ::: x is a doctor practicing internal medicine at y"
        ],
        "premises-FOL": [
            "SoftwareEngineer(daniel) ∧ WorksAt(daniel, palantirTechnologies) ::: Daniel is a software engineer and he works at Palantir Technologies",
            "StudiedBioengineering(daniel, riceUniversity) ::: Daniel studied bioengineering during his undergraduate at Rice University",
            "WorksAtMeta(danielsOlderSister) ∧ TechnicalSourcer(danielsOlderSister) ::: Daniel’s older sister works at Meta as a technical sourcer",
            "GraduatedFromStanfordUniversity(danielsOlderSister) ∧ GraduatedFromStanfordUniversity(danielsDad) ::: Daniel’s dad and older sister both graduated from Stanford University",
            "DoctorPracticingInternalMedicine(danielsDad, veteransHospitalInMinneapolis) ::: Daniel’s dad is a doctor practicing internal medicine at a veteran’s hospital in Minneapolis"
        ]
    },
    {
        "premises-NL": [
            "All commerical aircraft are produced by either Boeing or Airbus.",
            "All American Airlines jets are commerical aircraft. ",
            "Airbus made more in revenue than Boeing last year."
        ],
        "predicates": [
            "CommercialAircraft(x) ::: x is a commercial aircraft",
            "ProducedBy(x, y) ::: x is produced by y",
            "AmericanAirlinesAircraft(x) ::: x is an American Airlines aircraft",
            "MoreinRevenue(x, y) ::: x made more in revenue than y"
        ],
        "premises-FOL": [
            "∀x (CommercialAircraft(x) → (ProducedBy(x, boeing) ∨ ProducedBy(x, airbus))) ::: All commercial aircraft are produced by either Boeing or Airbus.",
            "∀x (AmericanAirlinesAircraft(x) → CommercialAircraft(x)) ::: All American Airlines jets are commercial aircraft.",
            "MoreinRevenue(airbus, boeing) ::: Airbus made more in revenue than Boeing last year."
        ]
    },
    {
        "premises-NL": [
            "Luzon is an island in the Philippines.",
            "In December 1999, an earthquake struck Luzon.",
            "People died in the December 1999 earthquake in Luzon."
        ],
        "predicates": [
            "Island(x) ::: x is an island",
            "In(x, y) ::: x is in y",
            "Earthquake(x) ::: x is an earthquake",
            "StruckIn(x, y) ::: x struck in y",
            "Struck(x, y) ::: x struck y",
            "DiedIn(x, y) ::: people died in x"
        ],
        "premises-FOL": [
            "Island(luzon) ∧ In(luzon, philippines) ::: Luzon is an island and is in the Philippines",
            "∃x (Earthquake(x) ∧ StruckIn(x, december1999) ∧ Struck(x, luzon)) ::: There exists an earthquake that struck in December 1999 and struck Luzon",
            "∃x (Earthquake(x) ∧ StruckIn(x, december1999) ∧ Struck(x, luzon) ∧ DiedIn(x, luzon)) ::: There exists an earthquake that struck in December 1999 and struck Luzon and people died in it"
        ]
    },
    {
        "premises-NL": [
            "People either invest in the public stock market regularly or enjoy gambling regularly.",
            "If people invest in the public stock market regularly, then they read the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.",
            "All people who enjoy gambling regularly spend a lot of money at casinos and other betting games.",
            "People who spend a lot of money at casinos and other betting games visit the Las Vegas Strip regularly.",
            "People who spend a lot of money at casinos and other betting games have a lot of disposable income to spend.",
            "If Matt invests in the public stock market regularly, then Matt neither has a lot of disposable income to spend nor invests in the public stock market regularly. "
        ],
        "predicates": [
            "Invests(x) ::: x invests in the public stock market regularly",
            "Gambling(x) ::: x enjoys gambling regularly",
            "Newspapers(x) ::: x reads the Wall Street Journal and other newspapers regularly to keep updated on financial metrics",
            "Casinos(x) ::: x spends a lot of money at casinos and other betting games",
            "LasVegas(x) ::: x visits the Las Vegas Strip regularly",
            "DisposableIncome(x) ::: x has a lot of disposable income to spend"
        ],
        "premises-FOL": [
            "∀x (Invests(x) ∨ Gambling(x)) ::: People either invest in the public stock market regularly or enjoy gambling regularly.",
            "∀x (Invests(x) → Newspapers(x)) ::: If people invest in the public stock market regularly, then they read the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.",
            "∀x (Gambling(x) → Casinos(x)) ::: All people who enjoy gambling regularly spend a lot of money at casinos and other betting games.",
            "∀x (Casinos(x) → LasVegas(x)) ::: People who spend a lot of money at casinos and other betting games visit the Las Vegas Strip regularly.",
            "∀x (Casinos(x) → DisposableIncome(x)) ::: People who spend a lot of money at casinos and other betting games have a lot of disposable income to spend.",
            "Invests(matt) → (¬DisposableIncome(matt) ∧ ¬Invests(matt)) ::: If Matt invests in the public stock market regularly, then Matt neither has a lot of disposable income to spend nor invests in the public stock market regularly."
        ]
    },
    {
        "premises-NL": [
            "All students learning piano can strike the right notes. ",
            "All students who can strike the right note can get the rhythms right. ",
            "If a student can get the rhythms right, he will start working on coordination between the left and the right hands. ",
            "Some students who start working on coordination between the left and the right hands become good at it. The other students find it challenging. ",
            "If John can strike the right notes, get the rhythms right and is good at coordination between right and left hands, then he puts emotions into his playing. ",
            "John is a student learning piano. ",
            "John does not find coordination between the left and the right hands challenging. "
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "LearningPiano(x) ::: x is learning piano",
            "StrikeRightNotes(x) ::: x can strike the right notes",
            "GetRhythmRight(x) ::: x can get the rhythms right",
            "StartCoordination(x) ::: x starts working on coordination between the left and the right hands",
            "GoodAtCoordination(x) ::: x is good at coordination between the left and the right hands",
            "FindCoordinationChallenging(x) ::: x finds coordination between the left and the right hands challenging",
            "PutEmotion(x) ::: x puts emotions into his playing"
        ],
        "premises-FOL": [
            "∀x (Student(x) ∧ LearningPiano(x) → StrikeRightNotes(x)) ::: All students learning piano can strike the right notes.",
            "∀x (Student(x) ∧ StrikeRightNotes(x) → GetRhythmRight(x)) ::: All students who can strike the right note can get the rhythms right.",
            "∀x (Student(x) ∧ GetRhythmRight(x) → StartCoordination(x)) ::: If a student can get the rhythms right, he will start working on coordination between the left and the right hands.",
            "∀x (Student(x) ∧ StartCoordination(x) → (GoodAtCoordination(x) ∨ FindCoordinationChallenging(x))) ::: Some students who start working on coordination between the left and the right hands become good at it. The other students find it challenging.",
            "StrikeRightNotes(john) ∧ GetRhythmRight(john) ∧ GoodAtCoordination(john) → PutEmotion(john) ::: If John can strike the right notes, get the rhythms right and is good at coordination between right and left hands, then he puts emotions into his playing.",
            "Student(john) ∧ LearningPiano(john) ::: John is a student learning piano.",
            "¬FindCoordinationChallenging(john) ::: John does not find coordination between the left and the right hands challenging."
        ]
    },
    {
        "premises-NL": [
            "Barbara Ann Marshall is a former swimmer and former world record-holder.",
            "Barbara Ann Marshall participated in the 1972 Summer Olympics.",
            "Barbara Ann Marshall's home country is the United States.",
            "All people who compete in the 1972 Summer Olympics represent their home country.",
            "Barbara Ann Marshall participated in the preliminary heat in the freestyle relay.",
            "Barbara Ann Marshall did not participate in the event final of the 1972 Summer Olympics freestyle relay.",
            "Only relay swimmers who participated in the event final received medals."
        ],
        "predicates": [
            "FormerSwimmer(x) ::: x is a former swimmer",
            "FormerWorldRecordHolder(x) ::: x is a former world record holder",
            "ParticipatedIn(x, y) ::: x participated in y",
            "HomeCountry(x, y) ::: x's home country is y",
            "Represented(x, y) ::: x represented y",
            "RelaySwimmer(x) ::: x is a relay swimmer",
            "Received(x, y) ::: x received y"
        ],
        "premises-FOL": [
            "FormerSwimmer(barbaraannmarshall) ∧ FormerWorldRecordHolder(barbaraannmarshall) ::: Barbara Ann Marshall is a former swimmer and former world record-holder.",
            "ParticipatedIn(barbaraannmarshall, summer1972olympics) ::: Barbara Ann Marshall participated in the 1972 Summer Olympics.",
            "HomeCountry(barbaraannmarshall, unitedstates) ::: Barbara Ann Marshall's home country is the United States.",
            "∀x ∃y (ParticipatedIn(x, summer1972olympics) ∧ HomeCountry(x, y) → Represented(x, y)) ::: All people who compete in the 1972 Summer Olympics represent their home country.",
            "ParticipatedIn(barbaraannmarshall, preliminaryheatfreestylerelay) ::: Barbara Ann Marshall participated in the preliminary heat in the freestyle relay.",
            "¬ParticipatedIn(barbaraannmarshall, finalheatfreestylerelay) ::: Barbara Ann Marshall did not participate in the event final of the 1972 Summer Olympics freestyle relay.",
            "∀x ((RelaySwimmer(x) ∧ ParticipatedIn(x,finalheatfreerelay)) → Received(x,medal)) ::: Only relay swimmers who participated in the event final received medals."
        ]
    },
    {
        "premises-NL": [
            "People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.",
            "If a person values physical touch as an especially important love language, then they are good with pets.",
            "No people that are good with pets are scared of animals.",
            "People are either scared of animals or love animals.",
            "Adam is either a person who values physical touch as an especially important love language or a person who loves animals."
        ],
        "predicates": [
            "Physical(x) ::: x values physical touch as an especially important love language",
            "Words(x) ::: x values words of affirmation as an especially important love language",
            "GoodWithPets(x) ::: x is good with pets",
            "ScaredOfAnimals(x) ::: x is scared of animals",
            "LoveAnimals(x) ::: x loves animals"
        ],
        "premises-FOL": [
            "∀x (Physical(x) ∨ Words(x)) ::: People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.",
            "∀x (Physical(x) → GoodWithPets(x)) ::: If a person values physical touch as an especially important love language, then they are good with pets.",
            "∀x (GoodWithPets(x) → ¬ScaredOfAnimals(x)) ::: No people that are good with pets are scared of animals.",
            "∀x (ScaredOfAnimals(x) ∨ LoveAnimals(x)) ::: People are either scared of animals or love animals.",
            "Physical(adam) ∨ LoveAnimals(adam) ::: Adam is either a person who values physical touch as an especially important love language or a person who loves animals."
        ]
    },
    {
        "premises-NL": [
            "All birds have wings.",
            "No animal with wings is a reptile.",
            "Some animals that fly are birds.",
            "If something is an iguana, then it is a reptile.",
            "John is neither an iguana nor a bird."
        ],
        "predicates": [
            "Bird(x) ::: x is a bird",
            "Winged(x) ::: x has wings",
            "Animal(x) ::: x is an animal",
            "Reptile(x) ::: x is a reptile",
            "Fly(x) ::: x can fly",
            "Iguana(x) ::: x is an iguana"
        ],
        "premises-FOL": [
            "∀x (Bird(x) → Winged(x)) ::: All birds have wings.",
            "∀x (Winged(x) → ¬Reptile(x)) ::: No animal with wings is a reptile.",
            "∃x (Fly(x) ∧ Bird(x)) ::: Some animals that fly are birds.",
            "∀x (Iguana(x) → Reptile(x)) ::: If something is an iguana, then it is a reptile.",
            "¬Iguana(john) ∧ ¬Bird(john) ::: John is neither an iguana nor a bird."
        ]
    },
    {
        "premises-NL": [
            "EndGame is a movie released in 2006.",
            "EndGame was set in Washington.",
            "EndGame was filmed outside of Washington.",
            "Some movies are filmed in New York.",
            "Andy Chang directed EndGame.",
            "Andy Chang is from Hong Kong."
        ],
        "predicates": [
            "Movie(x) ::: x is a movie",
            "Released(x, y) ::: x was released in year y",
            "Set(x, y) ::: x was set in y",
            "FilmedOutside(x, y) ::: x was filmed outside of y",
            "FilmedIn(x, y) ::: x was filmed in y",
            "Directed(x, y) ::: x directed y",
            "From(x, y) ::: x is from y"
        ],
        "premises-FOL": [
            "Movie(endGame) ∧ Released(endGame, year2006) ::: EndGame is a movie released in 2006",
            "Set(endGame, washington) ::: EndGame was set in Washington",
            "FilmedOutside(endGame, washington) ::: EndGame was filmed outside of Washington",
            "∃x (Movie(x) ∧ FilmedIn(x, newYork)) ::: Some movies are filmed in New York",
            "Directed(andyChang, endGame) ::: Andy Chang directed EndGame",
            "From(andyChang, hongKong) ::: Andy Chang is from Hong Kong"
        ]
    },
    {
        "premises-NL": [
            "Six, seven and eight are real numbers.",
            "If a real number equals another real number adding one, the first number is larger.",
            "If the number x is larger than number y, then y is not larger than x.",
            "Seven equals six plus one.",
            "Eight equals seven plus one.",
            "Two is positive.",
            "If a number is positive, then the double of it is also positive.",
            "Eight is the double of four.",
            "Four is the double of two."
        ],
        "predicates": [
            "RealNum(x) ::: x is a real number",
            "EqualAddOne(x, y) ::: x equals y plus one",
            "Larger(x, y) ::: x is larger than y",
            "Positive(x) ::: x is positive",
            "EqualDouble(x, y) ::: x is the double of y"
        ],
        "premises-FOL": [
            "RealNum(six) ∧ RealNum(seven) ∧ RealNum(eight) ::: Six, seven and eight are real numbers.",
            "∀x ∀y (RealNum(x) ∧ RealNum(y) ∧ EqualAddOne(x, y) → Larger(x, y)) ::: If a real number equals another real number adding one, the first number is larger.",
            "∀x ∀y (Larger(x, y) → ¬Larger(y, x)) ::: If the number x is larger than number y, then y is not larger than x.",
            "EqualAddOne(seven, six) ::: Seven equals six plus one.",
            "EqualAddOne(eight, seven) ::: Eight equals seven plus one.",
            "Positive(two) ::: Two is positive.",
            "∀x (Positive(x) → Positive(Double(x))) ::: If a number is positive, then the double of it is also positive.",
            "EqualDouble(eight, four) ::: Eight is the double of four.",
            "EqualDouble(four, two) ::: Four is the double of two."
        ]
    },
    {
        "premises-NL": [
            "A dog never tells the truth.",
            "Some poker players are dogs."
        ],
        "predicates": [
            "Dog(x) ::: x is a dog",
            "NeverTellsTruth(x) ::: x never tells the truth",
            "PokerPlayer(x) ::: x is a poker player"
        ],
        "premises-FOL": [
            "∀x (Dog(x) → NeverTellsTruth(x)) ::: All dogs never tell the truth",
            "∃x (PokerPlayer(x) ∧ Dog(x)) ::: Some poker players are dogs"
        ]
    },
    {
        "premises-NL": [
            "All Asians are human. ",
            "All Chinese are Asian.",
            "A man is either Chinese or British.",
            "All British are European. ",
            "All Spanish are European. ",
            "No Indian is European. ",
            "Jessee is either both an Indian and a human, or neither an Indian nor a human."
        ],
        "predicates": [
            "Asian(x) ::: x is Asian",
            "Human(x) ::: x is human",
            "Chinese(x) ::: x is Chinese",
            "British(x) ::: x is British",
            "European(x) ::: x is European",
            "Spanish(x) ::: x is Spanish",
            "Indian(x) ::: x is Indian",
            "Indian(jesse) ::: Jessee is Indian",
            "Human(jesse) ::: Jessee is human"
        ],
        "premises-FOL": [
            "∀x (Asian(x) → Human(x)) ::: All Asians are human",
            "∀x (Chinese(x) → Asian(x)) ::: All Chinese are Asian",
            "∀x (Man(x) → (Chinese(x) ∨ British(x))) ::: A man is either Chinese or British",
            "∀x (British(x) → European(x)) ::: All British are European",
            "∀x (Spanish(x) → European(x)) ::: All Spanish are European",
            "∀x (Indian(x) → ¬European(x)) ::: No Indian is European",
            "((Indian(jesse) ∧ Human(jesse)) ∨ (¬Indian(jesse) ∧ ¬Human(jesse))) ::: Jessee is either both an Indian and a human, or neither an Indian nor a human"
        ]
    },
    {
        "premises-NL": [
            "No people who never admit a mistake are good teachers.",
            "Some well-informed people are people who never admit a mistake."
        ],
        "predicates": [
            "NeverAdmitMistakes(x) ::: x never admits a mistake",
            "GoodTeacher(x) ::: x is a good teacher",
            "WellInformed(x) ::: x is well-informed"
        ],
        "premises-FOL": [
            "∀x (NeverAdmitMistakes(x) → ¬GoodTeacher(x)) ::: No people who never admit a mistake are good teachers.",
            "∃x (WellInformed(x) ∧ NeverAdmitMistakes(x)) ::: Some well-informed people are people who never admit a mistake."
        ]
    },
    {
        "premises-NL": [
            "Philatelic literature is divided into the following categories: Stamp catalogues, Periodicals, Auction catalogues, Books, Bibliographies, and Background Material",
            "Mort is not a Stamp catalogue.",
            "Mort is not a periodical, auction catalogue, bibliography, or background material.",
            "Mort is a piece of Philatelic literature."
        ],
        "predicates": [
            "PhilatelicLit(x) ::: x is a piece of Philatelic literature",
            "Stamp(x) ::: x is a stamp catalogue",
            "Periodical(x) ::: x is a periodical",
            "Auction(x) ::: x is an auction catalogue",
            "Book(x) ::: x is a book",
            "Bibliography(x) ::: x is a bibliography",
            "Background(x) ::: x is a background material"
        ],
        "premises-FOL": [
            "∀x (PhilatelicLit(x) → (Stamp(x) ∨ Periodical(x) ∨ Auction(x) ∨ Book(x) ∨ Bibliography(x) ∨ Background(x))) ::: If x is a piece of philatelic literature then it is a stamp catalogue, periodical, auction catalogue, book, bibliography, or background material.",
            "¬Stamp(mort) ::: Mort is not a stamp catalogue.",
            "¬(Periodical(mort) ∨ Auction(mort) ∨ Bibliography(mort) ∨ Background(mort)) ::: Mort is not a periodical, auction catalogue, bibliography, or background material.",
            "PhilatelicLit(mort) ::: Mort is a piece of Philatelic literature."
        ]
    },
    {
        "premises-NL": [
            "Adventures of Rusty is a drama film and children's film.",
            "Columbia Pictures produced Adventures of Rusty",
            "Tintin was produced by Paramount.",
            "Tintin is an adventure film."
        ],
        "predicates": [
            "DramaFilm(x) ::: x is a drama film",
            "ChildrensFilm(x) ::: x is a children's film",
            "Produced(x, y) ::: x produced y",
            "AdventureFilm(x) ::: x is an adventure film"
        ],
        "premises-FOL": [
            "DramaFilm(adventuresofrusty) ∧ ChildrensFilm(adventuresofrusty) ::: Adventures of Rusty is a drama film and children's film.",
            "Produced(columbiapictures, adventuresofrusty) ::: Columbia Pictures produced Adventures of Rusty",
            "Produced(paramount, tintin) ::: Tintin was produced by Paramount.",
            "AdventureFilm(tintin) ::: Tintin is an adventure film."
        ]
    },
    {
        "premises-NL": [
            "Deng Xiaoping served as the paramount leader of the People's Republic of China (PRC). ",
            "Deng Xiaoping was praised for his reaffirmation of the reform program in his Southern Tour of 1992 as well as the reversion of Hong Kong to Chinese control in 1997 and the return of Macau in 1999.",
            "As the party's Secretary-General under Mao and Vice Premier in he 1950s, Deng Xiaoping presided over the Anti-Rightist Campaign launched by Mao.",
            "Deng Xiaoping became instrumental in China's economic reconstruction following the disastrous Great Leap Forward (1958–1960).",
            "Mao Zedong died in 1976.",
            "After Mao Zedong's death, Deng Xiaoping gradually rose to supreme power."
        ],
        "predicates": [
            "ServedAs(x, y) ::: x served as y",
            "ParamountLeaderOf(x, y) ::: x is the paramount leader of y",
            "PraisedFor(x, y) ::: x was praised for y",
            "ReaffirmationOf(x, y) ::: reaffirmation of x in y",
            "ReversionOf(x, y) ::: reversion of x",
            "ReturnOf(x, y) ::: return of x",
            "PartySecretaryGeneral(x) ::: x is the party secretary general",
            "Under(x, y) ::: x is under y",
            "VicePremier(x) ::: x is the vice premier",
            "PresidedOver(x, y) ::: x presided over y",
            "LaunchedBy(x, y) ::: x was launched by y",
            "InstrumentalIn(x, y) ::: x was instrumental in y",
            "EconomicReconstruction(x) ::: x is an economic reconstruction",
            "Following(x, y) ::: x is following y",
            "Disastrous(x) ::: x is disastrous",
            "DiedIn(x, y) ::: x died in y",
            "GraduallyRoseTo(x, y) ::: x gradually rose to y"
        ],
        "premises-FOL": [
            "ServedAs(dengxiaoping, paramountleader) ::: Deng Xiaoping served as the paramount leader",
            "ParamountLeaderOf(paramountleader, prc) ::: The paramount leader is of the People's Republic of China",
            "PraisedFor(dengxiaoping, reaffirmationofreformprogram) ::: Deng Xiaoping was praised for reaffirmation of the reform program",
            "ReaffirmationOf(reformprogram, southerntour) ::: The reform program is in his Southern Tour",
            "PraisedFor(dengxiaoping, reversionofhongkong) ::: Deng Xiaoping was praised for the reversion of Hong Kong",
            "PraisedFor(dengxiaoping, returnofmacau) ::: Deng Xiaoping was praised for the return of Macau",
            "ReturnOf(macau, y1999) ::: The return of Macau in 1999",
            "PartySecretaryGeneral(dengxiaoping) ::: Deng Xiaoping was the party's Secretary-General",
            "Under(dengxiaoping, mao) ::: Deng Xiaoping was under Mao",
            "VicePremier(dengxiaoping) ::: Deng Xiaoping was Vice Premier",
            "PresidedOver(dengxiaoping, antirightistcampaign) ::: Deng Xiaoping presided over the Anti-Rightist Campaign",
            "LaunchedBy(antirightistcampaign, mao) ::: The Anti-Rightist Campaign was launched by Mao",
            "InstrumentalIn(dengxiaoping, chinaseconomicreconstruction) ::: Deng Xiaoping became instrumental in China's economic reconstruction",
            "Following(chinaseconomicreconstruction, greatleapforward) ::: The economic reconstruction followed the Great Leap Forward",
            "Disastrous(greatleapforward) ::: The Great Leap Forward was disastrous",
            "DiedIn(maozedong, y1976) ::: Mao Zedong died in 1976",
            "GraduallyRoseTo(dengxiaoping, supremepower) ::: Deng Xiaoping gradually rose to supreme power"
        ]
    },
    {
        "premises-NL": [
            "All imaginative processes are produced in human brains.",
            "All science-fiction is from an imaginative process.",
            "Either science-fiction or fact. ",
            "No facts are proven to be false.",
            "Dune is a science-fiction or proven to be false."
        ],
        "predicates": [
            "ImaginativeProcess(x) ::: x is an imaginative process",
            "ProducedInHumanBrains(x) ::: x is produced in human brains",
            "Science-fiction(x) ::: x is science-fiction",
            "Fact(x) ::: x is a fact",
            "ProvedToBeFalse(x) ::: x is proven to be false"
        ],
        "premises-FOL": [
            "∀x (ImaginativeProcess(x) → ProducedInHumanBrains(x)) ::: All imaginative processes are produced in human brains.",
            "∀x (Science-fiction(x) → ImaginativeProcess(x)) ::: All science-fiction is from an imaginative process.",
            "∀x (Science-fiction(x) ∨ Fact(x)) ::: Either science-fiction or fact.",
            "∀x (Fact(x) → ¬ProvedToBeFalse(x)) ::: No facts are proven to be false.",
            "Science-fiction(dune) ∨ ProvedToBeFalse(dune) ::: Dune is a science-fiction or proven to be false."
        ]
    },
    {
        "premises-NL": [
            "An American superhero comes from either DC universe or Marvel universe.",
            "Captain America is a superhero.",
            "Captain America is an American.",
            "Captain America does not come from DC universe.",
            "If a superhero is American, he speaks English.",
            "A superhero speaks English or Spanish."
        ],
        "predicates": [
            "Superhero(x) ::: x is a superhero",
            "American(x) ::: x is American",
            "ComeFrom(x, y) ::: x comes from universe y",
            "Speak(x, y) ::: x speaks language y"
        ],
        "premises-FOL": [
            "∀x (Superhero(x) ∧ American(x) → (ComeFrom(x, dc universe) ⊕ ComeFrom(x, marvel universe))) ::: If someone is an American superhero, then they come from either DC universe or Marvel universe.",
            "Superhero(captain america) ::: Captain America is a superhero.",
            "American(captain america) ::: Captain America is American.",
            "¬ComeFrom(captain america, dc universe) ::: Captain America does not come from the DC universe.",
            "∀x (Superhero(x) ∧ American(x) → Speak(x, english)) ::: If someone is a superhero and is American, then they speak English.",
            "∀x (Superhero(x) → (Speak(x, english) ∨ Speak(x, spanish))) ::: If someone is a superhero, then they speak English or Spanish."
        ]
    },
    {
        "premises-NL": [
            "Robert Zimmer was born in Germany.",
            "Robert Zimmer is an essayist.",
            "Robert Zimmer was born in 1953.",
            "Every essayist is a writer.",
            "Every person born in Germany is German."
        ],
        "predicates": [
            "BornInGermany(x) ::: x was born in Germany",
            "IsEssayist(x) ::: x is an essayist",
            "BornIn(x, y) ::: x was born in year y",
            "IsWriter(x) ::: x is a writer",
            "IsGerman(x) ::: x is German"
        ],
        "premises-FOL": [
            "BornInGermany(robertZimmer) ::: Robert Zimmer was born in Germany",
            "IsEssayist(robertZimmer) ::: Robert Zimmer is an essayist",
            "BornIn(robertZimmer, 1953) ::: Robert Zimmer was born in 1953",
            "∀x (IsEssayist(x) → IsWriter(x)) ::: Every essayist is a writer",
            "∀x (BornInGermany(x) → IsGerman(x)) ::: Every person born in Germany is German"
        ]
    },
    {
        "premises-NL": [
            "All people who repay their loans on time have a high credit score.",
            "Some people with high credit scores and high salaries are approved for mortgages.",
            "John has a high salary."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Repay(x) ::: x repays their loans on time",
            "HighCreditScore(x) ::: x has a high credit score",
            "HighSalary(x) ::: x has a high salary",
            "Mortgage(x) ::: x is approved for a mortgage"
        ],
        "premises-FOL": [
            "∀x (Person(x) ∧ Repay(x) → HighCreditScore(x)) ::: All people who repay their loans on time have a high credit score.",
            "∃x (Person(x) ∧ HighCreditScore(x) ∧ HighSalary(x) ∧ Mortgage(x)) ::: Some people with high credit scores and high salaries are approved for mortgages.",
            "Person(john) ∧ HighSalary(john) ::: John has a high salary."
        ]
    },
    {
        "premises-NL": [
            "All students are members of the university.",
            "All graduate students are students.",
            "All PhD students are graduate students.",
            "Some PhD students have high IQs.",
            "If John is not a PhD student, then he is not a member of the university.",
            "If John has a high IQ, then he is a PhD student or a graduate student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "MemberOfUniversity(x) ::: x is a member of the university",
            "GraduateStudent(x) ::: x is a graduate student",
            "PhDStudent(x) ::: x is a PhD student",
            "HighIQ(x) ::: x has high IQ"
        ],
        "premises-FOL": [
            "∀x (Student(x) → MemberOfUniversity(x)) ::: All students are members of the university.",
            "∀x (GraduateStudent(x) → Student(x)) ::: All graduate students are students.",
            "∀x (PhDStudent(x) → GraduateStudent(x)) ::: All PhD students are graduate students.",
            "∃x (PhDStudent(x) ∧ HighIQ(x)) ::: Some PhD students have high IQs.",
            "¬PhDStudent(john) → ¬MemberOfUniversity(john) ::: If John is not a PhD student, then he is not a member of the university.",
            "HighIQ(john) → PhDStudent(john) ∨ GraduateStudent(john) ::: If John has a high IQ, then he is a PhD student or a graduate student."
        ]
    },
    {
        "premises-NL": [
            "All sports cars are loud.",
            "No loud cars are electric.",
            "If a car is a Ferrari, then it is a sports car.",
            "All cars made in Maranello are Ferrari",
            "If Prius is neither a sports car nor a loud car, then Prius is a Maranello-made car or a loud car."
        ],
        "predicates": [
            "SportsCar(x) ::: x is a sports car",
            "LoudCar(x) ::: x is a loud car",
            "ElectricCar(x) ::: x is an electric car",
            "Ferrari(x) ::: x is a Ferrari",
            "MadeInMaranello(x) ::: x is made in Maranello"
        ],
        "premises-FOL": [
            "∀x (SportsCar(x) → LoudCar(x)) ::: All sports cars are loud.",
            "∀x (LoudCar(x) → ¬ElectricCar(x)) ::: No loud cars are electric.",
            "∀x (Ferrari(x) → SportsCar(x)) ::: If a car is a Ferrari, then it is a sports car.",
            "∀x (MadeInMaranello(x) → Ferrari(x)) ::: All cars made in Maranello are Ferrari.",
            "¬SportsCar(prius) ∨ ¬LoudCar(prius) → MadeInMaranello(prius) ∨ LoudCar(prius) ::: If Prius is neither a sports car nor a loud car, then Prius is a Maranello-made car or a loud car."
        ]
    },
    {
        "premises-NL": [
            "If something is a plant, then it is not a cute animal.",
            "All flowers are plants.",
            "Every kitten is a cute animal.",
            "If something is grown in a garden, then it is a flower.",
            "Piper is a kitten or a cute animal."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "CuteAnimal(x) ::: x is a cute animal",
            "Flower(x) ::: x is a flower",
            "Kitten(x) ::: x is a kitten",
            "GrownInGarden(x) ::: x is grown in a garden"
        ],
        "premises-FOL": [
            "∀x (Plant(x) → ¬CuteAnimal(x)) ::: If something is a plant, then it is not a cute animal.",
            "∀x (Flower(x) → Plant(x)) ::: All flowers are plants.",
            "∀x (Kitten(x) → CuteAnimal(x)) ::: Every kitten is a cute animal.",
            "∀x (GrownInGarden(x) → Flower(x)) ::: If something is grown in a garden, then it is a flower.",
            "Kitten(piper) ∨ CuteAnimal(piper) ::: Piper is a kitten or a cute animal."
        ]
    },
    {
        "premises-NL": [
            "Guam has participated in the Winter Olympics.",
            "In 1988, the Winter Olympics were held in Calgary.",
            "Guam sent an athlete to the Calgary Winter Olympics.",
            "If Guan sent an athlete to the Calgary Winter Olympics, then it participated in the Calgary Winter Olympics.",
            "Judd Bankert is the only athlete from Guam who has ever competed in the Winter Olympics."
        ],
        "predicates": [
            "ParticipatedIn(x, y) ::: x participated in y",
            "Year(x) ::: x is a year",
            "BeHeld(x, y) ::: x was held in y",
            "SendAthletes(x) ::: x sent athletes",
            "BeFrom(x, y) ::: x is from y"
        ],
        "premises-FOL": [
            "ParticipatedIn(guam, winterolympics) ::: Guam participated in the Winter Olympics",
            "Year(1988) → BeHeld(winterolympics, calgary) ::: If it is the year 1988, then the Winter Olympics were held in Calgary",
            "BeHeld(winterolympics, calgary) → SendAthletes(guam) ::: If the Winter Olympics were held in Calgary, then Guam sent athletes",
            "SendAthletes(guam, calgarywinterolympics) → ParticipatedIn(guam, calgarywinterolympics) ::: If Guam sent athletes to the Calgary Winter Olympics, then it participated in the Calgary Winter Olympics",
            "BeFrom(bankert, guam) ∧ ParticipatedIn(bankert, winterolympics) ::: Judd Bankert is from Guam and participated in the Winter Olympics"
        ]
    },
    {
        "premises-NL": [
            "Michael O'Donnell is a British physician, journalist, author and broadcaster.",
            "One of the word-setters of My Word! was Michael O'Donnell.",
            "The magazine World Medicine was edited by Michael O'Donnell.",
            "Michael O'Donnell was born in Yorkshire as the son of a general practitioner."
        ],
        "predicates": [
            "British(x) ::: x is British",
            "Physician(x) ::: x is a physician",
            "Journalist(x) ::: x is a journalist",
            "Author(x) ::: x is an author",
            "Broadcaster(x) ::: x is a broadcaster",
            "WordSetter(x) ::: x is a word-setter",
            "Magazine(x) ::: x is a magazine",
            "EditedBy(x, y) ::: x is edited by y",
            "BornIn(x, y) ::: x was born in y",
            "Son(x, y) ::: x is the son of y",
            "GeneralPractitioner(x) ::: x is a general practitioner"
        ],
        "premises-FOL": [
            "British(michael) ∧ Physician(michael) ∧ Journalist(michael) ∧ Author(michael) ∧ Broadcaster(michael) ::: Michael O'Donnell is a British physician, journalist, author and broadcaster.",
            "WordSetter(michael) ::: One of the word-setters of My Word! was Michael O'Donnell.",
            "Magazine(worldmedicine) ∧ EditedBy(worldmedicine, michael) ::: The magazine World Medicine was edited by Michael O'Donnell.",
            "∃x (BornIn(michael, yorkshire) ∧ Son(michael, x) ∧ GeneralPractitioner(x)) ::: Michael O'Donnell was born in Yorkshire as the son of a general practitioner."
        ]
    },
    {
        "premises-NL": [
            "No homework is fun.",
            "Some reading is homework."
        ],
        "predicates": [
            "Homework(x) ::: x is homework",
            "IsFun(x) ::: x is fun",
            "IsReading(x) ::: x is reading"
        ],
        "premises-FOL": [
            "∀x (Homework(x) → ¬IsFun(x)) ::: No homework is fun",
            "∃x (IsReading(x) ∧ Homework(x)) ::: Some reading is homework"
        ]
    },
    {
        "premises-NL": [
            "If violence is good, it is justified.",
            "If something is justified, it is lawful."
        ],
        "predicates": [
            "Violence(x) ::: x is violence",
            "Good(x) ::: x is good",
            "Justified(x) ::: x is justified",
            "Lawful(x) ::: x is lawful"
        ],
        "premises-FOL": [
            "∀x ((Violence(x) ∧ Good(x)) → Justified(x)) ::: If violence is good, it is justified.",
            "∀x (Justified(x) → Lawful(x)) ::: If something is justified, it is lawful."
        ]
    },
    {
        "premises-NL": [
            "All people who have a horse ranch regularly ride horses for pleasure and sport.",
            "All people who have a lot of disposable income have a horse ranch.",
            "If people compete in horse dressage shows, then they have a lot of disposable income.",
            "If people compete in horse dressage shows, then they have invested in high-quality equestrian gear and equipment.",
            "If people regularly ride horses for pleasure and sport, then they do not live in cramped residential buildings.",
            "Manny either has a horse ranch and lives in cramped residential buildings, or he neither has a horse ranch nor lives in cramped residential buildings."
        ],
        "predicates": [
            "Ranch(x) ::: x has a horse ranch",
            "RegularlyRide(x) ::: x regularly rides horses for pleasure and sport",
            "DisposableIncome(x) ::: x has a lot of disposable income",
            "Compete(x) ::: x competes in horse dressage shows",
            "Invested(x) ::: x has invested in high-quality equestrian gear and equipment",
            "Cramped(x) ::: x lives in cramped residential buildings"
        ],
        "premises-FOL": [
            "∀x (Ranch(x) → RegularlyRide(x)) ::: All people who have a horse ranch regularly ride horses for pleasure and sport.",
            "∀x (DisposableIncome(x) → Ranch(x)) ::: All people who have a lot of disposable income have a horse ranch.",
            "∀x (Compete(x) → DisposableIncome(x)) ::: If people compete in horse dressage shows, then they have a lot of disposable income.",
            "∀x (Compete(x) → Invested(x)) ::: If people compete in horse dressage shows, then they have invested in high-quality equestrian gear and equipment.",
            "∀x (RegularlyRide(x) → ¬Cramped(x)) ::: If people regularly ride horses for pleasure and sport, then they do not live in cramped residential buildings.",
            "(Ranch(manny) ∧ Cramped(manny)) ⊕ (¬Ranch(manny) ∧ ¬Cramped(manny)) ::: Manny either has a horse ranch and lives in cramped residential buildings, or he neither has a horse ranch nor lives in cramped residential buildings."
        ]
    },
    {
        "premises-NL": [
            "A roundel is a rounded artillery fortification.",
            "A roundel is not higher than adjacent walls. ",
            "Cannons can be deployed on artillery fortifications. ",
            "Roundels are the oldest artillery fortifications.",
            "Battery towers are an artillery fortification."
        ],
        "predicates": [
            "Roundel(x) ::: x is a roundel",
            "Rounded(x) ::: x is rounded",
            "ArtilleryFortification(x) ::: x is an artillery fortification",
            "Higher(x, y) ::: x is higher than y",
            "AdjacentWall(y) ::: y is an adjacent wall",
            "DeployCannons(x) ::: Cannons can be deployed on x",
            "Older(x, y) ::: x is older than y",
            "BatteryTower(x) ::: x is a battery tower"
        ],
        "premises-FOL": [
            "∀x (Roundel(x) → Rounded(x) ∧ ArtilleryFortification(x)) ::: A roundel is a rounded artillery fortification.",
            "∀x ∀y (Roundel(x) ∧ AdjacentWall(y) → ¬Higher(x, y)) ::: A roundel is not higher than adjacent walls.",
            "∀x (ArtilleryFortification(x) → DeployCannons(x)) ::: Cannons can be deployed on artillery fortifications.",
            "∀x ∀y (Roundel(x) ∧ ArtilleryFortification(x) ∧ ArtilleryFortification(y) → Older(x, y)) ::: Roundels are the oldest artillery fortifications.",
            "∀x (BatteryTower(x) → ArtilleryFortification(x)) ::: Battery towers are an artillery fortification."
        ]
    },
    {
        "premises-NL": [
            "All tissues are soft.",
            "Some papers are tissues."
        ],
        "predicates": [
            "Tissue(x) ::: x is a tissue",
            "Soft(x) ::: x is soft",
            "Paper(x) ::: x is a paper"
        ],
        "premises-FOL": [
            "∀x (Tissue(x) → Soft(x)) ::: All tissues are soft.",
            "∃x (Paper(x) ∧ Tissue(x)) ::: Some papers are tissues."
        ]
    },
    {
        "premises-NL": [
            "All volunteers receive intangible benefits for their work.",
            "Volunteers work regularly or on an as-needed basis.",
            "Some volunteers are trained.",
            "Volunteers work in groups or individually.",
            "Environmental volunteers contribute toward environmental management or conservation.",
            "Participating in natural disaster response is an example of volunteers working in groups on an as-needed basis."
        ],
        "predicates": [
            "Volunteer(x) ::: x is a volunteer",
            "GetIntangibleBenefits(x) ::: x receives intangible benefits",
            "WorkRegularly(x) ::: x works regularly",
            "WorkAsNeeded(x) ::: x works on an as-needed basis",
            "Trained(x) ::: x is trained",
            "WorkInGroup(x) ::: x works in groups",
            "WorkIndividually(x) ::: x works individually",
            "Environmental(x) ::: x is an environmental volunteer",
            "ContributeTo(x, y) ::: x contributes to y",
            "ParticipateIn(x, y) ::: x participates in y"
        ],
        "premises-FOL": [
            "∀x (Volunteer(x) → GetIntangibleBenefits(x)) ::: All volunteers receive intangible benefits for their work.",
            "∀x (Volunteer(x) → WorkRegularly(x) ∨ WorkAsNeeded(x)) ::: Volunteers work regularly or on an as-needed basis.",
            "∃x (Volunteer(x) ∧ Trained(x)) ::: Some volunteers are trained.",
            "∀x (Volunteer(x) → (WorkInGroup(x) ∨ WorkIndividually(x))) ::: Volunteers work in groups or individually.",
            "∀x (Volunteer(x) ∧ Environmental(x) → (ContributeTo(x, environmentalmanagement) ∨ ContributeTo(x, environmentalconservation))) ::: Environmental volunteers contribute toward environmental management or conservation.",
            "∃x (Volunteer(x) ∧ ParticipateIn(x, naturaldisasterresponse) ∧ WorkInGroup(x) ∧ WorkAsNeeded(x)) ::: Participating in natural disaster response is an example of volunteers working in groups on an as-needed basis."
        ]
    },
    {
        "premises-NL": [
            "All people who are very consistent and enjoy sticking to their regular routines do not like surprises.",
            "If people wear flannel shirts every day, then they are very consistent and enjoy sticking to their regular routines.",
            "If people do not like shopping for clothes and other materialistic goods, then they wear flannel shirts every day.",
            "All old people living in stable homes do not like surprises.",
            "If people have very high energy and are impulsive, then they like surprises.",
            "If Mike is not a person who wears flannel shirts every day and has very high energy and is impulsive, then Mike either is very consistent and enjoys sticking to his regular routines or does not like surprises."
        ],
        "predicates": [
            "Person(x) ::: x is a person",
            "Consistent(x) ::: x is very consistent and enjoys sticking to their regular routines",
            "NoSurprises(x) ::: x does not like surprises",
            "Flannel(x) ::: x wears flannel shirts every day",
            "NoShopping(x) ::: x does not like shopping for clothes and other materialistic goods",
            "Old(x) ::: x is old and living in a stable home",
            "Impulsive(x) ::: x has very high energy and is impulsive"
        ],
        "premises-FOL": [
            "∀x (Person(x) ∧ Consistent(x) → NoSurprises(x)) ::: All people who are very consistent and enjoy sticking to their regular routines do not like surprises.",
            "∀x (Person(x) ∧ Flannel(x) → Consistent(x)) ::: If people wear flannel shirts every day, then they are very consistent and enjoy sticking to their regular routines.",
            "∀x (Person(x) ∧ NoShopping(x) → Flannel(x)) ::: If people do not like shopping for clothes and other materialistic goods, then they wear flannel shirts every day.",
            "∀x (Person(x) ∧ Old(x) → NoSurprises(x)) ::: All old people living in stable homes do not like surprises.",
            "∀x (Person(x) ∧ Impulsive(x) → ¬NoSurprises(x)) ::: If people have very high energy and are impulsive, then they like surprises.",
            "¬(Person(mike) ∧ Flannel(mike) ∧ Impulsive(mike)) → (Consistent(mike) ∨ NoSurprises(mike)) ::: If Mike is not a person who wears flannel shirts every day and has very high energy and is impulsive, then Mike either is very consistent and enjoys sticking to his regular routines or does not like surprises."
        ]
    },
    {
        "premises-NL": [
            "Adam owns cars.",
            "Adam has a favorite car.",
            "Among the cars he owns, Adam's favorite car is European.",
            "Adam broke his favorite car."
        ],
        "predicates": [
            "Owns(x, y) ::: x owns y",
            "Favorite(x, y) ::: y is x's favorite",
            "European(x) ::: x is European",
            "Broke(x, y) ::: x broke y"
        ],
        "premises-FOL": [
            "∃x Owns(adam, x) ::: Adam owns something x",
            "∃x Favorite(adam, x) ::: Adam has a favorite thing x",
            "∀x ((Owns(adam, x) ∧ Favorite(adam, x)) → European(x)) ::: For all x, if Adam owns x and x is Adam's favorite, then x is European",
            "∃x ((Owns(adam, x) ∧ Favorite(adam, x) ∧ Broke(adam, x)) ::: There exists an x, such that Adam owns x and x is Adam's favorite and Adam broke x"
        ]
    },
    {
        "premises-NL": [
            "No buildings in New Haven are higher than 400 meters. ",
            "All buildings managed by Yale Housing are in New Haven. ",
            "All buildings in Manhattan are higher than 400 meters. ",
            "All buildings owned by Bloomberg are in Manhattan. ",
            "All buildings with the Bloomberg logo are buildings owned by Bloomberg. ",
            "Tower A is neither in New Haven nor in Manhattan.",
            "Tower B is a building with the Bloomberg logo and in Manhattan. "
        ],
        "predicates": [
            "NewHaven(x) ::: x is in New Haven",
            "High(x) ::: x is higher than 400 meters",
            "YaleHousing(x) ::: x is managed by Yale Housing",
            "Manhattan(x) ::: x is in Manhattan",
            "Bloomberg(x) ::: x is owned by Bloomberg",
            "BloombergLogo(x) ::: x is a building with the Bloomberg logo"
        ],
        "premises-FOL": [
            "∀x (NewHaven(x) → ¬High(x)) ::: No buildings in New Haven are higher than 400 meters.",
            "∀x (YaleHousing(x) → NewHaven(x)) ::: All buildings managed by Yale Housing are in New Haven.",
            "∀x (Manhattan(x) → High(x)) ::: All buildings in Manhattan are higher than 400 meters.",
            "∀x (Bloomberg(x) → Manhattan(x)) ::: All buildings owned by Bloomberg are in Manhattan.",
            "∀x (BloombergLogo(x) → Bloomberg(x)) ::: All buildings with the Bloomberg logo are buildings owned by Bloomberg.",
            "¬(NewHaven(towera) ∨ Manhattan(towera)) ::: Tower A is neither in New Haven nor in Manhattan.",
            "BloombergLogo(towerb) ∧ Manhattan(towerb) ::: Tower B is a building with the Bloomberg logo and in Manhattan."
        ]
    },
    {
        "premises-NL": [
            "No fish are birds.",
            "Everything that is an osprey is a bird.",
            "If something is a carp, then it is a fish.",
            "All goldfish are carp.",
            "If Bubbles is either an osprey or a goldfish, then Bubbles is not a fish."
        ],
        "predicates": [
            "Fish(x) ::: x is a fish",
            "Bird(x) ::: x is a bird",
            "Osprey(x) ::: x is an osprey",
            "Carp(x) ::: x is a carp",
            "Goldfish(x) ::: x is a goldfish"
        ],
        "premises-FOL": [
            "∀x (Fish(x) → ¬Bird(x)) ::: No fish are birds.",
            "∀x (Osprey(x) → Bird(x)) ::: Everything that is an osprey is a bird.",
            "∀x (Carp(x) → Fish(x)) ::: If something is a carp, then it is a fish.",
            "∀x (Goldfish(x) → Carp(x)) ::: All goldfish are carp.",
            "(Osprey(bubbles) ∨ Goldfish(bubbles)) → ¬Fish(bubbles) ::: If Bubbles is either an osprey or a goldfish, then Bubbles is not a fish."
        ]
    },
    {
        "premises-NL": [
            "Mr. and Mrs. Smith make a travel plan, they want to go to a city in California or Florida, and where neither of them has ever been.",
            "Cities in California that they are interested in are San Francisco, Los Angeles, and San Diego.",
            "Cities in Florida that they are interested in are Orlando and Miami.",
            "Mr. Smith has been to two cities in California.",
            "Mrs. Smith has been to one city in Florida."
        ],
        "predicates": [
            "MakePlan(x, y) ::: x and y make a plan",
            "WantToGo(x) ::: someone wants to go to x",
            "California(x) ::: x is in California",
            "Florida(x) ::: x is in Florida",
            "NeverGo(x) ::: they have never been to x",
            "Interested(x, y) ::: x is interested in y",
            "SanFrancisco(x) ::: x is San Francisco",
            "LosAngeles(x) ::: x is Los Angeles",
            "SanDiego(x) ::: x is San Diego",
            "Orlando(x) ::: x is Orlando",
            "Miami(x) ::: x is Miami",
            "CaliforniaCityVisited(x, y) ::: x has been to y cities in California",
            "FloridaCityVisited(x, y) ::: x has been to y cities in Florida"
        ],
        "premises-FOL": [
            "MakePlan(mr.smith, mrs.smith) ::: Mr. and Mrs. Smith make a travel plan",
            "∀x (WantToGo(x) → (California(x) ∨ Florida(x)) ∧ NeverGo(mr.smith, x) ∧ NeverGo(mrs.smith, x)) ::: they want to go to a city in California or Florida, and where neither of them has ever been",
            "∀x (((SanFrancisco(x) ∨ LosAngeles(x) ∨ SanDiego(x)) ∧ California(x) ∧ Interested(mr.smith, x) ∧ Interested(mrs.smith, x)) → WantToGo(x)) ::: Cities in California that they are interested in are San Francisco, Los Angeles, and San Diego",
            "∀x (((Orlando(x) ∨ Miami(x)) ∧ Florida(x) ∧ Interested(mr.smith, x) ∧ Interested(mrs.smith, x)) → WantToGo(x)) ::: Cities in Florida that they are interested in are Orlando and Miami",
            "CaliforniaCityVisited(mr.smith, two) ::: Mr. Smith has been to two cities in California",
            "FloridaCityVisited(mrs.smith, one) ::: Mrs. Smith has been to one city in Florida"
        ]
    },
    {
        "premises-NL": [
            "Everything is either big or small.",
            "All big things are heavy. ",
            "All small things are light. ",
            "All heavy things are still.",
            "All light things are unstable.",
            "All unstable things are changing.",
            "All unstable things are kinetic. ",
            "A bird is not both heavy and still."
        ],
        "predicates": [
            "Big(x) ::: x is big",
            "Small(x) ::: x is small",
            "Heavy(x) ::: x is heavy",
            "Still(x) ::: x is still",
            "Light(x) ::: x is light",
            "Unstable(x) ::: x is unstable",
            "Changing(x) ::: x is changing",
            "Kinetic(x) ::: x is kinetic"
        ],
        "premises-FOL": [
            "∀x (Big(x) ∨ Small(x)) ::: Everything is either big or small.",
            "∀x (Big(x) → Heavy(x)) ::: All big things are heavy.",
            "∀x (Small(x) → Light(x)) ::: All small things are light.",
            "∀x (Heavy(x) → Still(x)) ::: All heavy things are still.",
            "∀x (Light(x) → Unstable(x)) ::: All light things are unstable.",
            "∀x (Unstable(x) → Changing(x)) ::: All unstable things are changing.",
            "∀x (Unstable(x) → Kinetic(x)) ::: All unstable things are kinetic.",
            "¬(Heavy(bird) ∧ Still(bird)) ::: A bird is not both heavy and still."
        ]
    },
    {
        "premises-NL": [
            "DI Ray is a police procedural television series.",
            "DI Ray was created and written by Maya Sondhi.",
            "DI Ray was produced by Jed Mercurio.",
            "Maya Sondhi and Jed Mercurio are both British."
        ],
        "predicates": [
            "TelevisionSeries(x) ::: x is a television series",
            "PoliceProcedural(x) ::: x is a police procedural",
            "Create(x, y) ::: x created y",
            "Write(x, y) ::: x wrote y",
            "Produce(x, y) ::: x produced y",
            "British(x) ::: x is British"
        ],
        "premises-FOL": [
            "PoliceProcedural(diRay) ∧ TelevisionSeries(diRay) ::: DI Ray is a police procedural television series.",
            "Create(maya, diRay) ∧ Write(maya, diRay) ::: DI Ray was created and written by Maya Sondhi.",
            "Produce(jed, diRay) ::: DI Ray was produced by Jed Mercurio.",
            "British(maya) ∧ British(jed) ::: Maya Sondhi and Jed Mercurio are both British."
        ]
    },
    {
        "premises-NL": [
            "All men are human.",
            "All gentlemen are men.",
            "All lawyers are gentlemen.",
            "All women are human.",
            "No sheep are human.",
            "If Mike is not both a human and a sheep, then Mike is either a man or a human."
        ],
        "predicates": [
            "Man(x) ::: x is a man",
            "Human(x) ::: x is a human",
            "Gentleman(x) ::: x is a gentleman",
            "Lawyer(x) ::: x is a lawyer",
            "Woman(x) ::: x is a woman",
            "Sheep(x) ::: x is a sheep"
        ],
        "premises-FOL": [
            "∀x (Man(x) → Human(x)) ::: All men are human",
            "∀x (Gentleman(x) → Man(x)) ::: All gentlemen are men",
            "∀x (Lawyer(x) → Gentleman(x)) ::: All lawyers are gentlemen",
            "∀x (Woman(x) → Human(x)) ::: All women are human",
            "∀x (Sheep(x) → ¬Human(x)) ::: No sheep are human",
            "¬(Human(mike) ∧ Sheep(mike)) → (Man(mike) ∨ Human(mike)) ::: If Mike is not both a human and a sheep, then Mike is either a man or a human"
        ]
    },
    {
        "premises-NL": [
            "Some defenders are centerback.",
            "All defenders are soccer players.",
            "No soccer players are professional basketball players.",
            "All NBA players are professional basketball players.",
            "Stephen Curry is an NBA player."
        ],
        "predicates": [
            "Defender(x) ::: x is a defender",
            "Centerback(x) ::: x is a centerback",
            "SoccerPlayer(x) ::: x is a soccer player",
            "ProfessionalBasketballPlayer(x) ::: x is a professional basketball player",
            "NBAPlayer(x) ::: x is an NBA player"
        ],
        "premises-FOL": [
            "∃x (Defender(x) ∧ Centerback(x)) ::: Some defenders are centerback.",
            "∀x (Defender(x) → SoccerPlayer(x)) ::: All defenders are soccer players.",
            "¬(∃x (SoccerPlayer(x) ∧ ProfessionalBasketballPlayer(x))) ::: No soccer players are professional basketball players.",
            "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x)) ::: All NBA players are professional basketball players.",
            "NBAPlayer(stephencurry) ::: Stephen Curry is an NBA player."
        ]
    },
    {
        "premises-NL": [
            "All artificial satellites are important scientific achievements.",
            "Some artificial satellites are not U.S. inventions."
        ],
        "predicates": [
            "ArtificialSatellite(x) ::: x is an artificial satellite",
            "ImportantScientificAchievement(x) ::: x is an important scientific achievement",
            "USInvention(x) ::: x is a U.S. invention"
        ],
        "premises-FOL": [
            "∀x (ArtificialSatellite(x) → ImportantScientificAchievement(x)) ::: All artificial satellites are important scientific achievements.",
            "∃x (ArtificialSatellite(x) ∧ ¬USInvention(x)) ::: Some artificial satellites are not U.S. inventions."
        ]
    },
    {
        "premises-NL": [
            "Some cats are not pets.",
            "All cats are mammals."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Pet(x) ::: x is a pet",
            "Mammal(x) ::: x is a mammal"
        ],
        "premises-FOL": [
            "∃x (Cat(x) ∧ ¬Pet(x)) ::: Some cats are not pets.",
            "∀x (Cat(x) → Mammal(x)) ::: All cats are mammals."
        ]
    },
    {
        "premises-NL": [
            "If people visit a coffee shop at least three times a week, then they are addicted to coffee or other caffeinated drinks.",
            "People either visit a coffee shop at least three times a week or order takeout at least once a day.",
            "If people make a lot of their own food at home using recipes and online guides, then they order takeout at least once a day.",
            "If people own at least one coffeemaker and one blender in their home, then they do not order takeout at least once a day.",
            "All people who lead very busy lives that include 12-hour work hours make a lot of their own food at home using recipes and online guides.",
            "Sam is either both addicted to coffee or other caffeinated drinks or leads very busy lives that include 12-hour work hours, or she is neither addicted to coffee and other caffeinated drinks nor leads very busy lives that include 12-hour work hours"
        ],
        "predicates": [
            "CoffeeShop(x) ::: x visits a coffee shop at least three times a week",
            "CaffeineAddict(x) ::: x is addicted to coffee or other caffeinated drinks",
            "Takeout(x) ::: x orders takeout at least once a day",
            "MakeFood(x) ::: x makes a lot of their own food at home using recipes and online guides",
            "KitchenAppliance(x) ::: x owns at least one coffeemaker and one blender in their home",
            "Busy(x) ::: x leads very busy lives that include 12-hour work hours"
        ],
        "premises-FOL": [
            "∀x (CoffeeShop(x) → CaffeineAddict(x)) ::: If people visit a coffee shop at least three times a week, then they are addicted to coffee or other caffeinated drinks.",
            "∀x (CoffeeShop(x) ∨ Takeout(x)) ::: People either visit a coffee shop at least three times a week or order takeout at least once a day.",
            "∀x (MakeFood(x) → Takeout(x)) ::: If people make a lot of their own food at home using recipes and online guides, then they order takeout at least once a day.",
            "∀x (KitchenAppliance(x) → ¬Takeout(x)) ::: If people own at least one coffeemaker and one blender in their home, then they do not order takeout at least once a day.",
            "∀x (Busy(x) → MakeFood(x)) ::: All people who lead very busy lives that include 12-hour work hours make a lot of their own food at home using recipes and online guides.",
            "(CaffeineAddict(sam) ∧ Busy(sam)) ⊕ (¬CaffeineAddict(sam) ∧ ¬Busy(sam)) ::: Sam is either both addicted to coffee or other caffeinated drinks or leads very busy lives that include 12-hour work hours, or she is neither addicted to coffee and other caffeinated drinks nor leads very busy lives that include 12-hour work hours"
        ]
    },
    {
        "premises-NL": [
            "No professional basketball players are soccer players.",
            "All NBA players are professional basketball players.",
            "All defenders are soccer players.",
            "All centerbacks are defenders.",
            "Roger Federer is not an NBA player or a defender."
        ],
        "predicates": [
            "SoccerPlayer(x) ::: x is a soccer player",
            "ProfessionalBasketballPlayer(x) ::: x is a professional basketball player",
            "NBAPlayer(x) ::: x is an NBA player",
            "Defender(x) ::: x is a defender",
            "Centerback(x) ::: x is a centerback"
        ],
        "premises-FOL": [
            "¬(∃x (SoccerPlayer(x) ∧ ProfessionalBasketballPlayer(x))) ::: No professional basketball players are soccer players.",
            "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x)) ::: All NBA players are professional basketball players.",
            "∀x (Defender(x) → SoccerPlayer(x)) ::: All defenders are soccer players.",
            "∀x (Centerback(x) → Defender(x)) ::: All centerbacks are defenders.",
            "¬(NBAPlayer(rogerfederer) ∨ Defender(rogerfederer)) ::: Roger Federer is not an NBA player or a defender."
        ]
    },
    {
        "premises-NL": [
            "Some teachers working at a pool are not nice.",
            "All teachers working at pools are pool managers.",
            "All pool managers are lifeguards.",
            "If someone is a lifeguard, then they work at a pool.",
            "Mary does not work at a pool."
        ],
        "predicates": [
            "TeacherWorkingAtPool(x) ::: x is a teacher working at a pool",
            "Nice(x) ::: x is nice",
            "PoolManager(x) ::: x is a pool manager",
            "Lifeguard(x) ::: x is a lifeguard",
            "WorkAtPool(x) ::: x works at a pool"
        ],
        "premises-FOL": [
            "∃x (TeacherWorkingAtPool(x) ∧ ¬Nice(x)) ::: Some teachers working at a pool are not nice.",
            "∀x (TeacherWorkingAtPool(x) → PoolManager(x)) ::: All teachers working at pools are pool managers.",
            "∀x (PoolManager(x) → Lifeguard(x)) ::: All pool managers are lifeguards.",
            "∀x (Lifeguard(x) → WorkAtPool(x)) ::: If someone is a lifeguard, then they work at a pool.",
            "¬WorkAtPool(mary) ::: Mary does not work at a pool."
        ]
    },
    {
        "premises-NL": [
            "Not all art pieces require talent.",
            "Everything that requires talent requires practice."
        ],
        "predicates": [
            "ArtPiece(x) ::: x is an art piece",
            "RequiresTalent(x) ::: x requires talent",
            "RequiresPractice(x) ::: x requires practice"
        ],
        "premises-FOL": [
            "∃x (ArtPiece(x) ∧ ¬RequiresTalent(x)) ::: Not all art pieces require talent.",
            "∀x (RequiresTalent(x) → RequiresPractice(x)) ::: Everything that requires talent requires practice."
        ]
    },
    {
        "premises-NL": [
            "Bernarda Bryson Shahn was a painter and lithographer.",
            "Bernarda Bryson Shahn was born in Athens, Ohio. ",
            "Bernarda Bryson Shahn was married to Ben Shahn.",
            "People born in Athens, Ohio are Americans."
        ],
        "predicates": [
            "Painter(x) ::: x is a painter",
            "Lithographer(x) ::: x is a lithographer",
            "BornIn(x, y) ::: x was born in y",
            "MarriedTo(x, y) ::: x was married to y",
            "American(x) ::: x is American"
        ],
        "premises-FOL": [
            "Painter(bernardaBrysonShahn) ∧ Lithographer(bernardaBrysonShahn) ::: Bernarda Bryson Shahn was a painter and lithographer.",
            "BornIn(bernardaBrysonShahn, athensOhio) ::: Bernarda Bryson Shahn was born in Athens, Ohio.",
            "MarriedTo(bernardaBrysonShahn, benShahn) ::: Bernarda Bryson Shahn was married to Ben Shahn.",
            "∀x (BornIn(x, athensOhio) → American(x)) ::: People born in Athens, Ohio are Americans."
        ]
    },
    {
        "premises-NL": [
            "If people upgrade to the newest iPhone model every year, then they are not saving money for a down payment on a new house.",
            "If people enjoy reading about tech specs and keeping up to date on the latest technology, then they upgrade to the newest iPhone model every year.",
            "People either are saving money for a down payment on a new house or they live in apartments in big metropolitan cities.",
            "If people live with at least one roommate then they do not own at least one pet.",
            "All people who own at least one pet live with at least one roommate.",
            "If Emma does not both own at least one pet and live in apartments in big metropolitan cities, then Emma either owns at least one pet and lives in an apartment in big metropolitan cities, or she neither owns a pet nor lives in an apartment in big metropolitan cities. "
        ],
        "predicates": [
            "Iphone(x) ::: x upgrades to the newest iPhone model every year",
            "House(x) ::: x is saving money for a down payment on a new house",
            "Tech(x) ::: x enjoys reading about tech specs and keeping up to date on the latest technology",
            "Apartment(x) ::: x lives in apartments in big metropolitan cities",
            "Roommate(x) ::: x lives with at least one roommate",
            "Pet(x) ::: x owns at least one pet"
        ],
        "premises-FOL": [
            "∀x (Iphone(x) → ¬House(x)) ::: If people upgrade to the newest iPhone model every year, then they are not saving money for a down payment on a new house.",
            "∀x (Tech(x) → Iphone(x)) ::: If people enjoy reading about tech specs and keeping up to date on the latest technology, then they upgrade to the newest iPhone model every year.",
            "∀x (House(x) ∨ Apartment(x)) ::: People either are saving money for a down payment on a new house or they live in apartments in big metropolitan cities.",
            "∀x (Roommate(x) → ¬Pet(x)) ::: If people live with at least one roommate then they do not own at least one pet.",
            "∀x (Pet(x) → Roommate(x)) ::: All people who own at least one pet live with at least one roommate.",
            "¬(Pet(emma) ∧ Apartment(emma)) → ((Pet(emma) ∧ Apartment(emma)) ∨ (¬Pet(emma) ∧ ¬Apartment(emma))) ::: If Emma does not both own at least one pet and live in apartments in big metropolitan cities, then Emma either owns at least one pet and lives in an apartment in big metropolitan cities, or she neither owns a pet nor lives in an apartment in big metropolitan cities. "
        ]
    },
    {
        "premises-NL": [
            "If you are on the payroll, then you are being paid by the school.",
            "If someone has a job at a school, then they are on the payroll.",
            "All faculty members have a job at a school.",
            "One can either be a faculty member or a teacher.",
            "Every teacher has students.",
            "If Nancy is a teacher, then they are on the payroll.",
            "If Nancy is not a teacher, then they are not paid by the school."
        ],
        "predicates": [
            "OnPayroll(x) ::: x is on the payroll",
            "PaidBySchool(x) ::: x is paid by the school",
            "JobAtSchool(x) ::: x has a job at a school",
            "FacultyMember(x) ::: x is a faculty member",
            "Teacher(x) ::: x is a teacher",
            "HasStudents(x) ::: x has students"
        ],
        "premises-FOL": [
            "∀x (OnPayroll(x) → PaidBySchool(x)) ::: If you are on the payroll, then you are being paid by the school.",
            "∀x (JobAtSchool(x) → OnPayroll(x)) ::: If someone has a job at a school, then they are on the payroll.",
            "∀x (FacultyMember(x) → JobAtSchool(x)) ::: All faculty members have a job at a school.",
            "∀x (FacultyMember(x) ∨ Teacher(x)) ::: One can either be a faculty member or a teacher.",
            "∀x (Teacher(x) → HasStudents(x)) ::: Every teacher has students.",
            "Teacher(nancy) → OnPayroll(nancy) ::: If Nancy is a teacher, then they are on the payroll.",
            "¬Teacher(nancy) → ¬PaidBySchool(nancy) ::: If Nancy is not a teacher, then they are not paid by the school."
        ]
    },
    {
        "premises-NL": [
            "A heptalogy, is a compound literary or narrative work that is made up of seven distinct works.",
            "The Harry Potter series consists of 7 distinct works.",
            "The Chronicles of Narnia consists of 7 distinct works."
        ],
        "predicates": [
            "Heptalogy(x) ::: x is a heptalogy",
            "SevenDistinctWorks(x) ::: x consists of seven distinct works"
        ],
        "premises-FOL": [
            "∀x (SevenDistinctWorks(x) → Heptalogy(x)) ::: If x consists of seven distinct works, then x is a heptalogy",
            "SevenDistinctWorks(harryPotter) ::: The Harry Potter series consists of seven distinct works",
            "SevenDistinctWorks(chroniclesofNarnia) ::: The Chronicles of Narnia consists of seven distinct works"
        ]
    },
    {
        "premises-NL": [
            "All people who attend Renaissance fairs regularly enjoy dressing up in old-fashioned and historical period clothing.",
            "If people are fascinated by the history of the Renaissance and other past eras, then they attend Renaissance fairs regularly.",
            "People are either fascinated by the history of the Renaissance and other past eras, or are not nostalgic academics who enjoy learning.",
            "If people are focused on the future and industry professions, then they are not nostalgic academics who enjoy learning.",
            "If people are historical professors who are passionate about their job and subject, then they are nostalgic academics who enjoy learning.",
            "If Clyde is not focused on the future and industry professions, then he is neither focused on the future and industry professions nor enjoys dressing up in old-fashioned and historical period clothing."
        ],
        "predicates": [
            "RenaissanceFair(x) ::: x attends Renaissance fairs regularly",
            "DressingUp(x) ::: x enjoys dressing up in old-fashioned and historical period clothing",
            "HistoryRenaissance(x) ::: x is fascinated by the history of the Renaissance and other past eras",
            "NotAcademics(x) ::: x is not a nostalgic academic who enjoys learning",
            "Industry(x) ::: x is focused on the future and industry professions",
            "HistoryProf(x) ::: x is a historical professor who is passionate about their job and subject"
        ],
        "premises-FOL": [
            "∀x (RenaissanceFair(x) → DressingUp(x)) ::: All people who attend Renaissance fairs regularly enjoy dressing up in old-fashioned and historical period clothing.",
            "∀x (HistoryRenaissance(x) → RenaissanceFair(x)) ::: If people are fascinated by the history of the Renaissance and other past eras, then they attend Renaissance fairs regularly.",
            "∀x (HistoryRenaissance(x) ∨ NotAcademics(x)) ::: People are either fascinated by the history of the Renaissance and other past eras, or are not nostalgic academics who enjoy learning.",
            "∀x (Industry(x) → NotAcademics(x)) ::: If people are focused on the future and industry professions, then they are not nostalgic academics who enjoy learning.",
            "∀x (HistoryProf(x) → NotAcademics(x)) ::: If people are historical professors who are passionate about their job and subject, then they are nostalgic academics who enjoy learning.",
            "¬Industry(clyde) → ¬(Industry(clyde) ∧ DressingUp(clyde)) ::: If Clyde is not focused on the future and industry professions, then he is neither focused on the future and industry professions nor enjoys dressing up in old-fashioned and historical period clothing."
        ]
    },
    {
        "premises-NL": [
            "No sports cars are vehicles intended to be driven at moderate speeds.",
            "All automobiles designed for family use are vehicles intended to be driven at moderate speeds."
        ],
        "predicates": [
            "SportsCar(x) ::: x is a sports car",
            "IntendedToBeDrivenAtModerateSpeeds(x) ::: x is a vehicle intended to be driven at moderate speeds",
            "ForFamilyUse(x) ::: x is an automobile designed for family use"
        ],
        "premises-FOL": [
            "∀x (SportsCar(x) → ¬IntendedToBeDrivenAtModerateSpeeds(x)) ::: No sports cars are vehicles intended to be driven at moderate speeds.",
            "∀x (ForFamilyUse(x) → IntendedToBeDrivenAtModerateSpeeds(x)) ::: All automobiles designed for family use are vehicles intended to be driven at moderate speeds."
        ]
    },
    {
        "premises-NL": [
            "If people work well in teams in their workplace, then they get along with all their colleagues at their work.",
            "If people come to work every day with a positive attitude, then they work well in teams in their workplace.",
            "People either come into work every day with a positive attitude or are always tired every morning.",
            "If people get many promotions from their boss at work, then they receive negative feedback from teams at work.",
            "Kat is either both a person who works well in teams in their workplace and is always tired every morning, or she neither works well in teams in their workplace nor is always tired every morning."
        ],
        "predicates": [
            "WorkTeams(x) ::: x works well in teams in their workplace",
            "Colleagues(x) ::: x gets along with all their colleagues at their work",
            "PositiveAttitude(x) ::: x comes to work every day with a positive attitude",
            "Tired(x) ::: x is always tired every morning",
            "BossPromotions(x) ::: x gets many promotions from their boss at work",
            "NegativeFeedback(x) ::: x receives negative feedback from teams at work"
        ],
        "premises-FOL": [
            "∀x (WorkTeams(x) → Colleagues(x)) ::: If people work well in teams in their workplace, then they get along with all their colleagues at their work.",
            "∀x (PositiveAttitude(x) → WorkTeams(x)) ::: If people come to work every day with a positive attitude, then they work well in teams in their workplace.",
            "∀x (PositiveAttitude(x) ∨ Tired(x)) ::: People either come into work every day with a positive attitude or are always tired every morning.",
            "∀x (BossPromotions(x) → NegativeFeedback(x)) ::: If people get many promotions from their boss at work, then they receive negative feedback from teams at work.",
            "(WorkTeams(kat) ∧ Tired(kat)) ∨ (¬WorkTeams(kat) ∧ ¬Tired(kat)) ::: Kat is either both a person who works well in teams in their workplace and is always tired every morning, or she neither works well in teams in their workplace nor is always tired every morning."
        ]
    },
    {
        "premises-NL": [
            "Drishti is open-source.",
            "Open-source software is free to modify."
        ],
        "predicates": [
            "OpenSource(x) ::: x is open-source",
            "ModifyFree(x) ::: x is free to modify"
        ],
        "premises-FOL": [
            "OpenSource(drishti) ::: Drishti is open source",
            "∀x (OpenSource(x) → ModifyFree(x)) ::: If x is open source, then x is free to modify"
        ]
    },
    {
        "premises-NL": [
            "There are five grades including A+, A, B+, B, and C in English.",
            "If a student gets A+ in English, then his score is greater than 95.",
            "If a student gets A in English, then his score is in the range of 90-95.",
            "Zhang got an A in English.",
            "Wang's English score is better than Zhang's.",
            "Wu's English score is lower than 90."
        ],
        "predicates": [
            "Grade(x) ::: x is a grade",
            "GetGrade(x, y) ::: student x gets grade y",
            "GreaterThan(x, y) ::: x is greater than y",
            "Range(x, y, z) ::: x is in the range of y to z",
            "Better(x, y) ::: x's score is better than y's",
            "LowerThan(x, y) ::: x's score is lower than y"
        ],
        "premises-FOL": [
            "Grade(a+) ∧ Grade(a) ∧ Grade(b+) ∧ Grade(b) ∧ Grade(c) ::: There are five grades including A+, A, B+, B, and C",
            "∀x (GetGrade(x, a+) → GreaterThan(Score(x), 95)) ::: If a student gets A+ in English, then his score is greater than 95.",
            "∀x (GetGrade(x, a) → Range(Score(x), 90, 95)) ::: If a student gets A in English, then his score is in the range of 90-95.",
            "GetGrade(zhang, a) ::: Zhang got an A in English.",
            "Better(Score(wang), Score(zhang)) ::: Wang's English score is better than Zhang's.",
            "LowerThan(Score(wu), 90) ::: Wu's English score is lower than 90."
        ]
    },
    {
        "premises-NL": [
            "Olivia doesn't prefer warm temperature during the day.",
            "When Olivia sleeps, she prefers cool temperature.",
            "Olivia sleeps during the night.",
            "Olivia works during the day.",
            "Olivia either works or sleeps.",
            "The time is either the day or the night.",
            "Olivia either prefers warm temperature or prefers cool temperature."
        ],
        "predicates": [
            "PrefersWarmAt(x, y) ::: x prefers warm temperature at y",
            "PrefersCoolAt(x, y) ::: x prefers cool temperature at y",
            "SleepingDuring(x, y) ::: x sleeps during y",
            "WorkingDuring(x, y) ::: x works during y",
            "Day(x) ::: x is the day",
            "Night(x) ::: x is the night"
        ],
        "premises-FOL": [
            "∀x (Day(x) → ¬PrefersWarmAt(olivia, x)) ::: Olivia doesn't prefer warm temperature during the day.",
            "∀x (SleepingDuring(olivia, x) → PrefersCoolAt(olivia, x)) ::: When Olivia sleeps, she prefers cool temperature.",
            "∀x (SleepingDuring(olivia, x) → Night(x)) ::: Olivia sleeps during the night.",
            "∀x (WorkingDuring(olivia, x) → Day(x)) ::: Olivia works during the day.",
            "∀x (WorkingDuring(olivia, x) ∨ SleepingDuring(olivia, x)) ::: Olivia either works or sleeps.",
            "∀x (Day(x) ∨ Night(x)) ::: The time is either the day or the night.",
            "∀x (PrefersWarmAt(olivia, x) ∨ PrefersCoolAt(olivia, x)) ::: Olivia either prefers warm temperature or prefers cool temperature."
        ]
    },
    {
        "premises-NL": [
            "Taylor Swift gives a commencement speech in New York University in 2022.",
            "Both Columbia University and New York University are located in Manhattan.",
            "Taylor Swift has received three Grammy Album of the Year Awards.",
            "Columbia University is one of the Ivy League schools."
        ],
        "predicates": [
            "Give(x, y, z) ::: x gives y in z",
            "Located(x, y) ::: x is located in y",
            "Receive(x, y) ::: x receives y",
            "Album(x) ::: x is an album",
            "University(x) ::: x is a university",
            "IvyLeague(x) ::: x is an ivy league school"
        ],
        "premises-FOL": [
            "Give(taylorSwift, commencementSpeech, newYorkUniversity) ::: Taylor Swift gives a commencement speech in New York University",
            "Located(columbiaUniversity, manhattan) ∧ Located(newYorkUniversity, manhattan) ::: Both Columbia University and New York University are located in Manhattan.",
            "Receive(taylorSwift, grammyAlbumOfTheYearAwards) ::: Taylor Swift has received three Grammy Album of the Year Awards.",
            "IvyLeague(columbiaUniversity) ::: Columbia University is one of the Ivy League schools."
        ]
    },
    {
        "premises-NL": [
            "Customers either choose Plan A or Plan B.",
            "All who choose Plan B are rewarded with a $30 gift card. ",
            "There are no customers who do not choose any plans. ",
            "No customers rewarded a $30 gift card are older than 80.",
            "Customers are either older than 80 or are currently studying at school. ",
            "James is not a customer who is currently studying at school. "
        ],
        "predicates": [
            "PlanA(x) ::: Customer x choose plan A",
            "PlanB(x) ::: Customer x choose plan B",
            "Award(x) ::: Customer x is rewarded with a $30 gift card",
            "NoPlan(x) ::: Customer x do not choose any plans",
            "OlderThan80(x) ::: Customer x are older than 80",
            "StudyAtSchool(x) ::: Customer x are currently studying at school",
            "Customer(x) ::: x is a customer"
        ],
        "premises-FOL": [
            "∀x (Customer(x) → (PlanA(x) ∨ PlanB(x))) ::: Customers either choose Plan A or Plan B.",
            "∀x (Customer(x) ∧ PlanB(x) → Award(x)) ::: All who choose Plan B are rewarded with a $30 gift card. ",
            "∀x (Customer(x) →  (PlanA(x) ∨ PlanB(x))) ::: There are no customers who do not choose any plans. ",
            "∀x (Customer(x) ∧ Award(x) → ¬OlderThan80(x)) ::: No customers rewarded a $30 gift card are older than 80.",
            "∀x (Customer(x) → (OlderThan80(x) ∨ StudyAtSchool(x))) ::: Customers are either older than 80 or are currently studying at school. ",
            "¬StudyAtSchool(james) ∧ Customer(james) ::: James is not a customer who is currently studying at school."
        ]
    },
    {
        "premises-NL": [
            "Detroit City is a horse.",
            "Some horses are racehorses.",
            "If a horse falls during a race, then it dies.",
            "Detroit City fell during a race.",
            "A horse is a racehorse if it is in a race."
        ],
        "predicates": [
            "Horse(x) ::: x is a horse",
            "Racehorse(x) ::: x is a racehorse",
            "Racing(x) ::: x is in a race",
            "Falls(x) ::: x falls",
            "Dead(x) ::: x is dead"
        ],
        "premises-FOL": [
            "Horse(detroitcity) ::: Detroit City is a horse",
            "∃x (Horse(x) ∧ Racehorse(x)) ::: Some horses are racehorses",
            "∀x (Horse(x) ∧ Racing(x) ∧ Falls(x) → Dead(x)) ::: If a horse falls during a race, then it dies",
            "Racing(detroitcity) ∧ Falls(detroitcity) ::: Detroit City fell during a race",
            "∀x (Horse(x) ∧ Racing(x) → Racehorse(x)) ::: A horse is a racehorse if it is in a race"
        ]
    },
    {
        "premises-NL": [
            "Frederick Monhoff was an architect, artist, and illustrator.",
            "Frederick Monhoff was an American.",
            "An artist is good at painting or music.",
            "All Americans speak English."
        ],
        "predicates": [
            "Architect(x) ::: x is an architect",
            "Artist(x) ::: x is an artist",
            "Illustrator(x) ::: x is an illustrator",
            "American(x) ::: x is American",
            "GoodAt(x, y) ::: x is good at y",
            "Speak(x, y) ::: x speaks y"
        ],
        "premises-FOL": [
            "Architect(monhoff) ∧ Artist(monhoff) ∧ Illustrator(monhoff) ::: Frederick Monhoff was an architect, artist, and illustrator",
            "American(monhoff) ::: Frederick Monhoff was an American",
            "∀x (Artist(x) → GoodAt(x, painting) ∨ GoodAt(x, music)) ::: An artist is good at painting or music",
            "∀x (American(x) → Speak(x, english)) ::: All Americans speak English"
        ]
    },
    {
        "premises-NL": [
            "Miroslav Fiedler was a Czech mathematician.",
            "Miroslav Fiedler is known for his contributions to linear algebra and graph theory.",
            "Miroslav Fiedler is honored by the Fiedler eigenvalue.",
            "Fiedler eigenvalue is the second smallest eigenvalue of the graph Laplacian."
        ],
        "predicates": [
            "Czech(x) ::: x is Czech",
            "Mathematician(x) ::: x is a mathematician",
            "KnownFor(x, y) ::: x is known for y",
            "HonoredBy(x, y) ::: x is honored by y",
            "TheSecondSmallestEigenvalueOf(x, y) ::: x is the second smallest eigenvalue of y"
        ],
        "premises-FOL": [
            "Czech(miroslavfiedler) ∧ Mathematician(miroslavfiedler) ::: Miroslav Fiedler was a Czech mathematician.",
            "KnownFor(miroslavfiedler, contributionsToLinearAlgebraAndGraphTheory) ::: Miroslav Fiedler is known for his contributions to linear algebra and graph theory.",
            "HonoredBy(miroslavfiedler, fiedlerEigenvalue) ::: Miroslav Fiedler is honored by the Fiedler eigenvalue.",
            "TheSecondSmallestEigenvalueOf(fiedlerEigenvalue, theGraphLaplacian) ::: Fiedler eigenvalue is the second smallest eigenvalue of the graph Laplacian."
        ]
    },
    {
        "premises-NL": [
            "A laptop is a computer.",
            "You can play games on a computer.",
            "A phone is not a computer."
        ],
        "predicates": [
            "Laptop(x) ::: x is a laptop",
            "Computer(x) ::: x is a computer",
            "CanPlayGames(x, y) ::: x can play games on y",
            "Phone(x) ::: x is a phone"
        ],
        "premises-FOL": [
            "∀x (Laptop(x) → Computer(x)) ::: A laptop is a computer.",
            "∀x (Computer(x) → CanPlayGames(x)) ::: You can play games on a computer.",
            "∀x (Phone(x) → ¬Computer(x)) ::: A phone is not a computer."
        ]
    },
    {
        "premises-NL": [
            "Walter Folger Brown was an American politician and lawyer, and served as the postmaster general.",
            "Walter Folger Brown graduated from Harvard University with a Bachelors of Arts.",
            "While they were both in Toledo, Walter Folger Brown's father practiced law with Walter Folger Brown.",
            "Katherin Hafer married Walter Folger Brown."
        ],
        "predicates": [
            "AmericanPolitician(x) ::: x is an American politician",
            "Lawyer(x) ::: x is a lawyer",
            "ServedAs(x, y) ::: x served as y",
            "Graduated(x, y) ::: x graduated from y",
            "GraduatedWith(x, y) ::: x graduated with y",
            "In(x, y) ::: x is in y",
            "PracticedLawTogether(x, y) ::: x practiced law with y",
            "Married(x, y) ::: x married y"
        ],
        "premises-FOL": [
            "AmericanPolitician(walterbrown) ∧ Lawyer(walterbrown) ∧ ServedAs(walterbrown, postmastergeneral) ::: Walter Folger Brown was an American politician and lawyer, and served as the postmaster general.",
            "Graduated(walterbrown, harvarduniversity) ∧ GraduatedWith(walterbrown, bachelorsarts) ::: Walter Folger Brown graduated from Harvard University with a Bachelors of Arts.",
            "In(walterbrown, toledo) ∧ In(walterbrownfather, toledo) ∧ PracticedLawTogether(walterbrownfather, walterbrown) ::: While they were both in Toledo, Walter Folger Brown's father practiced law with Walter Folger Brown.",
            "Married(katherinhafer, walterbrown) ::: Katherin Hafer married Walter Folger Brown."
        ]
    },
    {
        "premises-NL": [
            "All products shipped from China are made in China. ",
            "All products sold in JD are shipped from China. ",
            "All products commonly used in China are sold in JD.",
            "All products favored by young people are commonly used in China. ",
            "MacBook is not made in China and is not commonly used in China."
        ],
        "predicates": [
            "ShipChina(x) ::: Product x is shipped from China",
            "MadeInChina(x) ::: Product x is made in China",
            "SoldJD(x) ::: Product x is sold in JD",
            "CommonlyUsedChina(x) ::: Product x is commonly used in China",
            "FavoredByYoungPeople(x) ::: Product x is favored by young people"
        ],
        "premises-FOL": [
            "∀x (ShipChina(x) → MadeInChina(x)) ::: All products shipped from China are made in China.",
            "∀x (SoldJD(x) → ShipChina(x)) ::: All products sold in JD are shipped from China.",
            "∀x (CommonlyUsedChina(x) → SoldJD(x)) ::: All products commonly used in China are sold in JD.",
            "∀x (FavoredByYoungPeople(x) → CommonlyUsedChina(x)) ::: All products favored by young people are commonly used in China.",
            "¬(MadeInChina(macbook) ∧ CommonlyUsedChina(macbook)) ::: MacBook is not made in China and is not commonly used in China."
        ]
    },
    {
        "premises-NL": [
            "An animal is either a cat or a dog.",
            "All dogs bark.",
            "Ghosts do not exist.",
            "If something barks, then it is not alive.",
            "A thing is either alive or dead.",
            "Jojo is not dead."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Dog(x) ::: x is a dog",
            "Bark(x) ::: x barks",
            "Ghost(x) ::: x is a ghost",
            "Alive(x) ::: x is alive",
            "Dead(x) ::: x is dead"
        ],
        "premises-FOL": [
            "∀x (Cat(x) ⊕ Dog(x)) ::: An animal is either a cat or a dog",
            "∀x (Dog(x) → Bark(x)) ::: All dogs bark",
            "∀x (¬Ghost(x)) ::: Ghosts do not exist",
            "∀x (Bark(x) → ¬Alive(x)) ::: If something barks, then it is not alive",
            "∀x (Alive(x) ⊕ Dead(x)) ::: A thing is either alive or dead",
            "¬Dead(jojo) ::: Jojo is not dead"
        ]
    },
    {
        "premises-NL": [
            "All animals that are tigers are cats.",
            "No cats are dogs.",
            "All Bengal tigers are tigers.",
            "Everything that is a husky is a dog.",
            "Fido is either a Bengal tiger or a cat."
        ],
        "predicates": [
            "Tiger(x) ::: x is a tiger",
            "Cat(x) ::: x is a cat",
            "Dog(x) ::: x is a dog",
            "BengalTiger(x) ::: x is a Bengal tiger",
            "Husky(x) ::: x is a husky"
        ],
        "premises-FOL": [
            "∀x (Tiger(x) → Cat(x)) ::: All tigers are cats.",
            "∀x (Cat(x) → ¬Dog(x)) ::: No cats are dogs.",
            "∀x (BengalTiger(x) → Tiger(x)) ::: All Bengal tigers are tigers.",
            "∀x (Husky(x) → Dog(x)) ::: All huskies are dogs.",
            "BengalTiger(fido) ∨ Cat(fido) ::: Fido is either a Bengal tiger or a cat."
        ]
    },
    {
        "premises-NL": [
            "The taiga vole is a large vole found in northwestern North America. ",
            "Cats like playing with all voles.",
            "The taiga vole lives in the boreal taiga zone.",
            "The boreal taiga zone in North America is a cold place to live in.",
            "Taiga vole is typically much larger than most other North American voles, especially those from the genus Microtus."
        ],
        "predicates": [
            "Vole(x) ::: x is a vole",
            "Find(x,y) ::: x is found in y",
            "CatLikePlayingWith(x) ::: cats like playing with x",
            "Live(x,y) ::: x lives in y",
            "LiveInColdPlace(x) ::: x lives in a cold place",
            "Larger(x,y) ::: x is larger than y"
        ],
        "premises-FOL": [
            "Vole(taigaVole) ∧ Find(taigaVole, northAmerica) ::: The taiga vole is a large vole found in northwestern North America.",
            "∀x (Vole(x) → CatLikePlayingWith(x)) ::: Cats like playing with all voles.",
            "Live(taigaVole, borealTaigaZone) ::: The taiga vole lives in the boreal taiga zone.",
            "∀x (Find(x, northAmerica) ∧ Live(x, borealTaigaZone) → LiveInColdPlace(x)) ::: The boreal taiga zone in North America is a cold place to live in.",
            "Larger(taigaVole, microtusVole) ::: Taiga vole is typically much larger than most other North American voles, especially those from the genus Microtus."
        ]
    },
    {
        "premises-NL": [
            "Either in women or in men. ",
            "No men have breast cancer.",
            "Either breast cancer or non-breast cancer. ",
            "No type of cancer is without a tumor.",
            "All non-breast cancers are a type of cancer.",
            "If adenocarcinoma is a type of cancer or without a tumor, then adenocarcinoma is in women or without a tumor."
        ],
        "predicates": [
            "Women(x) ::: x is a woman",
            "Men(x) ::: x is a man",
            "BreastCancer(x) ::: x has breast cancer",
            "Non-BreastCancer(x) ::: x does not have breast cancer",
            "ATypeOfCancer(x) ::: x is a type of cancer",
            "WithoutTumor(x) ::: x is without a tumor"
        ],
        "premises-FOL": [
            "∀x (Women(x) ∨ Men(x)) ::: everyone is either a woman or a man",
            "∀x (Men(x) → ¬BreastCancer(x)) ::: If someone is a man then they do not have breast cancer",
            "∀x (BreastCancer(x) ∨ Non-BreastCancer(x)) ::: everything is either breast cancer or not breast cancer",
            "∀x (ATypeOfCancer(x) → ¬WithoutTumor(x)) ::: If something is a type of cancer, then it does not lack a tumor.",
            "∀x (Non-BreastCancer(x) → ATypeOfCancer(x)) ::: if something is a non-breast cancer, then it is a type of cancer",
            "ATypeOfCancer(adenocarcinoma) ∨ WithoutTumor(adenocarcinoma) → Women(adenocarcinoma) ∨ WithoutTumor(adenocarcinoma) ::: If adenocarcinoma is a type of cancer or without a tumor, then adenocarcinoma is in women or without a tumor"
        ]
    },
    {
        "premises-NL": [
            "All fruits sold in Boston are shipped from Columbia. ",
            "Some fruits sold in New Haven are shipped from Mexico.",
            "No fruits shipped from Columbia are fruits sold in New York. ",
            "Avocadoe are a kind of fruit sold in New York or New York. ",
            "Avocadoe are either shipped from Columbia and sold in New Haven, or neither shipped from Columbia nor sold in New Haven. "
        ],
        "predicates": [
            "SoldBoston(x) ::: x is a fruit sold in Boston",
            "ShippedFromColumbia(x) ::: x is a fruit shipped from Columbia",
            "SoldNewHaven(x) ::: x is a fruit sold in New Haven",
            "ShippedFromMexico(x) ::: x is a fruit shipped from Mexico",
            "SoldNewYork(x) ::: x is a fruit sold in New York"
        ],
        "premises-FOL": [
            "∀x (SoldBoston(x) → ShippedFromColumbia(x)) ::: All fruits sold in Boston are shipped from Columbia.",
            "∃x (SoldNewHaven(x) ∧ ShippedFromMexico(x)) ::: Some fruits sold in New Haven are shipped from Mexico.",
            "∀x (ShippedFromColumbia(x) → ¬SoldNewYork(x)) ::: No fruits shipped from Columbia are fruits sold in New York.",
            "SoldNewYork(avocado) ∨ SoldNewYork(avocado) ::: Avocadoe are a kind of fruit sold in New York or New York.",
            "¬(ShippedFromColumbia(avocado) ⊕ SoldNewHaven(avocado)) ::: Avocadoe are either shipped from Columbia and sold in New Haven, or neither shipped from Columbia nor sold in New Haven."
        ]
    },
    {
        "premises-NL": [
            "Some monitors equipped in the library are produced by AOC. ",
            "All monitors equipped in the library are cheaper than 800 dollars. ",
            "All monitors cheaper than 800 dollars are with a resolution of 1080p. ",
            "If a monitor has a resolution of 1080p, then it does not support the type-c port. ",
            "A-2017 supports the type-c port. "
        ],
        "predicates": [
            "Library(x) ::: x is a monitor equipped in the library",
            "AOC(x) ::: x is produced by AOC",
            "Cheap(x) ::: x is cheaper than 800 dollars",
            "A1080p(x) ::: x is with a resolution of 1080p",
            "TypeC(x) ::: x supports the type-c port"
        ],
        "premises-FOL": [
            "∃x (Library(x) ∧ AOC(x)) ::: Some monitors equipped in the library are produced by AOC.",
            "∀x (Library(x) → Cheap(x)) ::: All monitors equipped in the library are cheaper than 800 dollars.",
            "∀x (Cheap(x) → A1080p(x)) ::: All monitors cheaper than 800 dollars are with a resolution of 1080p.",
            "∀x (A1080p(x) → ¬TypeC(x)) ::: If a monitor has a resolution of 1080p, then it does not support the type-c port.",
            "TypeC(a-2017) ::: A-2017 supports the type-c port."
        ]
    },
    {
        "premises-NL": [
            "Sūduva Marijampolė holds the Lithuanian Supercup.",
            "Sūduva Marijampolė is a soccer team."
        ],
        "predicates": [
            "Hold(x,y) ::: x holds y",
            "SoccerTeam(x) ::: x is a soccer team"
        ],
        "premises-FOL": [
            "Hold(suduva, thelithuaniansupercup) ::: Sūduva Marijampolė holds the Lithuanian Supercup.",
            "SoccerTeam(suduva) ::: Sūduva Marijampolė is a soccer team."
        ]
    },
    {
        "premises-NL": [
            "Ainderby Quernhow is a village and civil parish in the Hambleton District.",
            "Hambleton District is in North Yorkshire.",
            "North Yorkshire is in England."
        ],
        "predicates": [
            "AinderbyQuernhow(x) ::: x is Ainderby Quernhow",
            "Village(x) ::: x is a village",
            "CivilParish(x) ::: x is a civil parish",
            "Hambleton(x) ::: x is in Hambleton District",
            "NorthYorkshire(x) ::: x is in North Yorkshire",
            "England(x) ::: x is in England"
        ],
        "premises-FOL": [
            "AinderbyQuernhow(x) → Village(x) ∧ CivilParish(x) ∧ Hambleton(x) ::: If x is Ainderby Quernhow, then x is a village, a civil parish, and in Hambleton District.",
            "Hambleton(x) → NorthYorkshire(x) ::: If x is in Hambleton District, then x is in North Yorkshire.",
            "NorthYorkshire(x) → England(x) ::: If x is in North Yorkshire, then x is in England."
        ]
    },
    {
        "premises-NL": [
            "Douglas Adams is an author who created the book collection called The Salmon of Doubt. ",
            "The Salmon of Doubt is about life experiences and technology.",
            "All authors are writers.",
            "Writers create innovative ideas.",
            "Some books that contain innovative ideas are about technology."
        ],
        "predicates": [
            "Author(x) ::: x is an author",
            "Create(x, y) ::: x creates y",
            "BookCollection(x) ::: x is a book collection",
            "Called(x, y) ::: x is called y",
            "About(x, y) ::: x is about y",
            "LifeExperience(x) ::: x is a life experience",
            "Technology(x) ::: x is technology",
            "Writer(x) ::: x is a writer",
            "CreateInnovativeIdea(x) ::: x creates innovative ideas",
            "ContainInnovativeIdea(x) ::: x contains innovative ideas",
            "Book(x) ::: x is a book"
        ],
        "premises-FOL": [
            "Author(douglasAdams) ∧ Create(douglasAdams, theSalmonOfDoubt) ∧ BookCollection(theSalmonOfDoubt) ∧ Called(theSalmonOfDoubt, theSalmonOfDoubtName) ::: Douglas Adams is an author who created the book collection called The Salmon of Doubt.",
            "About(theSalmonOfDoubt, lifeExperiences) ∧ About(theSalmonOfDoubt, technology) ::: The Salmon of Doubt is about life experiences and technology.",
            "∀x (Author(x) → Writer(x)) ::: All authors are writers.",
            "∀x (Writer(x) → CreateInnovativeIdea(x)) ::: Writers create innovative ideas.",
            "∃x (Book(x) ∧ ContainInnovativeIdea(x) ∧ About(x, technology)) ::: Some books that contain innovative ideas are about technology."
        ]
    },
    {
        "premises-NL": [
            "No disposable products can help slow down global warming. ",
            "All eco-friendly brands can help slow down global warming. ",
            "All sustainable fashion brands are eco-friendly brands.",
            "All fast fashion products are disposable products.",
            "If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand."
        ],
        "predicates": [
            "DisposableProducts(x) ::: x is a disposable product",
            "HelpSlowDownGlobalWarming(x) ::: x helps slow down global warming",
            "Eco-friendlyBrand(x) ::: x is an eco-friendly brand",
            "SustainableFashionBrand(x) ::: x is a sustainable fashion brand",
            "FastFashionProducts(x) ::: x is a fast fashion product"
        ],
        "premises-FOL": [
            "∀x (DisposableProducts(x) → ¬HelpSlowDownGlobalWarming(x)) ::: No disposable products can help slow down global warming.",
            "∀x (Eco-friendlyBrand(x) → HelpSlowDownGlobalWarming(x)) ::: All eco-friendly brands can help slow down global warming.",
            "∀x (SustainableFashionBrand(x) → Eco-friendlyBrand(x)) ::: All sustainable fashion brands are eco-friendly brands.",
            "∀x (FastFashionProducts(x) → DisposableProducts(x)) ::: All fast fashion products are disposable products.",
            "¬HelpSlowDownGlobalWarming(reformation) → Eco-friendlyBrand(reformation) ∨ SustainableFashionBrand(reformation) ::: If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand."
        ]
    },
    {
        "premises-NL": [
            "Roy Richardson was a cricketer for Sint Maartener, a consituent country.",
            "Roy Richardson was a right handed batsman and medium pace bowler.",
            "Roy Richardson was old when he debuted in cricket.",
            "Sherville Huggins dismissed Roy Richardson."
        ],
        "predicates": [
            "Cricketeer(x) ::: x is a cricketer",
            "PlayedFor(x, y) ::: x played for y",
            "ConstituentCountry(x) ::: x is a constituent country",
            "RightHanded(x) ::: x is right handed",
            "Batsman(x) ::: x is a batsman",
            "MediumPaceBowler(x) ::: x is a medium pace bowler",
            "Old(x) ::: x is old",
            "DebutedIn(x, y) ::: x debuted in y",
            "Dismissed(x, y) ::: x dismissed y"
        ],
        "premises-FOL": [
            "Cricketeer(royrichardson) ∧ PlayedFor(royrichardson, sintmaartener) ∧ ConstituentCountry(sintmaartener) ::: Roy Richardson was a cricketer for Sint Maartener, a consituent country.",
            "RightHanded(royrichardson) ∧ Batsman(royrichardson) ∧ MediumPaceBowler(royrichardson) ::: Roy Richardson was a right handed batsman and medium pace bowler.",
            "Old(royrichardson) ∧ DebutedIn(royrichardson, cricket) ::: Roy Richardson was old when he debuted in cricket.",
            "Dismissed(shervillehuggins, royrichardson) ::: Sherville Huggins dismissed Roy Richardson."
        ]
    },
    {
        "premises-NL": [
            "To get a job at Google, you need to have a lot of work experience or a good education.",
            " All Yale graduates who submitted their resumes to Google got jobs there.",
            " John has a lot of work experience.",
            " John submitted his resume to Google and got a job there."
        ],
        "predicates": [
            "Employed(x, y) ::: x get a job at y",
            "WorkExp(x) ::: x has a lot of work experience",
            "GoodEduc(x) ::: x has a good education",
            "Yale(x) ::: x is a Yale graduate",
            "CV(x, y) ::: x submitted resume to y"
        ],
        "premises-FOL": [
            "Employed(x,google) → WorkExp(x) ∨ GoodEduc(x) ::: To get a job at Google, you need to have a lot of work experience or a good education",
            "Yale(x) ∧ CV(x,google) → Employed(x,google) ::: All Yale graduates who submitted their resumes to Google got jobs there.",
            "WorkExp(john) ::: John has a lot of work experience.",
            "CV(john,google) ∧ Employed(john,google) ::: John submitted his resume to Google and got a job there."
        ]
    },
    {
        "premises-NL": [
            "No students are doctors.",
            "All people taking classes are students. ",
            "All graduate students are people taking classes. ",
            "All PhD students are graduate students. ",
            "If Joe is a graduate student or a doctor (but not both), then Joe is not a graduate student and a student."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Doctor(x) ::: x is a doctor",
            "TakingClass(x) ::: x is taking a class",
            "GraduateStudent(x) ::: x is a graduate student",
            "PhDStudent(x) ::: x is a PhD student"
        ],
        "premises-FOL": [
            "∀x (Student(x) → ¬Doctor(x)) ::: No students are doctors.",
            "∀x (TakingClass(x) → Student(x)) ::: All people taking classes are students.",
            "∀x (GraduateStudent(x) → TakingClass(x)) ::: All graduate students are people taking classes.",
            "∀x (PhDStudent(x) → GraduateStudent(x)) ::: All PhD students are graduate students.",
            "((GraduateStudent(joe) ∨ Doctor(joe)) ∧ ¬(GraduateStudent(joe) ∧ Doctor(joe))) → ¬(GraduateStudent(joe) ∧ Student(joe)) ::: If Joe is a graduate student or a doctor (but not both), then Joe is not a graduate student and a student."
        ]
    },
    {
        "premises-NL": [
            "Hugh Vanstone is one of the world's leading lighting designers. ",
            "Hugh Vanstone is from the UK.",
            "Hugh Vanstone has lit more than 160 productions.",
            "Hugh Vanstone attended school where he is from. "
        ],
        "predicates": [
            "WorldLeadingLightningDesigner(x) ::: x is one of the world's leading lighting designers",
            "FromUK(x) ::: x is from the UK",
            "LitOver160Productions(x) ::: x has lit more than 160 productions",
            "AttendedSchoolWhereFrom(x) ::: x attended school where he is from"
        ],
        "premises-FOL": [
            "WorldLeadingLightningDesigner(hughVanstone) ::: Hugh Vanstone is one of the world's leading lighting designers.",
            "FromUK(hughVanstone) ::: Hugh Vanstone is from the UK.",
            "LitOver160Productions(hughVanstone) ::: Hugh Vanstone has lit more than 160 productions.",
            "AttendedSchoolWhereFrom(hughVanstone) ::: Hugh Vanstone attended school where he is from."
        ]
    },
    {
        "premises-NL": [
            "No man can run faster than Bolt. ",
            "Superman is not a man."
        ],
        "predicates": [
            "Man(x) ::: x is a man",
            "FasterThanBolt(x) ::: x can run faster than Bolt"
        ],
        "premises-FOL": [
            "∀x (Man(x) → ¬FasterThanBolt(x)) ::: No man can run faster than Bolt.",
            "¬Man(superman) ::: Superman is not a man."
        ]
    },
    {
        "premises-NL": [
            "Donald Ervin Knuth is an American computer scientist, mathematician, and Professor Emeritus at Stanford University.",
            "Knuth has been called the father of the analysis of algorithms."
        ],
        "predicates": [
            "AmericanComputerScientist(x) ::: x is an American computer scientist",
            "Mathematician(x) ::: x is a mathematician",
            "ProfessorEmeritusAt(x, y) ::: x is a Professor Emeritus at y",
            "BeCalled(x, y) ::: x is called y"
        ],
        "premises-FOL": [
            "AmericanComputerScientist(donaldErvinKnuth) ∧ Mathematician(donaldErvinKnuth) ∧ ProfessorEmeritusAt(donaldErvinKnuth, stanfordUniversity) ::: Donald Ervin Knuth is an American computer scientist, mathematician, and Professor Emeritus at Stanford University.",
            "BeCalled(donaldErvinKnuth, fatherOfTheAnalysisOfAlgorithms) ::: Knuth has been called the father of the analysis of algorithms."
        ]
    },
    {
        "premises-NL": [
            "Neocrepidodera Corpulentas are flea beetles or moths.",
            "The species Neocrepidodera Corpulenta is in the Chrysomelidae family.",
            "There are no moths within the Chrysomelidae family."
        ],
        "predicates": [
            "FleaBeetle(x) ::: x is a flea beetle",
            "Moth(x) ::: x is a moth",
            "Species(x) ::: x is a species",
            "Family(x) ::: x is a family",
            "In(x, y) ::: x is in the y family"
        ],
        "premises-FOL": [
            "FleaBeetle(neocrepidoderacorpulentas) ∨ Moth(neocrepidoderacorpulentas) ::: Neocrepidodera Corpulentas is a flea beetle or a moth",
            "Species(neocrepidoderacorpulenta) ∧ Family(chrysomelidae) ∧ In(neocrepidoderacorpulenta, chrysomelidae) ::: The species Neocrepidodera Corpulenta is in the Chrysomelidae family",
            "¬∃x (Moth(x) ∧ In(x, chrysomelidae)) ::: There are no moths within the Chrysomelidae family"
        ]
    },
    {
        "premises-NL": [
            "Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931.",
            "Carrozzeria Colli is a company that specialized in using aluminum.",
            "The first automobiles built by Carrozzeria Colli were racing cars.",
            "Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chasis.",
            "Carrozzeria Colli worked for airforces.",
            "Carrozzeria Colli made car bodies. "
        ],
        "predicates": [
            "MilaneseCoachbuilderCompany(x) ::: x is a Milanese coachbuilder company",
            "EstablishedBy(x, y) ::: x was established by y",
            "EstablishedIn(x, y) ::: x was established in year y",
            "SpecializedIn(x, y) ::: x specialized in y",
            "FirstAutomobilesBy(x, y) ::: x is the first automobile built by y",
            "Racingcar(x) ::: x is a racing car",
            "BuiltBy(x, y) ::: x was built by y",
            "Used(x, y) ::: x used y",
            "Airforce(x) ::: x is an airforce",
            "WorkedFor(x, y) ::: x worked for y",
            "Made(x, y) ::: x made y"
        ],
        "premises-FOL": [
            "MilaneseCoachbuilderCompany(carrozzeriacolli) ∧ EstablishedBy(carrozzeriacolli, giuseppecolli) ∧ EstablishedIn(carrozzeriacolli, 1931) ::: Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931.",
            "SpecializedIn(carrozzeriacolli, usingaluminum) ::: Carrozzeria Colli is a company that specialized in using aluminum.",
            "∀x (FirstAutomobilesBy(x, carrozzeriacolli) → Racingcar(x)) ::: The first automobiles built by Carrozzeria Colli were racing cars.",
            "∃x (RacingCar(x) ∧ BuiltBy(x, carrozzeriacolli) ∧ Used(x, fiat110mechanicals) ∧ Used(x, chasis)) ::: Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chasis.",
            "∃x (Airforce(x) ∧ WorkedFor(carrozzeriacolli, x)) ::: Carrozzeria Colli worked for airforces.",
            "Made(carrozzeriacolli, carbodies) ::: Carrozzeria Colli made car bodies."
        ]
    },
    {
        "premises-NL": [
            "John will go to the cinema if and only if Jack goes to the cinema today.",
            "Jack will go to the cinema if and only if Iron Man is on and the weather is not bad today.",
            "Some days in March have bad weather.",
            "Iron man is on.",
            "It's March now."
        ],
        "predicates": [
            "GoToTheCinema(x,y) ::: x goes to the cinema at time y",
            "Movie(x) ::: x is a movie",
            "BadWeather(x) ::: The weather is bad at time x",
            "Month(x) ::: x is a month"
        ],
        "premises-FOL": [
            "GoToTheCinema(john, today) ↔ GoToTheCinema(jack, today) ::: John goes to the cinema today if and only if Jack goes to the cinema today.",
            "GoToTheCinema(jack, today) ↔ (Movie(ironman) ∧ ¬BadWeather(today)) ::: Jack will go to the cinema today if and only if Iron Man is on and the weather is not bad today.",
            "∃x (Month(march) ∧ BadWeather(x)) ::: Some days in March have bad weather.",
            "Movie(ironman) ::: Iron man is on.",
            "Month(march) ::: It's March now."
        ]
    },
    {
        "premises-NL": [
            "Quiksilver sells sportswear, clothing, footwear, and accessories.",
            "Flannels are a type of clothing.",
            "Joe owns an item fron Quiksilver."
        ],
        "predicates": [
            "QuiksilverSells(x) ::: Quiksilver sells x",
            "Sportswear(x) ::: x is a sportswear item",
            "Clothing(x) ::: x is a clothing item",
            "Footwear(x) ::: x is a footwear item",
            "Accessory(x) ::: x is an accessory item",
            "JoeOwns(x) ::: Joe owns x"
        ],
        "premises-FOL": [
            "∀x (QuiksilverSells(x) → (Sportswear(x) ∨ Clothing(x) ∨ Footwear(x) ∨ Accessory(x))) ::: For all x, if Quiksilver sells x, then x is either sportswear, clothing, footwear, or an accessory.",
            "Clothing(Flannels) ::: Flannels are clothing.",
            "∃x (QuiksilverSells(x) ∧ JoeOwns(x)) ::: There exists an x such that Quiksilver sells x and Joe owns x."
        ]
    },
    {
        "premises-NL": [
            "No video games released by Nintendo support the PS4 platform.",
            "All video games in the Pokemon series are released by Nintendo. ",
            "All video games in the FIFA series support the PS4 platform. ",
            "All video games supporting users to simulate playing soccer games online are in the FIFA series.",
            "The video game named “Be Lionel” is in the Pokemon series or supports users to simulate playing football games online."
        ],
        "predicates": [
            "Nintendo(x) ::: x is a video game released by Nintendo",
            "SupportPS4(x) ::: x is a video game that supports the PS4 platform",
            "Pokemon(x) ::: x is a video game in the Pokemon series",
            "FIFA(x) ::: x is a video game in the FIFA series",
            "SoccerOnline(x) ::: x is a video game supporting users to simulate playing soccer games online"
        ],
        "premises-FOL": [
            "∀x (Nintendo(x) → ¬SupportPS4(x)) ::: No video games released by Nintendo support the PS4 platform.",
            "∀x (Pokemon(x) → Nintendo(x)) ::: All video games in the Pokemon series are released by Nintendo.",
            "∀x (FIFA(x) → SupportPS4(x)) ::: All video games in the FIFA series support the PS4 platform.",
            "∀x (SoccerOnline(x) → FIFA(x)) ::: All video games supporting users to simulate playing soccer games online are in the FIFA series.",
            "Pokemon(belionel) ∨ SoccerOnline(belionel) ::: The video game named “Be Lionel” is in the Pokemon series or supports users to simulate playing football games online."
        ]
    },
    {
        "premises-NL": [
            "No payment cards issued by Russian banks can be used with ApplePay.",
            "All MIR payment cards are issued by Russian banks.",
            "Some international payment cards can be used with ApplePay.",
            "Social payments in Russia can only be transferred to MIR payment cards.",
            "Bank of America payment cards can be used with ApplePay."
        ],
        "predicates": [
            "RussianBank(x) ::: x is a payment card issued by a Russian bank",
            "ApplePay(x) ::: x can be used with ApplePay",
            "Mir(x) ::: x is a MIR payment card",
            "International(x) ::: x is an international payment card",
            "SocialRussia(x) ::: x is a social payment in Russia"
        ],
        "premises-FOL": [
            "∀x (RussianBank(x) → ¬ApplePay(x)) ::: No payment cards issued by Russian banks can be used with ApplePay.",
            "∀x (Mir(x) → RussianBank(x)) ::: All MIR payment cards are issued by Russian banks.",
            "∃x (International(x) ∧ ApplePay(x)) ::: Some international payment cards can be used with ApplePay.",
            "∀x (SocialRussia(x) → Mir(x)) ::: Social payments in Russia can only be transferred to MIR payment cards.",
            "ApplePay(BankOfAmericaPaymentCards) ::: Bank of America payment cards can be used with ApplePay."
        ]
    },
    {
        "premises-NL": [
            "Everyone who works in person is a commuter.",
            "People either work in person or work from home.",
            "Everyone who works from home has a relaxed schedule.",
            "George is either a commuter or has a home office setup.",
            "If George is either a person who works from home or has a home office setup, then George is not a person who works from home and a commuter."
        ],
        "predicates": [
            "InPerson(x) ::: x works in person",
            "Commuter(x) ::: x is a commuter",
            "FromHome(x) ::: x works from home",
            "Relaxed(x) ::: x has a relaxed schedule",
            "HomeOffice(x) ::: x has a home office setup"
        ],
        "premises-FOL": [
            "∀x (InPerson(x) → Commuter(x)) ::: Everyone who works in person is a commuter.",
            "∀x (InPerson(x) ⊕ FromHome(x)) ::: People either work in person or work from home.",
            "∀x (FromHome(x) → Relaxed(x)) ::: Everyone who works from home has a relaxed schedule.",
            "Commuter(george) ⊕ HomeOffice(george) ::: George is either a commuter or has a home office setup.",
            "(FromHome(george) ∨ HomeOffice(george)) → ¬(FromHome(george) ∧ Commuter(george)) ::: If George is either a person who works from home or has a home office setup, then George is not a person who works from home and a commuter."
        ]
    },
    {
        "premises-NL": [
            "Jason Kramer is an American music supervisor.",
            "Some American radio personalities are also music supervisors. ",
            "Anyone who hosts a show on a public radio station is a radio personality.",
            "Joe Rogan is a radio personality.",
            "Jason Kramer hosted a show on a public radio station."
        ],
        "predicates": [
            "MusicSupervisor(x) ::: x is a music supervisor",
            "American(x) ::: x is American",
            "RadioPersonality(x) ::: x is a radio personality",
            "HostShowOnPublicRadioStation(x) ::: x hosts a show on a public radio station"
        ],
        "premises-FOL": [
            "MusicSupervisor(jasonKramer) ∧ American(jasonKramer) ::: Jason Kramer is an American music supervisor.",
            "∃x (American(x) ∧ MusicSupervisor(x) ∧ RadioPersonality(x)) ::: Some American radio personalities are also music supervisors.",
            "∀x (HostShowOnPublicRadioStation(x) → RadioPersonality(x)) ::: Anyone who hosts a show on a public radio station is a radio personality.",
            "RadioPersonality(joeRogan) ::: Joe Rogan is a radio personality.",
            "HostShowOnPublicRadioStation(jasonKramer) ::: Jason Kramer hosted a show on a public radio station."
        ]
    },
    {
        "premises-NL": [
            "No coffee sold in Walmart is produced in France. ",
            "All coffee supplied by the company is sold in Walmart. ",
            "All coffee produced in Columbia is produced in France. ",
            "All coffee favored by local residents is coffee produced in Columbia. ",
            "All coffee with high prices is favored by local residents. ",
            "Civet Coffee is not produced in Columbia and is cheap.",
            "Jamaica Blue is sold in Walmart or favored by local residents."
        ],
        "predicates": [
            "SoldIn(x, y) ::: x is sold in y",
            "ProducedIn(x, y) ::: x is produced in y",
            "Coffee(x) ::: x is a coffee",
            "Walmart(x) ::: x is Walmart",
            "France(x) ::: x is France",
            "SuppliedBy(x, y) ::: x is supplied by y",
            "Company(x) ::: x is a company",
            "Columbia(x) ::: x is Columbia",
            "FavoredBy(x, y) ::: x is favored by y",
            "LocalResidents(x) ::: x is local residents",
            "HighPrice(x) ::: x has high price",
            "Cheap(x) ::: x is cheap",
            "JamaicaBlue(x) ::: x is Jamaica Blue",
            "CivetCoffee(x) ::: x is Civet Coffee"
        ],
        "premises-FOL": [
            "∀x (Coffee(x) ∧ SoldIn(x, Walmart) → ¬ProducedIn(x, France)) ::: No coffee sold in Walmart is produced in France.",
            "∀x (Coffee(x) ∧ SuppliedBy(x, Company) → SoldIn(x, Walmart)) ::: All coffee supplied by the company is sold in Walmart.",
            "∀x (Coffee(x) ∧ ProducedIn(x, Columbia) → ProducedIn(x, France)) ::: All coffee produced in Columbia is produced in France.",
            "∀x (Coffee(x) ∧ FavoredBy(x, LocalResidents) → ProducedIn(x, Columbia)) ::: All coffee favored by local residents is coffee produced in Columbia.",
            "∀x (Coffee(x) ∧ HighPrice(x) → FavoredBy(x, LocalResidents)) ::: All coffee with high prices is favored by local residents.",
            "¬ProducedIn(CivetCoffee, Columbia) ∧ Cheap(CivetCoffee) ::: Civet Coffee is not produced in Columbia and is cheap.",
            "SoldIn(JamaicaBlue, Walmart) ∨ FavoredBy(JamaicaBlue, LocalResidents) ::: Jamaica Blue is sold in Walmart or favored by local residents."
        ]
    },
    {
        "premises-NL": [
            "There are two places named Galicia: either in Spain or in Poland.",
            "Spain is in Europe.",
            "Poland is in Europe.",
            "Rochelle lives in Europe.",
            "Dominique does not live in Europe.",
            "Alfonso lives in Galicia."
        ],
        "predicates": [
            "Galicia(x) ::: x is named Galicia",
            "Spain(x) ::: x is in Spain",
            "Poland(x) ::: x is in Poland",
            "Europe(x) ::: x is in Europe",
            "RochelleLive(x) ::: Rochelle lives in x",
            "DominiqueLive(x) ::: Dominique lives in x",
            "AlfonsoLive(x) ::: Alfonso lives in x"
        ],
        "premises-FOL": [
            "∀x (Galicia(x) → Spain(x) ∨ Poland(x)) ::: For all x, if x is Galicia, then x is Spain or x is Poland",
            "∀x (Spain(x) → Europe(x)) ::: For all x, if x is in Spain then x is in Europe",
            "∀x (Poland(x) → Europe(x)) ::: For all x, if x is in Poland then x is in Europe",
            "RochelleLive(Europe) ::: Rochelle lives in Europe",
            "¬DominiqueLive(Europe) ::: Dominique does not live in Europe",
            "AlfonsoLive(Galicia) ::: Alfonso lives in Galicia"
        ]
    },
    {
        "premises-NL": [
            "Ralph Hammerthaler was born in Wasserburg am Inn.",
            "Wasserburg am Inn is in Germany.",
            "Germany is in Europe.",
            "Ralph Hammerthaler is a German writer.",
            "Ralph Hammerthaler was born in 1965. "
        ],
        "predicates": [
            "BornIn(x, y) ::: x was born in y",
            "LocatedIn(x, y) ::: x is located in y",
            "Writer(x) ::: x is a writer",
            "BornInYear(x, y) ::: x was born in the year y"
        ],
        "premises-FOL": [
            "BornIn(ralphHammerthaler, wasserburgAmInn) ::: Ralph Hammerthaler was born in Wasserburg am Inn",
            "LocatedIn(wasserburgAmInn, germany) ::: Wasserburg am Inn is located in Germany",
            "LocatedIn(germany, europe) ::: Germany is located in Europe",
            "Writer(ralphHammerthaler) ::: Ralph Hammerthaler is a writer",
            "BornInYear(ralphHammerthaler, 1965) ::: Ralph Hammerthaler was born in 1965"
        ]
    },
    {
        "premises-NL": [
            "All books written by Tomas have sold more than 1 million copies. ",
            "Some books that have won Hugo Awards are written by Tomas.",
            "All books about the future are inspired by Shakespeare. ",
            "2001 is a book either inspired from Shakespeare or it has sold more than 1 million copies.",
            "2001 is a book that has either sold more than 1 million copies or it was written by Tomas."
        ],
        "predicates": [
            "WrittenByTomas(x) ::: x was written by Tomas",
            "SoldOneMillion(x) ::: x has sold more than 1 million copies",
            "WinningHugoAward(x) ::: x has won a Hugo Award",
            "AboutFuture(x) ::: x is about the future",
            "InspiredFromShakespeare(x) ::: x is inspired by Shakespeare"
        ],
        "premises-FOL": [
            "∀x (WrittenByTomas(x) → SoldOneMillion(x)) ::: All books written by Tomas have sold more than 1 million copies.",
            "∃x (WinningHugoAward(x) ∧ WrittenByTomas(x)) ::: Some books that have won Hugo Awards are written by Tomas.",
            "∀x (AboutFuture(x) → InspiredFromShakespeare(x)) ::: All books about the future are inspired by Shakespeare.",
            "InspiredFromShakespeare(y2001) ⊕ SoldOneMillion(y2001) ::: 2001 is a book either inspired from Shakespeare or it has sold more than 1 million copies.",
            "SoldOneMillion(y2001) ⊕ WrittenByTomas(y2001) ::: 2001 is a book that has either sold more than 1 million copies or it was written by Tomas."
        ]
    },
    {
        "premises-NL": [
            "The Golden State Warriors are a team from San Francisco.",
            "The Golden State Warriors won the NBA finals.",
            "All teams attending the NBA finals have more than thirty years of history.",
            "Boston Celtics are a team that lost the NBA finals.",
            "If a team wins the NBA finals, then they will have more income.",
            "If a team wins or loses at the NBA finals, then they are attending the finals."
        ],
        "predicates": [
            "Team(x) ::: x is a team",
            "From(x, y) ::: team x is from city y",
            "Won(x, y) ::: team x won event y",
            "Attending(x, y) ::: team x attended event y",
            "HasMoreThan(x, y) ::: team x has more than y",
            "Lost(x, y) ::: team x lost event y",
            "MoreIncome(x) ::: team x has more income"
        ],
        "premises-FOL": [
            "Team(goldenstatewarriors) ∧ From(goldenstatewarriors, sanfrancisco) ::: The Golden State Warriors are a team from San Francisco",
            "Won(goldenstatewarriors, nbafinals) ::: The Golden State Warriors won the NBA finals",
            "∀x (Team(x) ∧ Attending(x, nbafinals) → HasMoreThan(x, thirtyyearsofhistory)) ::: All teams attending the NBA finals have more than thirty years of history",
            "Team(bostonceltics) ∧ Lost(bostonceltics, nbafinals) ::: Boston Celtics are a team that lost the NBA finals",
            "∀x (Team(x) ∧ Won(x, nbafinals) → MoreIncome(x)) ::: If a team wins the NBA finals, then they will have more income",
            "∀x (Won(x, nbafinals) ∨ Lost(x, nbafinals) → Attending(x, nbafinals)) ::: If a team wins or loses at the NBA finals, then they are attending the finals"
        ]
    },
    {
        "premises-NL": [
            "Maya will play violin if and only if she never injures her fingers.",
            "Volleyball players can injure their ankle, fingers, or shoulder.",
            "Maya is a volleyball player."
        ],
        "predicates": [
            "WillPlayViolin(x) ::: x will play violin",
            "Injures(x, y) ::: x injures y",
            "CanInjure(x, y) ::: x can injure y",
            "VolleyballPlayer(x) ::: x is a volleyball player"
        ],
        "premises-FOL": [
            "WillPlayViolin(maya) ↔ ¬Injures(maya, fingers) ::: Maya will play violin if and only if she never injures her fingers",
            "∀x (VolleyballPlayer(x) → (CanInjure(x, ankle) ∨ CanInjure(x, fingers) ∨ CanInjure(x, shoulder))) ::: Volleyball players can injure their ankle, fingers, or shoulder",
            "VolleyballPlayer(maya) ::: Maya is a volleyball player"
        ]
    },
    {
        "premises-NL": [
            "All devices belonging to the company are connected to Google Home. ",
            "All devices with the company logo belong to the company. ",
            "A device is either with the company logo or belongs to employees. ",
            "All devices belonging to employees are available to connect to the company's wifi. ",
            "All devices connected to Google Home are controlled by managers. ",
            "All devices that connect to the company's wifi are easy to operate. ",
            "All devices that are easy to operate are produced after 2020. ",
            "IPod1 is produced before 2020. "
        ],
        "predicates": [
            "InCompany(x) ::: Device x belongs to the company",
            "GoogleHome(x) ::: Device x is connected to Google Home",
            "CompanyLogo(x) ::: Device x has the company logo",
            "Employee(x) ::: Device x belongs to employees",
            "Wifi(x) ::: Device x is available to connect to the company's wifi",
            "ControlledByManager(x) ::: Device x is controlled by managers",
            "EasyToOperate(x) ::: Device x is easy to operate",
            "ProducedAfter2020(x) ::: Device x is produced after 2020"
        ],
        "premises-FOL": [
            "∀x (InCompany(x) → GoogleHome(x)) ::: All devices belonging to the company are connected to Google Home.",
            "∀x (CompanyLogo(x) → InCompany(x)) ::: All devices with the company logo belong to the company.",
            "∀x (CompanyLogo(x) ∨ Employee(x)) ::: A device is either with the company logo or belongs to employees.",
            "∀x (Employee(x) → Wifi(x)) ::: All devices belonging to employees are available to connect to the company's wifi.",
            "∀x (GoogleHome(x) → ControlledByManager(x)) ::: All devices connected to Google Home are controlled by managers.",
            "∀x (Wifi(x) → EasyToOperate(x)) ::: All devices that connect to the company's wifi are easy to operate.",
            "∀x (EasyToOperate(x) → ProducedAfter2020(x)) ::: All devices that are easy to operate are produced after 2020.",
            "¬ProducedAfter2020(iPod1) ::: IPod1 is produced before 2020."
        ]
    },
    {
        "premises-NL": [
            "All CD players are delicate mechanisms.",
            "No delicate mechanisms are suitable toys for children."
        ],
        "predicates": [
            "CDPlayer(x) ::: x is a CD player",
            "DelicateMechanism(x) ::: x is a delicate mechanism",
            "SuitableToyForChildren(x) ::: x is a suitable toy for children"
        ],
        "premises-FOL": [
            "∀x (CDPlayer(x) → DelicateMechanism(x)) ::: All CD players are delicate mechanisms.",
            "∀x (DelicateMechanism(x) → ¬SuitableToyForChildren(x)) ::: No delicate mechanisms are suitable toys for children."
        ]
    },
    {
        "premises-NL": [
            "All mammals are living beings.",
            "All elephants are mammals.",
            "All baby elephants are elephants.",
            "Some baby elephants are sleepy.",
            "If Jumbo is a living being, then Jumbo is not an elephant or a mammal.",
            "If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant."
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal",
            "LivingBeing(x) ::: x is a living being",
            "Elephant(x) ::: x is an elephant",
            "BabyElephant(x) ::: x is a baby elephant",
            "Sleepy(x) ::: x is sleepy"
        ],
        "premises-FOL": [
            "∀x (Mammal(x) → LivingBeing(x)) ::: All mammals are living beings.",
            "∀x (Elephant(x) → Mammal(x)) ::: All elephants are mammals.",
            "∀x (BabyElephant(x) → Elephant(x)) ::: All baby elephants are elephants.",
            "∃x (BabyElephant(x) ∧ Sleepy(x)) ::: Some baby elephants are sleepy.",
            "LivingBeing(jumbo) → ¬(Elephant(jumbo) ∨ Mammal(jumbo)) ::: If Jumbo is a living being, then Jumbo is not an elephant or a mammal.",
            "Sleepy(jumbo) → BabyElephant(jumbo) ∨ Elephant(jumbo) ::: If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant."
        ]
    },
    {
        "premises-NL": [
            "No faculty does homework.",
            "All students do homework.",
            "All kids are students.",
            "If someone works at a school, then they are faculty.",
            "If Jill works at a school or is a teacher, then Jill works at a school."
        ],
        "predicates": [
            "Faculty(x) ::: x is a faculty",
            "DoesHomework(x) ::: x does homework",
            "Student(x) ::: x is a student",
            "Kid(x) ::: x is a kid",
            "WorkAtSchool(x) ::: x works at a school"
        ],
        "premises-FOL": [
            "∀x (Faculty(x) → ¬DoesHomework(x)) ::: No faculty does homework.",
            "∀x (Student(x) → DoesHomework(x)) ::: All students do homework.",
            "∀x (Kid(x) → Student(x)) ::: All kids are students.",
            "∀x (WorkAtSchool(x) → Faculty(x)) ::: If someone works at a school, then they are faculty.",
            "WorkAtSchool(jill) ∨ Teacher(jill) → WorkAtSchool(jill) ::: If Jill works at a school or is a teacher, then Jill works at a school."
        ]
    },
    {
        "premises-NL": [
            "Either Max listens to classical music or Max listens to rap. ",
            "All the songs that Max listens to that are classical music are from the 12th century.",
            "If the song Max listens to is rap, then the song is from Kanye West. ",
            "If a songs is from Kanye West, then the song is full of lyrics. ",
            "All songs that are full of lyrics need to be written with words",
            "If “As it was” by Harry Styles is classical music that Max listens to or  from the 12th century, then “As it was” by Harry Styles is either classical music that Max listens to, or the songs are from 12th century."
        ],
        "predicates": [
            "MaxListensToClassicalMusic(x) ::: Max listens to classical music x",
            "MaxListensToRap(x) ::: Max listens to rap x",
            "SongsFrom12thCentury(x) ::: Song x is from the 12th century",
            "SongsFromKanyeWest(x) ::: Song x is from Kanye West",
            "SongsFullOfLyrics(x) ::: Song x is full of lyrics",
            "NeedToBeWrittenWithWords(x) ::: Song x needs to be written with words"
        ],
        "premises-FOL": [
            "MaxListensToClassicalMusic(x) ∨ MaxListensToRap(x) ::: Either Max listens to classical music x or Max listens to rap x.",
            "MaxListensToClassicalMusic(x) → SongsFrom12thCentury(x) ::: All the songs x that Max listens to that are classical music are from the 12th century.",
            "MaxListensToRap(x) → SongsFromKanyeWest(x) ::: If the song x Max listens to is rap, then the song is from Kanye West.",
            "SongsFromKanyeWest(x) → SongsFullOfLyrics(x) ::: If a songs x is from Kanye West, then the song is full of lyrics.",
            "SongsFullOfLyrics(x) → NeedToBeWrittenWithWords(x) ::: All songs x that are full of lyrics need to be written with words",
            "(MaxListensToClassicalMusic(asItWasByHarryStyles) ∨ SongsFrom12thCentury(asItWasByHarryStyles)) → (MaxListensToClassicalMusic(asItWasByHarryStyles) ∨ SongsFrom12thCentury(asItWasByHarryStyles)) ::: If “As it was” by Harry Styles is classical music that Max listens to or from the 12th century, then “As it was” by Harry Styles is either classical music that Max listens to, or the songs are from 12th century."
        ]
    },
    {
        "premises-NL": [
            "Your Woman is a song by British one-man band White Town.",
            "Your Woman song peaked at No. 1 on the UK Singles Chart.",
            "If a song peaked at No.1 at a cetain place, then it was extremely popular.",
            "Your Woman also peaked No. 1 in Iceland, Israel and Spain."
        ],
        "predicates": [
            "Produce(x, y) ::: x produces y",
            "Peak(x, y) ::: x peaked at y",
            "Popular(x) ::: x was popular"
        ],
        "premises-FOL": [
            "Produce(whiteTown, yourWoman) ::: White Town produced Your Woman",
            "Peak(yourWoman, uKSinglesChart) ::: Your Woman peaked at UK Singles Chart",
            "∀x ∀y (Peak(x, y) → Popular(x)) ::: If x peaked at y then x was popular",
            "Peak(yourWoman, iceland) ∧ Peak(yourWoman, israel) ∧ Peak(yourWoman, spain) ::: Your Woman peaked in Iceland, Israel, and Spain"
        ]
    },
    {
        "premises-NL": [
            "All people who limp often and regularly have long-term medical issues with underlying causes.",
            "If people have long-term medical issues with underlying causes, then they are not often spry and energetic.",
            "People either stay indoors and rest a lot at home or people are often tired and disinterested in their activities.",
            "If people stay indoors and rest a lot at home, then they do not visit the gym at least once a day.",
            "If Mark either limps often and regularly or is often spry and energetic, then Mark limps often and regularly or is often tired and disinterested in his activities."
        ],
        "predicates": [
            "Limp(x) ::: x limps often and regularly",
            "Medical(x) ::: x has long-term medical issues with underlying causes",
            "Spry(x) ::: x is often spry and energetic",
            "Tired(x) ::: x is often tired and disinterested in their activities",
            "Indoors(x) ::: x stays indoors and rests a lot at home",
            "Gym(x) ::: x visits the gym at least once a day"
        ],
        "premises-FOL": [
            "∀x (Limp(x) → Medical(x)) ::: All people who limp often and regularly have long-term medical issues with underlying causes.",
            "∀x (Medical(x) → ¬Spry(x)) ::: If people have long-term medical issues with underlying causes, then they are not often spry and energetic.",
            "∀x (Indoors(x) ∨ Tired(x)) ::: People either stay indoors and rest a lot at home or people are often tired and disinterested in their activities.",
            "∀x (Indoors(x) → ¬Gym(x)) ::: If people stay indoors and rest a lot at home, then they do not visit the gym at least once a day.",
            "(Limp(Mark) ∨ Spry(Mark)) → (Limp(Mark) ∨ Tired(Mark)) ::: If Mark either limps often and regularly or is often spry and energetic, then Mark limps often and regularly or is often tired and disinterested in his activities."
        ]
    },
    {
        "premises-NL": [
            "System 7 is a UK-based electronic dance music band.",
            "Steve Hillage and Miquette Giraudy formed System 7.",
            "Steve Hillage and Miquette Giraudy are former members of the band Gong.",
            "Electric dance music bands are bands.",
            "System 7 has released several club singles.",
            "Club singles are not singles."
        ],
        "predicates": [
            "BasedOn(x, y) ::: x is based in y",
            "ElectronicDanceMusicBand(x) ::: x is an electronic dance music band",
            "Formed(x, y) ::: x formed y",
            "FormerMemberOf(x, y) ::: x is a former member of y",
            "Band(x) ::: x is a band",
            "ClubSingle(x) ::: x is a club single",
            "Released(x, y) ::: x released y",
            "Single(x) ::: x is a single"
        ],
        "premises-FOL": [
            "BasedOn(system7, uk) ∧ ElectronicDanceMusicBand(system7) ::: System 7 is based in the UK and is an electronic dance music band.",
            "Formed(stevehillage, system7) ∧ Formed(miquettegiraudy, system7) ::: Steve Hillage and Miquette Giraudy formed System 7.",
            "FormerMemberOf(stevehillage, gong) ∧ FormerMemberOf(miquettegiraudy, gong) ::: Steve Hillage and Miquette Giraudy are former members of Gong.",
            "∀x (ElectronicDanceMusicBand(x) → Band(x)) ::: If x is an electronic dance music band, then x is a band.",
            "∃x (ClubSingle(x) ∧ Released(system7, x)) ::: There exists an x such that x is a club single and System 7 released x.",
            "∀x (ClubSingle(x) → ¬Single(x)) ::: If x is a club single, then x is not a single."
        ]
    },
    {
        "premises-NL": [
            "A summarization model is always faithful if it uses content from the input documents.",
            "Extractive models are a kind of summarization models.",
            "Extractive model can only use content from the input documents."
        ],
        "predicates": [
            "Model(x) ::: x is a model",
            "Summarization(x) ::: x is a summarization model",
            "Faithful(x) ::: x is faithful",
            "OnlyUseInputDocument(x) ::: x only uses content from the input document",
            "Extractive(x) ::: x is an extractive model"
        ],
        "premises-FOL": [
            "∀x (Model(x) ∧ Summarization(x) ∧ OnlyUseInputDocument(x) → Faithful(x)) ::: A summarization model is always faithful if it uses content from the input documents.",
            "∀x (Model(x) ∧ Extractive(x) → Summarization(x)) ::: Extractive models are a kind of summarization models.",
            "∀x (Model(x) ∧ Extractive(x) → OnlyUseInputDocument(x)) ::: Extractive model can only use content from the input documents."
        ]
    },
    {
        "premises-NL": [
            "If people practice coding questions, then they are not studying to go to medical school to become a doctor.",
            "If people want to work in the software engineering industry, then they practice coding questions.",
            "If people enjoy healthcare fields and want to help people with medical issues, then they are studying to go to medical school to become a doctor.",
            "If people grew up with parents who worked as doctors, then they enjoy healthcare fields and want to help people with medical issues.",
            "If people study hard, then they grew up with parents who worked as doctors.",
            "If Robin neither enjoys healthcare fields and wants to help people with medical issues nor grew up with parents who worked as doctors, then Robin is either a person who studies hard or grew up with parents who worked as doctors."
        ],
        "predicates": [
            "Coding(x) ::: Person x practices coding questions",
            "StudyingToBeDoctor(x) ::: Person x is studying to go to medical school to become a doctor",
            "Industry(x) ::: Person x wants to work in the software engineering industry",
            "Healthcare(x) ::: Person x enjoys healthcare fields and wants to help people with medical issues",
            "ParentDoctors(x) ::: Person x grew up with parents who worked as doctors",
            "Study(x) ::: Person x studies hard"
        ],
        "premises-FOL": [
            "∀x Coding(x) → ¬StudyingToBeDoctor(x) ::: If people practice coding questions, then they are not studying to go to medical school to become a doctor.",
            "∀x Industry(x) → Coding(x) ::: If people want to work in the software engineering industry, then they practice coding questions.",
            "∀x Healthcare(x) → StudyingToBeDoctor(x) ::: If people enjoy healthcare fields and want to help people with medical issues, then they are studying to go to medical school to become a doctor.",
            "∀x ParentDoctors(x) → Healthcare(x) ::: If people grew up with parents who worked as doctors, then they enjoy healthcare fields and want to help people with medical issues.",
            "∀x Study(x) → ParentDoctors(x) ::: If people study hard, then they grew up with parents who worked as doctors.",
            "¬(Healthcare(Robin) ∨ ParentDoctors(Robin)) → (Study(Robin) ∨ ParentDoctors(Robin)) ::: If Robin neither enjoys healthcare fields and wants to help people with medical issues nor grew up with parents who worked as doctors, then Robin is either a person who studies hard or grew up with parents who worked as doctors."
        ]
    },
    {
        "premises-NL": [
            "If people go to the spa at least once a week, then they are not people who are miserly and need to save a large portion of their income.",
            "People are either miserly and need to save a large portion of their income, or people that frivolously spend a lot of money every time they go out.",
            "If people frivolously spend a lot of money every time they go out, then they value quality manufacturing and luxury items.",
            "If people value quality manufacturing and luxury items, then they enjoy shopping for materialistic items in their free time.",
            "If Jess is not miserly and needs to save a large portion of their income, then Jess does not value quality manufacturing and luxury items.",
            "If Jess either values quality manufacturing and luxury items or, if he does not, then he is miserly and needs to save a large portion of his income, then Jess frivolously spends a lot of money every time he goes out."
        ],
        "predicates": [
            "Spa(x) ::: x goes to the spa at least once a week",
            "Miserly(x) ::: x is miserly and needs to save a large portion of their income",
            "Frivolous(x) ::: x frivolously spends a lot of money every time they go out",
            "Luxury(x) ::: x values quality manufacturing and luxury items",
            "Shopping(x) ::: x enjoys shopping for materialistic items in their free time"
        ],
        "premises-FOL": [
            "∀x Spa(x) → ¬Miserly(x) ::: If people go to the spa at least once a week, then they are not people who are miserly and need to save a large portion of their income.",
            "∀x Miserly(x) ∨ Frivolous(x) ::: People are either miserly and need to save a large portion of their income, or people that frivolously spend a lot of money every time they go out.",
            "∀x Frivolous(x) → Luxury(x) ::: If people frivolously spend a lot of money every time they go out, then they value quality manufacturing and luxury items.",
            "∀x Luxury(x) → Shopping(x) ::: If people value quality manufacturing and luxury items, then they enjoy shopping for materialistic items in their free time.",
            "¬Miserly(Jess) → ¬Luxury(Jess) ::: If Jess is not miserly and needs to save a large portion of their income, then Jess does not value quality manufacturing and luxury items.",
            "(Luxury(Jess) ∨ ¬Luxury(Jess)) → Frivolous(Jess) ::: If Jess either values quality manufacturing and luxury items or, if he does not, then he is miserly and needs to save a large portion of his income, then Jess frivolously spends a lot of money every time he goes out."
        ]
    },
    {
        "premises-NL": [
            "The indie pop band Phoenix has released 6 albums. ",
            "Phoenix's album Wolfgang Amadeus Phoenix sold over 500,000 copies. ",
            "A certified gold album or single is one which sold over half a million copies. ",
            "1901 is a single from Phoenix's album Wolfgang Amadeus Phoenix.",
            "Over 400,000 copies of 1901 have been sold. "
        ],
        "predicates": [
            "AlbumsReleased(x, y) ::: band x has released y albums",
            "Album(x) ::: x is an album",
            "IsAlbumOf(x, y) ::: album x is an album of y",
            "SoldOver(x, y) ::: x sold over y copies",
            "CertifiedGold(x) ::: x is certified gold",
            "Single(x) ::: x is a single",
            "From(x, y) ::: single x is from album y",
            "By(x, y) ::: single x is by band y"
        ],
        "premises-FOL": [
            "AlbumsReleased(phoenix, 6) ::: The indie pop band Phoenix has released 6 albums.",
            "Album(wolfgangamadeusphoenix) ∧ IsAlbumOf(wolfgangamadeusphoenix, phoenix) ∧ SoldOver(wolfgangamadeusphoenix, 500000) ::: Phoenix's album Wolfgang Amadeus Phoenix sold over 500,000 copies.",
            "∀x ((Album(x) ∨ Single(x)) ∧ SoldOver(x, 500000) → CertifiedGold(x)) ::: A certified gold album or single is one which sold over half a million copies.",
            "Single(1901) ∧ From(1901, wolfgangamadeusphoenix) ∧ By(1901, phoenix) ::: 1901 is a single from Phoenix's album Wolfgang Amadeus Phoenix.",
            "SoldOver(1901, 400000) ::: Over 400,000 copies of 1901 have been sold."
        ]
    },
    {
        "premises-NL": [
            "Peter Parker is a either a superhero or a civilian.",
            "The Hulk is a destroyer.",
            "The Hulk wakes up when he is angry.",
            "If the Hulk wakes up, then he will break a bridge.",
            "Thor is a god.",
            "Thor will break a bridge when he is happy.",
            "A god is not a destroyer and a destroyer is not a god.",
            "Peter Parker wears a uniform when he is a superhero.",
            "Peter Parker is not a civilian if and only if a destroyer is breaking a bridge.",
            "If Thor is happy, the Hulk is angry."
        ],
        "predicates": [
            "Superhero(x) ::: x is a superhero",
            "Civilian(x) ::: x is a civilian",
            "Destroyer(x) ::: x is a destroyer",
            "Wake(x) ::: x wakes up",
            "Angry(x) ::: x is angry",
            "BreakBridge(x) ::: x will break a bridge",
            "God(x) ::: x is a god",
            "Happy(x) ::: x is happy",
            "WearUniform(x) ::: x wears a uniform"
        ],
        "premises-FOL": [
            "Superhero(peter) ⊕ Civilian(peter) ::: Peter Parker is either a superhero or a civilian",
            "Destroyer(hulk) ::: The Hulk is a destroyer",
            "Angry(hulk) → Wake(hulk) ::: The Hulk wakes up when he is angry",
            "Wake(hulk) → BreakBridge(hulk) ::: If the Hulk wakes up, then he will break a bridge",
            "God(thor) ::: Thor is a god",
            "Happy(thor) → BreakBridge(thor) ::: Thor will break a bridge when he is happy",
            "∀x (God(x) ↔ ¬Destroyer(x)) ::: A god is not a destroyer and a destroyer is not a god",
            "Superhero(peter) → WearUniform(peter) ::: Peter Parker wears a uniform when he is a superhero",
            "∀x (¬Civilian(peter) ↔ (Destroyer(x) ∧ BreakBridge(x))) ::: Peter Parker is not a civilian if and only if a destroyer is breaking a bridge",
            "Happy(thor) → Angry(hulk) ::: If Thor is happy, the Hulk is angry"
        ]
    },
    {
        "premises-NL": [
            "Diethylcarbamazine is a medication discovered in the year 1947.",
            "Diethylcarbamazine can be used to treat river blindness.",
            "The only preferred treatment for river blindness is ivermectin.",
            "Diethylcarbamazine is not ivermectin."
        ],
        "predicates": [
            "Diethylcarbamazine(x) ::: x is Diethylcarbamazine",
            "Medication(x) ::: x is a medication",
            "DiscoveredIn(x, y) ::: x was discovered in year y",
            "RiverBlindness(y) ::: y is river blindness",
            "Treats(x, y) ::: x treats y",
            "PreferredTreatment(x, y) ::: x is the preferred treatment for y",
            "Ivermectin(x) ::: x is ivermectin"
        ],
        "premises-FOL": [
            "Diethylcarbamazine(x) ∧ Medication(x) ∧ DiscoveredIn(x, 1947) ::: Diethylcarbamazine x is a medication and was discovered in 1947",
            "Diethylcarbamazine(x) ∧ RiverBlindness(y) → Treats(x, y) ::: If x is Diethylcarbamazine and y is river blindness, then x treats y",
            "RiverBlindness(y) ∧ PreferredTreatment(x, y) → Ivermectin(x) ::: If y is river blindness and x is the preferred treatment for y, then x is ivermectin",
            "Diethylcarbamazine(x) → ¬Ivermectin(x) ::: If x is Diethylcarbamazine, then x is not ivermectin"
        ]
    },
    {
        "premises-NL": [
            "All univariate analyses use a generalized linear model. ",
            "All multivoxel (pattern) analyses are implementing machine learning algorithms.",
            "All implementing machine learning algorithms are to learn and classify multivariate data.",
            "The Latent Dirichlet allocation model uses a generalized linear model or a univariate analysis. ",
            "If the Latent Dirichlet allocation model does not learn and classify multivariate data, then the Latent Dirichlet allocation model uses a generalized linear model and a multivoxel (pattern) analysis."
        ],
        "predicates": [
            "UnivariateAnalysis(x) ::: x is a univariate analysis",
            "UsesGeneralizedLinearModel(x) ::: x uses a generalized linear model",
            "MultivoxelPatternAnalysis(x) ::: x is a multivoxel pattern analysis",
            "ImplementingMachineLearningAlgorithms(x) ::: x is implementing machine learning algorithms",
            "LearnAndClassifyMultivariateData(x) ::: x learns and classifies multivariate data"
        ],
        "premises-FOL": [
            "∀x (UnivariateAnalysis(x) → UsesGeneralizedLinearModel(x)) ::: All univariate analyses use a generalized linear model",
            "∀x (MultivoxelPatternAnalysis(x) → ImplementingMachineLearningAlgorithms(x)) ::: All multivoxel (pattern) analyses are implementing machine learning algorithms",
            "∀x (ImplementingMachineLearningAlgorithms(x) → LearnAndClassifyMultivariateData(x)) ::: All implementing machine learning algorithms are to learn and classify multivariate data",
            "UsesGeneralizedLinearModel(latentDirichletAllocationModel) ∨ UnivariateAnalysis(latentDirichletAllocationModel) ::: The Latent Dirichlet allocation model uses a generalized linear model or a univariate analysis",
            "¬LearnAndClassifyMultivariateData(latentDirichletAllocationModel) → UsesGeneralizedLinearModel(latentDirichletAllocationModel) ∧ MultivoxelPatternAnalysis(latentDirichletAllocationModel) ::: If the Latent Dirichlet allocation model does not learn and classify multivariate data, then the Latent Dirichlet allocation model uses a generalized linear model and a multivoxel (pattern) analysis"
        ]
    },
    {
        "premises-NL": [
            "If something requires a medical diagnosis, then lab tests or imaging is required. ",
            "All rare diseases require a medical diagnosis.",
            "If something is mild, then no lab tests or imaging is required. ",
            "All blood cancers are rare diseases.",
            "All Leukemia is blood cancer. ",
            "If bladder cancer is either both blood cancer and Leukemia or neither blood cancer nor Leukemia, then bladder cancer is Leukemia."
        ],
        "predicates": [
            "RequiresAMedicalDiagnosis(x) ::: x requires a medical diagnosis",
            "LabTestsOrImagingRequired(x) ::: lab tests or imaging is required for x",
            "RareDiseases(x) ::: x is a rare disease",
            "Mild(x) ::: x is mild",
            "BloodCancer(x) ::: x is blood cancer",
            "Leukemia(x) ::: x is leukemia"
        ],
        "premises-FOL": [
            "∀x (RequiresAMedicalDiagnosis(x) → LabTestsOrImagingRequired(x)) ::: If something requires a medical diagnosis, then lab tests or imaging is required.",
            "∀x (RareDiseases(x) → RequiresAMedicalDiagnosis(x)) ::: All rare diseases require a medical diagnosis.",
            "∀x (Mild(x) → ¬LabTestsOrImagingRequired(x)) ::: If something is mild, then no lab tests or imaging is required.",
            "∀x (BloodCancer(x) → RareDiseases(x)) ::: All blood cancers are rare diseases.",
            "∀x (Leukemia(x) → BloodCancer(x)) ::: All Leukemia is blood cancer.",
            "¬(BloodCancer(bladderCancer) ⊕ Leukemia(bladderCancer)) → Leukemia(bladderCancer) ::: If bladder cancer is either both blood cancer and Leukemia or neither blood cancer nor Leukemia, then bladder cancer is Leukemia."
        ]
    },
    {
        "premises-NL": [
            "No precious metals aren't scarce.",
            "All non-rare earth metals are not scarce.",
            "Either non-rare earth metals or rare earth metals. ",
            "All rare earth metals can be used for batteries.",
            "All rare earth metals are essential for electric vehicles.",
            "Lithium is neither a non-rare earth metal nor essential for electric vehicles."
        ],
        "predicates": [
            "PreciousMetals(x) ::: x is a precious metal",
            "NotScarce(x) ::: x is not scarce",
            "Non-rareEarthMetals(x) ::: x is a non-rare earth metal",
            "RareEarthMetals(x) ::: x is a rare earth metal",
            "BeUsedForBatteries(x) ::: x can be used for batteries",
            "EssentialForElectricVehicles(x) ::: x is essential for electric vehicles"
        ],
        "premises-FOL": [
            "∀x (PreciousMetals(x) → ¬NotScarce(x)) ::: All precious metals are scarce.",
            "∀x (Non-rareEarthMetals(x) → NotScarce(x)) ::: All non-rare earth metals are not scarce.",
            "∀x (Non-rareEarthMetals(x) ∨ RareEarthMetals(x)) ::: Everything is either a non-rare earth metal or a rare earth metal.",
            "∀x (RareEarthMetals(x) → BeUsedForBatteries(x)) ::: All rare earth metals can be used for batteries.",
            "∀x (RareEarthMetals(x) → EssentialForElectricVehicles(x)) ::: All rare earth metals are essential for electric vehicles.",
            "¬Non-rareEarthMetals(lithium) ∧ ¬EssentialForElectricVehicles(lithium) ::: Lithium is not a non-rare earth metal and lithium is not essential for electric vehicles."
        ]
    },
    {
        "premises-NL": [
            "If people own at least one pet, then they do not have tidy houses.",
            "If people grew up with childhood pets, then they own at least one pet.",
            "If people hire a maid or cleaning service, then they have tidy houses.",
            "If people live in the suburbs, then they have tidy houses.",
            "Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet."
        ],
        "predicates": [
            "OwnPet(x) ::: x owns at least one pet",
            "TidyHouse(x) ::: x has a tidy house",
            "ChildhoodPet(x) ::: x grew up with childhood pets",
            "HireCleaning(x) ::: x hires a maid or cleaning service",
            "Suburbs(x) ::: x lives in the suburbs"
        ],
        "premises-FOL": [
            "∀x (OwnPet(x) → ¬TidyHouse(x)) ::: If people own at least one pet, then they do not have tidy houses.",
            "∀x (ChildhoodPet(x) → OwnPet(x)) ::: If people grew up with childhood pets, then they own at least one pet.",
            "∀x (HireCleaning(x) → TidyHouse(x)) ::: If people hire a maid or cleaning service, then they have tidy houses.",
            "∀x (Suburbs(x) → TidyHouse(x)) ::: If people live in the suburbs, then they have tidy houses.",
            "¬HireCleaning(jack) ∨ ¬OwnPet(jack) ::: Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet."
        ]
    },
    {
        "premises-NL": [
            "A bottle is either standing upright or toppled over. ",
            "The bottle is not upright."
        ],
        "predicates": [
            "Upright(x) ::: x is standing upright",
            "ToppledOver(x) ::: x is toppled over"
        ],
        "premises-FOL": [
            "Upright(bottle) ⊕ ToppledOver(bottle) ::: A bottle is either standing upright or toppled over.",
            "¬Upright(bottle) ::: The bottle is not upright."
        ]
    },
    {
        "premises-NL": [
            "If people eat cereal and milk every day for breakfast, then they have very busy morning schedules every day.",
            "All young children below the age of ten eat cereal and milk every day for breakfast.",
            "People are either young children below the age of ten or have a lot of commitments they voluntarily signed up for.",
            "If people have a lot of commitments they voluntarily signed up for, then they are hardworking individuals with high ambitions and goals for the future.",
            "If people are hardworking individuals with high ambitions and goals for the future, then they are not good at staying organized and motivated.",
            "John either is both a hardworking individual with high ambitions and goals for the future and has busy morning schedules every day, or he is neither a hardworking individual with high ambitions and goals for the future nor does he have a busy morning schedule every day."
        ],
        "predicates": [
            "EatCerealAndMilk(x) ::: x eats cereal and milk every day for breakfast",
            "HaveBusyMorningSchedules(x) ::: x has very busy morning schedules every day",
            "YoungChildren(x) ::: x are young children below the age of ten",
            "HaveALotOfCommitments(x) ::: x has a lot of commitments they voluntarily signed up for",
            "HardworkingIndividuals(x) ::: x are hardworking individuals with high ambitions and goals for the future",
            "GoodAtStayingOrganized(x) ::: x are good at staying organized and motivated"
        ],
        "premises-FOL": [
            "∀x (EatCerealAndMilk(x) → HaveBusyMorningSchedules(x)) ::: If people eat cereal and milk every day for breakfast, then they have very busy morning schedules every day.",
            "∀x (YoungChildren(x) → EatCerealAndMilk(x)) ::: All young children below the age of ten eat cereal and milk every day for breakfast.",
            "∀x (YoungChildren(x) ∨ HaveALotOfCommitments(x)) ::: People are either young children below the age of ten or have a lot of commitments they voluntarily signed up for.",
            "∀x (HaveALotOfCommitments(x) → HardworkingIndividuals(x)) ::: If people have a lot of commitments they voluntarily signed up for, then they are hardworking individuals with high ambitions and goals for the future.",
            "∀x (HardworkingIndividuals(x) → ¬GoodAtStayingOrganized(x)) ::: If people are hardworking individuals with high ambitions and goals for the future, then they are not good at staying organized and motivated.",
            "(HardworkingIndividuals(john) ∧ HaveBusyMorningSchedules(john)) ∨ (¬HardworkingIndividuals(john) ∧ ¬HaveBusyMorningSchedules(john)) ::: John either is both a hardworking individual with high ambitions and goals for the future and has busy morning schedules every day, or he is neither a hardworking individual with high ambitions and goals for the future nor does he have a busy morning schedule every day."
        ]
    },
    {
        "premises-NL": [
            "Every swimmer can go underwater.",
            "Everyone that eats fish they catch themselves is a swimmer.",
            "Every penguin eats fish they catch themselves.",
            "All nonflying birds in Antarctica are penguins.",
            "Fido is a penguin or a swimmer."
        ],
        "predicates": [
            "Swimmer(x) ::: x is a swimmer",
            "GoesUnderwater(x) ::: x can go underwater",
            "EatsFishCaughtThemselves(x) ::: x eats fish they catch themselves",
            "Penguin(x) ::: x is a penguin",
            "NonFlyingBirdAntartica(x) ::: x is a nonflying bird in Antarctica"
        ],
        "premises-FOL": [
            "∀x (Swimmer(x) → GoesUnderwater(x)) ::: Every swimmer can go underwater.",
            "∀x (EatsFishCaughtThemselves(x) → Swimmer(x)) ::: Everyone that eats fish they catch themselves is a swimmer.",
            "∀x (Penguin(x) → EatsFishCaughtThemselves(x)) ::: Every penguin eats fish they catch themselves.",
            "∀x (NonFlyingBirdAntartica(x) → Penguin(x)) ::: All nonflying birds in Antarctica are penguins.",
            "Penguin(fido) ∨ Swimmer(fido) ::: Fido is a penguin or a swimmer."
        ]
    },
    {
        "premises-NL": [
            "All professors are teachers.",
            "All researchers are professors.",
            "No teachers are students.",
            "All people who study are students.",
            "Leon is not studying or a researcher.",
            "If Leon is not studying, then Leon is a teacher."
        ],
        "predicates": [
            "Professor(x) ::: x is a professor",
            "Teacher(x) ::: x is a teacher",
            "Researcher(x) ::: x is a researcher",
            "Student(x) ::: x is a student",
            "Study(x) ::: x studies",
            "Study(x) ::: x is studying"
        ],
        "premises-FOL": [
            "∀x (Professor(x) → Teacher(x)) ::: All professors are teachers",
            "∀x (Researcher(x) → Professor(x)) ::: All researchers are professors",
            "∀x (Teacher(x) → ¬Student(x)) ::: No teachers are students",
            "∀x (Study(x) → Student(x)) ::: All people who study are students",
            "¬Study(leon) ∨ Researcher(leon) ::: Leon is not studying or a researcher",
            "¬Study(leon) → Teacher(leon) ::: If Leon is not studying, then Leon is a teacher"
        ]
    },
    {
        "premises-NL": [
            "No professional tennis umpires are professional tennis players.",
            "If you are a World Tour player, then you are a professional tennis player.",
            "All Grand Slam champions are World Tour players.",
            "All Grand Slam umpires are professional tennis umpires.",
            "Nadal is a World Tour player or a Grand Slam champion"
        ],
        "predicates": [
            "ProfessionalTennisUmpire(x) ::: x is a professional tennis umpire",
            "ProfessionalTennisPlayer(x) ::: x is a professional tennis player",
            "WorldTourPlayer(x) ::: x is a world tour player",
            "GrandSlamChampion(x) ::: x is a grand slam champion",
            "GrandSlamUmpire(x) ::: x is a grand slam umpire"
        ],
        "premises-FOL": [
            "∀x (ProfessionalTennisUmpire(x) → ¬ProfessionalTennisPlayer(x)) ::: No professional tennis umpires are professional tennis players.",
            "∀x (WorldTourPlayer(x) → ProfessionalTennisPlayer(x)) ::: If you are a World Tour player, then you are a professional tennis player.",
            "∀x (GrandSlamChampion(x) → WorldTourPlayer(x)) ::: All Grand Slam champions are World Tour players.",
            "∀x (GrandSlamUmpire(x) → ProfessionalTennisUmpire(x)) ::: All Grand Slam umpires are professional tennis umpires.",
            "WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal) ::: Nadal is a World Tour player or a Grand Slam champion"
        ]
    },
    {
        "premises-NL": [
            "Buisnesses are either sanctioned or unsanctioned.",
            "Sanctioned buisnesses are limited.",
            "Unsanctioned buisnesses are free.",
            "The Crude Oil Data Exchange is a buisness that isn't free."
        ],
        "predicates": [
            "Buisness(x) ::: x is a buisness",
            "Sanctioned(x) ::: x is sanctioned",
            "Unsanctioned(x) ::: x is unsanctioned",
            "Limited(x) ::: x is limited",
            "Free(x) ::: x is free"
        ],
        "premises-FOL": [
            "∀x (Buisness(x) → Sanctioned(x) ∨ Unsanctioned(x)) ::: All buisnesses are either sanctioned or unsanctioned",
            "∀x (Buisness(x) ∧ Sanctioned(x) → Limited(x)) ::: Sanctioned buisnesses are limited",
            "∀x (Buisness(x) ∧ Unsanctioned(x) → Free(x)) ::: Unsanctioned buisnesses are free",
            "Buisness(crudeoildataexchange) ∧ ¬Free(crudeoildataexchange) ::: The Crude Oil Data Exchange is a buisness that isn't free"
        ]
    },
    {
        "premises-NL": [
            "When something is depressing, it is sad.",
            "V is depressing. "
        ],
        "predicates": [
            "Depressing(x) ::: x is depressing",
            "Sad(x) ::: x is sad",
            "V(x) ::: x is V"
        ],
        "premises-FOL": [
            "∀x (Depressing(x) → Sad(x)) ::: When something is depressing, it is sad.",
            "∀x (V(x) → Depressing(x)) ::: V is depressing."
        ]
    },
    {
        "premises-NL": [
            "Palstaves are a type of early bronze axe.",
            "Commonly found in northern, western and south-western Europe, palstaves are cast in moulds.",
            "John Evans is an archeologist who popularized the term palstave.",
            "A paalstab is not an axe, but rather a digging shovel."
        ],
        "predicates": [
            "Palstave(x) ::: x is a palstave",
            "From(x, y) ::: x originated from y",
            "Axe(x) ::: x is an axe",
            "Mould(y) ::: y is a mould",
            "FoundIn(x, y) ::: x is found in y",
            "CastIn(x, y) ::: x is cast in y",
            "Archeologist(x) ::: x is an archeologist",
            "Popularized(x, y) ::: x popularized y",
            "TermPalstave(x) ::: x is the term palstave",
            "Paalstab(x) ::: x is a paalstab",
            "DiggingShovel(x) ::: x is a digging shovel"
        ],
        "premises-FOL": [
            "∀x (Palstave(x) → From(x, earlybronzeage) ∧ Axe(x)) ::: All palstaves are a type of early bronze axe.",
            "∀x ∀y (Palstave(x) ∧ Mould(y) → FoundIn(x, northerneurope) ∧ FoundIn(x, westerneurope) ∧ FoundIn(x, south-westerneurope) ∧ CastIn(x, y)) ::: Palstaves are commonly found in northern, western and south-western Europe, and palstaves are cast in moulds.",
            "Archeologist(johnevans) ∧ Popularized(johnevans, termpalstave) ::: John Evans is an archeologist who popularized the term palstave.",
            "∀x (Paalstab(x) → ¬Axe(x) ∧ DiggingShovel(x)) ::: A paalstab is not an axe, but rather a digging shovel."
        ]
    },
    {
        "premises-NL": [
            "Adam Buska is a European football player.",
            "If a European plays football, they play what Americans call soccer."
        ],
        "predicates": [
            "FootballPlayer(x) ::: x is a football player",
            "European(x) ::: x is European",
            "PlaysAmericanSoccer(x) ::: x plays what Americans call soccer"
        ],
        "premises-FOL": [
            "FootballPlayer(adambuska) ∧ European(adambuska) ::: Adam Buska is a European football player.",
            "∀x ((FootballPlayer(x) ∧ European(x)) → PlaysAmericanSoccer(x)) ::: If a European plays football, they play what Americans call soccer."
        ]
    },
    {
        "premises-NL": [
            "China is one of BRICS and its economy is emerging.",
            "India is one of BRICS and its economy is emerging.",
            "All people from China speak Chinese.",
            "All people from India speak Hindi or English.",
            "There is an Indian."
        ],
        "predicates": [
            "BRICS(x) ::: x is a member of BRICS",
            "China(x) ::: x is China",
            "India(x) ::: x is India",
            "EmergingEconomy(x) ::: x has an emerging economy",
            "From(x, y) ::: x is from y",
            "Speak(x, y) ::: x speaks language y",
            "Chinese(x) ::: x is the Chinese language",
            "Hindi(x) ::: x is the Hindi language",
            "English(x) ::: x is the English language",
            "Person(x) ::: x is a person"
        ],
        "premises-FOL": [
            "China(x) ∧ BRICS(x) ∧ EmergingEconomy(x) ::: China is one of BRICS and its economy is emerging.",
            "India(x) ∧ BRICS(x) ∧ EmergingEconomy(x) ::: India is one of BRICS and its economy is emerging.",
            "∀x (Person(x) ∧ From(x, China) → Speak(x, Chinese)) ::: All people from China speak Chinese.",
            "∀x (Person(x) ∧ From(x, India) → (Speak(x, Hindi) ∨ Speak(x, English))) ::: All people from India speak Hindi or English.",
            "∃x (Person(x) ∧ From(x, India)) ::: There is an Indian."
        ]
    },
    {
        "premises-NL": [
            "Daveed Diggs is an actor and film producer.",
            "Daveed Diggs played two roles in the musical Hamilton.",
            "One of the actors from Hamilton won the best actor award.",
            "The actor playing Thomas Jefferson won the best actor award.",
            "Daveed Diggs played Thomas Jefferson.",
            "Musicals are not films."
        ],
        "predicates": [
            "Actor(x) ::: x is an actor",
            "FilmProducer(x) ::: x is a film producer",
            "PlayedTwoRoles(x) ::: x played two roles",
            "PlayedIn(x, y) ::: x played in y",
            "Musical(x) ::: x is a musical",
            "WonBestActorAward(x) ::: x won the best actor award",
            "Played(x, y) ::: x played y",
            "Film(x) ::: x is a film"
        ],
        "premises-FOL": [
            "Actor(daveedDiggs) ∧ FilmProducer(daveedDiggs) ::: Daveed Diggs is an actor and film producer",
            "PlayedTwoRoles(daveedDiggs) ∧ PlayedIn(daveedDiggs, hamilton) ∧ Musical(hamilton) ::: Daveed Diggs played two roles in the musical Hamilton",
            "∃x (Actor(x) ∧ PlayedIn(x, hamilton) ∧ WonBestActorAward(x)) ::: One of the actors from Hamilton won the best actor award",
            "∀x (Actor(x) ∧ Played(x, thomasJefferson) → WonBestActorAward(x)) ::: The actor playing Thomas Jefferson won the best actor award",
            "Played(daveedDiggs, thomasJefferson) ::: Daveed Diggs played Thomas Jefferson",
            "∀x (Musical(x) → ¬Film(x)) ::: Musicals are not films"
        ]
    },
    {
        "premises-NL": [
            "Ernest Pohl was a Polish football player. ",
            "A football player in the Polish First Division has scored over 180 goals. ",
            "Ernest Pohl scored more than 180 goals in the Polish First Division. ",
            "Górnik Zabrze's stadium was named after a soccer player from Ruda Śląska. ",
            "Ernest Pohl is from Ruda Śląska. "
        ],
        "predicates": [
            "PolishFootballPlayer(x) ::: x is a Polish football player",
            "In(x, y) ::: x is in y",
            "ScoredMoreThan180Goals(x) ::: x scored more than 180 goals",
            "NamedAfter(x, y) ::: x was named after y",
            "FootballPlayer(x) ::: x is a football player",
            "From(x, y) ::: x is from y"
        ],
        "premises-FOL": [
            "PolishFootballPlayer(ernestpohl) ::: Ernest Pohl is a Polish football player",
            "∃x (In(x, polishfirstdivision) ∧ ScoredMoreThan180Goals(x)) ::: A football player in the Polish First Division has scored over 180 goals",
            "ScoredMoreThan180Goals(ernestpohl) ∧ In(ernestpohl, polishfirstdivision) ::: Ernest Pohl scored more than 180 goals in the Polish First Division",
            "∃x (NamedAfter(gornikzabrze, x) ∧ FootballPlayer(x) ∧ From(x, rudaslaska)) ::: Górnik Zabrze's stadium was named after a soccer player from Ruda Śląska",
            "From(ernestpohl, rudaslaska) ::: Ernest Pohl is from Ruda Śląska"
        ]
    },
    {
        "premises-NL": [
            "Ann J. Land was a member of the Philadelphia City Council and was also a member of the Democratic Party.",
            "Ann J. Land ran unopposed for the Philadephia City Council in 1980.",
            "People who run unopposed for the Philadelphia City Council are elected to the positions they run for in the same year.",
            "Michael Nutter was a political challenger.",
            "Ann J. Land defeated Michael Nutter and ran for the Philadelphia City Council in 1987."
        ],
        "predicates": [
            "Member(x, y) ::: x is a member of y",
            "PhiladelphiaCityCouncil(x) ::: x is a member of the Philadelphia City Council",
            "DemocraticParty(x) ::: x is a member of the Democratic Party",
            "RunUnopposedFor(x, y, z) ::: x runs unopposed for y in year z",
            "ElectedTo(x, y, z) ::: x is elected to position y in year z",
            "PoliticalChallenger(x) ::: x is a political challenger",
            "RunFor(x, y, z) ::: x ran for y in year z",
            "Defeated(x, y, z) ::: x defeated y in year z"
        ],
        "premises-FOL": [
            "PhiladelphiaCityCouncil(annJLand) ∧ DemocraticParty(annJLand) ::: Ann J. Land was a member of the Philadelphia City Council and the Democratic Party.",
            "RunUnopposedFor(annJLand, philadephiaCityCouncil, 1980) ::: Ann J. Land ran unopposed for the Philadephia City Council in 1980.",
            "∀x ∀y ∀z (RunUnopposedFor(x, y, z) → ElectedTo(x, y, z)) ::: People who run unopposed for the Philadelphia City Council are elected to the positions they run for in the same year.",
            "PoliticalChallenger(michaelNutter) ::: Michael Nutter was a political challenger.",
            "RunFor(annJLand, philadelphiaCityCouncil, 1987) ∧ Defeated(annJLand, michaelNutter, 1987) ::: Ann J. Land defeated Michael Nutter and ran for the Philadelphia City Council in 1987."
        ]
    },
    {
        "premises-NL": [
            "Aberdeen won the cup in the 2013 final.",
            "Rangers won the cup in 2014 final.",
            "Aberdeen and Rangers are different teams.",
            "Different teams cannot win the same cup in a given year's final."
        ],
        "predicates": [
            "WonCup(x, y) ::: team x won the cup in year y",
            "Different(x, y) ::: team x is different from team y"
        ],
        "premises-FOL": [
            "WonCup(aberdeen, twentythirteen) ::: Aberdeen won the cup in 2013",
            "WonCup(rangers, twentyfourteen) ::: Rangers won the cup in 2014",
            "Different(aberdeen, rangers) ::: Aberdeen and Rangers are different",
            "∀x ∀y ∀z (Different(x, y)  ∧ WonCup(x, z)  → ¬WonCup(y, z)) ::: Different teams cannot win the same cup in a given year's final."
        ]
    },
    {
        "premises-NL": [
            "All young working professionals who have regular 9-5 jobs also have pets.",
            "Some people who live in Manhattan are young working professionals who have regular 9-5 jobs.",
            "All people who have pets are people who have at least one child.",
            "People who do not have at least one child are people who own a sports car.",
            "Mary either does not own a sports car or, if they do, then they do not have at least one child."
        ],
        "predicates": [
            "Young(x) ::: x is young",
            "Working(x) ::: x is a working professional with a 9-5 job",
            "Pets(x) ::: x has pets",
            "Manhattan(x) ::: x lives in Manhattan",
            "Child(x) ::: x has at least one child",
            "Car(x) ::: x owns a sports car",
            "Owns(x,y) ::: x owns y"
        ],
        "premises-FOL": [
            "∀x (Young(x) ∧ Working(x) → Pets(x)) ::: All young working professionals who have regular 9-5 jobs also have pets.",
            "∃x (Manhattan(x) ∧ Young(x) ∧ Working(x)) ::: Some people who live in Manhattan are young working professionals who have regular 9-5 jobs.",
            "∀x (Pets(x) → Child(x)) ::: All people who have pets are people who have at least one child.",
            "∀x (¬Child(x) → Car(x)) ::: People who do not have at least one child are people who own a sports car.",
            "¬Car(mary) ∨ ¬Child(mary) ::: Mary either does not own a sports car or, if they do, then they do not have at least one child."
        ]
    },
    {
        "premises-NL": [
            "Either block design or event-related design. ",
            "All event-related designs are brain image acquisition.",
            "All brain image acquisition is preceded by data processing.",
            "Nothing preceded by data processing acquires data.",
            "Picture memory is either an event-related design and acquiring data or neither an event-related design nor acquiring data."
        ],
        "predicates": [
            "BlockDesign(x) ::: x is a block design",
            "Event-relatedDesign(x) ::: x is an event-related design",
            "BrainImageAcquisition(x) ::: x is brain image acquisition",
            "PrecededByDataProcessing(x) ::: x is preceded by data processing",
            "AcquiringData(x) ::: x acquires data"
        ],
        "premises-FOL": [
            "∀x (BlockDesign(x) ∨ Event-relatedDesign(x)) ::: Either x is a block design or x is an event-related design",
            "∀x (Event-relatedDesign(x) → BrainImageAcquisition(x)) ::: If x is an event-related design, then x is brain image acquisition",
            "∀x (BrainImageAcquisition(x) → PrecededByDataProcessing(x)) ::: If x is brain image acquisition, then x is preceded by data processing",
            "∀x (PrecededByDataProcessing(x) → ¬AcquiringData(x)) ::: If x is preceded by data processing, then x does not acquire data",
            "(Event-relatedDesign(pictureMemory) ∧ AcquiringData(pictureMemory)) ∨ (¬Event-relatedDesign(pictureMemory) ∧ ¬AcquiringData(pictureMemory)) ::: picture memory is either an event-related design and acquiring data or neither an event-related design nor acquiring data"
        ]
    },
    {
        "premises-NL": [
            "The USS Lyon was a US Navy ship involved in WWII.",
            "All ships involved in WWII are currently decommissioned or in a museum."
        ],
        "predicates": [
            "USNavyShip(x) ::: x is a US Navy ship",
            "InWWII(x) ::: x was involved in WWII",
            "Decommissioned(x) ::: x is currently decommissioned",
            "InMuseum(x) ::: x is in a museum"
        ],
        "premises-FOL": [
            "USNavyShip(usslyon) ∧ InWWII(usslyon) ::: The USS Lyon was a US Navy ship involved in WWII",
            "∀x (InWWII(x) → (Decommissioned(x) ∨ InMuseum(x))) ::: All ships involved in WWII are currently decommissioned or in a museum"
        ]
    },
    {
        "premises-NL": [
            "Anything that is lazy is unproductive.",
            "No one unproductive is an energetic person.",
            "If something is a sloth, then it is lazy.",
            "Some animals are sloths.",
            "Sid is not either an energetic person or a sloth."
        ],
        "predicates": [
            "Lazy(x) ::: x is lazy",
            "Unproductive(x) ::: x is unproductive",
            "Energetic(x) ::: x is an energetic person",
            "Sloth(x) ::: x is a sloth",
            "Animal(x) ::: x is an animal"
        ],
        "premises-FOL": [
            "∀x (Lazy(x) → Unproductive(x)) ::: Anything that is lazy is unproductive.",
            "∀x (Unproductive(x) → ¬Energetic(x)) ::: No one unproductive is an energetic person.",
            "∀x (Sloth(x) → Lazy(x)) ::: If something is a sloth, then it is lazy.",
            "∃x (Animal(x) ∧ Sloth(x)) ::: Some animals are sloths.",
            "¬Energetic(sid) ∧ ¬Sloth(sid) ::: Sid is not either an energetic person or a sloth."
        ]
    },
    {
        "premises-NL": [
            "European soccer clubs can attend UCL, UEL and UECL.",
            "A soccer club eligible to attend UCL has a higher ranking than a soccer club eligible to attend UEL.",
            "A soccer club eligible to attend UEL has a higher ranking than a soccer club eligible to attend UECL.",
            "Manchester United and Machester City are both European soccer clubs.",
            "Manchester United is eligible to attend UEL next season.",
            "Manchester City is eligible to attend UCL next season."
        ],
        "predicates": [
            "European(x) ::: x is European",
            "SoccerClub(x) ::: x is a soccer club",
            "Attend(x, y) ::: soccer club x can attend competition y",
            "HigherRank(x, y) ::: soccer club x has a higher ranking than soccer club y"
        ],
        "premises-FOL": [
            "∀x (European(x) ∧ SoccerClub(x) → Attend(x, ucl) ∨ Attend(x, uel) ∨ Attend(x, uecl)) ::: European soccer clubs can attend UCL, UEL and UECL.",
            "∀x ∀y (SoccerClub(x) ∧ SoccerClub(y) ∧ Attend(x, ucl) ∧ Attend(y, uel) → HigherRank(x, y)) ::: A soccer club eligible to attend UCL has a higher ranking than a soccer club eligible to attend UEL.",
            "∀x ∀y (SoccerClub(x) ∧ SoccerClub(y) ∧ Attend(x, uel) ∧ Attend(y, uecl) → HigherRank(x, y)) ::: A soccer club eligible to attend UEL has a higher ranking than a soccer club eligible to attend UECL.",
            "European(manchesterunited) ∧ SoccerClub(manchesterunited) ∧ European(manchestercity) ∧ SoccerClub(manchestercity) ::: Manchester United and Machester City are both European soccer clubs.",
            "Attend(manchesterunited, uel) ::: Manchester United is eligible to attend UEL next season.",
            "Attend(manchestercity, ucl) ::: Manchester City is eligible to attend UCL next season."
        ]
    },
    {
        "premises-NL": [
            "All cats are cute.",
            "Ghosts do not exist.",
            "An animal is either a cat or a dog.",
            "Nothing that barks is lovely. ",
            "If something is a dog, then it barks.",
            "Grace is either a cat and a dog, or neither a cat nor a dog."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Cute(x) ::: x is cute",
            "Ghost(x) ::: x is a ghost",
            "Dog(x) ::: x is a dog",
            "Bark(x) ::: x barks",
            "Lovely(x) ::: x is lovely"
        ],
        "premises-FOL": [
            "∀x (Cat(x) → Cute(x)) ::: All cats are cute.",
            "∀x (¬Ghost(x)) ::: Ghosts do not exist.",
            "∀x (Animal(x) → (Cat(x) ∨ Dog(x))) ::: An animal is either a cat or a dog.",
            "∀x (Bark(x) → ¬Lovely(x)) ::: Nothing that barks is lovely.",
            "∀x (Dog(x) → Bark(x)) ::: If something is a dog, then it barks.",
            "((Cat(grace) ∧ Dog(grace)) ∨ (¬Cat(grace) ∧ ¬Dog(grace))) ::: Grace is either both a cat and a dog, or neither a cat nor a dog."
        ]
    },
    {
        "premises-NL": [
            "Herodicus was a Greek physician, dietician, sophist, and gymnastic-master.",
            "Herodicus was born in the city of Selymbria.",
            "Selymbria is a colony of the city-state Megara.",
            "One of the tutors of Hippocrates was Herodicus.",
            "Massages were recommended by Herodicus.",
            "Some of theories of Herodicus are considered to be the foundation of sports medicine."
        ],
        "predicates": [
            "Greek(x) ::: x is Greek",
            "Physician(x) ::: x is a physician",
            "Dietician(x) ::: x is a dietician",
            "Sophist(x) ::: x is a sophist",
            "GymnasticMaster(x) ::: x is a gymnastic master",
            "Born(x, y) ::: x was born in y",
            "City(x) ::: x is a city",
            "Colony(x, y) ::: x is a colony of y",
            "CityState(x) ::: x is a city-state",
            "Tutored(x, y) ::: x tutored y",
            "Recommended(x, y) ::: x recommended y",
            "Theory(x) ::: x is a theory",
            "From(x, y) ::: x is from y",
            "FoundationOf(x, y) ::: x is the foundation of y"
        ],
        "premises-FOL": [
            "Greek(herodicus) ∧ Physician(herodicus) ∧ Dietician(herodicus) ∧ Sophist(herodicus) ∧ GymnasticMaster(herodicus) ::: Herodicus was Greek, a physician, a dietician, a sophist, and a gymnastic master.",
            "Born(herodicus, selymbia) ∧ City(selymbia) ::: Herodicus was born in Selymbria, which is a city.",
            "Colony(selymbia, megara) ∧ CityState(megara) ::: Selymbria is a colony of Megara, which is a city-state.",
            "Tutored(herodicus, hippocrates) ::: Herodicus was a tutor of Hippocrates.",
            "Recommended(herodicus, massages) ::: Herodicus recommended massages.",
            "∃x (Theory(x) ∧ From(x, herodicus) ∧ FoundationOf(x, sportsmedicine)) ::: Some theories of Herodicus are the foundation of sports medicine."
        ]
    },
    {
        "premises-NL": [
            "No kid loves the Opera.",
            "All adults love the Opera.",
            "If someone is a scientist, then they are an adult.",
            "Some students are kids.",
            "Billy is a kid."
        ],
        "predicates": [
            "Kid(x) ::: x is a kid",
            "OperaLover(x) ::: x loves the opera",
            "Adult(x) ::: x is an adult",
            "Scientist(x) ::: x is a scientist",
            "Student(x) ::: x is a student"
        ],
        "premises-FOL": [
            "∀x (Kid(x) → ¬OperaLover(x)) ::: No kid loves the Opera.",
            "∀x (Adult(x) → OperaLover(x)) ::: All adults love the Opera.",
            "∀x (Scientist(x) → Adult(x)) ::: If someone is a scientist, then they are an adult.",
            "∃x (Student(x) ∧ Kid(x)) ::: Some students are kids.",
            "Kid(billy) ::: Billy is a kid."
        ]
    },
    {
        "premises-NL": [
            "Brian Winter is a Scottish football referee.",
            "After being injured, Brian Winter retired in 2012.",
            "Brian Winter was appointed as a referee observer after his retirement.",
            "Some football referees become referee observers.",
            "The son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical."
        ],
        "predicates": [
            "Scottish(x) ::: x is Scottish",
            "FootballReferee(x) ::: x is a football referee",
            "Injured(x) ::: x is injured",
            "Retired(x) ::: x is retired",
            "RefereeObserver(x) ::: x is a referee observer",
            "Son(x, y) ::: x is the son of y",
            "FootballPlayer(x) ::: x is a football player",
            "PlaysFor(x, y) ::: x plays for y"
        ],
        "premises-FOL": [
            "Scottish(brianwinter) ∧ FootballReferee(brianwinter) ::: Brian Winter is Scottish and a football referee",
            "Injured(brianwinter) ∧ Retired(brianwinter) ::: Brian Winter was injured and retired",
            "RefereeObserver(brianwinter) ::: Brian Winter is a referee observer",
            "∃x (FootballReferee(x) ∧ RefereeObserver(x)) ::: There exists an x such that x is a football referee and x is a referee observer",
            "Son(andywinter, brianwinter) ∧ FootballPlayer(andywinter) ∧ PlaysFor(andywinter, hamiltonacademical) ::: Andy Winter is the son of Brian Winter, Andy Winter is a football player, and Andy Winter plays for Hamilton Academical"
        ]
    },
    {
        "premises-NL": [
            "People are either interested in puzzles or bad at chess.",
            "If a person is bad at chess, then they don't play a lot of chess.",
            "A person is either a planner or a creative person.",
            "Erica is someone who plays a lot of chess.",
            "If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative."
        ],
        "predicates": [
            "Puzzles(x) ::: x is interested in puzzles",
            "BadChess(x) ::: x is bad at chess",
            "PlaysLots(x) ::: x plays a lot of chess",
            "Plans(x) ::: x is a planner",
            "Creative(x) ::: x is a creative person"
        ],
        "premises-FOL": [
            "∀x (Puzzles(x) ∨ BadChess(x)) ::: People are either interested in puzzles or bad at chess.",
            "∀x (BadChess(x) → ¬PlaysLots(x)) ::: If a person is bad at chess, then they don't play a lot of chess.",
            "∀x (Plans(x) ∨ Creative(x)) ::: A person is either a planner or a creative person.",
            "PlaysLots(erica) ::: Erica is someone who plays a lot of chess.",
            "¬(BadChess(erica) ∨ Creative(erica)) → ((Plans(erica) ∧ Creative(erica)) ∨ (¬Plans(erica) ∧ ¬Creative(erica))) ::: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative."
        ]
    },
    {
        "premises-NL": [
            "Soccer players have a right foot and a left foot.",
            "Top soccer players are soccer players who can use their both feet very efficiently.",
            "If a soccer player can score many goals using left foot, then they can use that foot very efficiently.",
            "If a soccer player can score many goals using right foot, then they can use that foot very efficiently.",
            "Cristiano Ronaldo is a soccer player.",
            "Cristiano Ronaldo can use his right foot very efficiently.",
            "Cristiano Ronaldo have scored more than one hundred goals using his left foot."
        ],
        "predicates": [
            "SoccerPlayer(x) ::: x is a soccer player",
            "HasRightFoot(x) ::: x has a right foot",
            "HasLeftFoot(x) ::: x has a left foot",
            "Efficient(x, y) ::: x can use foot y efficiently",
            "Top(x) ::: x is a top soccer player",
            "ScoreManyGoals(x, y) ::: x can score many goals using foot y"
        ],
        "premises-FOL": [
            "∀x (SoccerPlayer(x) → HasLeftFoot(x) ∧ HasRightFoot(x)) ::: All soccer players have a left foot and a right foot.",
            "∀x (SoccerPlayer(x) ∧ Efficient(x, left) ∧ Efficient(x, right) → Top(x)) ::: All soccer players who can use their both feet very efficiently are top soccer players.",
            "∀x (SoccerPlayer(x) ∧ ScoreManyGoals(x, left) → Efficient(x, left)) ::: If a soccer player can score many goals using left foot, then they can use that foot very efficiently.",
            "∀x (SoccerPlayer(x) ∧ ScoreManyGoals(x, right) → Efficient(x, right)) ::: If a soccer player can score many goals using right foot, then they can use that foot very efficiently.",
            "SoccerPlayer(ronaldo) ::: Cristiano Ronaldo is a soccer player.",
            "Efficient(ronaldo, right) ::: Cristiano Ronaldo can use his right foot very efficiently.",
            "ScoreManyGoals(ronaldo, left) ::: Cristiano Ronaldo have scored more than one hundred goals using his left foot."
        ]
    },
    {
        "premises-NL": [
            "The National Lobster Hatchery is a hatchery located in Padstow England.",
            "The National Lobster Hatchery is open to visitors.",
            "A hatchery is either for profit, or for conservation.",
            "If a hatchery is for conservation, it might release animals into the wild.",
            "The National Lobster Hatchery is not for profit."
        ],
        "predicates": [
            "Hatchery(x) ::: x is a hatchery",
            "LocatedIn(x, y) ::: x is located in y",
            "OpenToVisitors(x) ::: x is open to visitors",
            "ForConservation(x) ::: x is for conservation",
            "ForProfit(x) ::: x is for profit",
            "ReleasesAnimalsToWild(x) ::: x releases animals into the wild"
        ],
        "premises-FOL": [
            "Hatchery(nationallobsterhatchery) ∧ LocatedIn(nationallobsterhatchery, padstowengland) ::: The National Lobster Hatchery is a hatchery located in Padstow England.",
            "OpenToVisitors(nationallobsterhatchery) ::: The National Lobster Hatchery is open to visitors.",
            "∀x (Hatchery(x) → ForProfit(x) ∨ ForConservation(x)) ::: A hatchery is either for profit, or for conservation.",
            "∀x (Hatchery(x) ∧ ForConservation(x) → MightReleaseAnimalsToWild(x)) ::: If a hatchery is for conservation, it might release animals into the wild.",
            "¬ForProfit(nationallobsterhatchery) ::: The National Lobster Hatchery is not for profit."
        ]
    },
    {
        "premises-NL": [
            "Rhos Aelwyd F.C. is a Welsh football club.",
            "Rhos Aelwyd F.C. is the only club based in Ponciau. ",
            "The Premier Division was won in 2005–06 by a team from Ponciau. ",
            "The winner of the Premier Division in 2009–10 was promoted back to the Cymru Alliance.",
            "The Premier Division in 2009–10 was won by the same team that won in 2005-06. "
        ],
        "predicates": [
            "Rhosaelwydfc(x) ::: x is Rhos Aelwyd F.C.",
            "FootballClub(x) ::: x is a football club",
            "Welsh(x) ::: x is Welsh",
            "BasedInPonciau(x) ::: x is based in Ponciau",
            "WonPremierDivisionDuring(x, y) ::: x won the Premier Division during y",
            "Promoted(x) ::: x was promoted"
        ],
        "premises-FOL": [
            "∀x (Rhosaelwydfc(x) → FootballClub(x) ∧ BasedInPonciau(x) ∧ Welsh(x)) ::: Rhos Aelwyd F.C. is a Welsh football club based in Ponciau.",
            "∀x (BasedInPonciau(x) ↔ Rhosaelwydfc(x)) ::: Rhos Aelwyd F.C. is the only club based in Ponciau.",
            "∃x (BasedInPonciau(x) ∧ WonPremierDivisionDuring(x, 2005)) ::: A team from Ponciau won the Premier Division in 2005–06.",
            "∀x (WonPremierDivisionDuring(x, 2009) → Promoted(x)) ::: The winner of the Premier Division in 2009–10 was promoted.",
            "∀x (WonPremierDivisionDuring(x, 2009) ↔ WonPremierDivisionDuring(x, 2005)) ::: The same team won the Premier Division in 2009–10 and 2005-06."
        ]
    },
    {
        "premises-NL": [
            "All OS are software.",
            "All Mac are OS.",
            "An OS is either Mac or Windows.",
            "All Windows are convenient.",
            "All software has code.",
            "If something is convenient, then it is popular.",
            "Burger is a piece of code and a Mac.",
            "PyTorch is either Windows and software, or neither Windows nor software."
        ],
        "predicates": [
            "OS(x) ::: x is an OS",
            "Software(x) ::: x is software",
            "Mac(x) ::: x is a Mac",
            "Windows(x) ::: x is Windows",
            "Convenient(x) ::: x is convenient",
            "Code(x) ::: x has code",
            "Popular(x) ::: x is popular"
        ],
        "premises-FOL": [
            "∀x (OS(x) → Software(x)) ::: All OS are software",
            "∀x (Mac(x) → OS(x)) ::: All Mac are OS",
            "∀x (OS(x) → (Mac(x) ∨ Windows(x))) ::: An OS is either Mac or Windows",
            "∀x (Windows(x) → Convenient(x)) ::: All Windows are convenient",
            "∀x (Software(x) → Code(x)) ::: All software has code",
            "∀x (Convenient(x) → Popular(x)) ::: If something is convenient, then it is popular",
            "Code(burger) ∧ Mac(burger) ::: Burger is a piece of code and a Mac",
            "(Windows(pytorch) ∧ Software(pytorch)) ⊕ (¬Windows(pytorch) ∧ ¬Software(pytorch)) ::: PyTorch is either Windows and software, or neither Windows nor software"
        ]
    },
    {
        "premises-NL": [
            "Roads are made of either concrete or asphalt.",
            "Roads made of concrete last longer than roads made with asphalt.",
            "Roads made of asphalt are smoother than roads made of concrete.",
            "Everyone prefers the smoother of two roads. ",
            "Road one is made of concrete and Road two is made of asphalt."
        ],
        "predicates": [
            "Road(x) ::: x is a road",
            "MadeOfConcrete(x) ::: x is made of concrete",
            "MadeOfAsphalt(x) ::: x is made of asphalt",
            "LastLonger(x, y) ::: x lasts longer than y",
            "Smoother(x, y) ::: x is smoother than y",
            "Prefers(x, y) ::: x prefers y"
        ],
        "premises-FOL": [
            "∀x (Road(x) → (MadeOfConcrete(x) ∨ MadeOfAsphalt(x))) ::: All roads are made of either concrete or asphalt.",
            "∀x ∀y (Road(x) ∧ MadeOfConcrete(x) ∧ Road(y) ∧ MadeOfAsphalt(y) → LastLonger(x, y)) ::: Roads made of concrete last longer than roads made with asphalt.",
            "∀x ∀y (Road(x) ∧ MadeOfAsphalt(x) ∧ Road(y) ∧ MadeOfConcrete(y) → Smoother(x, y)) ::: Roads made of asphalt are smoother than roads made of concrete.",
            "∀x ∀y ∀z (Road(x) ∧ Road(y) ∧ Smoother(x, y) → Prefers(z, x)) ::: Everyone prefers the smoother of two roads.",
            "Road(one) ∧ MadeOfConcrete(one) ∧ Road(two) ∧ MadeOfAsphalt(two) ::: Road one is made of concrete and Road two is made of asphalt."
        ]
    },
    {
        "premises-NL": [
            "Camp Davern is a traditional summer camp for boys and girls.",
            "Camp Davern was established in the year 1946.",
            "Camp Davern was operated by the YMCA until the year 2015.",
            "Camp Davern is one of Ontario's oldest summer camps."
        ],
        "predicates": [
            "TraditionalSummerCamp(x) ::: x is a traditional summer camp",
            "ForBoysAndGirls(x) ::: x is for both boys and girls",
            "EstablishedIn(x,y) ::: x was established in the year y",
            "OperatedByYMCAUntil(x,y) ::: x was operated by YMCA until the year y",
            "OneOf(x,y) ::: x is one of y"
        ],
        "premises-FOL": [
            "TraditionalSummerCamp(campdavern) ∧ ForBoysAndGirls(campdavern) ::: Camp Davern is a traditional summer camp for boys and girls.",
            "EstablishedIn(campdavern, 1964) ::: Camp Davern was established in the year 1946.",
            "OperatedByYMCAUntil(campdavern, 2015) ::: Camp Davern was operated by the YMCA until the year 2015.",
            "OneOf(campdavern, ontariosoldestsummercamps) ::: Camp Davern is one of Ontario's oldest summer camps."
        ]
    },
    {
        "premises-NL": [
            "If people publish journals, then they do not work in the entertainment industry.",
            "All people who are award-winning novelists publish journals.",
            "People either work in the entertainment industry or are highly acclaimed in their profession.",
            "If people are highly acclaimed in their profession, then they often hold tenured and high-ranking positions at their workplace.",
            "If people are highly acclaimed in their profession, then they often receive glowing feedback and recommendations from their colleagues.",
            "If Emily is either both highly acclaimed in her profession and often holds tenured and high-ranking positions at her workplace, or she is neither highly acclaimed in her profession nor often holds tenured and high-ranking positions at her workplace, then Emily is not highly acclaimed in her profession. "
        ],
        "predicates": [
            "PublishJournals(x) ::: Person x publishes journals",
            "Entertainment(x) ::: Person x works in the entertainment industry",
            "Novelist(x) ::: Person x is an award-winning novelist",
            "Acclaimed(x) ::: Person x is highly acclaimed in their profession",
            "Tenured(x) ::: Person x often holds tenured and high-ranking positions at their workplace",
            "Glowing(x) ::: Person x often receives glowing feedback and recommendations from their colleagues"
        ],
        "premises-FOL": [
            "∀x (PublishJournals(x) → ¬Entertainment(x)) ::: If people publish journals, then they do not work in the entertainment industry.",
            "∀x (Novelist(x) → PublishJournals(x)) ::: All people who are award-winning novelists publish journals.",
            "∀x (Entertainment(x) ∨ Acclaimed(x)) ::: People either work in the entertainment industry or are highly acclaimed in their profession.",
            "∀x (Acclaimed(x) → Tenured(x)) ::: If people are highly acclaimed in their profession, then they often hold tenured and high-ranking positions at their workplace.",
            "∀x (Acclaimed(x) → Glowing(x)) ::: If people are highly acclaimed in their profession, then they often receive glowing feedback and recommendations from their colleagues.",
            "((Acclaimed(emily) ∧ Tenured(emily)) ∨ (¬Acclaimed(emily) ∧ ¬Tenured(emily))) → ¬Acclaimed(emily) ::: If Emily is either both highly acclaimed in her profession and often holds tenured and high-ranking positions at her workplace, or she is neither highly acclaimed in her profession nor often holds tenured and high-ranking positions at her workplace, then Emily is not highly acclaimed in her profession."
        ]
    },
    {
        "premises-NL": [
            "All people are either healthy or not healthy.",
            "People who eat healthy food are healthy.",
            "Healthy people exercise regularly.",
            "People who get enough sleep are healthy.",
            "People with good genes are healthy.",
            "If a person smokes, they are not healthy.",
            "If a person drinks alcohol excessively, they are not healthy.",
            "If a person is happy, they are healthy.",
            "People who have good friends are happy.",
            "People who get regular checkups are healthy.",
            "If a person eats unhealthy food, they are not healthy.",
            "If a person is stressed, they are not healthy.",
            "If a person avoids stress, they are healthy.",
            "People who follow doctor's advice are healthy.",
            "People who exercise regularly live long lives.",
            "Some people are healthy."
        ],
        "premises-FOL": [
            "∀x (Person(x) → (Healthy(x) ∨ ¬Healthy(x))) ::: All people are either healthy or not healthy.",
            "∀x (EatsHealthyFood(x) → Healthy(x)) ::: People who eat healthy food are healthy.",
            "∀x (Healthy(x) → ExercisesRegularly(x)) ::: Healthy people exercise regularly.",
            "∀x (GetsEnoughSleep(x) → Healthy(x)) ::: People who get enough sleep are healthy.",
            "∀x (HasGoodGenes(x) → Healthy(x)) ::: People with good genes are healthy.",
            "∀x (Smokes(x) → ¬Healthy(x)) ::: If a person smokes, they are not healthy.",
            "∀x (DrinksAlcExcess(x) → ¬Healthy(x)) ::: If a person drinks alcohol excessively, they are not healthy.",
            "∀x (IsHappy(x) → Healthy(x)) ::: If a person is happy, they are healthy.",
            "∀x (HasGoodFriends(x) → IsHappy(x)) ::: People who have good friends are happy.",
            "∀x (GetsRegularCheckups(x) → Healthy(x)) ::: People who get regular checkups are healthy.",
            "∀x (EatsUnhealthyFood(x) → ¬Healthy(x)) ::: If a person eats unhealthy food, they are not healthy.",
            "∀x (IsStressed(x) → ¬Healthy(x)) ::: If a person is stressed, they are not healthy.",
            "∀x (AvoidsStress(x) → Healthy(x)) ::: If a person avoids stress, they are healthy.",
            "∀x (FollowsDoctorsAdvice(x) → Healthy(x)) ::: People who follow doctor's advice are healthy.",
            "∀x (ExercisesRegularly(x) → LongLife(x)) ::: People who exercise regularly live long lives.",
            "∀x (Healthy(x) → LongLife(x)) ::: People who are healthy live long lives.",
            "∃x Healthy(x) ::: Some people are healthy."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "Healthy(x) ::: x is healthy.",
            "ExercisesRegularly(x) ::: x exercises regularly.",
            "LongLife(x) ::: x lives a long life.",
            "EatsHealthyFood(x) ::: x eats healthy food.",
            "GetsEnoughSleep(x) ::: x gets enough sleep.",
            "HasGoodGenes(x) ::: x has good genes.",
            "Smokes(x) ::: x smokes.",
            "DrinksAlcExcess(x) ::: x drinks alcohol excessively.",
            "IsHappy(x) ::: x is happy.",
            "HasGoodFriends(x) ::: x has good friends.",
            "GetsRegularCheckups(x) ::: x gets regular checkups.",
            "EatsUnhealthyFood(x) ::: x eats unhealthy food.",
            "IsStressed(x) ::: x is stressed.",
            "AvoidsStress(x) ::: x avoids stress.",
            "FollowsDoctorsAdvice(x) ::: x follows the doctor's advice."
        ]
    },
    {
        "premises-NL": [
            "All scientists publish papers.",
            "Scientists who conduct research need equipment.",
            "Scientists who publish papers attend conferences.",
            "Those who attend conferences present results.",
            "Scientists with mentors get help.",
            "Mentors help scientists secure funding.",
            "Scientists who present results receive grants.",
            "Scientists who receive grants share data.",
            "Scientists who share data with others collaborate.",
            "Scientists who secure funding use a lab.",
            "Scientists who use a lab need support.",
            "Scientists who secure funding work on a project.",
            "Some scientists conduct research.",
            "If a scientist publishes papers, they finds interesting topics.",
            "If a scientist works on a project, they collaborate."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → PublishesPapers(x)) ::: All scientists publish papers.",
            "∀x (ConductsResearch(x) → NeedsEquipment(x)) ::: Scientists who conduct research need equipment.",
            "∀x (PublishesPapers(x) → AttendsConferences(x)) ::: Scientists who publish papers attend conferences.",
            "∀x (AttendsConferences(x) → PresentsResults(x)) ::: Those who attend conferences present results.",
            "∀x (HasMentors(x, y) → MentorsHelp(y, x)) ::: Scientists with mentors get help.",
            "∀x ∀y (MentorsHelp(x, y) → SecuresFunding(y)) ::: Mentors help scientists secure funding.",
            "∀x (PresentsResults(x) → ReceivesGrants(x)) ::: Scientists who present results receive grants.",
            "∃y (SharesData(x, y)) ::: Scientist x who receive grants share data shares data with y.",
            "∀x (SharesData(x, y) → Collaborates(x)) ::: Scientists who share data with others collaborate.",
            "∀x (SecuresFunding(x) → UsesLab(x)) ::: Scientists who secure funding use a lab.",
            "∀x (UsesLab(x) → NeedsSupport(x)) ::: Scientists who use a lab need support.",
            "∃y (SecuresFunding(x) → WorksOnProject(x, y)) ::: Scientist s who secure funding work on a project y.",
            "∃x ConductsResearch(x) ::: Some scientists conduct research.",
            "∀x (PublishesPapers(x) → FindsInterestingTopics(x)) ::: If a scientist publishes papers, they finds interesting topics.",
            "∀x ∀y (WorksOnProject(x, y) → Collaborates(x)) ::: If a scientist works on a project, they collaborate."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist.",
            "PublishesPapers(x) ::: x publishes papers.",
            "SecuresFunding(x) ::: x secures funding.",
            "Collaborates(x) ::: x collaborates.",
            "ConductsResearch(x) ::: x conducts research.",
            "NeedsEquipment(x) ::: x needs equipment.",
            "AttendsConferences(x) ::: x attends conferences.",
            "PresentsResults(x) ::: x presents results.",
            "HasMentors(x, y) ::: x has mentor y.",
            "MentorsHelp(x, y) ::: mentor x helps y.",
            "ReceivesGrants(x) ::: x receives grants.",
            "SharesData(x, y) ::: x shares data with y.",
            "UsesLab(x) ::: x uses lab.",
            "NeedsSupport(x) ::: x needs support.",
            "FindsInterestingTopics(x) ::: x finds interesting topics.",
            "WorksOnProject(x, y) ::: x works on project y."
        ]
    },
    {
        "premises-NL": [
            "All leaders have a good vision.",
            "People with a good vision inspire others.",
            "People who inspire others motivate their team.",
            "Leaders set goals.",
            "People who communicate effectively build relationships.",
            "People who make decisions understand people.",
            "Leaders are confident.",
            "People who take risks overcome challenges.",
            "People who learn from mistakes are leaders.",
            "People who follow rules help others.",
            "Those who have integrity are leaders.",
            "Leaders who motivate their team achieve great things.",
            "If a person sets goals and builds relationships, they are leaders.",
            "If a person has a good vision and communicates effectively, they are leaders.",
            "Some people are leaders.",
            "If a person is confident and takes risks, they inspire others.",
            "If a person overcomes challenges, they achieve great things.",
            "Leaders must have integrity."
        ],
        "premises-FOL": [
            "∀x (Leader(x) → GoodVision(x)) ::: All leaders have a good vision.",
            "∀x (GoodVision(x) → InspiresOthers(x)) ::: People with a good vision inspire others.",
            "∀x (InspiresOthers(x) → MotivatesTeam(x)) ::: People who inspire others motivate their team.",
            "∀x (Leader(x) → SetsGoals(x)) ::: Leaders set goals.",
            "∀x (CommunicatesEffectively(x) → BuildsRelationships(x)) ::: People who communicate effectively build relationships.",
            "∀x (MakesDecisions(x) → UnderstandsPeople(x)) ::: People who make decisions understand people.",
            "∀x (Leader(x) → IsConfident(x)) ::: Leaders are confident.",
            "∀x (TakesRisks(x) → OvercomesChallenges(x)) ::: People who take risks overcome challenges.",
            "∀x (LearnsFromMistakes(x) → Leader(x)) ::: People who learn from mistakes are leaders.",
            "∀x (FollowsRules(x) → HelpsOthers(x)) ::: People who follow rules help others.",
            "∀x (Leader(x) ∧ MotivatesTeam(x) → AchievesGreatThings(x)) ::: Leaders who motivate their team achieve great things.",
            "∀x (SetsGoals(x) ∧ BuildsRelationships(x) → Leader(x)) ::: If a person sets goals and builds relationships, they are leaders.",
            "∀x (GoodVision(x) ∧ CommunicatesEffectively(x) → Leader(x)) ::: If a person has a good vision and communicates effectively, they are leaders.",
            "∃x Leader(x) ::: Some people are leaders.",
            "∀x (IsConfident(x) ∧ TakesRisks(x) → InspiresOthers(x)) ::: If a person is confident and takes risks, they inspire others.",
            "∀x (OvercomesChallenges(x) → AchievesGreatThings(x)) ::: If a person overcomes challenges, they achieve great things.",
            "∀x (Leader(x) → HasIntegrity(x)) ::: Leaders must have integrity."
        ],
        "predicates": [
            "Person(x) ::: x is a person.",
            "Leader(x) ::: x is a leader.",
            "GoodVision(x) ::: x has a good vision.",
            "InspiresOthers(x) ::: x inspires others.",
            "AchievesGreatThings(x) ::: x achieves great things.",
            "MotivatesTeam(x) ::: x motivates a team.",
            "SetsGoals(x) ::: x sets goals.",
            "CommunicatesEffectively(x) ::: x communicates effectively.",
            "BuildsRelationships(x) ::: x builds relationships.",
            "MakesDecisions(x) ::: x makes decisions.",
            "UnderstandsPeople(x) ::: x understands people.",
            "IsConfident(x) ::: x is confident.",
            "TakesRisks(x) ::: x takes risks.",
            "OvercomesChallenges(x) ::: x overcomes challenges.",
            "LearnsFromMistakes(x) ::: x learns from mistakes.",
            "FollowsRules(x) ::: x follows rules.",
            "HelpsOthers(x) ::: x helps others.",
            "HasIntegrity(x) ::: x has integrity."
        ]
    },
    {
        "premises-NL": [
            "Every student studies hard.",
            "No lazy student attends classes.",
            "Some students pass exams.",
            "Anyone who studies hard reads books.",
            "If a student reads books, then they get good grades.",
            "Every student who gets good grades enjoys learning.",
            "If someone enjoys learning, they are diligent.",
            "Some diligent students are not lazy.",
            "Anyone who is not lazy does not skip classes.",
            "If a student attends classes, they do not fail exams.",
            "Anyone who is motivated studies hard.",
            "If a student is diligent, they are motivated.",
            "Someone who gets good grades gets an award.",
            "Some people get good grades and are not lazy.",
            "If someone passes exams then they succeeds.",
            "If someone succeeds they offer help.",
            "If someone gets award, they are smart."
        ],
        "premises-FOL": [
            "∀x (Student(x) → StudiesHard(x)) ::: Every student studies hard.",
            "∀x (IsLazy(x) → ¬AttendsClasses(x)) ::: No lazy student attends classes.",
            "∃x PassesExams(x) ::: Some students pass exams.",
            "∀x (StudiesHard(x) → ReadsBooks(x)) ::: Anyone who studies hard reads books.",
            "∀x (ReadsBooks(x) → GetsGoodGrades(x)) ::: If a student reads books, then they get good grades.",
            "∀x (GetsGoodGrades(x) → EnjoysLearning(x)) ::: Every student who gets good grades enjoys learning.",
            "∀x (EnjoysLearning(x) → IsDiligent(x)) ::: If someone enjoys learning, they are diligent.",
            "∃x (IsDiligent(x) ∧ ¬IsLazy(x)) ::: Some diligent students are not lazy.",
            "∀x (¬IsLazy(x) → ¬SkipsClasses(x)) ::: Anyone who is not lazy does not skip classes.",
            "∀x (AttendsClasses(x) → ¬FailsExams(x)) ::: If a student attends classes, they do not fail exams.",
            "∀x (IsMotivated(x) → StudiesHard(x)) ::: Anyone who is motivated studies hard.",
            "∀x (IsDiligent(x) → IsMotivated(x)) ::: If a student is diligent, they are motivated.",
            "∃x (GetsGoodGrades(x) ∧ GetsAward(x)) ::: Someone who gets good grades gets an award.",
            "∃x (GetsGoodGrades(x) ∧ ¬IsLazy(x)) ::: Some people get good grades and are not lazy.",
            "∀x (PassesExams(x) → Succeeds(x)) ::: If someone passes exams then they succeeds.",
            "∀x (Succeeds(x) → OffersHelp(x, x)) ::: If someone succeeds they offer help.",
            "∀x (GetsAward(x) → IsSmart(x)) ::: If someone gets award, they are smart.",
            "∀x (GetsGoodGrades(x) → PassesExams(x)) ::: If you get good grades, you pass exams."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "IsLazy(x) ::: x is lazy",
            "Succeeds(x) ::: x succeeds",
            "AttendsClasses(x) ::: x attends classes",
            "PassesExams(x) ::: x passes exams",
            "ReadsBooks(x) ::: x reads books",
            "GetsGoodGrades(x) ::: x gets good grades",
            "EnjoysLearning(x) ::: x enjoys learning",
            "IsDiligent(x) ::: x is diligent",
            "SkipsClasses(x) ::: x skips classes",
            "FailsExams(x) ::: x fails exams",
            "IsMotivated(x) ::: x is motivated",
            "NeedsHelp(x) ::: x needs help",
            "OffersHelp(x, y) ::: x offers help to y",
            "IsSmart(x) ::: x is smart",
            "GetsAward(x) ::: x gets an award"
        ]
    },
    {
        "premises-NL": [
            "All surgeons are doctors.",
            "All specialists are doctors.",
            "Every doctor treats illnesses.",
            "Anyone who treats illnesses uses medical equipment.",
            "Anyone who uses medical equipment prescribes medication.",
            "Everyone who prescribes medication diagnoses.",
            "Anyone who diagnoses sees patients.",
            "All who see patients work in a clinic or a hospital.",
            "Someone who conducts research is a doctor.",
            "Every doctor knows medicine.",
            "Anyone who knows medicine is educated.",
            "Everyone educated has a degree.",
            "All with a degree has a license.",
            "Anyone with a license can be a doctor.",
            "Not everyone works in a clinic.",
            "There are doctors who work in hospitals."
        ],
        "premises-FOL": [
            "∀x (Surgeon(x) → Doctor(x)) ::: All surgeons are doctors.",
            "∀x (SeesPatients(x) → HelpsPatients(x)) ::: Anyone who sees patients helps them.",
            "∀x (Specialist(x) → Doctor(x)) ::: All specialists are doctors.",
            "∀x (Doctor(x) → TreatsIllness(x)) ::: Every doctor treats illnesses.",
            "∀x (TreatsIllness(x) → UsesMedicalEquipment(x)) ::: Anyone who treats illnesses uses medical equipment.",
            "∀x (UsesMedicalEquipment(x) → PrescribesMedication(x)) ::: Anyone who uses medical equipment prescribes medication.",
            "∀x (PrescribesMedication(x) → Diagnoses(x)) ::: Everyone who prescribes medication diagnoses.",
            "∀x (Diagnoses(x) → SeesPatients(x)) ::: Anyone who diagnoses sees patients.",
            "∀x (SeesPatients(x) → (WorksInClinic(x) ∨ WorksInHospital(x))) ::: All who see patients work in a clinic or a hospital.",
            "∃x (ConductsResearch(x) ∧ Doctor(x)) ::: Someone who conducts research is a doctor.",
            "∀x (Doctor(x) → KnowsMedicine(x)) ::: Every doctor knows medicine.",
            "∀x (KnowsMedicine(x) → IsEducated(x)) ::: Anyone who knows medicine is educated.",
            "∀x (IsEducated(x) → HasDegree(x)) ::: Everyone educated has a degree.",
            "∀x (HasDegree(x) → HasLicense(x)) ::: All with a degree has a license.",
            "∀x (HasLicense(x) → Doctor(x)) ::: Anyone with a license can be a doctor.",
            "¬∀x WorksInClinic(x) ::: Not everyone works in a clinic.",
            "∃x (Doctor(x) ∧ WorksInHospital(x)) ::: There are doctors who work in hospitals.",
            "∀x (SeesPatients(x) → HelpsPatients(x)) ::: Anyone who sees patients helps them.",
            "∀x (Doctor(x) ∧ WorksInHospital(x) → SeesPatients(x)) ::: Doctors who work in hospitals see patients."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "WorksInHospital(x) ::: x works in a hospital",
            "HelpsPatients(x) ::: x helps patients",
            "Surgeon(x) ::: x is a surgeon",
            "Specialist(x) ::: x is a specialist",
            "TreatsIllness(x) ::: x treats illness",
            "UsesMedicalEquipment(x) ::: x uses medical equipment",
            "PrescribesMedication(x) ::: x prescribes medication",
            "Diagnoses(x) ::: x diagnoses",
            "SeesPatients(x) ::: x sees patients",
            "WorksInClinic(x) ::: x works in a clinic",
            "ConductsResearch(x) ::: x conducts research",
            "KnowsMedicine(x) ::: x knows medicine",
            "IsEducated(x) ::: x is educated",
            "HasDegree(x) ::: x has a degree",
            "HasLicense(x) ::: x has a license"
        ]
    },
    {
        "premises-NL": [
            "All students are enrolled.",
            "Anyone who is enrolled takes exams.",
            "Anyone who studies computer science attends lectures.",
            "Anyone who attends lectures submits assignments.",
            "Anyone who submits assignments understands concepts.",
            "Anyone who understands concepts passes exams.",
            "Anyone who passes exams gets good grades.",
            "Anyone who gets good grades does well.",
            "Anyone who does well has skills.",
            "Anyone with skills applies for jobs.",
            "Anyone who applies for jobs gets an interview.",
            "Anyone who gets an interview gets an offer.",
            "Anyone who gets an offer gets a job.",
            "Everyone who studies computer science works hard.",
            "Anyone who works hard is dedicated.",
            "Anyone who is dedicated submits assignments.",
            "Someone studies computer science.",
            "There are students."
        ],
        "premises-FOL": [
            "∀x (Student(x) → IsEnrolled(x)) ::: All students are enrolled.",
            "∀x (IsEnrolled(x) → TakesExams(x)) ::: Anyone who is enrolled takes exams.",
            "∀x (StudiesComputerScience(x) → AttendsLectures(x)) ::: Anyone who studies computer science attends lectures.",
            "∀x (AttendsLectures(x) → SubmitsAssignments(x)) ::: Anyone who attends lectures submits assignments.",
            "∀x (SubmitsAssignments(x) → UnderstandsConcepts(x)) ::: Anyone who submits assignments understands concepts.",
            "∀x (UnderstandsConcepts(x) → PassesExams(x)) ::: Anyone who understands concepts passes exams.",
            "∀x (PassesExams(x) → GetsGoodGrades(x)) ::: Anyone who passes exams gets good grades.",
            "∀x (GetsGoodGrades(x) → DoesWell(x)) ::: Anyone who gets good grades does well.",
            "∀x (DoesWell(x) → HasSkills(x)) ::: Anyone who does well has skills.",
            "∀x (HasSkills(x) → AppliesForJobs(x)) ::: Anyone with skills applies for jobs.",
            "∀x (AppliesForJobs(x) → GetsInterview(x)) ::: Anyone who applies for jobs gets an interview.",
            "∀x (GetsInterview(x) → GetsOffer(x)) ::: Anyone who gets an interview gets an offer.",
            "∀x (GetsOffer(x) → GetsJob(x)) ::: Anyone who gets an offer gets a job.",
            "∀x (StudiesComputerScience(x) → WorksHard(x)) ::: Everyone who studies computer science works hard.",
            "∀x (WorksHard(x) → IsDedicated(x)) ::: Anyone who works hard is dedicated.",
            "∀x (IsDedicated(x) → SubmitsAssignments(x)) ::: Anyone who is dedicated submits assignments.",
            "∃x StudiesComputerScience(x) ::: Someone studies computer science.",
            "∃x Student(x) ::: There are students."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "StudiesComputerScience(x) ::: x studies computer science",
            "DoesWell(x) ::: x does well",
            "GetsJob(x) ::: x gets a job",
            "IsEnrolled(x) ::: x is enrolled",
            "TakesExams(x) ::: x takes exams",
            "AttendsLectures(x) ::: x attends lectures",
            "SubmitsAssignments(x) ::: x submits assignments",
            "UnderstandsConcepts(x) ::: x understands concepts",
            "PassesExams(x) ::: x passes exams",
            "GetsGoodGrades(x) ::: x gets good grades",
            "HasSkills(x) ::: x has skills",
            "AppliesForJobs(x) ::: x applies for jobs",
            "GetsInterview(x) ::: x gets an interview",
            "GetsOffer(x) ::: x gets an offer",
            "WorksHard(x) ::: x works hard",
            "IsDedicated(x) ::: x is dedicated"
        ]
    },
    {
        "premises-NL": [
            "All scientists conduct experiments.",
            "Anyone who conducts experiments analyzes data.",
            "Anyone who analyzes data generates a report.",
            "Anyone who studies biology or chemistry works in a lab.",
            "Anyone who works in a lab uses lab equipment.",
            "Scientists publish papers.",
            "Anyone who publishes papers needs funding.",
            "Scientists collaborate with others.",
            "Anyone who collaborates presents findings.",
            "Anyone who presents findings attends conferences.",
            "Anyone who attends conferences is a scientist.",
            "All who specialize in biology or chemistry understands principles.",
            "Anyone who understands principles has knowledge.",
            "Anyone who has knowledge is educated.",
            "Anyone who is educated graduates.",
            "Anyone who graduates is a researcher.",
            "All researchers are scientists.",
            "Someone studies biology or chemistry.",
            "There is a scientist."
        ],
        "premises-FOL": [
            "∀x (Scientist(x) → ConductsExperiments(x)) ::: All scientists conduct experiments.",
            "∀x (ConductsExperiments(x) → AnalyzesData(x)) ::: Anyone who conducts experiments analyzes data.",
            "∀x (AnalyzesData(x) → GeneratesReport(x)) ::: Anyone who analyzes data generates a report.",
            "∀x ((StudiesBiology(x) ∨ StudiesChemistry(x)) → WorksInLab(x)) ::: Anyone who studies biology or chemistry works in a lab.",
            "∀x (WorksInLab(x) → UsesLabEquipment(x)) ::: Anyone who works in a lab uses lab equipment.",
            "∀x (Scientist(x) → PublishesPapers(x)) ::: Scientists publish papers.",
            "∀x (PublishesPapers(x) → NeedsFunding(x)) ::: Anyone who publishes papers needs funding.",
            "∀x ∃y Collaborates(x, y) ::: Scientists collaborate with others.",
            "∀x (Collaborates(x, y) → PresentsFindings(x)) ::: Anyone who collaborates presents findings.",
            "∀x (PresentsFindings(x) → AttendsConferences(x)) ::: Anyone who presents findings attends conferences.",
            "∀x (AttendsConferences(x) → Scientist(x)) ::: Anyone who attends conferences is a scientist.",
            "∀x ((SpecializesIn(x, \"Biology\") ∨ SpecializesIn(x, \"Chemistry\")) → UnderstandsPrinciples(x)) ::: All who specialize in biology or chemistry understands principles.",
            "∀x (UnderstandsPrinciples(x) → HasKnowledge(x)) ::: Anyone who understands principles has knowledge.",
            "∀x (HasKnowledge(x) → IsEducated(x)) ::: Anyone who has knowledge is educated.",
            "∀x (IsEducated(x) → Graduates(x)) ::: Anyone who is educated graduates.",
            "∀x (Graduates(x) → IsResearcher(x)) ::: Anyone who graduates is a researcher.",
            "∀x (IsResearcher(x) → Scientist(x)) ::: All researchers are scientists.",
            "∃x (StudiesBiology(x) ∨ StudiesChemistry(x)) ::: Someone studies biology or chemistry.",
            "∃x Scientist(x) ::: There is a scientist."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "StudiesBiology(x) ::: x studies biology",
            "StudiesChemistry(x) ::: x studies chemistry",
            "UsesLabEquipment(x) ::: x uses lab equipment",
            "GeneratesReport(x) ::: x generates a report",
            "ConductsExperiments(x) ::: x conducts experiments",
            "AnalyzesData(x) ::: x analyzes data",
            "PublishesPapers(x) ::: x publishes papers",
            "WorksInLab(x) ::: x works in a lab",
            "NeedsFunding(x) ::: x needs funding",
            "Collaborates(x, y) ::: x collaborates with y",
            "PresentsFindings(x) ::: x presents findings",
            "AttendsConferences(x) ::: x attends conferences",
            "SpecializesIn(x, y) ::: x specializes in y",
            "UnderstandsPrinciples(x) ::: x understands principles",
            "HasKnowledge(x) ::: x has knowledge",
            "IsEducated(x) ::: x is educated",
            "Graduates(x) ::: x graduates",
            "IsResearcher(x) ::: x is a researcher"
        ]
    },
    {
        "premises-NL": [
            "If a faculty member has completed training, they can teach undergraduate courses.",
            "If a faculty member can teach undergraduate courses and holds a PhD, they can supervise graduate students.",
            "If a faculty member can supervise graduate students and has at least 3 publications, they can serve on curriculum committees.",
            "If a faculty member can serve on curriculum committees and has a positive teaching evaluation, they can propose new courses.",
            "Professor John has completed pedagogical training.",
            "Professor John holds a PhD.",
            "Professor John has published at least 3 academic papers.",
            "Professor John has received a positive teaching evaluation."
        ],
        "premises-FOL": [
            "∀x (CompletedTraining(x) → TeachUndergrad(x)) ::: If a faculty member has completed training, they can teach undergraduate courses.",
            "∀x ((TeachUndergrad(x) ∧ HoldsPhD(x)) → SuperviseGrad(x)) ::: If a faculty member can teach undergraduate courses and holds a PhD, they can supervise graduate students.",
            "∀x ((SuperviseGrad(x) ∧ HasPublications(x)) → ServeCommittee(x)) ::: If a faculty member can supervise graduate students and has at least 3 publications, they can serve on curriculum committees.",
            "∀x ((ServeCommittee(x) ∧ PositiveEval(x)) → ProposeCourses(x)) ::: If a faculty member can serve on curriculum committees and has a positive teaching evaluation, they can propose new courses.",
            "CompletedTraining(John) ::: Professor John has completed pedagogical training.",
            "HoldsPhD(John) ::: Professor John holds a PhD.",
            "HasPublications(John) ::: Professor John has published at least 3 academic papers.",
            "PositiveEval(John) ::: Professor John has received a positive teaching evaluation."
        ],
        "predicates": [
            "CompletedTraining(x) ::: x has completed pedagogical training",
            "TeachUndergrad(x) ::: x can teach undergraduate courses",
            "HoldsPhD(x) ::: x holds a PhD",
            "SuperviseGrad(x) ::: x can supervise graduate students",
            "HasPublications(x) ::: x has at least three publications",
            "ServeCommittee(x) ::: x can serve on curriculum committees",
            "PositiveEval(x) ::: x has a positive teaching evaluation",
            "ProposeCourses(x) ::: x can propose new courses"
        ]
    },
    {
        "premises-NL": [
            "If an astronaut undergoes advanced training and excels in simulations, they earn a flight clearance.",
            "If an astronaut earns a flight clearance and the launch vehicle passes a safety audit, they are approved for a Mars expedition.",
            "If an astronaut is approved for a Mars expedition and the orbital trajectory is precisely calculated, the mission departs on schedule.",
            "If the mission departs on schedule and Mars' radiation levels are within safe limits, a surface landing is authorized.",
            "If a surface landing is authorized and the astronaut deploys a functioning rover, geological samples are collected.",
            "If geological samples are collected and the analysis equipment is operational, a scientific breakthrough is possible.",
            "Either Luna undergoes advanced training or she withdraws from the program.",
            "Luna does not withdraw from the program.",
            "Luna excels in simulations.",
            "The launch vehicle for Luna passes a safety audit.",
            "The orbital trajectory for Luna's mission is precisely calculated.",
            "Mars' radiation levels are within safe limits.",
            "Luna deploys a functioning rover.",
            "The analysis equipment on Luna's mission is operational.",
            "If the mission control loses contact, the trajectory cannot be calculated.",
            "Mission control does not lose contact.",
            "If the rover malfunctions, geological samples cannot be collected.",
            "The rover does not malfunction.",
            "If radiation exceeds safe limits, a landing is not authorized.",
            "Radiation does not exceed safe limits.",
            "If Luna fails psychological evaluations, she cannot earn flight clearance.",
            "Luna does not fail psychological evaluations.",
            "If the audit detects a flaw, the launch vehicle is not approved.",
            "The audit does not detect a flaw.",
            "If the equipment calibration fails, a breakthrough is not possible.",
            "The equipment calibration does not fail.",
            "If the expedition is delayed, samples cannot be collected on time.",
            "The expedition is not delayed."
        ],
        "premises-FOL": [
            "∀a (Training(a) ∧ Simulations(a) → Clearance(a))",
            "∀a (Clearance(a) ∧ AuditPassed(Vehicle(a)) → Approved(a))",
            "∀a (Approved(a) ∧ Trajectory(a) → Departs(a))",
            "∀a (Departs(a) ∧ SafeRadiation(Mars) → Landing(a))",
            "∀a (Landing(a) ∧ RoverOK(a) → Samples(a))",
            "∀a (Samples(a) ∧ EquipmentOK(a) → Breakthrough(a))",
            "Training(Luna) ∨ Withdraw(Luna)",
            "¬Withdraw(Luna)",
            "Simulations(Luna)",
            "AuditPassed(Vehicle(Luna))",
            "Trajectory(Luna)",
            "SafeRadiation(Mars)",
            "RoverOK(Luna)",
            "EquipmentOK(Luna)",
            "LoseContact(Control) → ¬Trajectory(Luna)",
            "¬LoseContact(Control)",
            "Malfunction(Rover(Luna)) → ¬Samples(Luna)",
            "¬Malfunction(Rover(Luna))",
            "ExceedRadiation(Mars) → ¬Landing(Luna)",
            "¬ExceedRadiation(Mars)",
            "FailPsych(Luna) → ¬Clearance(Luna)",
            "¬FailPsych(Luna)",
            "FlawAudit(Vehicle(Luna)) → ¬AuditPassed(Vehicle(Luna))",
            "¬FlawAudit(Vehicle(Luna))",
            "FailCalibration(Equipment(Luna)) → ¬Breakthrough(Luna)",
            "¬FailCalibration(Equipment(Luna))",
            "Delayed(Expedition) → ¬Samples(Luna)",
            "¬Delayed(Expedition)"
        ],
        "predicates": [
            "Training(a) ::: astronaut a completes advanced training",
            "Simulations(a) ::: astronaut a excels in simulations",
            "Clearance(a) ::: astronaut a earns flight clearance",
            "AuditPassed(v) ::: launch vehicle v passes safety audit",
            "Vehicle(a) ::: launch vehicle assigned to astronaut a",
            "Approved(a) ::: astronaut a is approved for Mars expedition",
            "Trajectory(a) ::: orbital trajectory for astronaut a is precisely calculated",
            "Departs(a) ::: mission of astronaut a departs on schedule",
            "SafeRadiation(Mars) ::: radiation on Mars is within safe limits",
            "Landing(a) ::: astronaut a is authorized to land on Mars",
            "RoverOK(a) ::: astronaut a deploys a functioning rover",
            "Samples(a) ::: astronaut a collects geological samples",
            "EquipmentOK(a) ::: analysis equipment for astronaut a is operational",
            "Breakthrough(a) ::: astronaut a achieves scientific breakthrough",
            "Withdraw(a) ::: astronaut a withdraws from the program",
            "LoseContact(Control) ::: mission control loses contact",
            "Malfunction(Rover(a)) ::: rover of astronaut a malfunctions",
            "ExceedRadiation(Mars) ::: radiation levels on Mars exceed safety limit",
            "FailPsych(a) ::: astronaut a fails psychological evaluation",
            "FlawAudit(v) ::: safety audit detects flaw in vehicle v",
            "FailCalibration(e) ::: equipment e calibration fails",
            "Delayed(Expedition) ::: expedition is delayed"
        ]
    },
    {
        "premises-NL": [
            "If a student builds a strong resume, they increase their chances of securing a job.",
            "If a student attends career workshops, they improve their job application skills.",
            "If a student improves their job application skills, they perform better in job interviews.",
            "If a student performs better in job interviews, they have a higher chance of getting hired.",
            "If a student participates in internships, they gain relevant work experience.",
            "If a student gains relevant work experience, they enhance their employability.",
            "If a student has professional networking skills, they can connect with potential employers.",
            "If a student connects with potential employers, they receive job opportunities.",
            "If a student has a career mentor, they receive guidance on career decisions.",
            "If a student receives guidance on career decisions, they make informed career choices.",
            "If a student makes informed career choices, they have better long-term career growth.",
            "If a student has better long-term career growth, they achieve financial stability."
        ],
        "premises-FOL": [
            "∀x (BuildResume(x) → HigherJobChance(x))",
            "∀x (AttendWorkshop(x) → ImproveAppSkills(x))",
            "∀x (ImproveAppSkills(x) → BetterInterview(x))",
            "∀x (BetterInterview(x) → HigherHiringChance(x))",
            "∀x (Internship(x) → GainExperience(x))",
            "∀x (GainExperience(x) → EnhanceEmployability(x))",
            "∀x (HasNetworking(x) → ConnectEmployers(x))",
            "∀x (ConnectEmployers(x) → GetJobOffers(x))",
            "∀x (HasMentor(x) → GetGuidance(x))",
            "∀x (GetGuidance(x) → MakeInformedChoices(x))",
            "∀x (MakeInformedChoices(x) → BetterCareerGrowth(x))",
            "∀x (BetterCareerGrowth(x) → FinancialStability(x))"
        ],
        "predicates": [
            "BuildResume(x) ::: student x builds a strong resume",
            "HigherJobChance(x) ::: student x increases chance of getting job",
            "AttendWorkshop(x) ::: student x attends career workshop",
            "ImproveAppSkills(x) ::: student x improves application skills",
            "BetterInterview(x) ::: student x performs better in interviews",
            "HigherHiringChance(x) ::: student x has higher chance of being hired",
            "Internship(x) ::: student x participates in internship",
            "GainExperience(x) ::: student x gains work experience",
            "EnhanceEmployability(x) ::: student x improves employability",
            "HasNetworking(x) ::: student x has networking skills",
            "ConnectEmployers(x) ::: student x connects with employers",
            "GetJobOffers(x) ::: student x receives job offers",
            "HasMentor(x) ::: student x has a career mentor",
            "GetGuidance(x) ::: student x receives career guidance",
            "MakeInformedChoices(x) ::: student x makes informed career choices",
            "BetterCareerGrowth(x) ::: student x achieves long-term career growth",
            "FinancialStability(x) ::: student x achieves financial stability"
        ]
    },
    {
        "premises-NL": [
            "If a Python code is well-tested, then the project is optimized.",
            "If a Python code does not follow PEP 8 standards, then it is not well-tested.",
            "All Python projects are easy to maintain.",
            "All Python code is well-tested.",
            "If a Python code follows PEP 8 standards, then it is easy to maintain.",
            "If a Python code is well-tested, then it follows PEP 8 standards.",
            "If a Python project is well-structured, then it is optimized.",
            "If a Python project is easy to maintain, then it is well-tested.",
            "If a Python project is optimized, then it has clean and readable code.",
            "All Python projects are well-structured.",
            "All Python projects have clean and readable code.",
            "There exists at least one Python project that follows best practices.",
            "There exists at least one Python project that is optimized.",
            "If a Python project is not well-structured, then it does not follow PEP 8 standards."
        ],
        "premises-FOL": [
            "∀x (WellTested(x) → Optimized(x)) ::: If a Python code is well-tested, then the project is optimized.",
            "∀x (¬FollowsPEP8(x) → ¬WellTested(x)) ::: If a Python code does not follow PEP 8 standards, then it is not well-tested.",
            "∀x (PythonProject(x) → EasyToMaintain(x)) ::: All Python projects are easy to maintain.",
            "∀x (PythonCode(x) → WellTested(x)) ::: All Python code is well-tested.",
            "∀x (FollowsPEP8(x) → EasyToMaintain(x)) ::: If a Python code follows PEP 8 standards, then it is easy to maintain.",
            "∀x (WellTested(x) → FollowsPEP8(x)) ::: If a Python code is well-tested, then it follows PEP 8 standards.",
            "∀x (WellStructured(x) → Optimized(x)) ::: If a Python project is well-structured, then it is optimized.",
            "∀x (EasyToMaintain(x) → WellTested(x)) ::: If a Python project is easy to maintain, then it is well-tested.",
            "∀x (Optimized(x) → CleanReadable(x)) ::: If a Python project is optimized, then it has clean and readable code.",
            "∀x (PythonProject(x) → WellStructured(x)) ::: All Python projects are well-structured.",
            "∀x (PythonProject(x) → CleanReadable(x)) ::: All Python projects have clean and readable code.",
            "∃x (FollowsBestPractices(x)) ::: There exists at least one Python project that follows best practices.",
            "∃x (Optimized(x)) ::: There exists at least one Python project that is optimized.",
            "∀x (¬WellStructured(x) → ¬FollowsPEP8(x)) ::: If a Python project is not well-structured, then it does not follow PEP 8 standards."
        ],
        "predicates": [
            "WellTested(x) ::: x is well-tested",
            "Optimized(x) ::: x is optimized",
            "FollowsPEP8(x) ::: x follows PEP 8 standards",
            "EasyToMaintain(x) ::: x is easy to maintain",
            "PythonCode(x) ::: x is a Python code",
            "PythonProject(x) ::: x is a Python project",
            "WellStructured(x) ::: x is well-structured",
            "CleanReadable(x) ::: x has clean and readable code",
            "FollowsBestPractices(x) ::: x follows best practices"
        ]
    },
    {
        "premises-NL": [
            "If a student has a GPA ≥ 3.7, then they are eligible for a scholarship.",
            "All students who are eligible for a scholarship submitted a personal statement.",
            "All students show strong academic commitment.",
            "There exists at least one student who published a research paper.",
            "All students have a GPA ≥ 3.7.",
            "All students participated in extracurricular activities.",
            "All students submitted a recommendation letter.",
            "If a student does not show academic commitment, then they did not publish a research paper."
        ],
        "predicates": [
            "GPA(x, g) ::: x has GPA g",
            "EligibleForScholarship(x) ::: x is eligible for a scholarship",
            "SubmittedPersonalStatement(x) ::: x submitted a personal statement",
            "ShowsAcademicCommitment(x) ::: x shows strong academic commitment",
            "PublishedResearch(x) ::: x published a research paper",
            "ParticipatedInExtracurriculars(x) ::: x participated in extracurricular activities",
            "SubmittedRecommendationLetter(x) ::: x submitted a recommendation letter"
        ],
        "premises-FOL": [
            "GPA(x, g) ∧ GreaterThanOrEqual(g, 37) → EligibleForScholarship(x) ::: If a student has GPA ≥ 3.7, then they are eligible for a scholarship",
            "EligibleForScholarship(x) → SubmittedPersonalStatement(x) ::: All students eligible for scholarship submitted a personal statement",
            "∀x ShowsAcademicCommitment(x) ::: All students show strong academic commitment",
            "∃x PublishedResearch(x) ::: At least one student published a research paper",
            "∀x GPA(x, g) ∧ GreaterThanOrEqual(g, 37) ::: All students have GPA ≥ 3.7",
            "∀x ParticipatedInExtracurriculars(x) ::: All students participated in extracurricular activities",
            "∀x SubmittedRecommendationLetter(x) ::: All students submitted a recommendation letter",
            "¬ShowsAcademicCommitment(x) → ¬PublishedResearch(x) ::: If a student does not show academic commitment, they did not publish research"
        ]
    },
    {
        "premises-NL": [
            "Students with unpaid tuition cannot have valid withdrawals.",
            "Lan has unpaid tuition fees for C3 in Fall.",
            "If a withdrawal is valid, the student receives an R grade and the course is excluded from their transcript.",
            "Invalid withdrawals do not result in an R grade.",
            "Invalid withdrawals result in the course remaining on the transcript."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "UnpaidTuition(x, c, t) ::: x has unpaid tuition for course c in term t",
            "ValidWithdrawal(x, c, t) ::: x has a valid withdrawal for course c in term t",
            "RGrade(x, c, t) ::: x receives an R grade for course c in term t",
            "ExcludedFromTranscript(x, c, t) ::: course c is excluded from x's transcript for term t",
            "RemainsOnTranscript(x, c, t) ::: course c remains on x's transcript for term t",
            "InvalidWithdrawal(x, c, t) ::: x's withdrawal from course c in term t is invalid"
        ],
        "premises-FOL": [
            "UnpaidTuition(x, c, t) → ¬ValidWithdrawal(x, c, t) ::: Students with unpaid tuition cannot have valid withdrawals",
            "UnpaidTuition(lan, c3, fall) ::: Lan has unpaid tuition fees for C3 in Fall",
            "ValidWithdrawal(x, c, t) → (RGrade(x, c, t) ∧ ExcludedFromTranscript(x, c, t)) ::: Valid withdrawal results in R grade and exclusion from transcript",
            "InvalidWithdrawal(x, c, t) → ¬RGrade(x, c, t) ::: Invalid withdrawals do not result in an R grade",
            "InvalidWithdrawal(x, c, t) → RemainsOnTranscript(x, c, t) ::: Invalid withdrawals result in the course remaining on the transcript"
        ]
    },
    {
        "premises-NL": [
            "In C++, variables need to be declared with a type before they can be used.",
            "C++ supports both primitive data types, such as int, char, and float, and user-defined types like structs and classes.",
            "Functions in C++ can return a value and are declared with a return type.",
            "C++ supports function overloading, allowing multiple functions with the same name but different parameters.",
            "Classes in C++ are defined with the 'class' keyword and support encapsulation, inheritance, and polymorphism.",
            "C++ uses pointers to reference memory locations, and pointers can be used to dynamically allocate memory.",
            "In C++, the 'new' keyword is used to dynamically allocate memory, and 'delete' is used to deallocate it.",
            "C++ supports exception handling with 'try', 'catch', and 'throw' keywords.",
            "Templates in C++ allow generic programming by defining functions and classes that work with any data type.",
            "The Standard Template Library (STL) in C++ includes data structures like vectors, maps, and sets, and algorithms like sort and find."
        ],
        "predicates": [
            "Language(x) ::: x is a programming language",
            "RequiresDeclarationWithType(x) ::: x requires variables to be declared with a type before use",
            "SupportsPrimitiveTypes(x) ::: x supports primitive types (e.g., int, char, float)",
            "SupportsUserDefinedTypes(x) ::: x supports user-defined types (e.g., struct, class)",
            "SupportsFunctionReturnType(x) ::: functions in x are declared with return types",
            "SupportsFunctionOverloading(x) ::: x allows multiple functions with the same name but different parameters",
            "SupportsOOPFeatures(x) ::: x supports encapsulation, inheritance, and polymorphism",
            "UsesPointers(x) ::: x uses pointers to reference memory",
            "SupportsDynamicMemory(x) ::: x supports dynamic memory allocation",
            "KeywordForNew(x, kw) ::: x uses keyword kw to allocate memory dynamically",
            "KeywordForDelete(x, kw) ::: x uses keyword kw to deallocate memory",
            "SupportsExceptionHandling(x) ::: x supports exception handling mechanisms",
            "ExceptionKeywords(x, k1, k2, k3) ::: x uses keywords k1, k2, and k3 for exception handling",
            "SupportsTemplates(x) ::: x supports generic programming with templates",
            "IncludesSTL(x) ::: x includes the Standard Template Library (STL)",
            "STLStructures(x, s) ::: x’s STL includes data structures like s",
            "STLAlgorithms(x, a) ::: x’s STL includes algorithms like a"
        ],
        "premises-FOL": [
            "Language(cpp) ∧ RequiresDeclarationWithType(cpp) ::: In C++, variables need to be declared with a type before they can be used",
            "Language(cpp) ∧ SupportsPrimitiveTypes(cpp) ∧ SupportsUserDefinedTypes(cpp) ::: C++ supports primitive and user-defined types",
            "Language(cpp) ∧ SupportsFunctionReturnType(cpp) ::: Functions in C++ require a return type",
            "Language(cpp) ∧ SupportsFunctionOverloading(cpp) ::: C++ supports function overloading",
            "Language(cpp) ∧ SupportsOOPFeatures(cpp) ::: C++ supports encapsulation, inheritance, and polymorphism",
            "Language(cpp) ∧ UsesPointers(cpp) ∧ SupportsDynamicMemory(cpp) ::: C++ uses pointers and dynamic memory",
            "KeywordForNew(cpp, new) ∧ KeywordForDelete(cpp, delete) ::: C++ uses 'new' and 'delete' for dynamic memory management",
            "SupportsExceptionHandling(cpp) ∧ ExceptionKeywords(cpp, try, catch, throw) ::: C++ uses try-catch-throw for exceptions",
            "Language(cpp) ∧ SupportsTemplates(cpp) ::: C++ supports templates for generic programming",
            "IncludesSTL(cpp) ∧ STLStructures(cpp, {vector, map, set}) ∧ STLAlgorithms(cpp, {sort, find}) ::: STL in C++ includes data structures and algorithms"
        ]
    },
    {
        "premises-NL": [
            "In JavaScript, a variable can be declared using 'let', 'const', or 'var'.",
            "If a variable is declared with 'let', it is block-scoped.",
            "If a variable is declared with 'const', its value cannot be reassigned.",
            "A function can be declared using the 'function' keyword or using arrow syntax.",
            "JavaScript supports asynchronous programming with promises and async/await.",
            "If a promise is resolved, the 'then' block will be executed.",
            "If a promise is rejected, the 'catch' block will be executed.",
            "A closure in JavaScript allows a function to access variables from its outer scope even after the outer function has finished execution.",
            "The DOM in JavaScript allows manipulation of HTML elements on the page.",
            "JavaScript supports event handling to respond to user interactions."
        ],
        "predicates": [
            "Language(x) ::: x is a programming language",
            "VariableDeclaredWith(x, kw) ::: variable x is declared using keyword kw (e.g., let, const, var)",
            "BlockScoped(x) ::: variable x is block-scoped",
            "Immutable(x) ::: variable x cannot be reassigned",
            "FunctionDeclaredWith(x, kw) ::: function x is declared with keyword or syntax kw (e.g., function, arrow)",
            "SupportsAsync(x) ::: language x supports asynchronous programming",
            "Resolved(p) ::: promise p is resolved",
            "Rejected(p) ::: promise p is rejected",
            "ExecutesThen(p) ::: the 'then' block is executed for promise p",
            "ExecutesCatch(p) ::: the 'catch' block is executed for promise p",
            "IsClosure(f) ::: f is a closure",
            "AccessesOuterScope(f) ::: function f accesses variables from its outer scope",
            "FinishedExecution(f) ::: function f has finished execution",
            "ManipulatesDOM(x) ::: x manipulates HTML elements via DOM",
            "SupportsEventHandling(x) ::: x supports event-driven interaction"
        ],
        "premises-FOL": [
            "Language(js) ∧ VariableDeclaredWith(x, let) ∨ VariableDeclaredWith(x, const) ∨ VariableDeclaredWith(x, var) ::: Variables in JavaScript can be declared with let, const, or var",
            "VariableDeclaredWith(x, let) → BlockScoped(x) ::: let-declared variables are block scoped",
            "VariableDeclaredWith(x, const) → Immutable(x) ::: const-declared variables cannot be reassigned",
            "FunctionDeclaredWith(f, function) ∨ FunctionDeclaredWith(f, arrow) ::: Functions can be declared using function or arrow syntax",
            "SupportsAsync(js) ::: JavaScript supports asynchronous programming (promises, async/await)",
            "Resolved(p) → ExecutesThen(p) ::: If promise is resolved, 'then' block executes",
            "Rejected(p) → ExecutesCatch(p) ::: If promise is rejected, 'catch' block executes",
            "IsClosure(f) → (AccessesOuterScope(f) ∧ FinishedExecution(f)) ::: A closure accesses outer scope even after its outer function finishes",
            "ManipulatesDOM(js) ::: JavaScript supports DOM manipulation",
            "SupportsEventHandling(js) ::: JavaScript supports event handling"
        ]
    }
]